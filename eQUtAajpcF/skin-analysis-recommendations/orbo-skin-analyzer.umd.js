(function(Hn,ir){typeof exports=="object"&&typeof module<"u"?ir(exports):typeof define=="function"&&define.amd?define(["exports"],ir):(Hn=typeof globalThis<"u"?globalThis:Hn||self,ir(Hn.OrboSkinAnalyzer={}))})(this,function(Hn){"use strict";var Xbe=Object.defineProperty;var $H=Hn=>{throw TypeError(Hn)};var Zbe=(Hn,ir,Qr)=>ir in Hn?Xbe(Hn,ir,{enumerable:!0,configurable:!0,writable:!0,value:Qr}):Hn[ir]=Qr;var qs=(Hn,ir,Qr)=>Zbe(Hn,typeof ir!="symbol"?ir+"":ir,Qr),HM=(Hn,ir,Qr)=>ir.has(Hn)||$H("Cannot "+Qr);var Js=(Hn,ir,Qr)=>(HM(Hn,ir,"read from private field"),Qr?Qr.call(Hn):ir.get(Hn)),Ju=(Hn,ir,Qr)=>ir.has(Hn)?$H("Cannot add the same private member more than once"):ir instanceof WeakSet?ir.add(Hn):ir.set(Hn,Qr),gd=(Hn,ir,Qr,$u)=>(HM(Hn,ir,"write to private field"),$u?$u.call(Hn,Qr):ir.set(Hn,Qr),Qr),_H=(Hn,ir,Qr)=>(HM(Hn,ir,"access private method"),Qr);var GM=(Hn,ir,Qr,$u)=>({set _(yd){gd(Hn,ir,yd,Qr)},get _(){return Js(Hn,ir,$u)}});var W0,j0,eG;function ir(a,i){for(var p=0;p<i.length;p++){const f=i[p];if(typeof f!="string"&&!Array.isArray(f)){for(const g in f)if(g!=="default"&&!(g in a)){const x=Object.getOwnPropertyDescriptor(f,g);x&&Object.defineProperty(a,g,x.get?x:{enumerable:!0,get:()=>f[g]})}}}return Object.freeze(Object.defineProperty(a,Symbol.toStringTag,{value:"Module"}))}function Qr(a){return a&&a.__esModule&&Object.prototype.hasOwnProperty.call(a,"default")?a.default:a}var $u={exports:{}},yd={},VM={exports:{}},jn={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var xh=Symbol.for("react.element"),tG=Symbol.for("react.portal"),nG=Symbol.for("react.fragment"),rG=Symbol.for("react.strict_mode"),sG=Symbol.for("react.profiler"),aG=Symbol.for("react.provider"),oG=Symbol.for("react.context"),iG=Symbol.for("react.forward_ref"),AG=Symbol.for("react.suspense"),lG=Symbol.for("react.memo"),uG=Symbol.for("react.lazy"),XM=Symbol.iterator;function cG(a){return a===null||typeof a!="object"?null:(a=XM&&a[XM]||a["@@iterator"],typeof a=="function"?a:null)}var ZM={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},YM=Object.assign,UM={};function bd(a,i,p){this.props=a,this.context=i,this.refs=UM,this.updater=p||ZM}bd.prototype.isReactComponent={},bd.prototype.setState=function(a,i){if(typeof a!="object"&&typeof a!="function"&&a!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,a,i,"setState")},bd.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};function QM(){}QM.prototype=bd.prototype;function U1(a,i,p){this.props=a,this.context=i,this.refs=UM,this.updater=p||ZM}var Q1=U1.prototype=new QM;Q1.constructor=U1,YM(Q1,bd.prototype),Q1.isPureReactComponent=!0;var KM=Array.isArray,qM=Object.prototype.hasOwnProperty,K1={current:null},JM={key:!0,ref:!0,__self:!0,__source:!0};function $M(a,i,p){var f,g={},x=null,k=null;if(i!=null)for(f in i.ref!==void 0&&(k=i.ref),i.key!==void 0&&(x=""+i.key),i)qM.call(i,f)&&!JM.hasOwnProperty(f)&&(g[f]=i[f]);var N=arguments.length-2;if(N===1)g.children=p;else if(1<N){for(var E=Array(N),z=0;z<N;z++)E[z]=arguments[z+2];g.children=E}if(a&&a.defaultProps)for(f in N=a.defaultProps,N)g[f]===void 0&&(g[f]=N[f]);return{$$typeof:xh,type:a,key:x,ref:k,props:g,_owner:K1.current}}function dG(a,i){return{$$typeof:xh,type:a.type,key:i,ref:a.ref,props:a.props,_owner:a._owner}}function q1(a){return typeof a=="object"&&a!==null&&a.$$typeof===xh}function pG(a){var i={"=":"=0",":":"=2"};return"$"+a.replace(/[=:]/g,function(p){return i[p]})}var _M=/\/+/g;function J1(a,i){return typeof a=="object"&&a!==null&&a.key!=null?pG(""+a.key):i.toString(36)}function Qg(a,i,p,f,g){var x=typeof a;(x==="undefined"||x==="boolean")&&(a=null);var k=!1;if(a===null)k=!0;else switch(x){case"string":case"number":k=!0;break;case"object":switch(a.$$typeof){case xh:case tG:k=!0}}if(k)return k=a,g=g(k),a=f===""?"."+J1(k,0):f,KM(g)?(p="",a!=null&&(p=a.replace(_M,"$&/")+"/"),Qg(g,i,p,"",function(z){return z})):g!=null&&(q1(g)&&(g=dG(g,p+(!g.key||k&&k.key===g.key?"":(""+g.key).replace(_M,"$&/")+"/")+a)),i.push(g)),1;if(k=0,f=f===""?".":f+":",KM(a))for(var N=0;N<a.length;N++){x=a[N];var E=f+J1(x,N);k+=Qg(x,i,p,E,g)}else if(E=cG(a),typeof E=="function")for(a=E.call(a),N=0;!(x=a.next()).done;)x=x.value,E=f+J1(x,N++),k+=Qg(x,i,p,E,g);else if(x==="object")throw i=String(a),Error("Objects are not valid as a React child (found: "+(i==="[object Object]"?"object with keys {"+Object.keys(a).join(", ")+"}":i)+"). If you meant to render a collection of children, use an array instead.");return k}function Kg(a,i,p){if(a==null)return a;var f=[],g=0;return Qg(a,f,"","",function(x){return i.call(p,x,g++)}),f}function hG(a){if(a._status===-1){var i=a._result;i=i(),i.then(function(p){(a._status===0||a._status===-1)&&(a._status=1,a._result=p)},function(p){(a._status===0||a._status===-1)&&(a._status=2,a._result=p)}),a._status===-1&&(a._status=0,a._result=i)}if(a._status===1)return a._result.default;throw a._result}var Za={current:null},qg={transition:null},fG={ReactCurrentDispatcher:Za,ReactCurrentBatchConfig:qg,ReactCurrentOwner:K1};function eE(){throw Error("act(...) is not supported in production builds of React.")}jn.Children={map:Kg,forEach:function(a,i,p){Kg(a,function(){i.apply(this,arguments)},p)},count:function(a){var i=0;return Kg(a,function(){i++}),i},toArray:function(a){return Kg(a,function(i){return i})||[]},only:function(a){if(!q1(a))throw Error("React.Children.only expected to receive a single React element child.");return a}},jn.Component=bd,jn.Fragment=nG,jn.Profiler=sG,jn.PureComponent=U1,jn.StrictMode=rG,jn.Suspense=AG,jn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=fG,jn.act=eE,jn.cloneElement=function(a,i,p){if(a==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+a+".");var f=YM({},a.props),g=a.key,x=a.ref,k=a._owner;if(i!=null){if(i.ref!==void 0&&(x=i.ref,k=K1.current),i.key!==void 0&&(g=""+i.key),a.type&&a.type.defaultProps)var N=a.type.defaultProps;for(E in i)qM.call(i,E)&&!JM.hasOwnProperty(E)&&(f[E]=i[E]===void 0&&N!==void 0?N[E]:i[E])}var E=arguments.length-2;if(E===1)f.children=p;else if(1<E){N=Array(E);for(var z=0;z<E;z++)N[z]=arguments[z+2];f.children=N}return{$$typeof:xh,type:a.type,key:g,ref:x,props:f,_owner:k}},jn.createContext=function(a){return a={$$typeof:oG,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},a.Provider={$$typeof:aG,_context:a},a.Consumer=a},jn.createElement=$M,jn.createFactory=function(a){var i=$M.bind(null,a);return i.type=a,i},jn.createRef=function(){return{current:null}},jn.forwardRef=function(a){return{$$typeof:iG,render:a}},jn.isValidElement=q1,jn.lazy=function(a){return{$$typeof:uG,_payload:{_status:-1,_result:a},_init:hG}},jn.memo=function(a,i){return{$$typeof:lG,type:a,compare:i===void 0?null:i}},jn.startTransition=function(a){var i=qg.transition;qg.transition={};try{a()}finally{qg.transition=i}},jn.unstable_act=eE,jn.useCallback=function(a,i){return Za.current.useCallback(a,i)},jn.useContext=function(a){return Za.current.useContext(a)},jn.useDebugValue=function(){},jn.useDeferredValue=function(a){return Za.current.useDeferredValue(a)},jn.useEffect=function(a,i){return Za.current.useEffect(a,i)},jn.useId=function(){return Za.current.useId()},jn.useImperativeHandle=function(a,i,p){return Za.current.useImperativeHandle(a,i,p)},jn.useInsertionEffect=function(a,i){return Za.current.useInsertionEffect(a,i)},jn.useLayoutEffect=function(a,i){return Za.current.useLayoutEffect(a,i)},jn.useMemo=function(a,i){return Za.current.useMemo(a,i)},jn.useReducer=function(a,i,p){return Za.current.useReducer(a,i,p)},jn.useRef=function(a){return Za.current.useRef(a)},jn.useState=function(a){return Za.current.useState(a)},jn.useSyncExternalStore=function(a,i,p){return Za.current.useSyncExternalStore(a,i,p)},jn.useTransition=function(){return Za.current.useTransition()},jn.version="18.3.1",VM.exports=jn;var se=VM.exports;const Ya=Qr(se),Jg=ir({__proto__:null,default:Ya},[se]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var mG=se,gG=Symbol.for("react.element"),yG=Symbol.for("react.fragment"),bG=Object.prototype.hasOwnProperty,vG=mG.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,xG={key:!0,ref:!0,__self:!0,__source:!0};function tE(a,i,p){var f,g={},x=null,k=null;p!==void 0&&(x=""+p),i.key!==void 0&&(x=""+i.key),i.ref!==void 0&&(k=i.ref);for(f in i)bG.call(i,f)&&!xG.hasOwnProperty(f)&&(g[f]=i[f]);if(a&&a.defaultProps)for(f in i=a.defaultProps,i)g[f]===void 0&&(g[f]=i[f]);return{$$typeof:gG,type:a,key:x,ref:k,props:g,_owner:vG.current}}yd.Fragment=yG,yd.jsx=tE,yd.jsxs=tE,$u.exports=yd;var q=$u.exports,nE={exports:{}},Po={},rE={exports:{}},sE={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(a){function i(xe,We){var Ke=xe.length;xe.push(We);e:for(;0<Ke;){var ut=Ke-1>>>1,ge=xe[ut];if(0<g(ge,We))xe[ut]=We,xe[Ke]=ge,Ke=ut;else break e}}function p(xe){return xe.length===0?null:xe[0]}function f(xe){if(xe.length===0)return null;var We=xe[0],Ke=xe.pop();if(Ke!==We){xe[0]=Ke;e:for(var ut=0,ge=xe.length,Qe=ge>>>1;ut<Qe;){var At=2*(ut+1)-1,dt=xe[At],It=At+1,Ft=xe[It];if(0>g(dt,Ke))It<ge&&0>g(Ft,dt)?(xe[ut]=Ft,xe[It]=Ke,ut=It):(xe[ut]=dt,xe[At]=Ke,ut=At);else if(It<ge&&0>g(Ft,Ke))xe[ut]=Ft,xe[It]=Ke,ut=It;else break e}}return We}function g(xe,We){var Ke=xe.sortIndex-We.sortIndex;return Ke!==0?Ke:xe.id-We.id}if(typeof performance=="object"&&typeof performance.now=="function"){var x=performance;a.unstable_now=function(){return x.now()}}else{var k=Date,N=k.now();a.unstable_now=function(){return k.now()-N}}var E=[],z=[],G=1,j=null,M=3,R=!1,B=!1,P=!1,H=typeof setTimeout=="function"?setTimeout:null,C=typeof clearTimeout=="function"?clearTimeout:null,O=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function F(xe){for(var We=p(z);We!==null;){if(We.callback===null)f(z);else if(We.startTime<=xe)f(z),We.sortIndex=We.expirationTime,i(E,We);else break;We=p(z)}}function Y(xe){if(P=!1,F(xe),!B)if(p(E)!==null)B=!0,Ie(ae);else{var We=p(z);We!==null&&je(Y,We.startTime-xe)}}function ae(xe,We){B=!1,P&&(P=!1,C(fe),fe=-1),R=!0;var Ke=M;try{for(F(We),j=p(E);j!==null&&(!(j.expirationTime>We)||xe&&!ye());){var ut=j.callback;if(typeof ut=="function"){j.callback=null,M=j.priorityLevel;var ge=ut(j.expirationTime<=We);We=a.unstable_now(),typeof ge=="function"?j.callback=ge:j===p(E)&&f(E),F(We)}else f(E);j=p(E)}if(j!==null)var Qe=!0;else{var At=p(z);At!==null&&je(Y,At.startTime-We),Qe=!1}return Qe}finally{j=null,M=Ke,R=!1}}var te=!1,oe=null,fe=-1,ue=5,Z=-1;function ye(){return!(a.unstable_now()-Z<ue)}function pe(){if(oe!==null){var xe=a.unstable_now();Z=xe;var We=!0;try{We=oe(!0,xe)}finally{We?Q():(te=!1,oe=null)}}else te=!1}var Q;if(typeof O=="function")Q=function(){O(pe)};else if(typeof MessageChannel<"u"){var ke=new MessageChannel,ie=ke.port2;ke.port1.onmessage=pe,Q=function(){ie.postMessage(null)}}else Q=function(){H(pe,0)};function Ie(xe){oe=xe,te||(te=!0,Q())}function je(xe,We){fe=H(function(){xe(a.unstable_now())},We)}a.unstable_IdlePriority=5,a.unstable_ImmediatePriority=1,a.unstable_LowPriority=4,a.unstable_NormalPriority=3,a.unstable_Profiling=null,a.unstable_UserBlockingPriority=2,a.unstable_cancelCallback=function(xe){xe.callback=null},a.unstable_continueExecution=function(){B||R||(B=!0,Ie(ae))},a.unstable_forceFrameRate=function(xe){0>xe||125<xe?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):ue=0<xe?Math.floor(1e3/xe):5},a.unstable_getCurrentPriorityLevel=function(){return M},a.unstable_getFirstCallbackNode=function(){return p(E)},a.unstable_next=function(xe){switch(M){case 1:case 2:case 3:var We=3;break;default:We=M}var Ke=M;M=We;try{return xe()}finally{M=Ke}},a.unstable_pauseExecution=function(){},a.unstable_requestPaint=function(){},a.unstable_runWithPriority=function(xe,We){switch(xe){case 1:case 2:case 3:case 4:case 5:break;default:xe=3}var Ke=M;M=xe;try{return We()}finally{M=Ke}},a.unstable_scheduleCallback=function(xe,We,Ke){var ut=a.unstable_now();switch(typeof Ke=="object"&&Ke!==null?(Ke=Ke.delay,Ke=typeof Ke=="number"&&0<Ke?ut+Ke:ut):Ke=ut,xe){case 1:var ge=-1;break;case 2:ge=250;break;case 5:ge=1073741823;break;case 4:ge=1e4;break;default:ge=5e3}return ge=Ke+ge,xe={id:G++,callback:We,priorityLevel:xe,startTime:Ke,expirationTime:ge,sortIndex:-1},Ke>ut?(xe.sortIndex=Ke,i(z,xe),p(E)===null&&xe===p(z)&&(P?(C(fe),fe=-1):P=!0,je(Y,Ke-ut))):(xe.sortIndex=ge,i(E,xe),B||R||(B=!0,Ie(ae))),xe},a.unstable_shouldYield=ye,a.unstable_wrapCallback=function(xe){var We=M;return function(){var Ke=M;M=We;try{return xe.apply(this,arguments)}finally{M=Ke}}}})(sE),rE.exports=sE;var wG=rE.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var kG=se,Bo=wG;function Ct(a){for(var i="https://reactjs.org/docs/error-decoder.html?invariant="+a,p=1;p<arguments.length;p++)i+="&args[]="+encodeURIComponent(arguments[p]);return"Minified React error #"+a+"; visit "+i+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var aE=new Set,wh={};function _u(a,i){vd(a,i),vd(a+"Capture",i)}function vd(a,i){for(wh[a]=i,a=0;a<i.length;a++)aE.add(i[a])}var jA=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),$1=Object.prototype.hasOwnProperty,CG=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,oE={},iE={};function IG(a){return $1.call(iE,a)?!0:$1.call(oE,a)?!1:CG.test(a)?iE[a]=!0:(oE[a]=!0,!1)}function SG(a,i,p,f){if(p!==null&&p.type===0)return!1;switch(typeof i){case"function":case"symbol":return!0;case"boolean":return f?!1:p!==null?!p.acceptsBooleans:(a=a.toLowerCase().slice(0,5),a!=="data-"&&a!=="aria-");default:return!1}}function NG(a,i,p,f){if(i===null||typeof i>"u"||SG(a,i,p,f))return!0;if(f)return!1;if(p!==null)switch(p.type){case 3:return!i;case 4:return i===!1;case 5:return isNaN(i);case 6:return isNaN(i)||1>i}return!1}function Ua(a,i,p,f,g,x,k){this.acceptsBooleans=i===2||i===3||i===4,this.attributeName=f,this.attributeNamespace=g,this.mustUseProperty=p,this.propertyName=a,this.type=i,this.sanitizeURL=x,this.removeEmptyString=k}var ha={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){ha[a]=new Ua(a,0,!1,a,null,!1,!1)}),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var i=a[0];ha[i]=new Ua(i,1,!1,a[1],null,!1,!1)}),["contentEditable","draggable","spellCheck","value"].forEach(function(a){ha[a]=new Ua(a,2,!1,a.toLowerCase(),null,!1,!1)}),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){ha[a]=new Ua(a,2,!1,a,null,!1,!1)}),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){ha[a]=new Ua(a,3,!1,a.toLowerCase(),null,!1,!1)}),["checked","multiple","muted","selected"].forEach(function(a){ha[a]=new Ua(a,3,!0,a,null,!1,!1)}),["capture","download"].forEach(function(a){ha[a]=new Ua(a,4,!1,a,null,!1,!1)}),["cols","rows","size","span"].forEach(function(a){ha[a]=new Ua(a,6,!1,a,null,!1,!1)}),["rowSpan","start"].forEach(function(a){ha[a]=new Ua(a,5,!1,a.toLowerCase(),null,!1,!1)});var _1=/[\-:]([a-z])/g;function ew(a){return a[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var i=a.replace(_1,ew);ha[i]=new Ua(i,1,!1,a,null,!1,!1)}),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var i=a.replace(_1,ew);ha[i]=new Ua(i,1,!1,a,"http://www.w3.org/1999/xlink",!1,!1)}),["xml:base","xml:lang","xml:space"].forEach(function(a){var i=a.replace(_1,ew);ha[i]=new Ua(i,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1,!1)}),["tabIndex","crossOrigin"].forEach(function(a){ha[a]=new Ua(a,1,!1,a.toLowerCase(),null,!1,!1)}),ha.xlinkHref=new Ua("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach(function(a){ha[a]=new Ua(a,1,!1,a.toLowerCase(),null,!0,!0)});function tw(a,i,p,f){var g=ha.hasOwnProperty(i)?ha[i]:null;(g!==null?g.type!==0:f||!(2<i.length)||i[0]!=="o"&&i[0]!=="O"||i[1]!=="n"&&i[1]!=="N")&&(NG(i,p,g,f)&&(p=null),f||g===null?IG(i)&&(p===null?a.removeAttribute(i):a.setAttribute(i,""+p)):g.mustUseProperty?a[g.propertyName]=p===null?g.type===3?!1:"":p:(i=g.attributeName,f=g.attributeNamespace,p===null?a.removeAttribute(i):(g=g.type,p=g===3||g===4&&p===!0?"":""+p,f?a.setAttributeNS(f,i,p):a.setAttribute(i,p))))}var HA=kG.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,$g=Symbol.for("react.element"),xd=Symbol.for("react.portal"),wd=Symbol.for("react.fragment"),nw=Symbol.for("react.strict_mode"),rw=Symbol.for("react.profiler"),AE=Symbol.for("react.provider"),lE=Symbol.for("react.context"),sw=Symbol.for("react.forward_ref"),aw=Symbol.for("react.suspense"),ow=Symbol.for("react.suspense_list"),iw=Symbol.for("react.memo"),Tl=Symbol.for("react.lazy"),uE=Symbol.for("react.offscreen"),cE=Symbol.iterator;function kh(a){return a===null||typeof a!="object"?null:(a=cE&&a[cE]||a["@@iterator"],typeof a=="function"?a:null)}var Kr=Object.assign,Aw;function Ch(a){if(Aw===void 0)try{throw Error()}catch(p){var i=p.stack.trim().match(/\n( *(at )?)/);Aw=i&&i[1]||""}return`
`+Aw+a}var lw=!1;function uw(a,i){if(!a||lw)return"";lw=!0;var p=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(i)if(i=function(){throw Error()},Object.defineProperty(i.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(i,[])}catch(z){var f=z}Reflect.construct(a,[],i)}else{try{i.call()}catch(z){f=z}a.call(i.prototype)}else{try{throw Error()}catch(z){f=z}a()}}catch(z){if(z&&f&&typeof z.stack=="string"){for(var g=z.stack.split(`
`),x=f.stack.split(`
`),k=g.length-1,N=x.length-1;1<=k&&0<=N&&g[k]!==x[N];)N--;for(;1<=k&&0<=N;k--,N--)if(g[k]!==x[N]){if(k!==1||N!==1)do if(k--,N--,0>N||g[k]!==x[N]){var E=`
`+g[k].replace(" at new "," at ");return a.displayName&&E.includes("<anonymous>")&&(E=E.replace("<anonymous>",a.displayName)),E}while(1<=k&&0<=N);break}}}finally{lw=!1,Error.prepareStackTrace=p}return(a=a?a.displayName||a.name:"")?Ch(a):""}function TG(a){switch(a.tag){case 5:return Ch(a.type);case 16:return Ch("Lazy");case 13:return Ch("Suspense");case 19:return Ch("SuspenseList");case 0:case 2:case 15:return a=uw(a.type,!1),a;case 11:return a=uw(a.type.render,!1),a;case 1:return a=uw(a.type,!0),a;default:return""}}function cw(a){if(a==null)return null;if(typeof a=="function")return a.displayName||a.name||null;if(typeof a=="string")return a;switch(a){case wd:return"Fragment";case xd:return"Portal";case rw:return"Profiler";case nw:return"StrictMode";case aw:return"Suspense";case ow:return"SuspenseList"}if(typeof a=="object")switch(a.$$typeof){case lE:return(a.displayName||"Context")+".Consumer";case AE:return(a._context.displayName||"Context")+".Provider";case sw:var i=a.render;return a=a.displayName,a||(a=i.displayName||i.name||"",a=a!==""?"ForwardRef("+a+")":"ForwardRef"),a;case iw:return i=a.displayName||null,i!==null?i:cw(a.type)||"Memo";case Tl:i=a._payload,a=a._init;try{return cw(a(i))}catch{}}return null}function MG(a){var i=a.type;switch(a.tag){case 24:return"Cache";case 9:return(i.displayName||"Context")+".Consumer";case 10:return(i._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return a=i.render,a=a.displayName||a.name||"",i.displayName||(a!==""?"ForwardRef("+a+")":"ForwardRef");case 7:return"Fragment";case 5:return i;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return cw(i);case 8:return i===nw?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof i=="function")return i.displayName||i.name||null;if(typeof i=="string")return i}return null}function Ml(a){switch(typeof a){case"boolean":case"number":case"string":case"undefined":return a;case"object":return a;default:return""}}function dE(a){var i=a.type;return(a=a.nodeName)&&a.toLowerCase()==="input"&&(i==="checkbox"||i==="radio")}function EG(a){var i=dE(a)?"checked":"value",p=Object.getOwnPropertyDescriptor(a.constructor.prototype,i),f=""+a[i];if(!a.hasOwnProperty(i)&&typeof p<"u"&&typeof p.get=="function"&&typeof p.set=="function"){var g=p.get,x=p.set;return Object.defineProperty(a,i,{configurable:!0,get:function(){return g.call(this)},set:function(k){f=""+k,x.call(this,k)}}),Object.defineProperty(a,i,{enumerable:p.enumerable}),{getValue:function(){return f},setValue:function(k){f=""+k},stopTracking:function(){a._valueTracker=null,delete a[i]}}}}function _g(a){a._valueTracker||(a._valueTracker=EG(a))}function pE(a){if(!a)return!1;var i=a._valueTracker;if(!i)return!0;var p=i.getValue(),f="";return a&&(f=dE(a)?a.checked?"true":"false":a.value),a=f,a!==p?(i.setValue(a),!0):!1}function ey(a){if(a=a||(typeof document<"u"?document:void 0),typeof a>"u")return null;try{return a.activeElement||a.body}catch{return a.body}}function dw(a,i){var p=i.checked;return Kr({},i,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:p??a._wrapperState.initialChecked})}function hE(a,i){var p=i.defaultValue==null?"":i.defaultValue,f=i.checked!=null?i.checked:i.defaultChecked;p=Ml(i.value!=null?i.value:p),a._wrapperState={initialChecked:f,initialValue:p,controlled:i.type==="checkbox"||i.type==="radio"?i.checked!=null:i.value!=null}}function fE(a,i){i=i.checked,i!=null&&tw(a,"checked",i,!1)}function pw(a,i){fE(a,i);var p=Ml(i.value),f=i.type;if(p!=null)f==="number"?(p===0&&a.value===""||a.value!=p)&&(a.value=""+p):a.value!==""+p&&(a.value=""+p);else if(f==="submit"||f==="reset"){a.removeAttribute("value");return}i.hasOwnProperty("value")?hw(a,i.type,p):i.hasOwnProperty("defaultValue")&&hw(a,i.type,Ml(i.defaultValue)),i.checked==null&&i.defaultChecked!=null&&(a.defaultChecked=!!i.defaultChecked)}function mE(a,i,p){if(i.hasOwnProperty("value")||i.hasOwnProperty("defaultValue")){var f=i.type;if(!(f!=="submit"&&f!=="reset"||i.value!==void 0&&i.value!==null))return;i=""+a._wrapperState.initialValue,p||i===a.value||(a.value=i),a.defaultValue=i}p=a.name,p!==""&&(a.name=""),a.defaultChecked=!!a._wrapperState.initialChecked,p!==""&&(a.name=p)}function hw(a,i,p){(i!=="number"||ey(a.ownerDocument)!==a)&&(p==null?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+p&&(a.defaultValue=""+p))}var Ih=Array.isArray;function kd(a,i,p,f){if(a=a.options,i){i={};for(var g=0;g<p.length;g++)i["$"+p[g]]=!0;for(p=0;p<a.length;p++)g=i.hasOwnProperty("$"+a[p].value),a[p].selected!==g&&(a[p].selected=g),g&&f&&(a[p].defaultSelected=!0)}else{for(p=""+Ml(p),i=null,g=0;g<a.length;g++){if(a[g].value===p){a[g].selected=!0,f&&(a[g].defaultSelected=!0);return}i!==null||a[g].disabled||(i=a[g])}i!==null&&(i.selected=!0)}}function fw(a,i){if(i.dangerouslySetInnerHTML!=null)throw Error(Ct(91));return Kr({},i,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function gE(a,i){var p=i.value;if(p==null){if(p=i.children,i=i.defaultValue,p!=null){if(i!=null)throw Error(Ct(92));if(Ih(p)){if(1<p.length)throw Error(Ct(93));p=p[0]}i=p}i==null&&(i=""),p=i}a._wrapperState={initialValue:Ml(p)}}function yE(a,i){var p=Ml(i.value),f=Ml(i.defaultValue);p!=null&&(p=""+p,p!==a.value&&(a.value=p),i.defaultValue==null&&a.defaultValue!==p&&(a.defaultValue=p)),f!=null&&(a.defaultValue=""+f)}function bE(a){var i=a.textContent;i===a._wrapperState.initialValue&&i!==""&&i!==null&&(a.value=i)}function vE(a){switch(a){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function mw(a,i){return a==null||a==="http://www.w3.org/1999/xhtml"?vE(i):a==="http://www.w3.org/2000/svg"&&i==="foreignObject"?"http://www.w3.org/1999/xhtml":a}var ty,xE=function(a){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(i,p,f,g){MSApp.execUnsafeLocalFunction(function(){return a(i,p,f,g)})}:a}(function(a,i){if(a.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in a)a.innerHTML=i;else{for(ty=ty||document.createElement("div"),ty.innerHTML="<svg>"+i.valueOf().toString()+"</svg>",i=ty.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;i.firstChild;)a.appendChild(i.firstChild)}});function Sh(a,i){if(i){var p=a.firstChild;if(p&&p===a.lastChild&&p.nodeType===3){p.nodeValue=i;return}}a.textContent=i}var Nh={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},DG=["Webkit","ms","Moz","O"];Object.keys(Nh).forEach(function(a){DG.forEach(function(i){i=i+a.charAt(0).toUpperCase()+a.substring(1),Nh[i]=Nh[a]})});function wE(a,i,p){return i==null||typeof i=="boolean"||i===""?"":p||typeof i!="number"||i===0||Nh.hasOwnProperty(a)&&Nh[a]?(""+i).trim():i+"px"}function kE(a,i){a=a.style;for(var p in i)if(i.hasOwnProperty(p)){var f=p.indexOf("--")===0,g=wE(p,i[p],f);p==="float"&&(p="cssFloat"),f?a.setProperty(p,g):a[p]=g}}var zG=Kr({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function gw(a,i){if(i){if(zG[a]&&(i.children!=null||i.dangerouslySetInnerHTML!=null))throw Error(Ct(137,a));if(i.dangerouslySetInnerHTML!=null){if(i.children!=null)throw Error(Ct(60));if(typeof i.dangerouslySetInnerHTML!="object"||!("__html"in i.dangerouslySetInnerHTML))throw Error(Ct(61))}if(i.style!=null&&typeof i.style!="object")throw Error(Ct(62))}}function yw(a,i){if(a.indexOf("-")===-1)return typeof i.is=="string";switch(a){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var bw=null;function vw(a){return a=a.target||a.srcElement||window,a.correspondingUseElement&&(a=a.correspondingUseElement),a.nodeType===3?a.parentNode:a}var xw=null,Cd=null,Id=null;function CE(a){if(a=Kh(a)){if(typeof xw!="function")throw Error(Ct(280));var i=a.stateNode;i&&(i=Cy(i),xw(a.stateNode,a.type,i))}}function IE(a){Cd?Id?Id.push(a):Id=[a]:Cd=a}function SE(){if(Cd){var a=Cd,i=Id;if(Id=Cd=null,CE(a),i)for(a=0;a<i.length;a++)CE(i[a])}}function NE(a,i){return a(i)}function TE(){}var ww=!1;function ME(a,i,p){if(ww)return a(i,p);ww=!0;try{return NE(a,i,p)}finally{ww=!1,(Cd!==null||Id!==null)&&(TE(),SE())}}function Th(a,i){var p=a.stateNode;if(p===null)return null;var f=Cy(p);if(f===null)return null;p=f[i];e:switch(i){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(f=!f.disabled)||(a=a.type,f=!(a==="button"||a==="input"||a==="select"||a==="textarea")),a=!f;break e;default:a=!1}if(a)return null;if(p&&typeof p!="function")throw Error(Ct(231,i,typeof p));return p}var kw=!1;if(jA)try{var Mh={};Object.defineProperty(Mh,"passive",{get:function(){kw=!0}}),window.addEventListener("test",Mh,Mh),window.removeEventListener("test",Mh,Mh)}catch{kw=!1}function OG(a,i,p,f,g,x,k,N,E){var z=Array.prototype.slice.call(arguments,3);try{i.apply(p,z)}catch(G){this.onError(G)}}var Eh=!1,ny=null,ry=!1,Cw=null,PG={onError:function(a){Eh=!0,ny=a}};function BG(a,i,p,f,g,x,k,N,E){Eh=!1,ny=null,OG.apply(PG,arguments)}function FG(a,i,p,f,g,x,k,N,E){if(BG.apply(this,arguments),Eh){if(Eh){var z=ny;Eh=!1,ny=null}else throw Error(Ct(198));ry||(ry=!0,Cw=z)}}function ec(a){var i=a,p=a;if(a.alternate)for(;i.return;)i=i.return;else{a=i;do i=a,i.flags&4098&&(p=i.return),a=i.return;while(a)}return i.tag===3?p:null}function EE(a){if(a.tag===13){var i=a.memoizedState;if(i===null&&(a=a.alternate,a!==null&&(i=a.memoizedState)),i!==null)return i.dehydrated}return null}function DE(a){if(ec(a)!==a)throw Error(Ct(188))}function LG(a){var i=a.alternate;if(!i){if(i=ec(a),i===null)throw Error(Ct(188));return i!==a?null:a}for(var p=a,f=i;;){var g=p.return;if(g===null)break;var x=g.alternate;if(x===null){if(f=g.return,f!==null){p=f;continue}break}if(g.child===x.child){for(x=g.child;x;){if(x===p)return DE(g),a;if(x===f)return DE(g),i;x=x.sibling}throw Error(Ct(188))}if(p.return!==f.return)p=g,f=x;else{for(var k=!1,N=g.child;N;){if(N===p){k=!0,p=g,f=x;break}if(N===f){k=!0,f=g,p=x;break}N=N.sibling}if(!k){for(N=x.child;N;){if(N===p){k=!0,p=x,f=g;break}if(N===f){k=!0,f=x,p=g;break}N=N.sibling}if(!k)throw Error(Ct(189))}}if(p.alternate!==f)throw Error(Ct(190))}if(p.tag!==3)throw Error(Ct(188));return p.stateNode.current===p?a:i}function zE(a){return a=LG(a),a!==null?OE(a):null}function OE(a){if(a.tag===5||a.tag===6)return a;for(a=a.child;a!==null;){var i=OE(a);if(i!==null)return i;a=a.sibling}return null}var PE=Bo.unstable_scheduleCallback,BE=Bo.unstable_cancelCallback,RG=Bo.unstable_shouldYield,WG=Bo.unstable_requestPaint,hs=Bo.unstable_now,jG=Bo.unstable_getCurrentPriorityLevel,Iw=Bo.unstable_ImmediatePriority,FE=Bo.unstable_UserBlockingPriority,sy=Bo.unstable_NormalPriority,HG=Bo.unstable_LowPriority,LE=Bo.unstable_IdlePriority,ay=null,oA=null;function GG(a){if(oA&&typeof oA.onCommitFiberRoot=="function")try{oA.onCommitFiberRoot(ay,a,void 0,(a.current.flags&128)===128)}catch{}}var zi=Math.clz32?Math.clz32:ZG,VG=Math.log,XG=Math.LN2;function ZG(a){return a>>>=0,a===0?32:31-(VG(a)/XG|0)|0}var oy=64,iy=4194304;function Dh(a){switch(a&-a){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return a&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return a&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return a}}function Ay(a,i){var p=a.pendingLanes;if(p===0)return 0;var f=0,g=a.suspendedLanes,x=a.pingedLanes,k=p&268435455;if(k!==0){var N=k&~g;N!==0?f=Dh(N):(x&=k,x!==0&&(f=Dh(x)))}else k=p&~g,k!==0?f=Dh(k):x!==0&&(f=Dh(x));if(f===0)return 0;if(i!==0&&i!==f&&!(i&g)&&(g=f&-f,x=i&-i,g>=x||g===16&&(x&4194240)!==0))return i;if(f&4&&(f|=p&16),i=a.entangledLanes,i!==0)for(a=a.entanglements,i&=f;0<i;)p=31-zi(i),g=1<<p,f|=a[p],i&=~g;return f}function YG(a,i){switch(a){case 1:case 2:case 4:return i+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return i+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function UG(a,i){for(var p=a.suspendedLanes,f=a.pingedLanes,g=a.expirationTimes,x=a.pendingLanes;0<x;){var k=31-zi(x),N=1<<k,E=g[k];E===-1?(!(N&p)||N&f)&&(g[k]=YG(N,i)):E<=i&&(a.expiredLanes|=N),x&=~N}}function Sw(a){return a=a.pendingLanes&-1073741825,a!==0?a:a&1073741824?1073741824:0}function RE(){var a=oy;return oy<<=1,!(oy&4194240)&&(oy=64),a}function Nw(a){for(var i=[],p=0;31>p;p++)i.push(a);return i}function zh(a,i,p){a.pendingLanes|=i,i!==536870912&&(a.suspendedLanes=0,a.pingedLanes=0),a=a.eventTimes,i=31-zi(i),a[i]=p}function QG(a,i){var p=a.pendingLanes&~i;a.pendingLanes=i,a.suspendedLanes=0,a.pingedLanes=0,a.expiredLanes&=i,a.mutableReadLanes&=i,a.entangledLanes&=i,i=a.entanglements;var f=a.eventTimes;for(a=a.expirationTimes;0<p;){var g=31-zi(p),x=1<<g;i[g]=0,f[g]=-1,a[g]=-1,p&=~x}}function Tw(a,i){var p=a.entangledLanes|=i;for(a=a.entanglements;p;){var f=31-zi(p),g=1<<f;g&i|a[f]&i&&(a[f]|=i),p&=~g}}var mr=0;function WE(a){return a&=-a,1<a?4<a?a&268435455?16:536870912:4:1}var jE,Mw,HE,GE,VE,Ew=!1,ly=[],El=null,Dl=null,zl=null,Oh=new Map,Ph=new Map,Ol=[],KG="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function XE(a,i){switch(a){case"focusin":case"focusout":El=null;break;case"dragenter":case"dragleave":Dl=null;break;case"mouseover":case"mouseout":zl=null;break;case"pointerover":case"pointerout":Oh.delete(i.pointerId);break;case"gotpointercapture":case"lostpointercapture":Ph.delete(i.pointerId)}}function Bh(a,i,p,f,g,x){return a===null||a.nativeEvent!==x?(a={blockedOn:i,domEventName:p,eventSystemFlags:f,nativeEvent:x,targetContainers:[g]},i!==null&&(i=Kh(i),i!==null&&Mw(i)),a):(a.eventSystemFlags|=f,i=a.targetContainers,g!==null&&i.indexOf(g)===-1&&i.push(g),a)}function qG(a,i,p,f,g){switch(i){case"focusin":return El=Bh(El,a,i,p,f,g),!0;case"dragenter":return Dl=Bh(Dl,a,i,p,f,g),!0;case"mouseover":return zl=Bh(zl,a,i,p,f,g),!0;case"pointerover":var x=g.pointerId;return Oh.set(x,Bh(Oh.get(x)||null,a,i,p,f,g)),!0;case"gotpointercapture":return x=g.pointerId,Ph.set(x,Bh(Ph.get(x)||null,a,i,p,f,g)),!0}return!1}function ZE(a){var i=tc(a.target);if(i!==null){var p=ec(i);if(p!==null){if(i=p.tag,i===13){if(i=EE(p),i!==null){a.blockedOn=i,VE(a.priority,function(){HE(p)});return}}else if(i===3&&p.stateNode.current.memoizedState.isDehydrated){a.blockedOn=p.tag===3?p.stateNode.containerInfo:null;return}}}a.blockedOn=null}function uy(a){if(a.blockedOn!==null)return!1;for(var i=a.targetContainers;0<i.length;){var p=zw(a.domEventName,a.eventSystemFlags,i[0],a.nativeEvent);if(p===null){p=a.nativeEvent;var f=new p.constructor(p.type,p);bw=f,p.target.dispatchEvent(f),bw=null}else return i=Kh(p),i!==null&&Mw(i),a.blockedOn=p,!1;i.shift()}return!0}function YE(a,i,p){uy(a)&&p.delete(i)}function JG(){Ew=!1,El!==null&&uy(El)&&(El=null),Dl!==null&&uy(Dl)&&(Dl=null),zl!==null&&uy(zl)&&(zl=null),Oh.forEach(YE),Ph.forEach(YE)}function Fh(a,i){a.blockedOn===i&&(a.blockedOn=null,Ew||(Ew=!0,Bo.unstable_scheduleCallback(Bo.unstable_NormalPriority,JG)))}function Lh(a){function i(g){return Fh(g,a)}if(0<ly.length){Fh(ly[0],a);for(var p=1;p<ly.length;p++){var f=ly[p];f.blockedOn===a&&(f.blockedOn=null)}}for(El!==null&&Fh(El,a),Dl!==null&&Fh(Dl,a),zl!==null&&Fh(zl,a),Oh.forEach(i),Ph.forEach(i),p=0;p<Ol.length;p++)f=Ol[p],f.blockedOn===a&&(f.blockedOn=null);for(;0<Ol.length&&(p=Ol[0],p.blockedOn===null);)ZE(p),p.blockedOn===null&&Ol.shift()}var Sd=HA.ReactCurrentBatchConfig,cy=!0;function $G(a,i,p,f){var g=mr,x=Sd.transition;Sd.transition=null;try{mr=1,Dw(a,i,p,f)}finally{mr=g,Sd.transition=x}}function _G(a,i,p,f){var g=mr,x=Sd.transition;Sd.transition=null;try{mr=4,Dw(a,i,p,f)}finally{mr=g,Sd.transition=x}}function Dw(a,i,p,f){if(cy){var g=zw(a,i,p,f);if(g===null)Kw(a,i,f,dy,p),XE(a,f);else if(qG(g,a,i,p,f))f.stopPropagation();else if(XE(a,f),i&4&&-1<KG.indexOf(a)){for(;g!==null;){var x=Kh(g);if(x!==null&&jE(x),x=zw(a,i,p,f),x===null&&Kw(a,i,f,dy,p),x===g)break;g=x}g!==null&&f.stopPropagation()}else Kw(a,i,f,null,p)}}var dy=null;function zw(a,i,p,f){if(dy=null,a=vw(f),a=tc(a),a!==null)if(i=ec(a),i===null)a=null;else if(p=i.tag,p===13){if(a=EE(i),a!==null)return a;a=null}else if(p===3){if(i.stateNode.current.memoizedState.isDehydrated)return i.tag===3?i.stateNode.containerInfo:null;a=null}else i!==a&&(a=null);return dy=a,null}function UE(a){switch(a){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(jG()){case Iw:return 1;case FE:return 4;case sy:case HG:return 16;case LE:return 536870912;default:return 16}default:return 16}}var Pl=null,Ow=null,py=null;function QE(){if(py)return py;var a,i=Ow,p=i.length,f,g="value"in Pl?Pl.value:Pl.textContent,x=g.length;for(a=0;a<p&&i[a]===g[a];a++);var k=p-a;for(f=1;f<=k&&i[p-f]===g[x-f];f++);return py=g.slice(a,1<f?1-f:void 0)}function hy(a){var i=a.keyCode;return"charCode"in a?(a=a.charCode,a===0&&i===13&&(a=13)):a=i,a===10&&(a=13),32<=a||a===13?a:0}function fy(){return!0}function KE(){return!1}function Fo(a){function i(p,f,g,x,k){this._reactName=p,this._targetInst=g,this.type=f,this.nativeEvent=x,this.target=k,this.currentTarget=null;for(var N in a)a.hasOwnProperty(N)&&(p=a[N],this[N]=p?p(x):x[N]);return this.isDefaultPrevented=(x.defaultPrevented!=null?x.defaultPrevented:x.returnValue===!1)?fy:KE,this.isPropagationStopped=KE,this}return Kr(i.prototype,{preventDefault:function(){this.defaultPrevented=!0;var p=this.nativeEvent;p&&(p.preventDefault?p.preventDefault():typeof p.returnValue!="unknown"&&(p.returnValue=!1),this.isDefaultPrevented=fy)},stopPropagation:function(){var p=this.nativeEvent;p&&(p.stopPropagation?p.stopPropagation():typeof p.cancelBubble!="unknown"&&(p.cancelBubble=!0),this.isPropagationStopped=fy)},persist:function(){},isPersistent:fy}),i}var Nd={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Pw=Fo(Nd),Rh=Kr({},Nd,{view:0,detail:0}),eV=Fo(Rh),Bw,Fw,Wh,my=Kr({},Rh,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Rw,button:0,buttons:0,relatedTarget:function(a){return a.relatedTarget===void 0?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){return"movementX"in a?a.movementX:(a!==Wh&&(Wh&&a.type==="mousemove"?(Bw=a.screenX-Wh.screenX,Fw=a.screenY-Wh.screenY):Fw=Bw=0,Wh=a),Bw)},movementY:function(a){return"movementY"in a?a.movementY:Fw}}),qE=Fo(my),tV=Kr({},my,{dataTransfer:0}),nV=Fo(tV),rV=Kr({},Rh,{relatedTarget:0}),Lw=Fo(rV),sV=Kr({},Nd,{animationName:0,elapsedTime:0,pseudoElement:0}),aV=Fo(sV),oV=Kr({},Nd,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),iV=Fo(oV),AV=Kr({},Nd,{data:0}),JE=Fo(AV),lV={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},uV={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},cV={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function dV(a){var i=this.nativeEvent;return i.getModifierState?i.getModifierState(a):(a=cV[a])?!!i[a]:!1}function Rw(){return dV}var pV=Kr({},Rh,{key:function(a){if(a.key){var i=lV[a.key]||a.key;if(i!=="Unidentified")return i}return a.type==="keypress"?(a=hy(a),a===13?"Enter":String.fromCharCode(a)):a.type==="keydown"||a.type==="keyup"?uV[a.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Rw,charCode:function(a){return a.type==="keypress"?hy(a):0},keyCode:function(a){return a.type==="keydown"||a.type==="keyup"?a.keyCode:0},which:function(a){return a.type==="keypress"?hy(a):a.type==="keydown"||a.type==="keyup"?a.keyCode:0}}),hV=Fo(pV),fV=Kr({},my,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),$E=Fo(fV),mV=Kr({},Rh,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Rw}),gV=Fo(mV),yV=Kr({},Nd,{propertyName:0,elapsedTime:0,pseudoElement:0}),bV=Fo(yV),vV=Kr({},my,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),xV=Fo(vV),wV=[9,13,27,32],Ww=jA&&"CompositionEvent"in window,jh=null;jA&&"documentMode"in document&&(jh=document.documentMode);var kV=jA&&"TextEvent"in window&&!jh,_E=jA&&(!Ww||jh&&8<jh&&11>=jh),eD=" ",tD=!1;function nD(a,i){switch(a){case"keyup":return wV.indexOf(i.keyCode)!==-1;case"keydown":return i.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function rD(a){return a=a.detail,typeof a=="object"&&"data"in a?a.data:null}var Td=!1;function CV(a,i){switch(a){case"compositionend":return rD(i);case"keypress":return i.which!==32?null:(tD=!0,eD);case"textInput":return a=i.data,a===eD&&tD?null:a;default:return null}}function IV(a,i){if(Td)return a==="compositionend"||!Ww&&nD(a,i)?(a=QE(),py=Ow=Pl=null,Td=!1,a):null;switch(a){case"paste":return null;case"keypress":if(!(i.ctrlKey||i.altKey||i.metaKey)||i.ctrlKey&&i.altKey){if(i.char&&1<i.char.length)return i.char;if(i.which)return String.fromCharCode(i.which)}return null;case"compositionend":return _E&&i.locale!=="ko"?null:i.data;default:return null}}var SV={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function sD(a){var i=a&&a.nodeName&&a.nodeName.toLowerCase();return i==="input"?!!SV[a.type]:i==="textarea"}function aD(a,i,p,f){IE(f),i=xy(i,"onChange"),0<i.length&&(p=new Pw("onChange","change",null,p,f),a.push({event:p,listeners:i}))}var Hh=null,Gh=null;function NV(a){kD(a,0)}function gy(a){var i=Od(a);if(pE(i))return a}function TV(a,i){if(a==="change")return i}var oD=!1;if(jA){var jw;if(jA){var Hw="oninput"in document;if(!Hw){var iD=document.createElement("div");iD.setAttribute("oninput","return;"),Hw=typeof iD.oninput=="function"}jw=Hw}else jw=!1;oD=jw&&(!document.documentMode||9<document.documentMode)}function AD(){Hh&&(Hh.detachEvent("onpropertychange",lD),Gh=Hh=null)}function lD(a){if(a.propertyName==="value"&&gy(Gh)){var i=[];aD(i,Gh,a,vw(a)),ME(NV,i)}}function MV(a,i,p){a==="focusin"?(AD(),Hh=i,Gh=p,Hh.attachEvent("onpropertychange",lD)):a==="focusout"&&AD()}function EV(a){if(a==="selectionchange"||a==="keyup"||a==="keydown")return gy(Gh)}function DV(a,i){if(a==="click")return gy(i)}function zV(a,i){if(a==="input"||a==="change")return gy(i)}function OV(a,i){return a===i&&(a!==0||1/a===1/i)||a!==a&&i!==i}var Oi=typeof Object.is=="function"?Object.is:OV;function Vh(a,i){if(Oi(a,i))return!0;if(typeof a!="object"||a===null||typeof i!="object"||i===null)return!1;var p=Object.keys(a),f=Object.keys(i);if(p.length!==f.length)return!1;for(f=0;f<p.length;f++){var g=p[f];if(!$1.call(i,g)||!Oi(a[g],i[g]))return!1}return!0}function uD(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function cD(a,i){var p=uD(a);a=0;for(var f;p;){if(p.nodeType===3){if(f=a+p.textContent.length,a<=i&&f>=i)return{node:p,offset:i-a};a=f}e:{for(;p;){if(p.nextSibling){p=p.nextSibling;break e}p=p.parentNode}p=void 0}p=uD(p)}}function dD(a,i){return a&&i?a===i?!0:a&&a.nodeType===3?!1:i&&i.nodeType===3?dD(a,i.parentNode):"contains"in a?a.contains(i):a.compareDocumentPosition?!!(a.compareDocumentPosition(i)&16):!1:!1}function pD(){for(var a=window,i=ey();i instanceof a.HTMLIFrameElement;){try{var p=typeof i.contentWindow.location.href=="string"}catch{p=!1}if(p)a=i.contentWindow;else break;i=ey(a.document)}return i}function Gw(a){var i=a&&a.nodeName&&a.nodeName.toLowerCase();return i&&(i==="input"&&(a.type==="text"||a.type==="search"||a.type==="tel"||a.type==="url"||a.type==="password")||i==="textarea"||a.contentEditable==="true")}function PV(a){var i=pD(),p=a.focusedElem,f=a.selectionRange;if(i!==p&&p&&p.ownerDocument&&dD(p.ownerDocument.documentElement,p)){if(f!==null&&Gw(p)){if(i=f.start,a=f.end,a===void 0&&(a=i),"selectionStart"in p)p.selectionStart=i,p.selectionEnd=Math.min(a,p.value.length);else if(a=(i=p.ownerDocument||document)&&i.defaultView||window,a.getSelection){a=a.getSelection();var g=p.textContent.length,x=Math.min(f.start,g);f=f.end===void 0?x:Math.min(f.end,g),!a.extend&&x>f&&(g=f,f=x,x=g),g=cD(p,x);var k=cD(p,f);g&&k&&(a.rangeCount!==1||a.anchorNode!==g.node||a.anchorOffset!==g.offset||a.focusNode!==k.node||a.focusOffset!==k.offset)&&(i=i.createRange(),i.setStart(g.node,g.offset),a.removeAllRanges(),x>f?(a.addRange(i),a.extend(k.node,k.offset)):(i.setEnd(k.node,k.offset),a.addRange(i)))}}for(i=[],a=p;a=a.parentNode;)a.nodeType===1&&i.push({element:a,left:a.scrollLeft,top:a.scrollTop});for(typeof p.focus=="function"&&p.focus(),p=0;p<i.length;p++)a=i[p],a.element.scrollLeft=a.left,a.element.scrollTop=a.top}}var BV=jA&&"documentMode"in document&&11>=document.documentMode,Md=null,Vw=null,Xh=null,Xw=!1;function hD(a,i,p){var f=p.window===p?p.document:p.nodeType===9?p:p.ownerDocument;Xw||Md==null||Md!==ey(f)||(f=Md,"selectionStart"in f&&Gw(f)?f={start:f.selectionStart,end:f.selectionEnd}:(f=(f.ownerDocument&&f.ownerDocument.defaultView||window).getSelection(),f={anchorNode:f.anchorNode,anchorOffset:f.anchorOffset,focusNode:f.focusNode,focusOffset:f.focusOffset}),Xh&&Vh(Xh,f)||(Xh=f,f=xy(Vw,"onSelect"),0<f.length&&(i=new Pw("onSelect","select",null,i,p),a.push({event:i,listeners:f}),i.target=Md)))}function yy(a,i){var p={};return p[a.toLowerCase()]=i.toLowerCase(),p["Webkit"+a]="webkit"+i,p["Moz"+a]="moz"+i,p}var Ed={animationend:yy("Animation","AnimationEnd"),animationiteration:yy("Animation","AnimationIteration"),animationstart:yy("Animation","AnimationStart"),transitionend:yy("Transition","TransitionEnd")},Zw={},fD={};jA&&(fD=document.createElement("div").style,"AnimationEvent"in window||(delete Ed.animationend.animation,delete Ed.animationiteration.animation,delete Ed.animationstart.animation),"TransitionEvent"in window||delete Ed.transitionend.transition);function by(a){if(Zw[a])return Zw[a];if(!Ed[a])return a;var i=Ed[a],p;for(p in i)if(i.hasOwnProperty(p)&&p in fD)return Zw[a]=i[p];return a}var mD=by("animationend"),gD=by("animationiteration"),yD=by("animationstart"),bD=by("transitionend"),vD=new Map,xD="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Bl(a,i){vD.set(a,i),_u(i,[a])}for(var Yw=0;Yw<xD.length;Yw++){var Uw=xD[Yw],FV=Uw.toLowerCase(),LV=Uw[0].toUpperCase()+Uw.slice(1);Bl(FV,"on"+LV)}Bl(mD,"onAnimationEnd"),Bl(gD,"onAnimationIteration"),Bl(yD,"onAnimationStart"),Bl("dblclick","onDoubleClick"),Bl("focusin","onFocus"),Bl("focusout","onBlur"),Bl(bD,"onTransitionEnd"),vd("onMouseEnter",["mouseout","mouseover"]),vd("onMouseLeave",["mouseout","mouseover"]),vd("onPointerEnter",["pointerout","pointerover"]),vd("onPointerLeave",["pointerout","pointerover"]),_u("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),_u("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),_u("onBeforeInput",["compositionend","keypress","textInput","paste"]),_u("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),_u("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),_u("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Zh="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),RV=new Set("cancel close invalid load scroll toggle".split(" ").concat(Zh));function wD(a,i,p){var f=a.type||"unknown-event";a.currentTarget=p,FG(f,i,void 0,a),a.currentTarget=null}function kD(a,i){i=(i&4)!==0;for(var p=0;p<a.length;p++){var f=a[p],g=f.event;f=f.listeners;e:{var x=void 0;if(i)for(var k=f.length-1;0<=k;k--){var N=f[k],E=N.instance,z=N.currentTarget;if(N=N.listener,E!==x&&g.isPropagationStopped())break e;wD(g,N,z),x=E}else for(k=0;k<f.length;k++){if(N=f[k],E=N.instance,z=N.currentTarget,N=N.listener,E!==x&&g.isPropagationStopped())break e;wD(g,N,z),x=E}}}if(ry)throw a=Cw,ry=!1,Cw=null,a}function Pr(a,i){var p=i[t2];p===void 0&&(p=i[t2]=new Set);var f=a+"__bubble";p.has(f)||(CD(i,a,2,!1),p.add(f))}function Qw(a,i,p){var f=0;i&&(f|=4),CD(p,a,f,i)}var vy="_reactListening"+Math.random().toString(36).slice(2);function Yh(a){if(!a[vy]){a[vy]=!0,aE.forEach(function(p){p!=="selectionchange"&&(RV.has(p)||Qw(p,!1,a),Qw(p,!0,a))});var i=a.nodeType===9?a:a.ownerDocument;i===null||i[vy]||(i[vy]=!0,Qw("selectionchange",!1,i))}}function CD(a,i,p,f){switch(UE(i)){case 1:var g=$G;break;case 4:g=_G;break;default:g=Dw}p=g.bind(null,i,p,a),g=void 0,!kw||i!=="touchstart"&&i!=="touchmove"&&i!=="wheel"||(g=!0),f?g!==void 0?a.addEventListener(i,p,{capture:!0,passive:g}):a.addEventListener(i,p,!0):g!==void 0?a.addEventListener(i,p,{passive:g}):a.addEventListener(i,p,!1)}function Kw(a,i,p,f,g){var x=f;if(!(i&1)&&!(i&2)&&f!==null)e:for(;;){if(f===null)return;var k=f.tag;if(k===3||k===4){var N=f.stateNode.containerInfo;if(N===g||N.nodeType===8&&N.parentNode===g)break;if(k===4)for(k=f.return;k!==null;){var E=k.tag;if((E===3||E===4)&&(E=k.stateNode.containerInfo,E===g||E.nodeType===8&&E.parentNode===g))return;k=k.return}for(;N!==null;){if(k=tc(N),k===null)return;if(E=k.tag,E===5||E===6){f=x=k;continue e}N=N.parentNode}}f=f.return}ME(function(){var z=x,G=vw(p),j=[];e:{var M=vD.get(a);if(M!==void 0){var R=Pw,B=a;switch(a){case"keypress":if(hy(p)===0)break e;case"keydown":case"keyup":R=hV;break;case"focusin":B="focus",R=Lw;break;case"focusout":B="blur",R=Lw;break;case"beforeblur":case"afterblur":R=Lw;break;case"click":if(p.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":R=qE;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":R=nV;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":R=gV;break;case mD:case gD:case yD:R=aV;break;case bD:R=bV;break;case"scroll":R=eV;break;case"wheel":R=xV;break;case"copy":case"cut":case"paste":R=iV;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":R=$E}var P=(i&4)!==0,H=!P&&a==="scroll",C=P?M!==null?M+"Capture":null:M;P=[];for(var O=z,F;O!==null;){F=O;var Y=F.stateNode;if(F.tag===5&&Y!==null&&(F=Y,C!==null&&(Y=Th(O,C),Y!=null&&P.push(Uh(O,Y,F)))),H)break;O=O.return}0<P.length&&(M=new R(M,B,null,p,G),j.push({event:M,listeners:P}))}}if(!(i&7)){e:{if(M=a==="mouseover"||a==="pointerover",R=a==="mouseout"||a==="pointerout",M&&p!==bw&&(B=p.relatedTarget||p.fromElement)&&(tc(B)||B[GA]))break e;if((R||M)&&(M=G.window===G?G:(M=G.ownerDocument)?M.defaultView||M.parentWindow:window,R?(B=p.relatedTarget||p.toElement,R=z,B=B?tc(B):null,B!==null&&(H=ec(B),B!==H||B.tag!==5&&B.tag!==6)&&(B=null)):(R=null,B=z),R!==B)){if(P=qE,Y="onMouseLeave",C="onMouseEnter",O="mouse",(a==="pointerout"||a==="pointerover")&&(P=$E,Y="onPointerLeave",C="onPointerEnter",O="pointer"),H=R==null?M:Od(R),F=B==null?M:Od(B),M=new P(Y,O+"leave",R,p,G),M.target=H,M.relatedTarget=F,Y=null,tc(G)===z&&(P=new P(C,O+"enter",B,p,G),P.target=F,P.relatedTarget=H,Y=P),H=Y,R&&B)t:{for(P=R,C=B,O=0,F=P;F;F=Dd(F))O++;for(F=0,Y=C;Y;Y=Dd(Y))F++;for(;0<O-F;)P=Dd(P),O--;for(;0<F-O;)C=Dd(C),F--;for(;O--;){if(P===C||C!==null&&P===C.alternate)break t;P=Dd(P),C=Dd(C)}P=null}else P=null;R!==null&&ID(j,M,R,P,!1),B!==null&&H!==null&&ID(j,H,B,P,!0)}}e:{if(M=z?Od(z):window,R=M.nodeName&&M.nodeName.toLowerCase(),R==="select"||R==="input"&&M.type==="file")var ae=TV;else if(sD(M))if(oD)ae=zV;else{ae=EV;var te=MV}else(R=M.nodeName)&&R.toLowerCase()==="input"&&(M.type==="checkbox"||M.type==="radio")&&(ae=DV);if(ae&&(ae=ae(a,z))){aD(j,ae,p,G);break e}te&&te(a,M,z),a==="focusout"&&(te=M._wrapperState)&&te.controlled&&M.type==="number"&&hw(M,"number",M.value)}switch(te=z?Od(z):window,a){case"focusin":(sD(te)||te.contentEditable==="true")&&(Md=te,Vw=z,Xh=null);break;case"focusout":Xh=Vw=Md=null;break;case"mousedown":Xw=!0;break;case"contextmenu":case"mouseup":case"dragend":Xw=!1,hD(j,p,G);break;case"selectionchange":if(BV)break;case"keydown":case"keyup":hD(j,p,G)}var oe;if(Ww)e:{switch(a){case"compositionstart":var fe="onCompositionStart";break e;case"compositionend":fe="onCompositionEnd";break e;case"compositionupdate":fe="onCompositionUpdate";break e}fe=void 0}else Td?nD(a,p)&&(fe="onCompositionEnd"):a==="keydown"&&p.keyCode===229&&(fe="onCompositionStart");fe&&(_E&&p.locale!=="ko"&&(Td||fe!=="onCompositionStart"?fe==="onCompositionEnd"&&Td&&(oe=QE()):(Pl=G,Ow="value"in Pl?Pl.value:Pl.textContent,Td=!0)),te=xy(z,fe),0<te.length&&(fe=new JE(fe,a,null,p,G),j.push({event:fe,listeners:te}),oe?fe.data=oe:(oe=rD(p),oe!==null&&(fe.data=oe)))),(oe=kV?CV(a,p):IV(a,p))&&(z=xy(z,"onBeforeInput"),0<z.length&&(G=new JE("onBeforeInput","beforeinput",null,p,G),j.push({event:G,listeners:z}),G.data=oe))}kD(j,i)})}function Uh(a,i,p){return{instance:a,listener:i,currentTarget:p}}function xy(a,i){for(var p=i+"Capture",f=[];a!==null;){var g=a,x=g.stateNode;g.tag===5&&x!==null&&(g=x,x=Th(a,p),x!=null&&f.unshift(Uh(a,x,g)),x=Th(a,i),x!=null&&f.push(Uh(a,x,g))),a=a.return}return f}function Dd(a){if(a===null)return null;do a=a.return;while(a&&a.tag!==5);return a||null}function ID(a,i,p,f,g){for(var x=i._reactName,k=[];p!==null&&p!==f;){var N=p,E=N.alternate,z=N.stateNode;if(E!==null&&E===f)break;N.tag===5&&z!==null&&(N=z,g?(E=Th(p,x),E!=null&&k.unshift(Uh(p,E,N))):g||(E=Th(p,x),E!=null&&k.push(Uh(p,E,N)))),p=p.return}k.length!==0&&a.push({event:i,listeners:k})}var WV=/\r\n?/g,jV=/\u0000|\uFFFD/g;function SD(a){return(typeof a=="string"?a:""+a).replace(WV,`
`).replace(jV,"")}function wy(a,i,p){if(i=SD(i),SD(a)!==i&&p)throw Error(Ct(425))}function ky(){}var qw=null,Jw=null;function $w(a,i){return a==="textarea"||a==="noscript"||typeof i.children=="string"||typeof i.children=="number"||typeof i.dangerouslySetInnerHTML=="object"&&i.dangerouslySetInnerHTML!==null&&i.dangerouslySetInnerHTML.__html!=null}var _w=typeof setTimeout=="function"?setTimeout:void 0,HV=typeof clearTimeout=="function"?clearTimeout:void 0,ND=typeof Promise=="function"?Promise:void 0,GV=typeof queueMicrotask=="function"?queueMicrotask:typeof ND<"u"?function(a){return ND.resolve(null).then(a).catch(VV)}:_w;function VV(a){setTimeout(function(){throw a})}function e2(a,i){var p=i,f=0;do{var g=p.nextSibling;if(a.removeChild(p),g&&g.nodeType===8)if(p=g.data,p==="/$"){if(f===0){a.removeChild(g),Lh(i);return}f--}else p!=="$"&&p!=="$?"&&p!=="$!"||f++;p=g}while(p);Lh(i)}function Fl(a){for(;a!=null;a=a.nextSibling){var i=a.nodeType;if(i===1||i===3)break;if(i===8){if(i=a.data,i==="$"||i==="$!"||i==="$?")break;if(i==="/$")return null}}return a}function TD(a){a=a.previousSibling;for(var i=0;a;){if(a.nodeType===8){var p=a.data;if(p==="$"||p==="$!"||p==="$?"){if(i===0)return a;i--}else p==="/$"&&i++}a=a.previousSibling}return null}var zd=Math.random().toString(36).slice(2),iA="__reactFiber$"+zd,Qh="__reactProps$"+zd,GA="__reactContainer$"+zd,t2="__reactEvents$"+zd,XV="__reactListeners$"+zd,ZV="__reactHandles$"+zd;function tc(a){var i=a[iA];if(i)return i;for(var p=a.parentNode;p;){if(i=p[GA]||p[iA]){if(p=i.alternate,i.child!==null||p!==null&&p.child!==null)for(a=TD(a);a!==null;){if(p=a[iA])return p;a=TD(a)}return i}a=p,p=a.parentNode}return null}function Kh(a){return a=a[iA]||a[GA],!a||a.tag!==5&&a.tag!==6&&a.tag!==13&&a.tag!==3?null:a}function Od(a){if(a.tag===5||a.tag===6)return a.stateNode;throw Error(Ct(33))}function Cy(a){return a[Qh]||null}var n2=[],Pd=-1;function Ll(a){return{current:a}}function Br(a){0>Pd||(a.current=n2[Pd],n2[Pd]=null,Pd--)}function Tr(a,i){Pd++,n2[Pd]=a.current,a.current=i}var Rl={},Ta=Ll(Rl),uo=Ll(!1),nc=Rl;function Bd(a,i){var p=a.type.contextTypes;if(!p)return Rl;var f=a.stateNode;if(f&&f.__reactInternalMemoizedUnmaskedChildContext===i)return f.__reactInternalMemoizedMaskedChildContext;var g={},x;for(x in p)g[x]=i[x];return f&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=i,a.__reactInternalMemoizedMaskedChildContext=g),g}function co(a){return a=a.childContextTypes,a!=null}function Iy(){Br(uo),Br(Ta)}function MD(a,i,p){if(Ta.current!==Rl)throw Error(Ct(168));Tr(Ta,i),Tr(uo,p)}function ED(a,i,p){var f=a.stateNode;if(i=i.childContextTypes,typeof f.getChildContext!="function")return p;f=f.getChildContext();for(var g in f)if(!(g in i))throw Error(Ct(108,MG(a)||"Unknown",g));return Kr({},p,f)}function Sy(a){return a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Rl,nc=Ta.current,Tr(Ta,a),Tr(uo,uo.current),!0}function DD(a,i,p){var f=a.stateNode;if(!f)throw Error(Ct(169));p?(a=ED(a,i,nc),f.__reactInternalMemoizedMergedChildContext=a,Br(uo),Br(Ta),Tr(Ta,a)):Br(uo),Tr(uo,p)}var VA=null,Ny=!1,r2=!1;function zD(a){VA===null?VA=[a]:VA.push(a)}function YV(a){Ny=!0,zD(a)}function Wl(){if(!r2&&VA!==null){r2=!0;var a=0,i=mr;try{var p=VA;for(mr=1;a<p.length;a++){var f=p[a];do f=f(!0);while(f!==null)}VA=null,Ny=!1}catch(g){throw VA!==null&&(VA=VA.slice(a+1)),PE(Iw,Wl),g}finally{mr=i,r2=!1}}return null}var Fd=[],Ld=0,Ty=null,My=0,ai=[],oi=0,rc=null,XA=1,ZA="";function sc(a,i){Fd[Ld++]=My,Fd[Ld++]=Ty,Ty=a,My=i}function OD(a,i,p){ai[oi++]=XA,ai[oi++]=ZA,ai[oi++]=rc,rc=a;var f=XA;a=ZA;var g=32-zi(f)-1;f&=~(1<<g),p+=1;var x=32-zi(i)+g;if(30<x){var k=g-g%5;x=(f&(1<<k)-1).toString(32),f>>=k,g-=k,XA=1<<32-zi(i)+g|p<<g|f,ZA=x+a}else XA=1<<x|p<<g|f,ZA=a}function s2(a){a.return!==null&&(sc(a,1),OD(a,1,0))}function a2(a){for(;a===Ty;)Ty=Fd[--Ld],Fd[Ld]=null,My=Fd[--Ld],Fd[Ld]=null;for(;a===rc;)rc=ai[--oi],ai[oi]=null,ZA=ai[--oi],ai[oi]=null,XA=ai[--oi],ai[oi]=null}var Lo=null,Ro=null,Gr=!1,Pi=null;function PD(a,i){var p=ui(5,null,null,0);p.elementType="DELETED",p.stateNode=i,p.return=a,i=a.deletions,i===null?(a.deletions=[p],a.flags|=16):i.push(p)}function BD(a,i){switch(a.tag){case 5:var p=a.type;return i=i.nodeType!==1||p.toLowerCase()!==i.nodeName.toLowerCase()?null:i,i!==null?(a.stateNode=i,Lo=a,Ro=Fl(i.firstChild),!0):!1;case 6:return i=a.pendingProps===""||i.nodeType!==3?null:i,i!==null?(a.stateNode=i,Lo=a,Ro=null,!0):!1;case 13:return i=i.nodeType!==8?null:i,i!==null?(p=rc!==null?{id:XA,overflow:ZA}:null,a.memoizedState={dehydrated:i,treeContext:p,retryLane:1073741824},p=ui(18,null,null,0),p.stateNode=i,p.return=a,a.child=p,Lo=a,Ro=null,!0):!1;default:return!1}}function o2(a){return(a.mode&1)!==0&&(a.flags&128)===0}function i2(a){if(Gr){var i=Ro;if(i){var p=i;if(!BD(a,i)){if(o2(a))throw Error(Ct(418));i=Fl(p.nextSibling);var f=Lo;i&&BD(a,i)?PD(f,p):(a.flags=a.flags&-4097|2,Gr=!1,Lo=a)}}else{if(o2(a))throw Error(Ct(418));a.flags=a.flags&-4097|2,Gr=!1,Lo=a}}}function FD(a){for(a=a.return;a!==null&&a.tag!==5&&a.tag!==3&&a.tag!==13;)a=a.return;Lo=a}function Ey(a){if(a!==Lo)return!1;if(!Gr)return FD(a),Gr=!0,!1;var i;if((i=a.tag!==3)&&!(i=a.tag!==5)&&(i=a.type,i=i!=="head"&&i!=="body"&&!$w(a.type,a.memoizedProps)),i&&(i=Ro)){if(o2(a))throw LD(),Error(Ct(418));for(;i;)PD(a,i),i=Fl(i.nextSibling)}if(FD(a),a.tag===13){if(a=a.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(Ct(317));e:{for(a=a.nextSibling,i=0;a;){if(a.nodeType===8){var p=a.data;if(p==="/$"){if(i===0){Ro=Fl(a.nextSibling);break e}i--}else p!=="$"&&p!=="$!"&&p!=="$?"||i++}a=a.nextSibling}Ro=null}}else Ro=Lo?Fl(a.stateNode.nextSibling):null;return!0}function LD(){for(var a=Ro;a;)a=Fl(a.nextSibling)}function Rd(){Ro=Lo=null,Gr=!1}function A2(a){Pi===null?Pi=[a]:Pi.push(a)}var UV=HA.ReactCurrentBatchConfig;function qh(a,i,p){if(a=p.ref,a!==null&&typeof a!="function"&&typeof a!="object"){if(p._owner){if(p=p._owner,p){if(p.tag!==1)throw Error(Ct(309));var f=p.stateNode}if(!f)throw Error(Ct(147,a));var g=f,x=""+a;return i!==null&&i.ref!==null&&typeof i.ref=="function"&&i.ref._stringRef===x?i.ref:(i=function(k){var N=g.refs;k===null?delete N[x]:N[x]=k},i._stringRef=x,i)}if(typeof a!="string")throw Error(Ct(284));if(!p._owner)throw Error(Ct(290,a))}return a}function Dy(a,i){throw a=Object.prototype.toString.call(i),Error(Ct(31,a==="[object Object]"?"object with keys {"+Object.keys(i).join(", ")+"}":a))}function RD(a){var i=a._init;return i(a._payload)}function WD(a){function i(C,O){if(a){var F=C.deletions;F===null?(C.deletions=[O],C.flags|=16):F.push(O)}}function p(C,O){if(!a)return null;for(;O!==null;)i(C,O),O=O.sibling;return null}function f(C,O){for(C=new Map;O!==null;)O.key!==null?C.set(O.key,O):C.set(O.index,O),O=O.sibling;return C}function g(C,O){return C=Ul(C,O),C.index=0,C.sibling=null,C}function x(C,O,F){return C.index=F,a?(F=C.alternate,F!==null?(F=F.index,F<O?(C.flags|=2,O):F):(C.flags|=2,O)):(C.flags|=1048576,O)}function k(C){return a&&C.alternate===null&&(C.flags|=2),C}function N(C,O,F,Y){return O===null||O.tag!==6?(O=_2(F,C.mode,Y),O.return=C,O):(O=g(O,F),O.return=C,O)}function E(C,O,F,Y){var ae=F.type;return ae===wd?G(C,O,F.props.children,Y,F.key):O!==null&&(O.elementType===ae||typeof ae=="object"&&ae!==null&&ae.$$typeof===Tl&&RD(ae)===O.type)?(Y=g(O,F.props),Y.ref=qh(C,O,F),Y.return=C,Y):(Y=tb(F.type,F.key,F.props,null,C.mode,Y),Y.ref=qh(C,O,F),Y.return=C,Y)}function z(C,O,F,Y){return O===null||O.tag!==4||O.stateNode.containerInfo!==F.containerInfo||O.stateNode.implementation!==F.implementation?(O=ek(F,C.mode,Y),O.return=C,O):(O=g(O,F.children||[]),O.return=C,O)}function G(C,O,F,Y,ae){return O===null||O.tag!==7?(O=dc(F,C.mode,Y,ae),O.return=C,O):(O=g(O,F),O.return=C,O)}function j(C,O,F){if(typeof O=="string"&&O!==""||typeof O=="number")return O=_2(""+O,C.mode,F),O.return=C,O;if(typeof O=="object"&&O!==null){switch(O.$$typeof){case $g:return F=tb(O.type,O.key,O.props,null,C.mode,F),F.ref=qh(C,null,O),F.return=C,F;case xd:return O=ek(O,C.mode,F),O.return=C,O;case Tl:var Y=O._init;return j(C,Y(O._payload),F)}if(Ih(O)||kh(O))return O=dc(O,C.mode,F,null),O.return=C,O;Dy(C,O)}return null}function M(C,O,F,Y){var ae=O!==null?O.key:null;if(typeof F=="string"&&F!==""||typeof F=="number")return ae!==null?null:N(C,O,""+F,Y);if(typeof F=="object"&&F!==null){switch(F.$$typeof){case $g:return F.key===ae?E(C,O,F,Y):null;case xd:return F.key===ae?z(C,O,F,Y):null;case Tl:return ae=F._init,M(C,O,ae(F._payload),Y)}if(Ih(F)||kh(F))return ae!==null?null:G(C,O,F,Y,null);Dy(C,F)}return null}function R(C,O,F,Y,ae){if(typeof Y=="string"&&Y!==""||typeof Y=="number")return C=C.get(F)||null,N(O,C,""+Y,ae);if(typeof Y=="object"&&Y!==null){switch(Y.$$typeof){case $g:return C=C.get(Y.key===null?F:Y.key)||null,E(O,C,Y,ae);case xd:return C=C.get(Y.key===null?F:Y.key)||null,z(O,C,Y,ae);case Tl:var te=Y._init;return R(C,O,F,te(Y._payload),ae)}if(Ih(Y)||kh(Y))return C=C.get(F)||null,G(O,C,Y,ae,null);Dy(O,Y)}return null}function B(C,O,F,Y){for(var ae=null,te=null,oe=O,fe=O=0,ue=null;oe!==null&&fe<F.length;fe++){oe.index>fe?(ue=oe,oe=null):ue=oe.sibling;var Z=M(C,oe,F[fe],Y);if(Z===null){oe===null&&(oe=ue);break}a&&oe&&Z.alternate===null&&i(C,oe),O=x(Z,O,fe),te===null?ae=Z:te.sibling=Z,te=Z,oe=ue}if(fe===F.length)return p(C,oe),Gr&&sc(C,fe),ae;if(oe===null){for(;fe<F.length;fe++)oe=j(C,F[fe],Y),oe!==null&&(O=x(oe,O,fe),te===null?ae=oe:te.sibling=oe,te=oe);return Gr&&sc(C,fe),ae}for(oe=f(C,oe);fe<F.length;fe++)ue=R(oe,C,fe,F[fe],Y),ue!==null&&(a&&ue.alternate!==null&&oe.delete(ue.key===null?fe:ue.key),O=x(ue,O,fe),te===null?ae=ue:te.sibling=ue,te=ue);return a&&oe.forEach(function(ye){return i(C,ye)}),Gr&&sc(C,fe),ae}function P(C,O,F,Y){var ae=kh(F);if(typeof ae!="function")throw Error(Ct(150));if(F=ae.call(F),F==null)throw Error(Ct(151));for(var te=ae=null,oe=O,fe=O=0,ue=null,Z=F.next();oe!==null&&!Z.done;fe++,Z=F.next()){oe.index>fe?(ue=oe,oe=null):ue=oe.sibling;var ye=M(C,oe,Z.value,Y);if(ye===null){oe===null&&(oe=ue);break}a&&oe&&ye.alternate===null&&i(C,oe),O=x(ye,O,fe),te===null?ae=ye:te.sibling=ye,te=ye,oe=ue}if(Z.done)return p(C,oe),Gr&&sc(C,fe),ae;if(oe===null){for(;!Z.done;fe++,Z=F.next())Z=j(C,Z.value,Y),Z!==null&&(O=x(Z,O,fe),te===null?ae=Z:te.sibling=Z,te=Z);return Gr&&sc(C,fe),ae}for(oe=f(C,oe);!Z.done;fe++,Z=F.next())Z=R(oe,C,fe,Z.value,Y),Z!==null&&(a&&Z.alternate!==null&&oe.delete(Z.key===null?fe:Z.key),O=x(Z,O,fe),te===null?ae=Z:te.sibling=Z,te=Z);return a&&oe.forEach(function(pe){return i(C,pe)}),Gr&&sc(C,fe),ae}function H(C,O,F,Y){if(typeof F=="object"&&F!==null&&F.type===wd&&F.key===null&&(F=F.props.children),typeof F=="object"&&F!==null){switch(F.$$typeof){case $g:e:{for(var ae=F.key,te=O;te!==null;){if(te.key===ae){if(ae=F.type,ae===wd){if(te.tag===7){p(C,te.sibling),O=g(te,F.props.children),O.return=C,C=O;break e}}else if(te.elementType===ae||typeof ae=="object"&&ae!==null&&ae.$$typeof===Tl&&RD(ae)===te.type){p(C,te.sibling),O=g(te,F.props),O.ref=qh(C,te,F),O.return=C,C=O;break e}p(C,te);break}else i(C,te);te=te.sibling}F.type===wd?(O=dc(F.props.children,C.mode,Y,F.key),O.return=C,C=O):(Y=tb(F.type,F.key,F.props,null,C.mode,Y),Y.ref=qh(C,O,F),Y.return=C,C=Y)}return k(C);case xd:e:{for(te=F.key;O!==null;){if(O.key===te)if(O.tag===4&&O.stateNode.containerInfo===F.containerInfo&&O.stateNode.implementation===F.implementation){p(C,O.sibling),O=g(O,F.children||[]),O.return=C,C=O;break e}else{p(C,O);break}else i(C,O);O=O.sibling}O=ek(F,C.mode,Y),O.return=C,C=O}return k(C);case Tl:return te=F._init,H(C,O,te(F._payload),Y)}if(Ih(F))return B(C,O,F,Y);if(kh(F))return P(C,O,F,Y);Dy(C,F)}return typeof F=="string"&&F!==""||typeof F=="number"?(F=""+F,O!==null&&O.tag===6?(p(C,O.sibling),O=g(O,F),O.return=C,C=O):(p(C,O),O=_2(F,C.mode,Y),O.return=C,C=O),k(C)):p(C,O)}return H}var Wd=WD(!0),jD=WD(!1),zy=Ll(null),Oy=null,jd=null,l2=null;function u2(){l2=jd=Oy=null}function c2(a){var i=zy.current;Br(zy),a._currentValue=i}function d2(a,i,p){for(;a!==null;){var f=a.alternate;if((a.childLanes&i)!==i?(a.childLanes|=i,f!==null&&(f.childLanes|=i)):f!==null&&(f.childLanes&i)!==i&&(f.childLanes|=i),a===p)break;a=a.return}}function Hd(a,i){Oy=a,l2=jd=null,a=a.dependencies,a!==null&&a.firstContext!==null&&(a.lanes&i&&(po=!0),a.firstContext=null)}function ii(a){var i=a._currentValue;if(l2!==a)if(a={context:a,memoizedValue:i,next:null},jd===null){if(Oy===null)throw Error(Ct(308));jd=a,Oy.dependencies={lanes:0,firstContext:a}}else jd=jd.next=a;return i}var ac=null;function p2(a){ac===null?ac=[a]:ac.push(a)}function HD(a,i,p,f){var g=i.interleaved;return g===null?(p.next=p,p2(i)):(p.next=g.next,g.next=p),i.interleaved=p,YA(a,f)}function YA(a,i){a.lanes|=i;var p=a.alternate;for(p!==null&&(p.lanes|=i),p=a,a=a.return;a!==null;)a.childLanes|=i,p=a.alternate,p!==null&&(p.childLanes|=i),p=a,a=a.return;return p.tag===3?p.stateNode:null}var jl=!1;function h2(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function GD(a,i){a=a.updateQueue,i.updateQueue===a&&(i.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,effects:a.effects})}function UA(a,i){return{eventTime:a,lane:i,tag:0,payload:null,callback:null,next:null}}function Hl(a,i,p){var f=a.updateQueue;if(f===null)return null;if(f=f.shared,er&2){var g=f.pending;return g===null?i.next=i:(i.next=g.next,g.next=i),f.pending=i,YA(a,p)}return g=f.interleaved,g===null?(i.next=i,p2(f)):(i.next=g.next,g.next=i),f.interleaved=i,YA(a,p)}function Py(a,i,p){if(i=i.updateQueue,i!==null&&(i=i.shared,(p&4194240)!==0)){var f=i.lanes;f&=a.pendingLanes,p|=f,i.lanes=p,Tw(a,p)}}function VD(a,i){var p=a.updateQueue,f=a.alternate;if(f!==null&&(f=f.updateQueue,p===f)){var g=null,x=null;if(p=p.firstBaseUpdate,p!==null){do{var k={eventTime:p.eventTime,lane:p.lane,tag:p.tag,payload:p.payload,callback:p.callback,next:null};x===null?g=x=k:x=x.next=k,p=p.next}while(p!==null);x===null?g=x=i:x=x.next=i}else g=x=i;p={baseState:f.baseState,firstBaseUpdate:g,lastBaseUpdate:x,shared:f.shared,effects:f.effects},a.updateQueue=p;return}a=p.lastBaseUpdate,a===null?p.firstBaseUpdate=i:a.next=i,p.lastBaseUpdate=i}function By(a,i,p,f){var g=a.updateQueue;jl=!1;var x=g.firstBaseUpdate,k=g.lastBaseUpdate,N=g.shared.pending;if(N!==null){g.shared.pending=null;var E=N,z=E.next;E.next=null,k===null?x=z:k.next=z,k=E;var G=a.alternate;G!==null&&(G=G.updateQueue,N=G.lastBaseUpdate,N!==k&&(N===null?G.firstBaseUpdate=z:N.next=z,G.lastBaseUpdate=E))}if(x!==null){var j=g.baseState;k=0,G=z=E=null,N=x;do{var M=N.lane,R=N.eventTime;if((f&M)===M){G!==null&&(G=G.next={eventTime:R,lane:0,tag:N.tag,payload:N.payload,callback:N.callback,next:null});e:{var B=a,P=N;switch(M=i,R=p,P.tag){case 1:if(B=P.payload,typeof B=="function"){j=B.call(R,j,M);break e}j=B;break e;case 3:B.flags=B.flags&-65537|128;case 0:if(B=P.payload,M=typeof B=="function"?B.call(R,j,M):B,M==null)break e;j=Kr({},j,M);break e;case 2:jl=!0}}N.callback!==null&&N.lane!==0&&(a.flags|=64,M=g.effects,M===null?g.effects=[N]:M.push(N))}else R={eventTime:R,lane:M,tag:N.tag,payload:N.payload,callback:N.callback,next:null},G===null?(z=G=R,E=j):G=G.next=R,k|=M;if(N=N.next,N===null){if(N=g.shared.pending,N===null)break;M=N,N=M.next,M.next=null,g.lastBaseUpdate=M,g.shared.pending=null}}while(!0);if(G===null&&(E=j),g.baseState=E,g.firstBaseUpdate=z,g.lastBaseUpdate=G,i=g.shared.interleaved,i!==null){g=i;do k|=g.lane,g=g.next;while(g!==i)}else x===null&&(g.shared.lanes=0);Ac|=k,a.lanes=k,a.memoizedState=j}}function XD(a,i,p){if(a=i.effects,i.effects=null,a!==null)for(i=0;i<a.length;i++){var f=a[i],g=f.callback;if(g!==null){if(f.callback=null,f=p,typeof g!="function")throw Error(Ct(191,g));g.call(f)}}}var Jh={},AA=Ll(Jh),$h=Ll(Jh),_h=Ll(Jh);function oc(a){if(a===Jh)throw Error(Ct(174));return a}function f2(a,i){switch(Tr(_h,i),Tr($h,a),Tr(AA,Jh),a=i.nodeType,a){case 9:case 11:i=(i=i.documentElement)?i.namespaceURI:mw(null,"");break;default:a=a===8?i.parentNode:i,i=a.namespaceURI||null,a=a.tagName,i=mw(i,a)}Br(AA),Tr(AA,i)}function Gd(){Br(AA),Br($h),Br(_h)}function ZD(a){oc(_h.current);var i=oc(AA.current),p=mw(i,a.type);i!==p&&(Tr($h,a),Tr(AA,p))}function m2(a){$h.current===a&&(Br(AA),Br($h))}var qr=Ll(0);function Fy(a){for(var i=a;i!==null;){if(i.tag===13){var p=i.memoizedState;if(p!==null&&(p=p.dehydrated,p===null||p.data==="$?"||p.data==="$!"))return i}else if(i.tag===19&&i.memoizedProps.revealOrder!==void 0){if(i.flags&128)return i}else if(i.child!==null){i.child.return=i,i=i.child;continue}if(i===a)break;for(;i.sibling===null;){if(i.return===null||i.return===a)return null;i=i.return}i.sibling.return=i.return,i=i.sibling}return null}var g2=[];function y2(){for(var a=0;a<g2.length;a++)g2[a]._workInProgressVersionPrimary=null;g2.length=0}var Ly=HA.ReactCurrentDispatcher,b2=HA.ReactCurrentBatchConfig,ic=0,Jr=null,Rs=null,$s=null,Ry=!1,ef=!1,tf=0,QV=0;function Ma(){throw Error(Ct(321))}function v2(a,i){if(i===null)return!1;for(var p=0;p<i.length&&p<a.length;p++)if(!Oi(a[p],i[p]))return!1;return!0}function x2(a,i,p,f,g,x){if(ic=x,Jr=i,i.memoizedState=null,i.updateQueue=null,i.lanes=0,Ly.current=a===null||a.memoizedState===null?$V:_V,a=p(f,g),ef){x=0;do{if(ef=!1,tf=0,25<=x)throw Error(Ct(301));x+=1,$s=Rs=null,i.updateQueue=null,Ly.current=eX,a=p(f,g)}while(ef)}if(Ly.current=Hy,i=Rs!==null&&Rs.next!==null,ic=0,$s=Rs=Jr=null,Ry=!1,i)throw Error(Ct(300));return a}function w2(){var a=tf!==0;return tf=0,a}function lA(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return $s===null?Jr.memoizedState=$s=a:$s=$s.next=a,$s}function Ai(){if(Rs===null){var a=Jr.alternate;a=a!==null?a.memoizedState:null}else a=Rs.next;var i=$s===null?Jr.memoizedState:$s.next;if(i!==null)$s=i,Rs=a;else{if(a===null)throw Error(Ct(310));Rs=a,a={memoizedState:Rs.memoizedState,baseState:Rs.baseState,baseQueue:Rs.baseQueue,queue:Rs.queue,next:null},$s===null?Jr.memoizedState=$s=a:$s=$s.next=a}return $s}function nf(a,i){return typeof i=="function"?i(a):i}function k2(a){var i=Ai(),p=i.queue;if(p===null)throw Error(Ct(311));p.lastRenderedReducer=a;var f=Rs,g=f.baseQueue,x=p.pending;if(x!==null){if(g!==null){var k=g.next;g.next=x.next,x.next=k}f.baseQueue=g=x,p.pending=null}if(g!==null){x=g.next,f=f.baseState;var N=k=null,E=null,z=x;do{var G=z.lane;if((ic&G)===G)E!==null&&(E=E.next={lane:0,action:z.action,hasEagerState:z.hasEagerState,eagerState:z.eagerState,next:null}),f=z.hasEagerState?z.eagerState:a(f,z.action);else{var j={lane:G,action:z.action,hasEagerState:z.hasEagerState,eagerState:z.eagerState,next:null};E===null?(N=E=j,k=f):E=E.next=j,Jr.lanes|=G,Ac|=G}z=z.next}while(z!==null&&z!==x);E===null?k=f:E.next=N,Oi(f,i.memoizedState)||(po=!0),i.memoizedState=f,i.baseState=k,i.baseQueue=E,p.lastRenderedState=f}if(a=p.interleaved,a!==null){g=a;do x=g.lane,Jr.lanes|=x,Ac|=x,g=g.next;while(g!==a)}else g===null&&(p.lanes=0);return[i.memoizedState,p.dispatch]}function C2(a){var i=Ai(),p=i.queue;if(p===null)throw Error(Ct(311));p.lastRenderedReducer=a;var f=p.dispatch,g=p.pending,x=i.memoizedState;if(g!==null){p.pending=null;var k=g=g.next;do x=a(x,k.action),k=k.next;while(k!==g);Oi(x,i.memoizedState)||(po=!0),i.memoizedState=x,i.baseQueue===null&&(i.baseState=x),p.lastRenderedState=x}return[x,f]}function YD(){}function UD(a,i){var p=Jr,f=Ai(),g=i(),x=!Oi(f.memoizedState,g);if(x&&(f.memoizedState=g,po=!0),f=f.queue,I2(qD.bind(null,p,f,a),[a]),f.getSnapshot!==i||x||$s!==null&&$s.memoizedState.tag&1){if(p.flags|=2048,rf(9,KD.bind(null,p,f,g,i),void 0,null),_s===null)throw Error(Ct(349));ic&30||QD(p,i,g)}return g}function QD(a,i,p){a.flags|=16384,a={getSnapshot:i,value:p},i=Jr.updateQueue,i===null?(i={lastEffect:null,stores:null},Jr.updateQueue=i,i.stores=[a]):(p=i.stores,p===null?i.stores=[a]:p.push(a))}function KD(a,i,p,f){i.value=p,i.getSnapshot=f,JD(i)&&$D(a)}function qD(a,i,p){return p(function(){JD(i)&&$D(a)})}function JD(a){var i=a.getSnapshot;a=a.value;try{var p=i();return!Oi(a,p)}catch{return!0}}function $D(a){var i=YA(a,1);i!==null&&Ri(i,a,1,-1)}function _D(a){var i=lA();return typeof a=="function"&&(a=a()),i.memoizedState=i.baseState=a,a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:nf,lastRenderedState:a},i.queue=a,a=a.dispatch=JV.bind(null,Jr,a),[i.memoizedState,a]}function rf(a,i,p,f){return a={tag:a,create:i,destroy:p,deps:f,next:null},i=Jr.updateQueue,i===null?(i={lastEffect:null,stores:null},Jr.updateQueue=i,i.lastEffect=a.next=a):(p=i.lastEffect,p===null?i.lastEffect=a.next=a:(f=p.next,p.next=a,a.next=f,i.lastEffect=a)),a}function ez(){return Ai().memoizedState}function Wy(a,i,p,f){var g=lA();Jr.flags|=a,g.memoizedState=rf(1|i,p,void 0,f===void 0?null:f)}function jy(a,i,p,f){var g=Ai();f=f===void 0?null:f;var x=void 0;if(Rs!==null){var k=Rs.memoizedState;if(x=k.destroy,f!==null&&v2(f,k.deps)){g.memoizedState=rf(i,p,x,f);return}}Jr.flags|=a,g.memoizedState=rf(1|i,p,x,f)}function tz(a,i){return Wy(8390656,8,a,i)}function I2(a,i){return jy(2048,8,a,i)}function nz(a,i){return jy(4,2,a,i)}function rz(a,i){return jy(4,4,a,i)}function sz(a,i){if(typeof i=="function")return a=a(),i(a),function(){i(null)};if(i!=null)return a=a(),i.current=a,function(){i.current=null}}function az(a,i,p){return p=p!=null?p.concat([a]):null,jy(4,4,sz.bind(null,i,a),p)}function S2(){}function oz(a,i){var p=Ai();i=i===void 0?null:i;var f=p.memoizedState;return f!==null&&i!==null&&v2(i,f[1])?f[0]:(p.memoizedState=[a,i],a)}function iz(a,i){var p=Ai();i=i===void 0?null:i;var f=p.memoizedState;return f!==null&&i!==null&&v2(i,f[1])?f[0]:(a=a(),p.memoizedState=[a,i],a)}function Az(a,i,p){return ic&21?(Oi(p,i)||(p=RE(),Jr.lanes|=p,Ac|=p,a.baseState=!0),i):(a.baseState&&(a.baseState=!1,po=!0),a.memoizedState=p)}function KV(a,i){var p=mr;mr=p!==0&&4>p?p:4,a(!0);var f=b2.transition;b2.transition={};try{a(!1),i()}finally{mr=p,b2.transition=f}}function lz(){return Ai().memoizedState}function qV(a,i,p){var f=Zl(a);if(p={lane:f,action:p,hasEagerState:!1,eagerState:null,next:null},uz(a))cz(i,p);else if(p=HD(a,i,p,f),p!==null){var g=Ka();Ri(p,a,f,g),dz(p,i,f)}}function JV(a,i,p){var f=Zl(a),g={lane:f,action:p,hasEagerState:!1,eagerState:null,next:null};if(uz(a))cz(i,g);else{var x=a.alternate;if(a.lanes===0&&(x===null||x.lanes===0)&&(x=i.lastRenderedReducer,x!==null))try{var k=i.lastRenderedState,N=x(k,p);if(g.hasEagerState=!0,g.eagerState=N,Oi(N,k)){var E=i.interleaved;E===null?(g.next=g,p2(i)):(g.next=E.next,E.next=g),i.interleaved=g;return}}catch{}finally{}p=HD(a,i,g,f),p!==null&&(g=Ka(),Ri(p,a,f,g),dz(p,i,f))}}function uz(a){var i=a.alternate;return a===Jr||i!==null&&i===Jr}function cz(a,i){ef=Ry=!0;var p=a.pending;p===null?i.next=i:(i.next=p.next,p.next=i),a.pending=i}function dz(a,i,p){if(p&4194240){var f=i.lanes;f&=a.pendingLanes,p|=f,i.lanes=p,Tw(a,p)}}var Hy={readContext:ii,useCallback:Ma,useContext:Ma,useEffect:Ma,useImperativeHandle:Ma,useInsertionEffect:Ma,useLayoutEffect:Ma,useMemo:Ma,useReducer:Ma,useRef:Ma,useState:Ma,useDebugValue:Ma,useDeferredValue:Ma,useTransition:Ma,useMutableSource:Ma,useSyncExternalStore:Ma,useId:Ma,unstable_isNewReconciler:!1},$V={readContext:ii,useCallback:function(a,i){return lA().memoizedState=[a,i===void 0?null:i],a},useContext:ii,useEffect:tz,useImperativeHandle:function(a,i,p){return p=p!=null?p.concat([a]):null,Wy(4194308,4,sz.bind(null,i,a),p)},useLayoutEffect:function(a,i){return Wy(4194308,4,a,i)},useInsertionEffect:function(a,i){return Wy(4,2,a,i)},useMemo:function(a,i){var p=lA();return i=i===void 0?null:i,a=a(),p.memoizedState=[a,i],a},useReducer:function(a,i,p){var f=lA();return i=p!==void 0?p(i):i,f.memoizedState=f.baseState=i,a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:a,lastRenderedState:i},f.queue=a,a=a.dispatch=qV.bind(null,Jr,a),[f.memoizedState,a]},useRef:function(a){var i=lA();return a={current:a},i.memoizedState=a},useState:_D,useDebugValue:S2,useDeferredValue:function(a){return lA().memoizedState=a},useTransition:function(){var a=_D(!1),i=a[0];return a=KV.bind(null,a[1]),lA().memoizedState=a,[i,a]},useMutableSource:function(){},useSyncExternalStore:function(a,i,p){var f=Jr,g=lA();if(Gr){if(p===void 0)throw Error(Ct(407));p=p()}else{if(p=i(),_s===null)throw Error(Ct(349));ic&30||QD(f,i,p)}g.memoizedState=p;var x={value:p,getSnapshot:i};return g.queue=x,tz(qD.bind(null,f,x,a),[a]),f.flags|=2048,rf(9,KD.bind(null,f,x,p,i),void 0,null),p},useId:function(){var a=lA(),i=_s.identifierPrefix;if(Gr){var p=ZA,f=XA;p=(f&~(1<<32-zi(f)-1)).toString(32)+p,i=":"+i+"R"+p,p=tf++,0<p&&(i+="H"+p.toString(32)),i+=":"}else p=QV++,i=":"+i+"r"+p.toString(32)+":";return a.memoizedState=i},unstable_isNewReconciler:!1},_V={readContext:ii,useCallback:oz,useContext:ii,useEffect:I2,useImperativeHandle:az,useInsertionEffect:nz,useLayoutEffect:rz,useMemo:iz,useReducer:k2,useRef:ez,useState:function(){return k2(nf)},useDebugValue:S2,useDeferredValue:function(a){var i=Ai();return Az(i,Rs.memoizedState,a)},useTransition:function(){var a=k2(nf)[0],i=Ai().memoizedState;return[a,i]},useMutableSource:YD,useSyncExternalStore:UD,useId:lz,unstable_isNewReconciler:!1},eX={readContext:ii,useCallback:oz,useContext:ii,useEffect:I2,useImperativeHandle:az,useInsertionEffect:nz,useLayoutEffect:rz,useMemo:iz,useReducer:C2,useRef:ez,useState:function(){return C2(nf)},useDebugValue:S2,useDeferredValue:function(a){var i=Ai();return Rs===null?i.memoizedState=a:Az(i,Rs.memoizedState,a)},useTransition:function(){var a=C2(nf)[0],i=Ai().memoizedState;return[a,i]},useMutableSource:YD,useSyncExternalStore:UD,useId:lz,unstable_isNewReconciler:!1};function Bi(a,i){if(a&&a.defaultProps){i=Kr({},i),a=a.defaultProps;for(var p in a)i[p]===void 0&&(i[p]=a[p]);return i}return i}function N2(a,i,p,f){i=a.memoizedState,p=p(f,i),p=p==null?i:Kr({},i,p),a.memoizedState=p,a.lanes===0&&(a.updateQueue.baseState=p)}var Gy={isMounted:function(a){return(a=a._reactInternals)?ec(a)===a:!1},enqueueSetState:function(a,i,p){a=a._reactInternals;var f=Ka(),g=Zl(a),x=UA(f,g);x.payload=i,p!=null&&(x.callback=p),i=Hl(a,x,g),i!==null&&(Ri(i,a,g,f),Py(i,a,g))},enqueueReplaceState:function(a,i,p){a=a._reactInternals;var f=Ka(),g=Zl(a),x=UA(f,g);x.tag=1,x.payload=i,p!=null&&(x.callback=p),i=Hl(a,x,g),i!==null&&(Ri(i,a,g,f),Py(i,a,g))},enqueueForceUpdate:function(a,i){a=a._reactInternals;var p=Ka(),f=Zl(a),g=UA(p,f);g.tag=2,i!=null&&(g.callback=i),i=Hl(a,g,f),i!==null&&(Ri(i,a,f,p),Py(i,a,f))}};function pz(a,i,p,f,g,x,k){return a=a.stateNode,typeof a.shouldComponentUpdate=="function"?a.shouldComponentUpdate(f,x,k):i.prototype&&i.prototype.isPureReactComponent?!Vh(p,f)||!Vh(g,x):!0}function hz(a,i,p){var f=!1,g=Rl,x=i.contextType;return typeof x=="object"&&x!==null?x=ii(x):(g=co(i)?nc:Ta.current,f=i.contextTypes,x=(f=f!=null)?Bd(a,g):Rl),i=new i(p,x),a.memoizedState=i.state!==null&&i.state!==void 0?i.state:null,i.updater=Gy,a.stateNode=i,i._reactInternals=a,f&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=g,a.__reactInternalMemoizedMaskedChildContext=x),i}function fz(a,i,p,f){a=i.state,typeof i.componentWillReceiveProps=="function"&&i.componentWillReceiveProps(p,f),typeof i.UNSAFE_componentWillReceiveProps=="function"&&i.UNSAFE_componentWillReceiveProps(p,f),i.state!==a&&Gy.enqueueReplaceState(i,i.state,null)}function T2(a,i,p,f){var g=a.stateNode;g.props=p,g.state=a.memoizedState,g.refs={},h2(a);var x=i.contextType;typeof x=="object"&&x!==null?g.context=ii(x):(x=co(i)?nc:Ta.current,g.context=Bd(a,x)),g.state=a.memoizedState,x=i.getDerivedStateFromProps,typeof x=="function"&&(N2(a,i,x,p),g.state=a.memoizedState),typeof i.getDerivedStateFromProps=="function"||typeof g.getSnapshotBeforeUpdate=="function"||typeof g.UNSAFE_componentWillMount!="function"&&typeof g.componentWillMount!="function"||(i=g.state,typeof g.componentWillMount=="function"&&g.componentWillMount(),typeof g.UNSAFE_componentWillMount=="function"&&g.UNSAFE_componentWillMount(),i!==g.state&&Gy.enqueueReplaceState(g,g.state,null),By(a,p,g,f),g.state=a.memoizedState),typeof g.componentDidMount=="function"&&(a.flags|=4194308)}function Vd(a,i){try{var p="",f=i;do p+=TG(f),f=f.return;while(f);var g=p}catch(x){g=`
Error generating stack: `+x.message+`
`+x.stack}return{value:a,source:i,stack:g,digest:null}}function M2(a,i,p){return{value:a,source:null,stack:p??null,digest:i??null}}function E2(a,i){try{console.error(i.value)}catch(p){setTimeout(function(){throw p})}}var tX=typeof WeakMap=="function"?WeakMap:Map;function mz(a,i,p){p=UA(-1,p),p.tag=3,p.payload={element:null};var f=i.value;return p.callback=function(){Ky||(Ky=!0,Z2=f),E2(a,i)},p}function gz(a,i,p){p=UA(-1,p),p.tag=3;var f=a.type.getDerivedStateFromError;if(typeof f=="function"){var g=i.value;p.payload=function(){return f(g)},p.callback=function(){E2(a,i)}}var x=a.stateNode;return x!==null&&typeof x.componentDidCatch=="function"&&(p.callback=function(){E2(a,i),typeof f!="function"&&(Vl===null?Vl=new Set([this]):Vl.add(this));var k=i.stack;this.componentDidCatch(i.value,{componentStack:k!==null?k:""})}),p}function yz(a,i,p){var f=a.pingCache;if(f===null){f=a.pingCache=new tX;var g=new Set;f.set(i,g)}else g=f.get(i),g===void 0&&(g=new Set,f.set(i,g));g.has(p)||(g.add(p),a=fX.bind(null,a,i,p),i.then(a,a))}function bz(a){do{var i;if((i=a.tag===13)&&(i=a.memoizedState,i=i!==null?i.dehydrated!==null:!0),i)return a;a=a.return}while(a!==null);return null}function vz(a,i,p,f,g){return a.mode&1?(a.flags|=65536,a.lanes=g,a):(a===i?a.flags|=65536:(a.flags|=128,p.flags|=131072,p.flags&=-52805,p.tag===1&&(p.alternate===null?p.tag=17:(i=UA(-1,1),i.tag=2,Hl(p,i,1))),p.lanes|=1),a)}var nX=HA.ReactCurrentOwner,po=!1;function Qa(a,i,p,f){i.child=a===null?jD(i,null,p,f):Wd(i,a.child,p,f)}function xz(a,i,p,f,g){p=p.render;var x=i.ref;return Hd(i,g),f=x2(a,i,p,f,x,g),p=w2(),a!==null&&!po?(i.updateQueue=a.updateQueue,i.flags&=-2053,a.lanes&=~g,QA(a,i,g)):(Gr&&p&&s2(i),i.flags|=1,Qa(a,i,f,g),i.child)}function wz(a,i,p,f,g){if(a===null){var x=p.type;return typeof x=="function"&&!$2(x)&&x.defaultProps===void 0&&p.compare===null&&p.defaultProps===void 0?(i.tag=15,i.type=x,kz(a,i,x,f,g)):(a=tb(p.type,null,f,i,i.mode,g),a.ref=i.ref,a.return=i,i.child=a)}if(x=a.child,!(a.lanes&g)){var k=x.memoizedProps;if(p=p.compare,p=p!==null?p:Vh,p(k,f)&&a.ref===i.ref)return QA(a,i,g)}return i.flags|=1,a=Ul(x,f),a.ref=i.ref,a.return=i,i.child=a}function kz(a,i,p,f,g){if(a!==null){var x=a.memoizedProps;if(Vh(x,f)&&a.ref===i.ref)if(po=!1,i.pendingProps=f=x,(a.lanes&g)!==0)a.flags&131072&&(po=!0);else return i.lanes=a.lanes,QA(a,i,g)}return D2(a,i,p,f,g)}function Cz(a,i,p){var f=i.pendingProps,g=f.children,x=a!==null?a.memoizedState:null;if(f.mode==="hidden")if(!(i.mode&1))i.memoizedState={baseLanes:0,cachePool:null,transitions:null},Tr(Zd,Wo),Wo|=p;else{if(!(p&1073741824))return a=x!==null?x.baseLanes|p:p,i.lanes=i.childLanes=1073741824,i.memoizedState={baseLanes:a,cachePool:null,transitions:null},i.updateQueue=null,Tr(Zd,Wo),Wo|=a,null;i.memoizedState={baseLanes:0,cachePool:null,transitions:null},f=x!==null?x.baseLanes:p,Tr(Zd,Wo),Wo|=f}else x!==null?(f=x.baseLanes|p,i.memoizedState=null):f=p,Tr(Zd,Wo),Wo|=f;return Qa(a,i,g,p),i.child}function Iz(a,i){var p=i.ref;(a===null&&p!==null||a!==null&&a.ref!==p)&&(i.flags|=512,i.flags|=2097152)}function D2(a,i,p,f,g){var x=co(p)?nc:Ta.current;return x=Bd(i,x),Hd(i,g),p=x2(a,i,p,f,x,g),f=w2(),a!==null&&!po?(i.updateQueue=a.updateQueue,i.flags&=-2053,a.lanes&=~g,QA(a,i,g)):(Gr&&f&&s2(i),i.flags|=1,Qa(a,i,p,g),i.child)}function Sz(a,i,p,f,g){if(co(p)){var x=!0;Sy(i)}else x=!1;if(Hd(i,g),i.stateNode===null)Xy(a,i),hz(i,p,f),T2(i,p,f,g),f=!0;else if(a===null){var k=i.stateNode,N=i.memoizedProps;k.props=N;var E=k.context,z=p.contextType;typeof z=="object"&&z!==null?z=ii(z):(z=co(p)?nc:Ta.current,z=Bd(i,z));var G=p.getDerivedStateFromProps,j=typeof G=="function"||typeof k.getSnapshotBeforeUpdate=="function";j||typeof k.UNSAFE_componentWillReceiveProps!="function"&&typeof k.componentWillReceiveProps!="function"||(N!==f||E!==z)&&fz(i,k,f,z),jl=!1;var M=i.memoizedState;k.state=M,By(i,f,k,g),E=i.memoizedState,N!==f||M!==E||uo.current||jl?(typeof G=="function"&&(N2(i,p,G,f),E=i.memoizedState),(N=jl||pz(i,p,N,f,M,E,z))?(j||typeof k.UNSAFE_componentWillMount!="function"&&typeof k.componentWillMount!="function"||(typeof k.componentWillMount=="function"&&k.componentWillMount(),typeof k.UNSAFE_componentWillMount=="function"&&k.UNSAFE_componentWillMount()),typeof k.componentDidMount=="function"&&(i.flags|=4194308)):(typeof k.componentDidMount=="function"&&(i.flags|=4194308),i.memoizedProps=f,i.memoizedState=E),k.props=f,k.state=E,k.context=z,f=N):(typeof k.componentDidMount=="function"&&(i.flags|=4194308),f=!1)}else{k=i.stateNode,GD(a,i),N=i.memoizedProps,z=i.type===i.elementType?N:Bi(i.type,N),k.props=z,j=i.pendingProps,M=k.context,E=p.contextType,typeof E=="object"&&E!==null?E=ii(E):(E=co(p)?nc:Ta.current,E=Bd(i,E));var R=p.getDerivedStateFromProps;(G=typeof R=="function"||typeof k.getSnapshotBeforeUpdate=="function")||typeof k.UNSAFE_componentWillReceiveProps!="function"&&typeof k.componentWillReceiveProps!="function"||(N!==j||M!==E)&&fz(i,k,f,E),jl=!1,M=i.memoizedState,k.state=M,By(i,f,k,g);var B=i.memoizedState;N!==j||M!==B||uo.current||jl?(typeof R=="function"&&(N2(i,p,R,f),B=i.memoizedState),(z=jl||pz(i,p,z,f,M,B,E)||!1)?(G||typeof k.UNSAFE_componentWillUpdate!="function"&&typeof k.componentWillUpdate!="function"||(typeof k.componentWillUpdate=="function"&&k.componentWillUpdate(f,B,E),typeof k.UNSAFE_componentWillUpdate=="function"&&k.UNSAFE_componentWillUpdate(f,B,E)),typeof k.componentDidUpdate=="function"&&(i.flags|=4),typeof k.getSnapshotBeforeUpdate=="function"&&(i.flags|=1024)):(typeof k.componentDidUpdate!="function"||N===a.memoizedProps&&M===a.memoizedState||(i.flags|=4),typeof k.getSnapshotBeforeUpdate!="function"||N===a.memoizedProps&&M===a.memoizedState||(i.flags|=1024),i.memoizedProps=f,i.memoizedState=B),k.props=f,k.state=B,k.context=E,f=z):(typeof k.componentDidUpdate!="function"||N===a.memoizedProps&&M===a.memoizedState||(i.flags|=4),typeof k.getSnapshotBeforeUpdate!="function"||N===a.memoizedProps&&M===a.memoizedState||(i.flags|=1024),f=!1)}return z2(a,i,p,f,x,g)}function z2(a,i,p,f,g,x){Iz(a,i);var k=(i.flags&128)!==0;if(!f&&!k)return g&&DD(i,p,!1),QA(a,i,x);f=i.stateNode,nX.current=i;var N=k&&typeof p.getDerivedStateFromError!="function"?null:f.render();return i.flags|=1,a!==null&&k?(i.child=Wd(i,a.child,null,x),i.child=Wd(i,null,N,x)):Qa(a,i,N,x),i.memoizedState=f.state,g&&DD(i,p,!0),i.child}function Nz(a){var i=a.stateNode;i.pendingContext?MD(a,i.pendingContext,i.pendingContext!==i.context):i.context&&MD(a,i.context,!1),f2(a,i.containerInfo)}function Tz(a,i,p,f,g){return Rd(),A2(g),i.flags|=256,Qa(a,i,p,f),i.child}var O2={dehydrated:null,treeContext:null,retryLane:0};function P2(a){return{baseLanes:a,cachePool:null,transitions:null}}function Mz(a,i,p){var f=i.pendingProps,g=qr.current,x=!1,k=(i.flags&128)!==0,N;if((N=k)||(N=a!==null&&a.memoizedState===null?!1:(g&2)!==0),N?(x=!0,i.flags&=-129):(a===null||a.memoizedState!==null)&&(g|=1),Tr(qr,g&1),a===null)return i2(i),a=i.memoizedState,a!==null&&(a=a.dehydrated,a!==null)?(i.mode&1?a.data==="$!"?i.lanes=8:i.lanes=1073741824:i.lanes=1,null):(k=f.children,a=f.fallback,x?(f=i.mode,x=i.child,k={mode:"hidden",children:k},!(f&1)&&x!==null?(x.childLanes=0,x.pendingProps=k):x=nb(k,f,0,null),a=dc(a,f,p,null),x.return=i,a.return=i,x.sibling=a,i.child=x,i.child.memoizedState=P2(p),i.memoizedState=O2,a):B2(i,k));if(g=a.memoizedState,g!==null&&(N=g.dehydrated,N!==null))return rX(a,i,k,f,N,g,p);if(x){x=f.fallback,k=i.mode,g=a.child,N=g.sibling;var E={mode:"hidden",children:f.children};return!(k&1)&&i.child!==g?(f=i.child,f.childLanes=0,f.pendingProps=E,i.deletions=null):(f=Ul(g,E),f.subtreeFlags=g.subtreeFlags&14680064),N!==null?x=Ul(N,x):(x=dc(x,k,p,null),x.flags|=2),x.return=i,f.return=i,f.sibling=x,i.child=f,f=x,x=i.child,k=a.child.memoizedState,k=k===null?P2(p):{baseLanes:k.baseLanes|p,cachePool:null,transitions:k.transitions},x.memoizedState=k,x.childLanes=a.childLanes&~p,i.memoizedState=O2,f}return x=a.child,a=x.sibling,f=Ul(x,{mode:"visible",children:f.children}),!(i.mode&1)&&(f.lanes=p),f.return=i,f.sibling=null,a!==null&&(p=i.deletions,p===null?(i.deletions=[a],i.flags|=16):p.push(a)),i.child=f,i.memoizedState=null,f}function B2(a,i){return i=nb({mode:"visible",children:i},a.mode,0,null),i.return=a,a.child=i}function Vy(a,i,p,f){return f!==null&&A2(f),Wd(i,a.child,null,p),a=B2(i,i.pendingProps.children),a.flags|=2,i.memoizedState=null,a}function rX(a,i,p,f,g,x,k){if(p)return i.flags&256?(i.flags&=-257,f=M2(Error(Ct(422))),Vy(a,i,k,f)):i.memoizedState!==null?(i.child=a.child,i.flags|=128,null):(x=f.fallback,g=i.mode,f=nb({mode:"visible",children:f.children},g,0,null),x=dc(x,g,k,null),x.flags|=2,f.return=i,x.return=i,f.sibling=x,i.child=f,i.mode&1&&Wd(i,a.child,null,k),i.child.memoizedState=P2(k),i.memoizedState=O2,x);if(!(i.mode&1))return Vy(a,i,k,null);if(g.data==="$!"){if(f=g.nextSibling&&g.nextSibling.dataset,f)var N=f.dgst;return f=N,x=Error(Ct(419)),f=M2(x,f,void 0),Vy(a,i,k,f)}if(N=(k&a.childLanes)!==0,po||N){if(f=_s,f!==null){switch(k&-k){case 4:g=2;break;case 16:g=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:g=32;break;case 536870912:g=268435456;break;default:g=0}g=g&(f.suspendedLanes|k)?0:g,g!==0&&g!==x.retryLane&&(x.retryLane=g,YA(a,g),Ri(f,a,g,-1))}return J2(),f=M2(Error(Ct(421))),Vy(a,i,k,f)}return g.data==="$?"?(i.flags|=128,i.child=a.child,i=mX.bind(null,a),g._reactRetry=i,null):(a=x.treeContext,Ro=Fl(g.nextSibling),Lo=i,Gr=!0,Pi=null,a!==null&&(ai[oi++]=XA,ai[oi++]=ZA,ai[oi++]=rc,XA=a.id,ZA=a.overflow,rc=i),i=B2(i,f.children),i.flags|=4096,i)}function Ez(a,i,p){a.lanes|=i;var f=a.alternate;f!==null&&(f.lanes|=i),d2(a.return,i,p)}function F2(a,i,p,f,g){var x=a.memoizedState;x===null?a.memoizedState={isBackwards:i,rendering:null,renderingStartTime:0,last:f,tail:p,tailMode:g}:(x.isBackwards=i,x.rendering=null,x.renderingStartTime=0,x.last=f,x.tail=p,x.tailMode=g)}function Dz(a,i,p){var f=i.pendingProps,g=f.revealOrder,x=f.tail;if(Qa(a,i,f.children,p),f=qr.current,f&2)f=f&1|2,i.flags|=128;else{if(a!==null&&a.flags&128)e:for(a=i.child;a!==null;){if(a.tag===13)a.memoizedState!==null&&Ez(a,p,i);else if(a.tag===19)Ez(a,p,i);else if(a.child!==null){a.child.return=a,a=a.child;continue}if(a===i)break e;for(;a.sibling===null;){if(a.return===null||a.return===i)break e;a=a.return}a.sibling.return=a.return,a=a.sibling}f&=1}if(Tr(qr,f),!(i.mode&1))i.memoizedState=null;else switch(g){case"forwards":for(p=i.child,g=null;p!==null;)a=p.alternate,a!==null&&Fy(a)===null&&(g=p),p=p.sibling;p=g,p===null?(g=i.child,i.child=null):(g=p.sibling,p.sibling=null),F2(i,!1,g,p,x);break;case"backwards":for(p=null,g=i.child,i.child=null;g!==null;){if(a=g.alternate,a!==null&&Fy(a)===null){i.child=g;break}a=g.sibling,g.sibling=p,p=g,g=a}F2(i,!0,p,null,x);break;case"together":F2(i,!1,null,null,void 0);break;default:i.memoizedState=null}return i.child}function Xy(a,i){!(i.mode&1)&&a!==null&&(a.alternate=null,i.alternate=null,i.flags|=2)}function QA(a,i,p){if(a!==null&&(i.dependencies=a.dependencies),Ac|=i.lanes,!(p&i.childLanes))return null;if(a!==null&&i.child!==a.child)throw Error(Ct(153));if(i.child!==null){for(a=i.child,p=Ul(a,a.pendingProps),i.child=p,p.return=i;a.sibling!==null;)a=a.sibling,p=p.sibling=Ul(a,a.pendingProps),p.return=i;p.sibling=null}return i.child}function sX(a,i,p){switch(i.tag){case 3:Nz(i),Rd();break;case 5:ZD(i);break;case 1:co(i.type)&&Sy(i);break;case 4:f2(i,i.stateNode.containerInfo);break;case 10:var f=i.type._context,g=i.memoizedProps.value;Tr(zy,f._currentValue),f._currentValue=g;break;case 13:if(f=i.memoizedState,f!==null)return f.dehydrated!==null?(Tr(qr,qr.current&1),i.flags|=128,null):p&i.child.childLanes?Mz(a,i,p):(Tr(qr,qr.current&1),a=QA(a,i,p),a!==null?a.sibling:null);Tr(qr,qr.current&1);break;case 19:if(f=(p&i.childLanes)!==0,a.flags&128){if(f)return Dz(a,i,p);i.flags|=128}if(g=i.memoizedState,g!==null&&(g.rendering=null,g.tail=null,g.lastEffect=null),Tr(qr,qr.current),f)break;return null;case 22:case 23:return i.lanes=0,Cz(a,i,p)}return QA(a,i,p)}var zz,L2,Oz,Pz;zz=function(a,i){for(var p=i.child;p!==null;){if(p.tag===5||p.tag===6)a.appendChild(p.stateNode);else if(p.tag!==4&&p.child!==null){p.child.return=p,p=p.child;continue}if(p===i)break;for(;p.sibling===null;){if(p.return===null||p.return===i)return;p=p.return}p.sibling.return=p.return,p=p.sibling}},L2=function(){},Oz=function(a,i,p,f){var g=a.memoizedProps;if(g!==f){a=i.stateNode,oc(AA.current);var x=null;switch(p){case"input":g=dw(a,g),f=dw(a,f),x=[];break;case"select":g=Kr({},g,{value:void 0}),f=Kr({},f,{value:void 0}),x=[];break;case"textarea":g=fw(a,g),f=fw(a,f),x=[];break;default:typeof g.onClick!="function"&&typeof f.onClick=="function"&&(a.onclick=ky)}gw(p,f);var k;p=null;for(z in g)if(!f.hasOwnProperty(z)&&g.hasOwnProperty(z)&&g[z]!=null)if(z==="style"){var N=g[z];for(k in N)N.hasOwnProperty(k)&&(p||(p={}),p[k]="")}else z!=="dangerouslySetInnerHTML"&&z!=="children"&&z!=="suppressContentEditableWarning"&&z!=="suppressHydrationWarning"&&z!=="autoFocus"&&(wh.hasOwnProperty(z)?x||(x=[]):(x=x||[]).push(z,null));for(z in f){var E=f[z];if(N=g!=null?g[z]:void 0,f.hasOwnProperty(z)&&E!==N&&(E!=null||N!=null))if(z==="style")if(N){for(k in N)!N.hasOwnProperty(k)||E&&E.hasOwnProperty(k)||(p||(p={}),p[k]="");for(k in E)E.hasOwnProperty(k)&&N[k]!==E[k]&&(p||(p={}),p[k]=E[k])}else p||(x||(x=[]),x.push(z,p)),p=E;else z==="dangerouslySetInnerHTML"?(E=E?E.__html:void 0,N=N?N.__html:void 0,E!=null&&N!==E&&(x=x||[]).push(z,E)):z==="children"?typeof E!="string"&&typeof E!="number"||(x=x||[]).push(z,""+E):z!=="suppressContentEditableWarning"&&z!=="suppressHydrationWarning"&&(wh.hasOwnProperty(z)?(E!=null&&z==="onScroll"&&Pr("scroll",a),x||N===E||(x=[])):(x=x||[]).push(z,E))}p&&(x=x||[]).push("style",p);var z=x;(i.updateQueue=z)&&(i.flags|=4)}},Pz=function(a,i,p,f){p!==f&&(i.flags|=4)};function sf(a,i){if(!Gr)switch(a.tailMode){case"hidden":i=a.tail;for(var p=null;i!==null;)i.alternate!==null&&(p=i),i=i.sibling;p===null?a.tail=null:p.sibling=null;break;case"collapsed":p=a.tail;for(var f=null;p!==null;)p.alternate!==null&&(f=p),p=p.sibling;f===null?i||a.tail===null?a.tail=null:a.tail.sibling=null:f.sibling=null}}function Ea(a){var i=a.alternate!==null&&a.alternate.child===a.child,p=0,f=0;if(i)for(var g=a.child;g!==null;)p|=g.lanes|g.childLanes,f|=g.subtreeFlags&14680064,f|=g.flags&14680064,g.return=a,g=g.sibling;else for(g=a.child;g!==null;)p|=g.lanes|g.childLanes,f|=g.subtreeFlags,f|=g.flags,g.return=a,g=g.sibling;return a.subtreeFlags|=f,a.childLanes=p,i}function aX(a,i,p){var f=i.pendingProps;switch(a2(i),i.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Ea(i),null;case 1:return co(i.type)&&Iy(),Ea(i),null;case 3:return f=i.stateNode,Gd(),Br(uo),Br(Ta),y2(),f.pendingContext&&(f.context=f.pendingContext,f.pendingContext=null),(a===null||a.child===null)&&(Ey(i)?i.flags|=4:a===null||a.memoizedState.isDehydrated&&!(i.flags&256)||(i.flags|=1024,Pi!==null&&(Q2(Pi),Pi=null))),L2(a,i),Ea(i),null;case 5:m2(i);var g=oc(_h.current);if(p=i.type,a!==null&&i.stateNode!=null)Oz(a,i,p,f,g),a.ref!==i.ref&&(i.flags|=512,i.flags|=2097152);else{if(!f){if(i.stateNode===null)throw Error(Ct(166));return Ea(i),null}if(a=oc(AA.current),Ey(i)){f=i.stateNode,p=i.type;var x=i.memoizedProps;switch(f[iA]=i,f[Qh]=x,a=(i.mode&1)!==0,p){case"dialog":Pr("cancel",f),Pr("close",f);break;case"iframe":case"object":case"embed":Pr("load",f);break;case"video":case"audio":for(g=0;g<Zh.length;g++)Pr(Zh[g],f);break;case"source":Pr("error",f);break;case"img":case"image":case"link":Pr("error",f),Pr("load",f);break;case"details":Pr("toggle",f);break;case"input":hE(f,x),Pr("invalid",f);break;case"select":f._wrapperState={wasMultiple:!!x.multiple},Pr("invalid",f);break;case"textarea":gE(f,x),Pr("invalid",f)}gw(p,x),g=null;for(var k in x)if(x.hasOwnProperty(k)){var N=x[k];k==="children"?typeof N=="string"?f.textContent!==N&&(x.suppressHydrationWarning!==!0&&wy(f.textContent,N,a),g=["children",N]):typeof N=="number"&&f.textContent!==""+N&&(x.suppressHydrationWarning!==!0&&wy(f.textContent,N,a),g=["children",""+N]):wh.hasOwnProperty(k)&&N!=null&&k==="onScroll"&&Pr("scroll",f)}switch(p){case"input":_g(f),mE(f,x,!0);break;case"textarea":_g(f),bE(f);break;case"select":case"option":break;default:typeof x.onClick=="function"&&(f.onclick=ky)}f=g,i.updateQueue=f,f!==null&&(i.flags|=4)}else{k=g.nodeType===9?g:g.ownerDocument,a==="http://www.w3.org/1999/xhtml"&&(a=vE(p)),a==="http://www.w3.org/1999/xhtml"?p==="script"?(a=k.createElement("div"),a.innerHTML="<script><\/script>",a=a.removeChild(a.firstChild)):typeof f.is=="string"?a=k.createElement(p,{is:f.is}):(a=k.createElement(p),p==="select"&&(k=a,f.multiple?k.multiple=!0:f.size&&(k.size=f.size))):a=k.createElementNS(a,p),a[iA]=i,a[Qh]=f,zz(a,i,!1,!1),i.stateNode=a;e:{switch(k=yw(p,f),p){case"dialog":Pr("cancel",a),Pr("close",a),g=f;break;case"iframe":case"object":case"embed":Pr("load",a),g=f;break;case"video":case"audio":for(g=0;g<Zh.length;g++)Pr(Zh[g],a);g=f;break;case"source":Pr("error",a),g=f;break;case"img":case"image":case"link":Pr("error",a),Pr("load",a),g=f;break;case"details":Pr("toggle",a),g=f;break;case"input":hE(a,f),g=dw(a,f),Pr("invalid",a);break;case"option":g=f;break;case"select":a._wrapperState={wasMultiple:!!f.multiple},g=Kr({},f,{value:void 0}),Pr("invalid",a);break;case"textarea":gE(a,f),g=fw(a,f),Pr("invalid",a);break;default:g=f}gw(p,g),N=g;for(x in N)if(N.hasOwnProperty(x)){var E=N[x];x==="style"?kE(a,E):x==="dangerouslySetInnerHTML"?(E=E?E.__html:void 0,E!=null&&xE(a,E)):x==="children"?typeof E=="string"?(p!=="textarea"||E!=="")&&Sh(a,E):typeof E=="number"&&Sh(a,""+E):x!=="suppressContentEditableWarning"&&x!=="suppressHydrationWarning"&&x!=="autoFocus"&&(wh.hasOwnProperty(x)?E!=null&&x==="onScroll"&&Pr("scroll",a):E!=null&&tw(a,x,E,k))}switch(p){case"input":_g(a),mE(a,f,!1);break;case"textarea":_g(a),bE(a);break;case"option":f.value!=null&&a.setAttribute("value",""+Ml(f.value));break;case"select":a.multiple=!!f.multiple,x=f.value,x!=null?kd(a,!!f.multiple,x,!1):f.defaultValue!=null&&kd(a,!!f.multiple,f.defaultValue,!0);break;default:typeof g.onClick=="function"&&(a.onclick=ky)}switch(p){case"button":case"input":case"select":case"textarea":f=!!f.autoFocus;break e;case"img":f=!0;break e;default:f=!1}}f&&(i.flags|=4)}i.ref!==null&&(i.flags|=512,i.flags|=2097152)}return Ea(i),null;case 6:if(a&&i.stateNode!=null)Pz(a,i,a.memoizedProps,f);else{if(typeof f!="string"&&i.stateNode===null)throw Error(Ct(166));if(p=oc(_h.current),oc(AA.current),Ey(i)){if(f=i.stateNode,p=i.memoizedProps,f[iA]=i,(x=f.nodeValue!==p)&&(a=Lo,a!==null))switch(a.tag){case 3:wy(f.nodeValue,p,(a.mode&1)!==0);break;case 5:a.memoizedProps.suppressHydrationWarning!==!0&&wy(f.nodeValue,p,(a.mode&1)!==0)}x&&(i.flags|=4)}else f=(p.nodeType===9?p:p.ownerDocument).createTextNode(f),f[iA]=i,i.stateNode=f}return Ea(i),null;case 13:if(Br(qr),f=i.memoizedState,a===null||a.memoizedState!==null&&a.memoizedState.dehydrated!==null){if(Gr&&Ro!==null&&i.mode&1&&!(i.flags&128))LD(),Rd(),i.flags|=98560,x=!1;else if(x=Ey(i),f!==null&&f.dehydrated!==null){if(a===null){if(!x)throw Error(Ct(318));if(x=i.memoizedState,x=x!==null?x.dehydrated:null,!x)throw Error(Ct(317));x[iA]=i}else Rd(),!(i.flags&128)&&(i.memoizedState=null),i.flags|=4;Ea(i),x=!1}else Pi!==null&&(Q2(Pi),Pi=null),x=!0;if(!x)return i.flags&65536?i:null}return i.flags&128?(i.lanes=p,i):(f=f!==null,f!==(a!==null&&a.memoizedState!==null)&&f&&(i.child.flags|=8192,i.mode&1&&(a===null||qr.current&1?Ws===0&&(Ws=3):J2())),i.updateQueue!==null&&(i.flags|=4),Ea(i),null);case 4:return Gd(),L2(a,i),a===null&&Yh(i.stateNode.containerInfo),Ea(i),null;case 10:return c2(i.type._context),Ea(i),null;case 17:return co(i.type)&&Iy(),Ea(i),null;case 19:if(Br(qr),x=i.memoizedState,x===null)return Ea(i),null;if(f=(i.flags&128)!==0,k=x.rendering,k===null)if(f)sf(x,!1);else{if(Ws!==0||a!==null&&a.flags&128)for(a=i.child;a!==null;){if(k=Fy(a),k!==null){for(i.flags|=128,sf(x,!1),f=k.updateQueue,f!==null&&(i.updateQueue=f,i.flags|=4),i.subtreeFlags=0,f=p,p=i.child;p!==null;)x=p,a=f,x.flags&=14680066,k=x.alternate,k===null?(x.childLanes=0,x.lanes=a,x.child=null,x.subtreeFlags=0,x.memoizedProps=null,x.memoizedState=null,x.updateQueue=null,x.dependencies=null,x.stateNode=null):(x.childLanes=k.childLanes,x.lanes=k.lanes,x.child=k.child,x.subtreeFlags=0,x.deletions=null,x.memoizedProps=k.memoizedProps,x.memoizedState=k.memoizedState,x.updateQueue=k.updateQueue,x.type=k.type,a=k.dependencies,x.dependencies=a===null?null:{lanes:a.lanes,firstContext:a.firstContext}),p=p.sibling;return Tr(qr,qr.current&1|2),i.child}a=a.sibling}x.tail!==null&&hs()>Yd&&(i.flags|=128,f=!0,sf(x,!1),i.lanes=4194304)}else{if(!f)if(a=Fy(k),a!==null){if(i.flags|=128,f=!0,p=a.updateQueue,p!==null&&(i.updateQueue=p,i.flags|=4),sf(x,!0),x.tail===null&&x.tailMode==="hidden"&&!k.alternate&&!Gr)return Ea(i),null}else 2*hs()-x.renderingStartTime>Yd&&p!==1073741824&&(i.flags|=128,f=!0,sf(x,!1),i.lanes=4194304);x.isBackwards?(k.sibling=i.child,i.child=k):(p=x.last,p!==null?p.sibling=k:i.child=k,x.last=k)}return x.tail!==null?(i=x.tail,x.rendering=i,x.tail=i.sibling,x.renderingStartTime=hs(),i.sibling=null,p=qr.current,Tr(qr,f?p&1|2:p&1),i):(Ea(i),null);case 22:case 23:return q2(),f=i.memoizedState!==null,a!==null&&a.memoizedState!==null!==f&&(i.flags|=8192),f&&i.mode&1?Wo&1073741824&&(Ea(i),i.subtreeFlags&6&&(i.flags|=8192)):Ea(i),null;case 24:return null;case 25:return null}throw Error(Ct(156,i.tag))}function oX(a,i){switch(a2(i),i.tag){case 1:return co(i.type)&&Iy(),a=i.flags,a&65536?(i.flags=a&-65537|128,i):null;case 3:return Gd(),Br(uo),Br(Ta),y2(),a=i.flags,a&65536&&!(a&128)?(i.flags=a&-65537|128,i):null;case 5:return m2(i),null;case 13:if(Br(qr),a=i.memoizedState,a!==null&&a.dehydrated!==null){if(i.alternate===null)throw Error(Ct(340));Rd()}return a=i.flags,a&65536?(i.flags=a&-65537|128,i):null;case 19:return Br(qr),null;case 4:return Gd(),null;case 10:return c2(i.type._context),null;case 22:case 23:return q2(),null;case 24:return null;default:return null}}var Zy=!1,Da=!1,iX=typeof WeakSet=="function"?WeakSet:Set,Zt=null;function Xd(a,i){var p=a.ref;if(p!==null)if(typeof p=="function")try{p(null)}catch(f){rs(a,i,f)}else p.current=null}function R2(a,i,p){try{p()}catch(f){rs(a,i,f)}}var Bz=!1;function AX(a,i){if(qw=cy,a=pD(),Gw(a)){if("selectionStart"in a)var p={start:a.selectionStart,end:a.selectionEnd};else e:{p=(p=a.ownerDocument)&&p.defaultView||window;var f=p.getSelection&&p.getSelection();if(f&&f.rangeCount!==0){p=f.anchorNode;var g=f.anchorOffset,x=f.focusNode;f=f.focusOffset;try{p.nodeType,x.nodeType}catch{p=null;break e}var k=0,N=-1,E=-1,z=0,G=0,j=a,M=null;t:for(;;){for(var R;j!==p||g!==0&&j.nodeType!==3||(N=k+g),j!==x||f!==0&&j.nodeType!==3||(E=k+f),j.nodeType===3&&(k+=j.nodeValue.length),(R=j.firstChild)!==null;)M=j,j=R;for(;;){if(j===a)break t;if(M===p&&++z===g&&(N=k),M===x&&++G===f&&(E=k),(R=j.nextSibling)!==null)break;j=M,M=j.parentNode}j=R}p=N===-1||E===-1?null:{start:N,end:E}}else p=null}p=p||{start:0,end:0}}else p=null;for(Jw={focusedElem:a,selectionRange:p},cy=!1,Zt=i;Zt!==null;)if(i=Zt,a=i.child,(i.subtreeFlags&1028)!==0&&a!==null)a.return=i,Zt=a;else for(;Zt!==null;){i=Zt;try{var B=i.alternate;if(i.flags&1024)switch(i.tag){case 0:case 11:case 15:break;case 1:if(B!==null){var P=B.memoizedProps,H=B.memoizedState,C=i.stateNode,O=C.getSnapshotBeforeUpdate(i.elementType===i.type?P:Bi(i.type,P),H);C.__reactInternalSnapshotBeforeUpdate=O}break;case 3:var F=i.stateNode.containerInfo;F.nodeType===1?F.textContent="":F.nodeType===9&&F.documentElement&&F.removeChild(F.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(Ct(163))}}catch(Y){rs(i,i.return,Y)}if(a=i.sibling,a!==null){a.return=i.return,Zt=a;break}Zt=i.return}return B=Bz,Bz=!1,B}function af(a,i,p){var f=i.updateQueue;if(f=f!==null?f.lastEffect:null,f!==null){var g=f=f.next;do{if((g.tag&a)===a){var x=g.destroy;g.destroy=void 0,x!==void 0&&R2(i,p,x)}g=g.next}while(g!==f)}}function Yy(a,i){if(i=i.updateQueue,i=i!==null?i.lastEffect:null,i!==null){var p=i=i.next;do{if((p.tag&a)===a){var f=p.create;p.destroy=f()}p=p.next}while(p!==i)}}function W2(a){var i=a.ref;if(i!==null){var p=a.stateNode;switch(a.tag){case 5:a=p;break;default:a=p}typeof i=="function"?i(a):i.current=a}}function Fz(a){var i=a.alternate;i!==null&&(a.alternate=null,Fz(i)),a.child=null,a.deletions=null,a.sibling=null,a.tag===5&&(i=a.stateNode,i!==null&&(delete i[iA],delete i[Qh],delete i[t2],delete i[XV],delete i[ZV])),a.stateNode=null,a.return=null,a.dependencies=null,a.memoizedProps=null,a.memoizedState=null,a.pendingProps=null,a.stateNode=null,a.updateQueue=null}function Lz(a){return a.tag===5||a.tag===3||a.tag===4}function Rz(a){e:for(;;){for(;a.sibling===null;){if(a.return===null||Lz(a.return))return null;a=a.return}for(a.sibling.return=a.return,a=a.sibling;a.tag!==5&&a.tag!==6&&a.tag!==18;){if(a.flags&2||a.child===null||a.tag===4)continue e;a.child.return=a,a=a.child}if(!(a.flags&2))return a.stateNode}}function j2(a,i,p){var f=a.tag;if(f===5||f===6)a=a.stateNode,i?p.nodeType===8?p.parentNode.insertBefore(a,i):p.insertBefore(a,i):(p.nodeType===8?(i=p.parentNode,i.insertBefore(a,p)):(i=p,i.appendChild(a)),p=p._reactRootContainer,p!=null||i.onclick!==null||(i.onclick=ky));else if(f!==4&&(a=a.child,a!==null))for(j2(a,i,p),a=a.sibling;a!==null;)j2(a,i,p),a=a.sibling}function H2(a,i,p){var f=a.tag;if(f===5||f===6)a=a.stateNode,i?p.insertBefore(a,i):p.appendChild(a);else if(f!==4&&(a=a.child,a!==null))for(H2(a,i,p),a=a.sibling;a!==null;)H2(a,i,p),a=a.sibling}var fa=null,Fi=!1;function Gl(a,i,p){for(p=p.child;p!==null;)Wz(a,i,p),p=p.sibling}function Wz(a,i,p){if(oA&&typeof oA.onCommitFiberUnmount=="function")try{oA.onCommitFiberUnmount(ay,p)}catch{}switch(p.tag){case 5:Da||Xd(p,i);case 6:var f=fa,g=Fi;fa=null,Gl(a,i,p),fa=f,Fi=g,fa!==null&&(Fi?(a=fa,p=p.stateNode,a.nodeType===8?a.parentNode.removeChild(p):a.removeChild(p)):fa.removeChild(p.stateNode));break;case 18:fa!==null&&(Fi?(a=fa,p=p.stateNode,a.nodeType===8?e2(a.parentNode,p):a.nodeType===1&&e2(a,p),Lh(a)):e2(fa,p.stateNode));break;case 4:f=fa,g=Fi,fa=p.stateNode.containerInfo,Fi=!0,Gl(a,i,p),fa=f,Fi=g;break;case 0:case 11:case 14:case 15:if(!Da&&(f=p.updateQueue,f!==null&&(f=f.lastEffect,f!==null))){g=f=f.next;do{var x=g,k=x.destroy;x=x.tag,k!==void 0&&(x&2||x&4)&&R2(p,i,k),g=g.next}while(g!==f)}Gl(a,i,p);break;case 1:if(!Da&&(Xd(p,i),f=p.stateNode,typeof f.componentWillUnmount=="function"))try{f.props=p.memoizedProps,f.state=p.memoizedState,f.componentWillUnmount()}catch(N){rs(p,i,N)}Gl(a,i,p);break;case 21:Gl(a,i,p);break;case 22:p.mode&1?(Da=(f=Da)||p.memoizedState!==null,Gl(a,i,p),Da=f):Gl(a,i,p);break;default:Gl(a,i,p)}}function jz(a){var i=a.updateQueue;if(i!==null){a.updateQueue=null;var p=a.stateNode;p===null&&(p=a.stateNode=new iX),i.forEach(function(f){var g=gX.bind(null,a,f);p.has(f)||(p.add(f),f.then(g,g))})}}function Li(a,i){var p=i.deletions;if(p!==null)for(var f=0;f<p.length;f++){var g=p[f];try{var x=a,k=i,N=k;e:for(;N!==null;){switch(N.tag){case 5:fa=N.stateNode,Fi=!1;break e;case 3:fa=N.stateNode.containerInfo,Fi=!0;break e;case 4:fa=N.stateNode.containerInfo,Fi=!0;break e}N=N.return}if(fa===null)throw Error(Ct(160));Wz(x,k,g),fa=null,Fi=!1;var E=g.alternate;E!==null&&(E.return=null),g.return=null}catch(z){rs(g,i,z)}}if(i.subtreeFlags&12854)for(i=i.child;i!==null;)Hz(i,a),i=i.sibling}function Hz(a,i){var p=a.alternate,f=a.flags;switch(a.tag){case 0:case 11:case 14:case 15:if(Li(i,a),uA(a),f&4){try{af(3,a,a.return),Yy(3,a)}catch(P){rs(a,a.return,P)}try{af(5,a,a.return)}catch(P){rs(a,a.return,P)}}break;case 1:Li(i,a),uA(a),f&512&&p!==null&&Xd(p,p.return);break;case 5:if(Li(i,a),uA(a),f&512&&p!==null&&Xd(p,p.return),a.flags&32){var g=a.stateNode;try{Sh(g,"")}catch(P){rs(a,a.return,P)}}if(f&4&&(g=a.stateNode,g!=null)){var x=a.memoizedProps,k=p!==null?p.memoizedProps:x,N=a.type,E=a.updateQueue;if(a.updateQueue=null,E!==null)try{N==="input"&&x.type==="radio"&&x.name!=null&&fE(g,x),yw(N,k);var z=yw(N,x);for(k=0;k<E.length;k+=2){var G=E[k],j=E[k+1];G==="style"?kE(g,j):G==="dangerouslySetInnerHTML"?xE(g,j):G==="children"?Sh(g,j):tw(g,G,j,z)}switch(N){case"input":pw(g,x);break;case"textarea":yE(g,x);break;case"select":var M=g._wrapperState.wasMultiple;g._wrapperState.wasMultiple=!!x.multiple;var R=x.value;R!=null?kd(g,!!x.multiple,R,!1):M!==!!x.multiple&&(x.defaultValue!=null?kd(g,!!x.multiple,x.defaultValue,!0):kd(g,!!x.multiple,x.multiple?[]:"",!1))}g[Qh]=x}catch(P){rs(a,a.return,P)}}break;case 6:if(Li(i,a),uA(a),f&4){if(a.stateNode===null)throw Error(Ct(162));g=a.stateNode,x=a.memoizedProps;try{g.nodeValue=x}catch(P){rs(a,a.return,P)}}break;case 3:if(Li(i,a),uA(a),f&4&&p!==null&&p.memoizedState.isDehydrated)try{Lh(i.containerInfo)}catch(P){rs(a,a.return,P)}break;case 4:Li(i,a),uA(a);break;case 13:Li(i,a),uA(a),g=a.child,g.flags&8192&&(x=g.memoizedState!==null,g.stateNode.isHidden=x,!x||g.alternate!==null&&g.alternate.memoizedState!==null||(X2=hs())),f&4&&jz(a);break;case 22:if(G=p!==null&&p.memoizedState!==null,a.mode&1?(Da=(z=Da)||G,Li(i,a),Da=z):Li(i,a),uA(a),f&8192){if(z=a.memoizedState!==null,(a.stateNode.isHidden=z)&&!G&&a.mode&1)for(Zt=a,G=a.child;G!==null;){for(j=Zt=G;Zt!==null;){switch(M=Zt,R=M.child,M.tag){case 0:case 11:case 14:case 15:af(4,M,M.return);break;case 1:Xd(M,M.return);var B=M.stateNode;if(typeof B.componentWillUnmount=="function"){f=M,p=M.return;try{i=f,B.props=i.memoizedProps,B.state=i.memoizedState,B.componentWillUnmount()}catch(P){rs(f,p,P)}}break;case 5:Xd(M,M.return);break;case 22:if(M.memoizedState!==null){Xz(j);continue}}R!==null?(R.return=M,Zt=R):Xz(j)}G=G.sibling}e:for(G=null,j=a;;){if(j.tag===5){if(G===null){G=j;try{g=j.stateNode,z?(x=g.style,typeof x.setProperty=="function"?x.setProperty("display","none","important"):x.display="none"):(N=j.stateNode,E=j.memoizedProps.style,k=E!=null&&E.hasOwnProperty("display")?E.display:null,N.style.display=wE("display",k))}catch(P){rs(a,a.return,P)}}}else if(j.tag===6){if(G===null)try{j.stateNode.nodeValue=z?"":j.memoizedProps}catch(P){rs(a,a.return,P)}}else if((j.tag!==22&&j.tag!==23||j.memoizedState===null||j===a)&&j.child!==null){j.child.return=j,j=j.child;continue}if(j===a)break e;for(;j.sibling===null;){if(j.return===null||j.return===a)break e;G===j&&(G=null),j=j.return}G===j&&(G=null),j.sibling.return=j.return,j=j.sibling}}break;case 19:Li(i,a),uA(a),f&4&&jz(a);break;case 21:break;default:Li(i,a),uA(a)}}function uA(a){var i=a.flags;if(i&2){try{e:{for(var p=a.return;p!==null;){if(Lz(p)){var f=p;break e}p=p.return}throw Error(Ct(160))}switch(f.tag){case 5:var g=f.stateNode;f.flags&32&&(Sh(g,""),f.flags&=-33);var x=Rz(a);H2(a,x,g);break;case 3:case 4:var k=f.stateNode.containerInfo,N=Rz(a);j2(a,N,k);break;default:throw Error(Ct(161))}}catch(E){rs(a,a.return,E)}a.flags&=-3}i&4096&&(a.flags&=-4097)}function lX(a,i,p){Zt=a,Gz(a)}function Gz(a,i,p){for(var f=(a.mode&1)!==0;Zt!==null;){var g=Zt,x=g.child;if(g.tag===22&&f){var k=g.memoizedState!==null||Zy;if(!k){var N=g.alternate,E=N!==null&&N.memoizedState!==null||Da;N=Zy;var z=Da;if(Zy=k,(Da=E)&&!z)for(Zt=g;Zt!==null;)k=Zt,E=k.child,k.tag===22&&k.memoizedState!==null?Zz(g):E!==null?(E.return=k,Zt=E):Zz(g);for(;x!==null;)Zt=x,Gz(x),x=x.sibling;Zt=g,Zy=N,Da=z}Vz(a)}else g.subtreeFlags&8772&&x!==null?(x.return=g,Zt=x):Vz(a)}}function Vz(a){for(;Zt!==null;){var i=Zt;if(i.flags&8772){var p=i.alternate;try{if(i.flags&8772)switch(i.tag){case 0:case 11:case 15:Da||Yy(5,i);break;case 1:var f=i.stateNode;if(i.flags&4&&!Da)if(p===null)f.componentDidMount();else{var g=i.elementType===i.type?p.memoizedProps:Bi(i.type,p.memoizedProps);f.componentDidUpdate(g,p.memoizedState,f.__reactInternalSnapshotBeforeUpdate)}var x=i.updateQueue;x!==null&&XD(i,x,f);break;case 3:var k=i.updateQueue;if(k!==null){if(p=null,i.child!==null)switch(i.child.tag){case 5:p=i.child.stateNode;break;case 1:p=i.child.stateNode}XD(i,k,p)}break;case 5:var N=i.stateNode;if(p===null&&i.flags&4){p=N;var E=i.memoizedProps;switch(i.type){case"button":case"input":case"select":case"textarea":E.autoFocus&&p.focus();break;case"img":E.src&&(p.src=E.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(i.memoizedState===null){var z=i.alternate;if(z!==null){var G=z.memoizedState;if(G!==null){var j=G.dehydrated;j!==null&&Lh(j)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(Ct(163))}Da||i.flags&512&&W2(i)}catch(M){rs(i,i.return,M)}}if(i===a){Zt=null;break}if(p=i.sibling,p!==null){p.return=i.return,Zt=p;break}Zt=i.return}}function Xz(a){for(;Zt!==null;){var i=Zt;if(i===a){Zt=null;break}var p=i.sibling;if(p!==null){p.return=i.return,Zt=p;break}Zt=i.return}}function Zz(a){for(;Zt!==null;){var i=Zt;try{switch(i.tag){case 0:case 11:case 15:var p=i.return;try{Yy(4,i)}catch(E){rs(i,p,E)}break;case 1:var f=i.stateNode;if(typeof f.componentDidMount=="function"){var g=i.return;try{f.componentDidMount()}catch(E){rs(i,g,E)}}var x=i.return;try{W2(i)}catch(E){rs(i,x,E)}break;case 5:var k=i.return;try{W2(i)}catch(E){rs(i,k,E)}}}catch(E){rs(i,i.return,E)}if(i===a){Zt=null;break}var N=i.sibling;if(N!==null){N.return=i.return,Zt=N;break}Zt=i.return}}var uX=Math.ceil,Uy=HA.ReactCurrentDispatcher,G2=HA.ReactCurrentOwner,li=HA.ReactCurrentBatchConfig,er=0,_s=null,ks=null,ma=0,Wo=0,Zd=Ll(0),Ws=0,of=null,Ac=0,Qy=0,V2=0,Af=null,ho=null,X2=0,Yd=1/0,KA=null,Ky=!1,Z2=null,Vl=null,qy=!1,Xl=null,Jy=0,lf=0,Y2=null,$y=-1,_y=0;function Ka(){return er&6?hs():$y!==-1?$y:$y=hs()}function Zl(a){return a.mode&1?er&2&&ma!==0?ma&-ma:UV.transition!==null?(_y===0&&(_y=RE()),_y):(a=mr,a!==0||(a=window.event,a=a===void 0?16:UE(a.type)),a):1}function Ri(a,i,p,f){if(50<lf)throw lf=0,Y2=null,Error(Ct(185));zh(a,p,f),(!(er&2)||a!==_s)&&(a===_s&&(!(er&2)&&(Qy|=p),Ws===4&&Yl(a,ma)),fo(a,f),p===1&&er===0&&!(i.mode&1)&&(Yd=hs()+500,Ny&&Wl()))}function fo(a,i){var p=a.callbackNode;UG(a,i);var f=Ay(a,a===_s?ma:0);if(f===0)p!==null&&BE(p),a.callbackNode=null,a.callbackPriority=0;else if(i=f&-f,a.callbackPriority!==i){if(p!=null&&BE(p),i===1)a.tag===0?YV(Uz.bind(null,a)):zD(Uz.bind(null,a)),GV(function(){!(er&6)&&Wl()}),p=null;else{switch(WE(f)){case 1:p=Iw;break;case 4:p=FE;break;case 16:p=sy;break;case 536870912:p=LE;break;default:p=sy}p=tO(p,Yz.bind(null,a))}a.callbackPriority=i,a.callbackNode=p}}function Yz(a,i){if($y=-1,_y=0,er&6)throw Error(Ct(327));var p=a.callbackNode;if(Ud()&&a.callbackNode!==p)return null;var f=Ay(a,a===_s?ma:0);if(f===0)return null;if(f&30||f&a.expiredLanes||i)i=eb(a,f);else{i=f;var g=er;er|=2;var x=Kz();(_s!==a||ma!==i)&&(KA=null,Yd=hs()+500,uc(a,i));do try{pX();break}catch(N){Qz(a,N)}while(!0);u2(),Uy.current=x,er=g,ks!==null?i=0:(_s=null,ma=0,i=Ws)}if(i!==0){if(i===2&&(g=Sw(a),g!==0&&(f=g,i=U2(a,g))),i===1)throw p=of,uc(a,0),Yl(a,f),fo(a,hs()),p;if(i===6)Yl(a,f);else{if(g=a.current.alternate,!(f&30)&&!cX(g)&&(i=eb(a,f),i===2&&(x=Sw(a),x!==0&&(f=x,i=U2(a,x))),i===1))throw p=of,uc(a,0),Yl(a,f),fo(a,hs()),p;switch(a.finishedWork=g,a.finishedLanes=f,i){case 0:case 1:throw Error(Ct(345));case 2:cc(a,ho,KA);break;case 3:if(Yl(a,f),(f&130023424)===f&&(i=X2+500-hs(),10<i)){if(Ay(a,0)!==0)break;if(g=a.suspendedLanes,(g&f)!==f){Ka(),a.pingedLanes|=a.suspendedLanes&g;break}a.timeoutHandle=_w(cc.bind(null,a,ho,KA),i);break}cc(a,ho,KA);break;case 4:if(Yl(a,f),(f&4194240)===f)break;for(i=a.eventTimes,g=-1;0<f;){var k=31-zi(f);x=1<<k,k=i[k],k>g&&(g=k),f&=~x}if(f=g,f=hs()-f,f=(120>f?120:480>f?480:1080>f?1080:1920>f?1920:3e3>f?3e3:4320>f?4320:1960*uX(f/1960))-f,10<f){a.timeoutHandle=_w(cc.bind(null,a,ho,KA),f);break}cc(a,ho,KA);break;case 5:cc(a,ho,KA);break;default:throw Error(Ct(329))}}}return fo(a,hs()),a.callbackNode===p?Yz.bind(null,a):null}function U2(a,i){var p=Af;return a.current.memoizedState.isDehydrated&&(uc(a,i).flags|=256),a=eb(a,i),a!==2&&(i=ho,ho=p,i!==null&&Q2(i)),a}function Q2(a){ho===null?ho=a:ho.push.apply(ho,a)}function cX(a){for(var i=a;;){if(i.flags&16384){var p=i.updateQueue;if(p!==null&&(p=p.stores,p!==null))for(var f=0;f<p.length;f++){var g=p[f],x=g.getSnapshot;g=g.value;try{if(!Oi(x(),g))return!1}catch{return!1}}}if(p=i.child,i.subtreeFlags&16384&&p!==null)p.return=i,i=p;else{if(i===a)break;for(;i.sibling===null;){if(i.return===null||i.return===a)return!0;i=i.return}i.sibling.return=i.return,i=i.sibling}}return!0}function Yl(a,i){for(i&=~V2,i&=~Qy,a.suspendedLanes|=i,a.pingedLanes&=~i,a=a.expirationTimes;0<i;){var p=31-zi(i),f=1<<p;a[p]=-1,i&=~f}}function Uz(a){if(er&6)throw Error(Ct(327));Ud();var i=Ay(a,0);if(!(i&1))return fo(a,hs()),null;var p=eb(a,i);if(a.tag!==0&&p===2){var f=Sw(a);f!==0&&(i=f,p=U2(a,f))}if(p===1)throw p=of,uc(a,0),Yl(a,i),fo(a,hs()),p;if(p===6)throw Error(Ct(345));return a.finishedWork=a.current.alternate,a.finishedLanes=i,cc(a,ho,KA),fo(a,hs()),null}function K2(a,i){var p=er;er|=1;try{return a(i)}finally{er=p,er===0&&(Yd=hs()+500,Ny&&Wl())}}function lc(a){Xl!==null&&Xl.tag===0&&!(er&6)&&Ud();var i=er;er|=1;var p=li.transition,f=mr;try{if(li.transition=null,mr=1,a)return a()}finally{mr=f,li.transition=p,er=i,!(er&6)&&Wl()}}function q2(){Wo=Zd.current,Br(Zd)}function uc(a,i){a.finishedWork=null,a.finishedLanes=0;var p=a.timeoutHandle;if(p!==-1&&(a.timeoutHandle=-1,HV(p)),ks!==null)for(p=ks.return;p!==null;){var f=p;switch(a2(f),f.tag){case 1:f=f.type.childContextTypes,f!=null&&Iy();break;case 3:Gd(),Br(uo),Br(Ta),y2();break;case 5:m2(f);break;case 4:Gd();break;case 13:Br(qr);break;case 19:Br(qr);break;case 10:c2(f.type._context);break;case 22:case 23:q2()}p=p.return}if(_s=a,ks=a=Ul(a.current,null),ma=Wo=i,Ws=0,of=null,V2=Qy=Ac=0,ho=Af=null,ac!==null){for(i=0;i<ac.length;i++)if(p=ac[i],f=p.interleaved,f!==null){p.interleaved=null;var g=f.next,x=p.pending;if(x!==null){var k=x.next;x.next=g,f.next=k}p.pending=f}ac=null}return a}function Qz(a,i){do{var p=ks;try{if(u2(),Ly.current=Hy,Ry){for(var f=Jr.memoizedState;f!==null;){var g=f.queue;g!==null&&(g.pending=null),f=f.next}Ry=!1}if(ic=0,$s=Rs=Jr=null,ef=!1,tf=0,G2.current=null,p===null||p.return===null){Ws=1,of=i,ks=null;break}e:{var x=a,k=p.return,N=p,E=i;if(i=ma,N.flags|=32768,E!==null&&typeof E=="object"&&typeof E.then=="function"){var z=E,G=N,j=G.tag;if(!(G.mode&1)&&(j===0||j===11||j===15)){var M=G.alternate;M?(G.updateQueue=M.updateQueue,G.memoizedState=M.memoizedState,G.lanes=M.lanes):(G.updateQueue=null,G.memoizedState=null)}var R=bz(k);if(R!==null){R.flags&=-257,vz(R,k,N,x,i),R.mode&1&&yz(x,z,i),i=R,E=z;var B=i.updateQueue;if(B===null){var P=new Set;P.add(E),i.updateQueue=P}else B.add(E);break e}else{if(!(i&1)){yz(x,z,i),J2();break e}E=Error(Ct(426))}}else if(Gr&&N.mode&1){var H=bz(k);if(H!==null){!(H.flags&65536)&&(H.flags|=256),vz(H,k,N,x,i),A2(Vd(E,N));break e}}x=E=Vd(E,N),Ws!==4&&(Ws=2),Af===null?Af=[x]:Af.push(x),x=k;do{switch(x.tag){case 3:x.flags|=65536,i&=-i,x.lanes|=i;var C=mz(x,E,i);VD(x,C);break e;case 1:N=E;var O=x.type,F=x.stateNode;if(!(x.flags&128)&&(typeof O.getDerivedStateFromError=="function"||F!==null&&typeof F.componentDidCatch=="function"&&(Vl===null||!Vl.has(F)))){x.flags|=65536,i&=-i,x.lanes|=i;var Y=gz(x,N,i);VD(x,Y);break e}}x=x.return}while(x!==null)}Jz(p)}catch(ae){i=ae,ks===p&&p!==null&&(ks=p=p.return);continue}break}while(!0)}function Kz(){var a=Uy.current;return Uy.current=Hy,a===null?Hy:a}function J2(){(Ws===0||Ws===3||Ws===2)&&(Ws=4),_s===null||!(Ac&268435455)&&!(Qy&268435455)||Yl(_s,ma)}function eb(a,i){var p=er;er|=2;var f=Kz();(_s!==a||ma!==i)&&(KA=null,uc(a,i));do try{dX();break}catch(g){Qz(a,g)}while(!0);if(u2(),er=p,Uy.current=f,ks!==null)throw Error(Ct(261));return _s=null,ma=0,Ws}function dX(){for(;ks!==null;)qz(ks)}function pX(){for(;ks!==null&&!RG();)qz(ks)}function qz(a){var i=eO(a.alternate,a,Wo);a.memoizedProps=a.pendingProps,i===null?Jz(a):ks=i,G2.current=null}function Jz(a){var i=a;do{var p=i.alternate;if(a=i.return,i.flags&32768){if(p=oX(p,i),p!==null){p.flags&=32767,ks=p;return}if(a!==null)a.flags|=32768,a.subtreeFlags=0,a.deletions=null;else{Ws=6,ks=null;return}}else if(p=aX(p,i,Wo),p!==null){ks=p;return}if(i=i.sibling,i!==null){ks=i;return}ks=i=a}while(i!==null);Ws===0&&(Ws=5)}function cc(a,i,p){var f=mr,g=li.transition;try{li.transition=null,mr=1,hX(a,i,p,f)}finally{li.transition=g,mr=f}return null}function hX(a,i,p,f){do Ud();while(Xl!==null);if(er&6)throw Error(Ct(327));p=a.finishedWork;var g=a.finishedLanes;if(p===null)return null;if(a.finishedWork=null,a.finishedLanes=0,p===a.current)throw Error(Ct(177));a.callbackNode=null,a.callbackPriority=0;var x=p.lanes|p.childLanes;if(QG(a,x),a===_s&&(ks=_s=null,ma=0),!(p.subtreeFlags&2064)&&!(p.flags&2064)||qy||(qy=!0,tO(sy,function(){return Ud(),null})),x=(p.flags&15990)!==0,p.subtreeFlags&15990||x){x=li.transition,li.transition=null;var k=mr;mr=1;var N=er;er|=4,G2.current=null,AX(a,p),Hz(p,a),PV(Jw),cy=!!qw,Jw=qw=null,a.current=p,lX(p),WG(),er=N,mr=k,li.transition=x}else a.current=p;if(qy&&(qy=!1,Xl=a,Jy=g),x=a.pendingLanes,x===0&&(Vl=null),GG(p.stateNode),fo(a,hs()),i!==null)for(f=a.onRecoverableError,p=0;p<i.length;p++)g=i[p],f(g.value,{componentStack:g.stack,digest:g.digest});if(Ky)throw Ky=!1,a=Z2,Z2=null,a;return Jy&1&&a.tag!==0&&Ud(),x=a.pendingLanes,x&1?a===Y2?lf++:(lf=0,Y2=a):lf=0,Wl(),null}function Ud(){if(Xl!==null){var a=WE(Jy),i=li.transition,p=mr;try{if(li.transition=null,mr=16>a?16:a,Xl===null)var f=!1;else{if(a=Xl,Xl=null,Jy=0,er&6)throw Error(Ct(331));var g=er;for(er|=4,Zt=a.current;Zt!==null;){var x=Zt,k=x.child;if(Zt.flags&16){var N=x.deletions;if(N!==null){for(var E=0;E<N.length;E++){var z=N[E];for(Zt=z;Zt!==null;){var G=Zt;switch(G.tag){case 0:case 11:case 15:af(8,G,x)}var j=G.child;if(j!==null)j.return=G,Zt=j;else for(;Zt!==null;){G=Zt;var M=G.sibling,R=G.return;if(Fz(G),G===z){Zt=null;break}if(M!==null){M.return=R,Zt=M;break}Zt=R}}}var B=x.alternate;if(B!==null){var P=B.child;if(P!==null){B.child=null;do{var H=P.sibling;P.sibling=null,P=H}while(P!==null)}}Zt=x}}if(x.subtreeFlags&2064&&k!==null)k.return=x,Zt=k;else e:for(;Zt!==null;){if(x=Zt,x.flags&2048)switch(x.tag){case 0:case 11:case 15:af(9,x,x.return)}var C=x.sibling;if(C!==null){C.return=x.return,Zt=C;break e}Zt=x.return}}var O=a.current;for(Zt=O;Zt!==null;){k=Zt;var F=k.child;if(k.subtreeFlags&2064&&F!==null)F.return=k,Zt=F;else e:for(k=O;Zt!==null;){if(N=Zt,N.flags&2048)try{switch(N.tag){case 0:case 11:case 15:Yy(9,N)}}catch(ae){rs(N,N.return,ae)}if(N===k){Zt=null;break e}var Y=N.sibling;if(Y!==null){Y.return=N.return,Zt=Y;break e}Zt=N.return}}if(er=g,Wl(),oA&&typeof oA.onPostCommitFiberRoot=="function")try{oA.onPostCommitFiberRoot(ay,a)}catch{}f=!0}return f}finally{mr=p,li.transition=i}}return!1}function $z(a,i,p){i=Vd(p,i),i=mz(a,i,1),a=Hl(a,i,1),i=Ka(),a!==null&&(zh(a,1,i),fo(a,i))}function rs(a,i,p){if(a.tag===3)$z(a,a,p);else for(;i!==null;){if(i.tag===3){$z(i,a,p);break}else if(i.tag===1){var f=i.stateNode;if(typeof i.type.getDerivedStateFromError=="function"||typeof f.componentDidCatch=="function"&&(Vl===null||!Vl.has(f))){a=Vd(p,a),a=gz(i,a,1),i=Hl(i,a,1),a=Ka(),i!==null&&(zh(i,1,a),fo(i,a));break}}i=i.return}}function fX(a,i,p){var f=a.pingCache;f!==null&&f.delete(i),i=Ka(),a.pingedLanes|=a.suspendedLanes&p,_s===a&&(ma&p)===p&&(Ws===4||Ws===3&&(ma&130023424)===ma&&500>hs()-X2?uc(a,0):V2|=p),fo(a,i)}function _z(a,i){i===0&&(a.mode&1?(i=iy,iy<<=1,!(iy&130023424)&&(iy=4194304)):i=1);var p=Ka();a=YA(a,i),a!==null&&(zh(a,i,p),fo(a,p))}function mX(a){var i=a.memoizedState,p=0;i!==null&&(p=i.retryLane),_z(a,p)}function gX(a,i){var p=0;switch(a.tag){case 13:var f=a.stateNode,g=a.memoizedState;g!==null&&(p=g.retryLane);break;case 19:f=a.stateNode;break;default:throw Error(Ct(314))}f!==null&&f.delete(i),_z(a,p)}var eO;eO=function(a,i,p){if(a!==null)if(a.memoizedProps!==i.pendingProps||uo.current)po=!0;else{if(!(a.lanes&p)&&!(i.flags&128))return po=!1,sX(a,i,p);po=!!(a.flags&131072)}else po=!1,Gr&&i.flags&1048576&&OD(i,My,i.index);switch(i.lanes=0,i.tag){case 2:var f=i.type;Xy(a,i),a=i.pendingProps;var g=Bd(i,Ta.current);Hd(i,p),g=x2(null,i,f,a,g,p);var x=w2();return i.flags|=1,typeof g=="object"&&g!==null&&typeof g.render=="function"&&g.$$typeof===void 0?(i.tag=1,i.memoizedState=null,i.updateQueue=null,co(f)?(x=!0,Sy(i)):x=!1,i.memoizedState=g.state!==null&&g.state!==void 0?g.state:null,h2(i),g.updater=Gy,i.stateNode=g,g._reactInternals=i,T2(i,f,a,p),i=z2(null,i,f,!0,x,p)):(i.tag=0,Gr&&x&&s2(i),Qa(null,i,g,p),i=i.child),i;case 16:f=i.elementType;e:{switch(Xy(a,i),a=i.pendingProps,g=f._init,f=g(f._payload),i.type=f,g=i.tag=bX(f),a=Bi(f,a),g){case 0:i=D2(null,i,f,a,p);break e;case 1:i=Sz(null,i,f,a,p);break e;case 11:i=xz(null,i,f,a,p);break e;case 14:i=wz(null,i,f,Bi(f.type,a),p);break e}throw Error(Ct(306,f,""))}return i;case 0:return f=i.type,g=i.pendingProps,g=i.elementType===f?g:Bi(f,g),D2(a,i,f,g,p);case 1:return f=i.type,g=i.pendingProps,g=i.elementType===f?g:Bi(f,g),Sz(a,i,f,g,p);case 3:e:{if(Nz(i),a===null)throw Error(Ct(387));f=i.pendingProps,x=i.memoizedState,g=x.element,GD(a,i),By(i,f,null,p);var k=i.memoizedState;if(f=k.element,x.isDehydrated)if(x={element:f,isDehydrated:!1,cache:k.cache,pendingSuspenseBoundaries:k.pendingSuspenseBoundaries,transitions:k.transitions},i.updateQueue.baseState=x,i.memoizedState=x,i.flags&256){g=Vd(Error(Ct(423)),i),i=Tz(a,i,f,p,g);break e}else if(f!==g){g=Vd(Error(Ct(424)),i),i=Tz(a,i,f,p,g);break e}else for(Ro=Fl(i.stateNode.containerInfo.firstChild),Lo=i,Gr=!0,Pi=null,p=jD(i,null,f,p),i.child=p;p;)p.flags=p.flags&-3|4096,p=p.sibling;else{if(Rd(),f===g){i=QA(a,i,p);break e}Qa(a,i,f,p)}i=i.child}return i;case 5:return ZD(i),a===null&&i2(i),f=i.type,g=i.pendingProps,x=a!==null?a.memoizedProps:null,k=g.children,$w(f,g)?k=null:x!==null&&$w(f,x)&&(i.flags|=32),Iz(a,i),Qa(a,i,k,p),i.child;case 6:return a===null&&i2(i),null;case 13:return Mz(a,i,p);case 4:return f2(i,i.stateNode.containerInfo),f=i.pendingProps,a===null?i.child=Wd(i,null,f,p):Qa(a,i,f,p),i.child;case 11:return f=i.type,g=i.pendingProps,g=i.elementType===f?g:Bi(f,g),xz(a,i,f,g,p);case 7:return Qa(a,i,i.pendingProps,p),i.child;case 8:return Qa(a,i,i.pendingProps.children,p),i.child;case 12:return Qa(a,i,i.pendingProps.children,p),i.child;case 10:e:{if(f=i.type._context,g=i.pendingProps,x=i.memoizedProps,k=g.value,Tr(zy,f._currentValue),f._currentValue=k,x!==null)if(Oi(x.value,k)){if(x.children===g.children&&!uo.current){i=QA(a,i,p);break e}}else for(x=i.child,x!==null&&(x.return=i);x!==null;){var N=x.dependencies;if(N!==null){k=x.child;for(var E=N.firstContext;E!==null;){if(E.context===f){if(x.tag===1){E=UA(-1,p&-p),E.tag=2;var z=x.updateQueue;if(z!==null){z=z.shared;var G=z.pending;G===null?E.next=E:(E.next=G.next,G.next=E),z.pending=E}}x.lanes|=p,E=x.alternate,E!==null&&(E.lanes|=p),d2(x.return,p,i),N.lanes|=p;break}E=E.next}}else if(x.tag===10)k=x.type===i.type?null:x.child;else if(x.tag===18){if(k=x.return,k===null)throw Error(Ct(341));k.lanes|=p,N=k.alternate,N!==null&&(N.lanes|=p),d2(k,p,i),k=x.sibling}else k=x.child;if(k!==null)k.return=x;else for(k=x;k!==null;){if(k===i){k=null;break}if(x=k.sibling,x!==null){x.return=k.return,k=x;break}k=k.return}x=k}Qa(a,i,g.children,p),i=i.child}return i;case 9:return g=i.type,f=i.pendingProps.children,Hd(i,p),g=ii(g),f=f(g),i.flags|=1,Qa(a,i,f,p),i.child;case 14:return f=i.type,g=Bi(f,i.pendingProps),g=Bi(f.type,g),wz(a,i,f,g,p);case 15:return kz(a,i,i.type,i.pendingProps,p);case 17:return f=i.type,g=i.pendingProps,g=i.elementType===f?g:Bi(f,g),Xy(a,i),i.tag=1,co(f)?(a=!0,Sy(i)):a=!1,Hd(i,p),hz(i,f,g),T2(i,f,g,p),z2(null,i,f,!0,a,p);case 19:return Dz(a,i,p);case 22:return Cz(a,i,p)}throw Error(Ct(156,i.tag))};function tO(a,i){return PE(a,i)}function yX(a,i,p,f){this.tag=a,this.key=p,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=i,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=f,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function ui(a,i,p,f){return new yX(a,i,p,f)}function $2(a){return a=a.prototype,!(!a||!a.isReactComponent)}function bX(a){if(typeof a=="function")return $2(a)?1:0;if(a!=null){if(a=a.$$typeof,a===sw)return 11;if(a===iw)return 14}return 2}function Ul(a,i){var p=a.alternate;return p===null?(p=ui(a.tag,i,a.key,a.mode),p.elementType=a.elementType,p.type=a.type,p.stateNode=a.stateNode,p.alternate=a,a.alternate=p):(p.pendingProps=i,p.type=a.type,p.flags=0,p.subtreeFlags=0,p.deletions=null),p.flags=a.flags&14680064,p.childLanes=a.childLanes,p.lanes=a.lanes,p.child=a.child,p.memoizedProps=a.memoizedProps,p.memoizedState=a.memoizedState,p.updateQueue=a.updateQueue,i=a.dependencies,p.dependencies=i===null?null:{lanes:i.lanes,firstContext:i.firstContext},p.sibling=a.sibling,p.index=a.index,p.ref=a.ref,p}function tb(a,i,p,f,g,x){var k=2;if(f=a,typeof a=="function")$2(a)&&(k=1);else if(typeof a=="string")k=5;else e:switch(a){case wd:return dc(p.children,g,x,i);case nw:k=8,g|=8;break;case rw:return a=ui(12,p,i,g|2),a.elementType=rw,a.lanes=x,a;case aw:return a=ui(13,p,i,g),a.elementType=aw,a.lanes=x,a;case ow:return a=ui(19,p,i,g),a.elementType=ow,a.lanes=x,a;case uE:return nb(p,g,x,i);default:if(typeof a=="object"&&a!==null)switch(a.$$typeof){case AE:k=10;break e;case lE:k=9;break e;case sw:k=11;break e;case iw:k=14;break e;case Tl:k=16,f=null;break e}throw Error(Ct(130,a==null?a:typeof a,""))}return i=ui(k,p,i,g),i.elementType=a,i.type=f,i.lanes=x,i}function dc(a,i,p,f){return a=ui(7,a,f,i),a.lanes=p,a}function nb(a,i,p,f){return a=ui(22,a,f,i),a.elementType=uE,a.lanes=p,a.stateNode={isHidden:!1},a}function _2(a,i,p){return a=ui(6,a,null,i),a.lanes=p,a}function ek(a,i,p){return i=ui(4,a.children!==null?a.children:[],a.key,i),i.lanes=p,i.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation},i}function vX(a,i,p,f,g){this.tag=i,this.containerInfo=a,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=Nw(0),this.expirationTimes=Nw(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Nw(0),this.identifierPrefix=f,this.onRecoverableError=g,this.mutableSourceEagerHydrationData=null}function tk(a,i,p,f,g,x,k,N,E){return a=new vX(a,i,p,N,E),i===1?(i=1,x===!0&&(i|=8)):i=0,x=ui(3,null,null,i),a.current=x,x.stateNode=a,x.memoizedState={element:f,isDehydrated:p,cache:null,transitions:null,pendingSuspenseBoundaries:null},h2(x),a}function xX(a,i,p){var f=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:xd,key:f==null?null:""+f,children:a,containerInfo:i,implementation:p}}function nO(a){if(!a)return Rl;a=a._reactInternals;e:{if(ec(a)!==a||a.tag!==1)throw Error(Ct(170));var i=a;do{switch(i.tag){case 3:i=i.stateNode.context;break e;case 1:if(co(i.type)){i=i.stateNode.__reactInternalMemoizedMergedChildContext;break e}}i=i.return}while(i!==null);throw Error(Ct(171))}if(a.tag===1){var p=a.type;if(co(p))return ED(a,p,i)}return i}function rO(a,i,p,f,g,x,k,N,E){return a=tk(p,f,!0,a,g,x,k,N,E),a.context=nO(null),p=a.current,f=Ka(),g=Zl(p),x=UA(f,g),x.callback=i??null,Hl(p,x,g),a.current.lanes=g,zh(a,g,f),fo(a,f),a}function rb(a,i,p,f){var g=i.current,x=Ka(),k=Zl(g);return p=nO(p),i.context===null?i.context=p:i.pendingContext=p,i=UA(x,k),i.payload={element:a},f=f===void 0?null:f,f!==null&&(i.callback=f),a=Hl(g,i,k),a!==null&&(Ri(a,g,k,x),Py(a,g,k)),k}function sb(a){if(a=a.current,!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function sO(a,i){if(a=a.memoizedState,a!==null&&a.dehydrated!==null){var p=a.retryLane;a.retryLane=p!==0&&p<i?p:i}}function nk(a,i){sO(a,i),(a=a.alternate)&&sO(a,i)}function wX(){return null}var aO=typeof reportError=="function"?reportError:function(a){console.error(a)};function rk(a){this._internalRoot=a}ab.prototype.render=rk.prototype.render=function(a){var i=this._internalRoot;if(i===null)throw Error(Ct(409));rb(a,i,null,null)},ab.prototype.unmount=rk.prototype.unmount=function(){var a=this._internalRoot;if(a!==null){this._internalRoot=null;var i=a.containerInfo;lc(function(){rb(null,a,null,null)}),i[GA]=null}};function ab(a){this._internalRoot=a}ab.prototype.unstable_scheduleHydration=function(a){if(a){var i=GE();a={blockedOn:null,target:a,priority:i};for(var p=0;p<Ol.length&&i!==0&&i<Ol[p].priority;p++);Ol.splice(p,0,a),p===0&&ZE(a)}};function sk(a){return!(!a||a.nodeType!==1&&a.nodeType!==9&&a.nodeType!==11)}function ob(a){return!(!a||a.nodeType!==1&&a.nodeType!==9&&a.nodeType!==11&&(a.nodeType!==8||a.nodeValue!==" react-mount-point-unstable "))}function oO(){}function kX(a,i,p,f,g){if(g){if(typeof f=="function"){var x=f;f=function(){var z=sb(k);x.call(z)}}var k=rO(i,f,a,0,null,!1,!1,"",oO);return a._reactRootContainer=k,a[GA]=k.current,Yh(a.nodeType===8?a.parentNode:a),lc(),k}for(;g=a.lastChild;)a.removeChild(g);if(typeof f=="function"){var N=f;f=function(){var z=sb(E);N.call(z)}}var E=tk(a,0,!1,null,null,!1,!1,"",oO);return a._reactRootContainer=E,a[GA]=E.current,Yh(a.nodeType===8?a.parentNode:a),lc(function(){rb(i,E,p,f)}),E}function ib(a,i,p,f,g){var x=p._reactRootContainer;if(x){var k=x;if(typeof g=="function"){var N=g;g=function(){var E=sb(k);N.call(E)}}rb(i,k,a,g)}else k=kX(p,i,a,g,f);return sb(k)}jE=function(a){switch(a.tag){case 3:var i=a.stateNode;if(i.current.memoizedState.isDehydrated){var p=Dh(i.pendingLanes);p!==0&&(Tw(i,p|1),fo(i,hs()),!(er&6)&&(Yd=hs()+500,Wl()))}break;case 13:lc(function(){var f=YA(a,1);if(f!==null){var g=Ka();Ri(f,a,1,g)}}),nk(a,1)}},Mw=function(a){if(a.tag===13){var i=YA(a,134217728);if(i!==null){var p=Ka();Ri(i,a,134217728,p)}nk(a,134217728)}},HE=function(a){if(a.tag===13){var i=Zl(a),p=YA(a,i);if(p!==null){var f=Ka();Ri(p,a,i,f)}nk(a,i)}},GE=function(){return mr},VE=function(a,i){var p=mr;try{return mr=a,i()}finally{mr=p}},xw=function(a,i,p){switch(i){case"input":if(pw(a,p),i=p.name,p.type==="radio"&&i!=null){for(p=a;p.parentNode;)p=p.parentNode;for(p=p.querySelectorAll("input[name="+JSON.stringify(""+i)+'][type="radio"]'),i=0;i<p.length;i++){var f=p[i];if(f!==a&&f.form===a.form){var g=Cy(f);if(!g)throw Error(Ct(90));pE(f),pw(f,g)}}}break;case"textarea":yE(a,p);break;case"select":i=p.value,i!=null&&kd(a,!!p.multiple,i,!1)}},NE=K2,TE=lc;var CX={usingClientEntryPoint:!1,Events:[Kh,Od,Cy,IE,SE,K2]},uf={findFiberByHostInstance:tc,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},IX={bundleType:uf.bundleType,version:uf.version,rendererPackageName:uf.rendererPackageName,rendererConfig:uf.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:HA.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){return a=zE(a),a===null?null:a.stateNode},findFiberByHostInstance:uf.findFiberByHostInstance||wX,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Ab=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Ab.isDisabled&&Ab.supportsFiber)try{ay=Ab.inject(IX),oA=Ab}catch{}}Po.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=CX,Po.createPortal=function(a,i){var p=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!sk(i))throw Error(Ct(200));return xX(a,i,null,p)},Po.createRoot=function(a,i){if(!sk(a))throw Error(Ct(299));var p=!1,f="",g=aO;return i!=null&&(i.unstable_strictMode===!0&&(p=!0),i.identifierPrefix!==void 0&&(f=i.identifierPrefix),i.onRecoverableError!==void 0&&(g=i.onRecoverableError)),i=tk(a,1,!1,null,null,p,!1,f,g),a[GA]=i.current,Yh(a.nodeType===8?a.parentNode:a),new rk(i)},Po.findDOMNode=function(a){if(a==null)return null;if(a.nodeType===1)return a;var i=a._reactInternals;if(i===void 0)throw typeof a.render=="function"?Error(Ct(188)):(a=Object.keys(a).join(","),Error(Ct(268,a)));return a=zE(i),a=a===null?null:a.stateNode,a},Po.flushSync=function(a){return lc(a)},Po.hydrate=function(a,i,p){if(!ob(i))throw Error(Ct(200));return ib(null,a,i,!0,p)},Po.hydrateRoot=function(a,i,p){if(!sk(a))throw Error(Ct(405));var f=p!=null&&p.hydratedSources||null,g=!1,x="",k=aO;if(p!=null&&(p.unstable_strictMode===!0&&(g=!0),p.identifierPrefix!==void 0&&(x=p.identifierPrefix),p.onRecoverableError!==void 0&&(k=p.onRecoverableError)),i=rO(i,null,a,1,p??null,g,!1,x,k),a[GA]=i.current,Yh(a),f)for(a=0;a<f.length;a++)p=f[a],g=p._getVersion,g=g(p._source),i.mutableSourceEagerHydrationData==null?i.mutableSourceEagerHydrationData=[p,g]:i.mutableSourceEagerHydrationData.push(p,g);return new ab(i)},Po.render=function(a,i,p){if(!ob(i))throw Error(Ct(200));return ib(null,a,i,!1,p)},Po.unmountComponentAtNode=function(a){if(!ob(a))throw Error(Ct(40));return a._reactRootContainer?(lc(function(){ib(null,null,a,!1,function(){a._reactRootContainer=null,a[GA]=null})}),!0):!1},Po.unstable_batchedUpdates=K2,Po.unstable_renderSubtreeIntoContainer=function(a,i,p,f){if(!ob(p))throw Error(Ct(200));if(a==null||a._reactInternals===void 0)throw Error(Ct(38));return ib(a,i,p,!1,f)},Po.version="18.3.1-next-f1338f8080-20240426";function iO(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(iO)}catch(a){console.error(a)}}iO(),nE.exports=Po;var ak=nE.exports;const lb=Qr(ak);var AO,lO=ak;AO=lO.createRoot,lO.hydrateRoot;const cf={black:"#000",white:"#fff"},Qd={50:"#ffebee",100:"#ffcdd2",200:"#ef9a9a",300:"#e57373",400:"#ef5350",500:"#f44336",600:"#e53935",700:"#d32f2f",800:"#c62828",900:"#b71c1c",A100:"#ff8a80",A200:"#ff5252",A400:"#ff1744",A700:"#d50000"},Kd={50:"#f3e5f5",100:"#e1bee7",200:"#ce93d8",300:"#ba68c8",400:"#ab47bc",500:"#9c27b0",600:"#8e24aa",700:"#7b1fa2",800:"#6a1b9a",900:"#4a148c",A100:"#ea80fc",A200:"#e040fb",A400:"#d500f9",A700:"#aa00ff"},qd={50:"#e3f2fd",100:"#bbdefb",200:"#90caf9",300:"#64b5f6",400:"#42a5f5",500:"#2196f3",600:"#1e88e5",700:"#1976d2",800:"#1565c0",900:"#0d47a1",A100:"#82b1ff",A200:"#448aff",A400:"#2979ff",A700:"#2962ff"},Jd={50:"#e1f5fe",100:"#b3e5fc",200:"#81d4fa",300:"#4fc3f7",400:"#29b6f6",500:"#03a9f4",600:"#039be5",700:"#0288d1",800:"#0277bd",900:"#01579b",A100:"#80d8ff",A200:"#40c4ff",A400:"#00b0ff",A700:"#0091ea"},$d={50:"#e8f5e9",100:"#c8e6c9",200:"#a5d6a7",300:"#81c784",400:"#66bb6a",500:"#4caf50",600:"#43a047",700:"#388e3c",800:"#2e7d32",900:"#1b5e20",A100:"#b9f6ca",A200:"#69f0ae",A400:"#00e676",A700:"#00c853"},df={50:"#fff3e0",100:"#ffe0b2",200:"#ffcc80",300:"#ffb74d",400:"#ffa726",500:"#ff9800",600:"#fb8c00",700:"#f57c00",800:"#ef6c00",900:"#e65100",A100:"#ffd180",A200:"#ffab40",A400:"#ff9100",A700:"#ff6d00"},SX={50:"#fafafa",100:"#f5f5f5",200:"#eeeeee",300:"#e0e0e0",400:"#bdbdbd",500:"#9e9e9e",600:"#757575",700:"#616161",800:"#424242",900:"#212121",A100:"#f5f5f5",A200:"#eeeeee",A400:"#bdbdbd",A700:"#616161"};function qA(a,...i){const p=new URL(`https://mui.com/production-error/?code=${a}`);return i.forEach(f=>p.searchParams.append("args[]",f)),`Minified MUI error #${a}; visit ${p} for the full message.`}const Wi="$$material";function ub(){return ub=Object.assign?Object.assign.bind():function(a){for(var i=1;i<arguments.length;i++){var p=arguments[i];for(var f in p)({}).hasOwnProperty.call(p,f)&&(a[f]=p[f])}return a},ub.apply(null,arguments)}function uO(a){var i=Object.create(null);return function(p){return i[p]===void 0&&(i[p]=a(p)),i[p]}}var NX=/^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,TX=uO(function(a){return NX.test(a)||a.charCodeAt(0)===111&&a.charCodeAt(1)===110&&a.charCodeAt(2)<91}),MX=!1;function EX(a){if(a.sheet)return a.sheet;for(var i=0;i<document.styleSheets.length;i++)if(document.styleSheets[i].ownerNode===a)return document.styleSheets[i]}function DX(a){var i=document.createElement("style");return i.setAttribute("data-emotion",a.key),a.nonce!==void 0&&i.setAttribute("nonce",a.nonce),i.appendChild(document.createTextNode("")),i.setAttribute("data-s",""),i}var zX=function(){function a(p){var f=this;this._insertTag=function(g){var x;f.tags.length===0?f.insertionPoint?x=f.insertionPoint.nextSibling:f.prepend?x=f.container.firstChild:x=f.before:x=f.tags[f.tags.length-1].nextSibling,f.container.insertBefore(g,x),f.tags.push(g)},this.isSpeedy=p.speedy===void 0?!MX:p.speedy,this.tags=[],this.ctr=0,this.nonce=p.nonce,this.key=p.key,this.container=p.container,this.prepend=p.prepend,this.insertionPoint=p.insertionPoint,this.before=null}var i=a.prototype;return i.hydrate=function(f){f.forEach(this._insertTag)},i.insert=function(f){this.ctr%(this.isSpeedy?65e3:1)===0&&this._insertTag(DX(this));var g=this.tags[this.tags.length-1];if(this.isSpeedy){var x=EX(g);try{x.insertRule(f,x.cssRules.length)}catch{}}else g.appendChild(document.createTextNode(f));this.ctr++},i.flush=function(){this.tags.forEach(function(f){var g;return(g=f.parentNode)==null?void 0:g.removeChild(f)}),this.tags=[],this.ctr=0},a}(),za="-ms-",cb="-moz-",Ar="-webkit-",cO="comm",ok="rule",ik="decl",OX="@import",dO="@keyframes",PX="@layer",BX=Math.abs,db=String.fromCharCode,FX=Object.assign;function LX(a,i){return ga(a,0)^45?(((i<<2^ga(a,0))<<2^ga(a,1))<<2^ga(a,2))<<2^ga(a,3):0}function pO(a){return a.trim()}function RX(a,i){return(a=i.exec(a))?a[0]:a}function lr(a,i,p){return a.replace(i,p)}function Ak(a,i){return a.indexOf(i)}function ga(a,i){return a.charCodeAt(i)|0}function pf(a,i,p){return a.slice(i,p)}function cA(a){return a.length}function lk(a){return a.length}function pb(a,i){return i.push(a),a}function WX(a,i){return a.map(i).join("")}var hb=1,_d=1,hO=0,mo=0,Cs=0,ep="";function fb(a,i,p,f,g,x,k){return{value:a,root:i,parent:p,type:f,props:g,children:x,line:hb,column:_d,length:k,return:""}}function hf(a,i){return FX(fb("",null,null,"",null,null,0),a,{length:-a.length},i)}function jX(){return Cs}function HX(){return Cs=mo>0?ga(ep,--mo):0,_d--,Cs===10&&(_d=1,hb--),Cs}function jo(){return Cs=mo<hO?ga(ep,mo++):0,_d++,Cs===10&&(_d=1,hb++),Cs}function dA(){return ga(ep,mo)}function mb(){return mo}function ff(a,i){return pf(ep,a,i)}function mf(a){switch(a){case 0:case 9:case 10:case 13:case 32:return 5;case 33:case 43:case 44:case 47:case 62:case 64:case 126:case 59:case 123:case 125:return 4;case 58:return 3;case 34:case 39:case 40:case 91:return 2;case 41:case 93:return 1}return 0}function fO(a){return hb=_d=1,hO=cA(ep=a),mo=0,[]}function mO(a){return ep="",a}function gb(a){return pO(ff(mo-1,uk(a===91?a+2:a===40?a+1:a)))}function GX(a){for(;(Cs=dA())&&Cs<33;)jo();return mf(a)>2||mf(Cs)>3?"":" "}function VX(a,i){for(;--i&&jo()&&!(Cs<48||Cs>102||Cs>57&&Cs<65||Cs>70&&Cs<97););return ff(a,mb()+(i<6&&dA()==32&&jo()==32))}function uk(a){for(;jo();)switch(Cs){case a:return mo;case 34:case 39:a!==34&&a!==39&&uk(Cs);break;case 40:a===41&&uk(a);break;case 92:jo();break}return mo}function XX(a,i){for(;jo()&&a+Cs!==57;)if(a+Cs===84&&dA()===47)break;return"/*"+ff(i,mo-1)+"*"+db(a===47?a:jo())}function ZX(a){for(;!mf(dA());)jo();return ff(a,mo)}function YX(a){return mO(yb("",null,null,null,[""],a=fO(a),0,[0],a))}function yb(a,i,p,f,g,x,k,N,E){for(var z=0,G=0,j=k,M=0,R=0,B=0,P=1,H=1,C=1,O=0,F="",Y=g,ae=x,te=f,oe=F;H;)switch(B=O,O=jo()){case 40:if(B!=108&&ga(oe,j-1)==58){Ak(oe+=lr(gb(O),"&","&\f"),"&\f")!=-1&&(C=-1);break}case 34:case 39:case 91:oe+=gb(O);break;case 9:case 10:case 13:case 32:oe+=GX(B);break;case 92:oe+=VX(mb()-1,7);continue;case 47:switch(dA()){case 42:case 47:pb(UX(XX(jo(),mb()),i,p),E);break;default:oe+="/"}break;case 123*P:N[z++]=cA(oe)*C;case 125*P:case 59:case 0:switch(O){case 0:case 125:H=0;case 59+G:C==-1&&(oe=lr(oe,/\f/g,"")),R>0&&cA(oe)-j&&pb(R>32?yO(oe+";",f,p,j-1):yO(lr(oe," ","")+";",f,p,j-2),E);break;case 59:oe+=";";default:if(pb(te=gO(oe,i,p,z,G,g,N,F,Y=[],ae=[],j),x),O===123)if(G===0)yb(oe,i,te,te,Y,x,j,N,ae);else switch(M===99&&ga(oe,3)===110?100:M){case 100:case 108:case 109:case 115:yb(a,te,te,f&&pb(gO(a,te,te,0,0,g,N,F,g,Y=[],j),ae),g,ae,j,N,f?Y:ae);break;default:yb(oe,te,te,te,[""],ae,0,N,ae)}}z=G=R=0,P=C=1,F=oe="",j=k;break;case 58:j=1+cA(oe),R=B;default:if(P<1){if(O==123)--P;else if(O==125&&P++==0&&HX()==125)continue}switch(oe+=db(O),O*P){case 38:C=G>0?1:(oe+="\f",-1);break;case 44:N[z++]=(cA(oe)-1)*C,C=1;break;case 64:dA()===45&&(oe+=gb(jo())),M=dA(),G=j=cA(F=oe+=ZX(mb())),O++;break;case 45:B===45&&cA(oe)==2&&(P=0)}}return x}function gO(a,i,p,f,g,x,k,N,E,z,G){for(var j=g-1,M=g===0?x:[""],R=lk(M),B=0,P=0,H=0;B<f;++B)for(var C=0,O=pf(a,j+1,j=BX(P=k[B])),F=a;C<R;++C)(F=pO(P>0?M[C]+" "+O:lr(O,/&\f/g,M[C])))&&(E[H++]=F);return fb(a,i,p,g===0?ok:N,E,z,G)}function UX(a,i,p){return fb(a,i,p,cO,db(jX()),pf(a,2,-2),0)}function yO(a,i,p,f){return fb(a,i,p,ik,pf(a,0,f),pf(a,f+1,-1),f)}function tp(a,i){for(var p="",f=lk(a),g=0;g<f;g++)p+=i(a[g],g,a,i)||"";return p}function QX(a,i,p,f){switch(a.type){case PX:if(a.children.length)break;case OX:case ik:return a.return=a.return||a.value;case cO:return"";case dO:return a.return=a.value+"{"+tp(a.children,f)+"}";case ok:a.value=a.props.join(",")}return cA(p=tp(a.children,f))?a.return=a.value+"{"+p+"}":""}function KX(a){var i=lk(a);return function(p,f,g,x){for(var k="",N=0;N<i;N++)k+=a[N](p,f,g,x)||"";return k}}function qX(a){return function(i){i.root||(i=i.return)&&a(i)}}var JX=function(i,p,f){for(var g=0,x=0;g=x,x=dA(),g===38&&x===12&&(p[f]=1),!mf(x);)jo();return ff(i,mo)},$X=function(i,p){var f=-1,g=44;do switch(mf(g)){case 0:g===38&&dA()===12&&(p[f]=1),i[f]+=JX(mo-1,p,f);break;case 2:i[f]+=gb(g);break;case 4:if(g===44){i[++f]=dA()===58?"&\f":"",p[f]=i[f].length;break}default:i[f]+=db(g)}while(g=jo());return i},_X=function(i,p){return mO($X(fO(i),p))},bO=new WeakMap,eZ=function(i){if(!(i.type!=="rule"||!i.parent||i.length<1)){for(var p=i.value,f=i.parent,g=i.column===f.column&&i.line===f.line;f.type!=="rule";)if(f=f.parent,!f)return;if(!(i.props.length===1&&p.charCodeAt(0)!==58&&!bO.get(f))&&!g){bO.set(i,!0);for(var x=[],k=_X(p,x),N=f.props,E=0,z=0;E<k.length;E++)for(var G=0;G<N.length;G++,z++)i.props[z]=x[E]?k[E].replace(/&\f/g,N[G]):N[G]+" "+k[E]}}},tZ=function(i){if(i.type==="decl"){var p=i.value;p.charCodeAt(0)===108&&p.charCodeAt(2)===98&&(i.return="",i.value="")}};function vO(a,i){switch(LX(a,i)){case 5103:return Ar+"print-"+a+a;case 5737:case 4201:case 3177:case 3433:case 1641:case 4457:case 2921:case 5572:case 6356:case 5844:case 3191:case 6645:case 3005:case 6391:case 5879:case 5623:case 6135:case 4599:case 4855:case 4215:case 6389:case 5109:case 5365:case 5621:case 3829:return Ar+a+a;case 5349:case 4246:case 4810:case 6968:case 2756:return Ar+a+cb+a+za+a+a;case 6828:case 4268:return Ar+a+za+a+a;case 6165:return Ar+a+za+"flex-"+a+a;case 5187:return Ar+a+lr(a,/(\w+).+(:[^]+)/,Ar+"box-$1$2"+za+"flex-$1$2")+a;case 5443:return Ar+a+za+"flex-item-"+lr(a,/flex-|-self/,"")+a;case 4675:return Ar+a+za+"flex-line-pack"+lr(a,/align-content|flex-|-self/,"")+a;case 5548:return Ar+a+za+lr(a,"shrink","negative")+a;case 5292:return Ar+a+za+lr(a,"basis","preferred-size")+a;case 6060:return Ar+"box-"+lr(a,"-grow","")+Ar+a+za+lr(a,"grow","positive")+a;case 4554:return Ar+lr(a,/([^-])(transform)/g,"$1"+Ar+"$2")+a;case 6187:return lr(lr(lr(a,/(zoom-|grab)/,Ar+"$1"),/(image-set)/,Ar+"$1"),a,"")+a;case 5495:case 3959:return lr(a,/(image-set\([^]*)/,Ar+"$1$`$1");case 4968:return lr(lr(a,/(.+:)(flex-)?(.*)/,Ar+"box-pack:$3"+za+"flex-pack:$3"),/s.+-b[^;]+/,"justify")+Ar+a+a;case 4095:case 3583:case 4068:case 2532:return lr(a,/(.+)-inline(.+)/,Ar+"$1$2")+a;case 8116:case 7059:case 5753:case 5535:case 5445:case 5701:case 4933:case 4677:case 5533:case 5789:case 5021:case 4765:if(cA(a)-1-i>6)switch(ga(a,i+1)){case 109:if(ga(a,i+4)!==45)break;case 102:return lr(a,/(.+:)(.+)-([^]+)/,"$1"+Ar+"$2-$3$1"+cb+(ga(a,i+3)==108?"$3":"$2-$3"))+a;case 115:return~Ak(a,"stretch")?vO(lr(a,"stretch","fill-available"),i)+a:a}break;case 4949:if(ga(a,i+1)!==115)break;case 6444:switch(ga(a,cA(a)-3-(~Ak(a,"!important")&&10))){case 107:return lr(a,":",":"+Ar)+a;case 101:return lr(a,/(.+:)([^;!]+)(;|!.+)?/,"$1"+Ar+(ga(a,14)===45?"inline-":"")+"box$3$1"+Ar+"$2$3$1"+za+"$2box$3")+a}break;case 5936:switch(ga(a,i+11)){case 114:return Ar+a+za+lr(a,/[svh]\w+-[tblr]{2}/,"tb")+a;case 108:return Ar+a+za+lr(a,/[svh]\w+-[tblr]{2}/,"tb-rl")+a;case 45:return Ar+a+za+lr(a,/[svh]\w+-[tblr]{2}/,"lr")+a}return Ar+a+za+a+a}return a}var nZ=function(i,p,f,g){if(i.length>-1&&!i.return)switch(i.type){case ik:i.return=vO(i.value,i.length);break;case dO:return tp([hf(i,{value:lr(i.value,"@","@"+Ar)})],g);case ok:if(i.length)return WX(i.props,function(x){switch(RX(x,/(::plac\w+|:read-\w+)/)){case":read-only":case":read-write":return tp([hf(i,{props:[lr(x,/:(read-\w+)/,":"+cb+"$1")]})],g);case"::placeholder":return tp([hf(i,{props:[lr(x,/:(plac\w+)/,":"+Ar+"input-$1")]}),hf(i,{props:[lr(x,/:(plac\w+)/,":"+cb+"$1")]}),hf(i,{props:[lr(x,/:(plac\w+)/,za+"input-$1")]})],g)}return""})}},rZ=[nZ],sZ=function(i){var p=i.key;if(p==="css"){var f=document.querySelectorAll("style[data-emotion]:not([data-s])");Array.prototype.forEach.call(f,function(P){var H=P.getAttribute("data-emotion");H.indexOf(" ")!==-1&&(document.head.appendChild(P),P.setAttribute("data-s",""))})}var g=i.stylisPlugins||rZ,x={},k,N=[];k=i.container||document.head,Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="'+p+' "]'),function(P){for(var H=P.getAttribute("data-emotion").split(" "),C=1;C<H.length;C++)x[H[C]]=!0;N.push(P)});var E,z=[eZ,tZ];{var G,j=[QX,qX(function(P){G.insert(P)})],M=KX(z.concat(g,j)),R=function(H){return tp(YX(H),M)};E=function(H,C,O,F){G=O,R(H?H+"{"+C.styles+"}":C.styles),F&&(B.inserted[C.name]=!0)}}var B={key:p,sheet:new zX({key:p,container:k,nonce:i.nonce,speedy:i.speedy,prepend:i.prepend,insertionPoint:i.insertionPoint}),nonce:i.nonce,inserted:x,registered:{},insert:E};return B.sheet.hydrate(N),B},xO={exports:{}},gr={};/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var ea=typeof Symbol=="function"&&Symbol.for,ck=ea?Symbol.for("react.element"):60103,dk=ea?Symbol.for("react.portal"):60106,bb=ea?Symbol.for("react.fragment"):60107,vb=ea?Symbol.for("react.strict_mode"):60108,xb=ea?Symbol.for("react.profiler"):60114,wb=ea?Symbol.for("react.provider"):60109,kb=ea?Symbol.for("react.context"):60110,pk=ea?Symbol.for("react.async_mode"):60111,Cb=ea?Symbol.for("react.concurrent_mode"):60111,Ib=ea?Symbol.for("react.forward_ref"):60112,Sb=ea?Symbol.for("react.suspense"):60113,aZ=ea?Symbol.for("react.suspense_list"):60120,Nb=ea?Symbol.for("react.memo"):60115,Tb=ea?Symbol.for("react.lazy"):60116,oZ=ea?Symbol.for("react.block"):60121,iZ=ea?Symbol.for("react.fundamental"):60117,AZ=ea?Symbol.for("react.responder"):60118,lZ=ea?Symbol.for("react.scope"):60119;function Ho(a){if(typeof a=="object"&&a!==null){var i=a.$$typeof;switch(i){case ck:switch(a=a.type,a){case pk:case Cb:case bb:case xb:case vb:case Sb:return a;default:switch(a=a&&a.$$typeof,a){case kb:case Ib:case Tb:case Nb:case wb:return a;default:return i}}case dk:return i}}}function wO(a){return Ho(a)===Cb}gr.AsyncMode=pk,gr.ConcurrentMode=Cb,gr.ContextConsumer=kb,gr.ContextProvider=wb,gr.Element=ck,gr.ForwardRef=Ib,gr.Fragment=bb,gr.Lazy=Tb,gr.Memo=Nb,gr.Portal=dk,gr.Profiler=xb,gr.StrictMode=vb,gr.Suspense=Sb,gr.isAsyncMode=function(a){return wO(a)||Ho(a)===pk},gr.isConcurrentMode=wO,gr.isContextConsumer=function(a){return Ho(a)===kb},gr.isContextProvider=function(a){return Ho(a)===wb},gr.isElement=function(a){return typeof a=="object"&&a!==null&&a.$$typeof===ck},gr.isForwardRef=function(a){return Ho(a)===Ib},gr.isFragment=function(a){return Ho(a)===bb},gr.isLazy=function(a){return Ho(a)===Tb},gr.isMemo=function(a){return Ho(a)===Nb},gr.isPortal=function(a){return Ho(a)===dk},gr.isProfiler=function(a){return Ho(a)===xb},gr.isStrictMode=function(a){return Ho(a)===vb},gr.isSuspense=function(a){return Ho(a)===Sb},gr.isValidElementType=function(a){return typeof a=="string"||typeof a=="function"||a===bb||a===Cb||a===xb||a===vb||a===Sb||a===aZ||typeof a=="object"&&a!==null&&(a.$$typeof===Tb||a.$$typeof===Nb||a.$$typeof===wb||a.$$typeof===kb||a.$$typeof===Ib||a.$$typeof===iZ||a.$$typeof===AZ||a.$$typeof===lZ||a.$$typeof===oZ)},gr.typeOf=Ho,xO.exports=gr;var uZ=xO.exports,kO=uZ,cZ={$$typeof:!0,render:!0,defaultProps:!0,displayName:!0,propTypes:!0},dZ={$$typeof:!0,compare:!0,defaultProps:!0,displayName:!0,propTypes:!0,type:!0},CO={};CO[kO.ForwardRef]=cZ,CO[kO.Memo]=dZ;var pZ=!0;function hZ(a,i,p){var f="";return p.split(" ").forEach(function(g){a[g]!==void 0?i.push(a[g]+";"):g&&(f+=g+" ")}),f}var IO=function(i,p,f){var g=i.key+"-"+p.name;(f===!1||pZ===!1)&&i.registered[g]===void 0&&(i.registered[g]=p.styles)},SO=function(i,p,f){IO(i,p,f);var g=i.key+"-"+p.name;if(i.inserted[p.name]===void 0){var x=p;do i.insert(p===x?"."+g:"",x,i.sheet,!0),x=x.next;while(x!==void 0)}};function fZ(a){for(var i=0,p,f=0,g=a.length;g>=4;++f,g-=4)p=a.charCodeAt(f)&255|(a.charCodeAt(++f)&255)<<8|(a.charCodeAt(++f)&255)<<16|(a.charCodeAt(++f)&255)<<24,p=(p&65535)*1540483477+((p>>>16)*59797<<16),p^=p>>>24,i=(p&65535)*1540483477+((p>>>16)*59797<<16)^(i&65535)*1540483477+((i>>>16)*59797<<16);switch(g){case 3:i^=(a.charCodeAt(f+2)&255)<<16;case 2:i^=(a.charCodeAt(f+1)&255)<<8;case 1:i^=a.charCodeAt(f)&255,i=(i&65535)*1540483477+((i>>>16)*59797<<16)}return i^=i>>>13,i=(i&65535)*1540483477+((i>>>16)*59797<<16),((i^i>>>15)>>>0).toString(36)}var mZ={animationIterationCount:1,aspectRatio:1,borderImageOutset:1,borderImageSlice:1,borderImageWidth:1,boxFlex:1,boxFlexGroup:1,boxOrdinalGroup:1,columnCount:1,columns:1,flex:1,flexGrow:1,flexPositive:1,flexShrink:1,flexNegative:1,flexOrder:1,gridRow:1,gridRowEnd:1,gridRowSpan:1,gridRowStart:1,gridColumn:1,gridColumnEnd:1,gridColumnSpan:1,gridColumnStart:1,msGridRow:1,msGridRowSpan:1,msGridColumn:1,msGridColumnSpan:1,fontWeight:1,lineHeight:1,opacity:1,order:1,orphans:1,scale:1,tabSize:1,widows:1,zIndex:1,zoom:1,WebkitLineClamp:1,fillOpacity:1,floodOpacity:1,stopOpacity:1,strokeDasharray:1,strokeDashoffset:1,strokeMiterlimit:1,strokeOpacity:1,strokeWidth:1},gZ=!1,yZ=/[A-Z]|^ms/g,bZ=/_EMO_([^_]+?)_([^]*?)_EMO_/g,NO=function(i){return i.charCodeAt(1)===45},TO=function(i){return i!=null&&typeof i!="boolean"},hk=uO(function(a){return NO(a)?a:a.replace(yZ,"-$&").toLowerCase()}),MO=function(i,p){switch(i){case"animation":case"animationName":if(typeof p=="string")return p.replace(bZ,function(f,g,x){return pA={name:g,styles:x,next:pA},g})}return mZ[i]!==1&&!NO(i)&&typeof p=="number"&&p!==0?p+"px":p},vZ="Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";function gf(a,i,p){if(p==null)return"";var f=p;if(f.__emotion_styles!==void 0)return f;switch(typeof p){case"boolean":return"";case"object":{var g=p;if(g.anim===1)return pA={name:g.name,styles:g.styles,next:pA},g.name;var x=p;if(x.styles!==void 0){var k=x.next;if(k!==void 0)for(;k!==void 0;)pA={name:k.name,styles:k.styles,next:pA},k=k.next;var N=x.styles+";";return N}return xZ(a,i,p)}case"function":{if(a!==void 0){var E=pA,z=p(a);return pA=E,gf(a,i,z)}break}}var G=p;if(i==null)return G;var j=i[G];return j!==void 0?j:G}function xZ(a,i,p){var f="";if(Array.isArray(p))for(var g=0;g<p.length;g++)f+=gf(a,i,p[g])+";";else for(var x in p){var k=p[x];if(typeof k!="object"){var N=k;i!=null&&i[N]!==void 0?f+=x+"{"+i[N]+"}":TO(N)&&(f+=hk(x)+":"+MO(x,N)+";")}else{if(x==="NO_COMPONENT_SELECTOR"&&gZ)throw new Error(vZ);if(Array.isArray(k)&&typeof k[0]=="string"&&(i==null||i[k[0]]===void 0))for(var E=0;E<k.length;E++)TO(k[E])&&(f+=hk(x)+":"+MO(x,k[E])+";");else{var z=gf(a,i,k);switch(x){case"animation":case"animationName":{f+=hk(x)+":"+z+";";break}default:f+=x+"{"+z+"}"}}}}return f}var EO=/label:\s*([^\s;{]+)\s*(;|$)/g,pA;function Mb(a,i,p){if(a.length===1&&typeof a[0]=="object"&&a[0]!==null&&a[0].styles!==void 0)return a[0];var f=!0,g="";pA=void 0;var x=a[0];if(x==null||x.raw===void 0)f=!1,g+=gf(p,i,x);else{var k=x;g+=k[0]}for(var N=1;N<a.length;N++)if(g+=gf(p,i,a[N]),f){var E=x;g+=E[N]}EO.lastIndex=0;for(var z="",G;(G=EO.exec(g))!==null;)z+="-"+G[1];var j=fZ(g)+z;return{name:j,styles:g,next:pA}}var wZ=function(i){return i()},DO=Jg.useInsertionEffect?Jg.useInsertionEffect:!1,kZ=DO||wZ,zO=DO||se.useLayoutEffect,OO=se.createContext(typeof HTMLElement<"u"?sZ({key:"css"}):null);OO.Provider;var PO=function(i){return se.forwardRef(function(p,f){var g=se.useContext(OO);return i(p,g,f)})},Eb=se.createContext({}),CZ=PO(function(a,i){var p=a.styles,f=Mb([p],void 0,se.useContext(Eb)),g=se.useRef();return zO(function(){var x=i.key+"-global",k=new i.sheet.constructor({key:x,nonce:i.sheet.nonce,container:i.sheet.container,speedy:i.sheet.isSpeedy}),N=!1,E=document.querySelector('style[data-emotion="'+x+" "+f.name+'"]');return i.sheet.tags.length&&(k.before=i.sheet.tags[0]),E!==null&&(N=!0,E.setAttribute("data-emotion",x),k.hydrate([E])),g.current=[k,N],function(){k.flush()}},[i]),zO(function(){var x=g.current,k=x[0],N=x[1];if(N){x[1]=!1;return}if(f.next!==void 0&&SO(i,f.next,!0),k.tags.length){var E=k.tags[k.tags.length-1].nextElementSibling;k.before=E,k.flush()}i.insert("",f,k,!1)},[i,f.name]),null});function IZ(){for(var a=arguments.length,i=new Array(a),p=0;p<a;p++)i[p]=arguments[p];return Mb(i)}var fk=function(){var i=IZ.apply(void 0,arguments),p="animation-"+i.name;return{name:p,styles:"@keyframes "+p+"{"+i.styles+"}",anim:1,toString:function(){return"_EMO_"+this.name+"_"+this.styles+"_EMO_"}}},SZ=TX,NZ=function(i){return i!=="theme"},BO=function(i){return typeof i=="string"&&i.charCodeAt(0)>96?SZ:NZ},FO=function(i,p,f){var g;if(p){var x=p.shouldForwardProp;g=i.__emotion_forwardProp&&x?function(k){return i.__emotion_forwardProp(k)&&x(k)}:x}return typeof g!="function"&&f&&(g=i.__emotion_forwardProp),g},TZ=!1,MZ=function(i){var p=i.cache,f=i.serialized,g=i.isStringTag;return IO(p,f,g),kZ(function(){return SO(p,f,g)}),null},EZ=function a(i,p){var f=i.__emotion_real===i,g=f&&i.__emotion_base||i,x,k;p!==void 0&&(x=p.label,k=p.target);var N=FO(i,p,f),E=N||BO(g),z=!E("as");return function(){var G=arguments,j=f&&i.__emotion_styles!==void 0?i.__emotion_styles.slice(0):[];if(x!==void 0&&j.push("label:"+x+";"),G[0]==null||G[0].raw===void 0)j.push.apply(j,G);else{j.push(G[0][0]);for(var M=G.length,R=1;R<M;R++)j.push(G[R],G[0][R])}var B=PO(function(P,H,C){var O=z&&P.as||g,F="",Y=[],ae=P;if(P.theme==null){ae={};for(var te in P)ae[te]=P[te];ae.theme=se.useContext(Eb)}typeof P.className=="string"?F=hZ(H.registered,Y,P.className):P.className!=null&&(F=P.className+" ");var oe=Mb(j.concat(Y),H.registered,ae);F+=H.key+"-"+oe.name,k!==void 0&&(F+=" "+k);var fe=z&&N===void 0?BO(O):E,ue={};for(var Z in P)z&&Z==="as"||fe(Z)&&(ue[Z]=P[Z]);return ue.className=F,C&&(ue.ref=C),se.createElement(se.Fragment,null,se.createElement(MZ,{cache:H,serialized:oe,isStringTag:typeof O=="string"}),se.createElement(O,ue))});return B.displayName=x!==void 0?x:"Styled("+(typeof g=="string"?g:g.displayName||g.name||"Component")+")",B.defaultProps=i.defaultProps,B.__emotion_real=B,B.__emotion_base=g,B.__emotion_styles=j,B.__emotion_forwardProp=N,Object.defineProperty(B,"toString",{value:function(){return k===void 0&&TZ?"NO_COMPONENT_SELECTOR":"."+k}}),B.withComponent=function(P,H){return a(P,ub({},p,H,{shouldForwardProp:FO(B,H,!0)})).apply(void 0,j)},B}},DZ=["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","big","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","keygen","label","legend","li","link","main","map","mark","marquee","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","small","source","span","strong","style","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","title","tr","track","u","ul","var","video","wbr","circle","clipPath","defs","ellipse","foreignObject","g","image","line","linearGradient","mask","path","pattern","polygon","polyline","radialGradient","rect","stop","svg","text","tspan"],mk=EZ.bind();DZ.forEach(function(a){mk[a]=mk(a)});var LO={exports:{}},zZ="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",OZ=zZ,PZ=OZ;function RO(){}function WO(){}WO.resetWarningCache=RO;var BZ=function(){function a(f,g,x,k,N,E){if(E!==PZ){var z=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw z.name="Invariant Violation",z}}a.isRequired=a;function i(){return a}var p={array:a,bigint:a,bool:a,func:a,number:a,object:a,string:a,symbol:a,any:a,arrayOf:i,element:a,elementType:a,instanceOf:i,node:a,objectOf:i,oneOf:i,oneOfType:i,shape:i,exact:i,checkPropTypes:WO,resetWarningCache:RO};return p.PropTypes=p,p};LO.exports=BZ();var FZ=LO.exports;const Db=Qr(FZ);function LZ(a){return a==null||Object.keys(a).length===0}function jO(a){const{styles:i,defaultTheme:p={}}=a,f=typeof i=="function"?g=>i(LZ(g)?p:g):i;return q.jsx(CZ,{styles:f})}/**
 * @mui/styled-engine v6.1.9
 *
 * @license MIT
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */function HO(a,i){return mk(a,i)}function RZ(a,i){Array.isArray(a.__emotion_styles)&&(a.__emotion_styles=i(a.__emotion_styles))}const GO=[];function VO(a){return GO[0]=a,Mb(GO)}function hA(a){if(typeof a!="object"||a===null)return!1;const i=Object.getPrototypeOf(a);return(i===null||i===Object.prototype||Object.getPrototypeOf(i)===null)&&!(Symbol.toStringTag in a)&&!(Symbol.iterator in a)}function XO(a){if(se.isValidElement(a)||!hA(a))return a;const i={};return Object.keys(a).forEach(p=>{i[p]=XO(a[p])}),i}function Oa(a,i,p={clone:!0}){const f=p.clone?{...a}:a;return hA(a)&&hA(i)&&Object.keys(i).forEach(g=>{se.isValidElement(i[g])?f[g]=i[g]:hA(i[g])&&Object.prototype.hasOwnProperty.call(a,g)&&hA(a[g])?f[g]=Oa(a[g],i[g],p):p.clone?f[g]=hA(i[g])?XO(i[g]):i[g]:f[g]=i[g]}),f}const WZ=a=>{const i=Object.keys(a).map(p=>({key:p,val:a[p]}))||[];return i.sort((p,f)=>p.val-f.val),i.reduce((p,f)=>({...p,[f.key]:f.val}),{})};function jZ(a){const{values:i={xs:0,sm:600,md:900,lg:1200,xl:1536},unit:p="px",step:f=5,...g}=a,x=WZ(i),k=Object.keys(x);function N(M){return`@media (min-width:${typeof i[M]=="number"?i[M]:M}${p})`}function E(M){return`@media (max-width:${(typeof i[M]=="number"?i[M]:M)-f/100}${p})`}function z(M,R){const B=k.indexOf(R);return`@media (min-width:${typeof i[M]=="number"?i[M]:M}${p}) and (max-width:${(B!==-1&&typeof i[k[B]]=="number"?i[k[B]]:R)-f/100}${p})`}function G(M){return k.indexOf(M)+1<k.length?z(M,k[k.indexOf(M)+1]):N(M)}function j(M){const R=k.indexOf(M);return R===0?N(k[1]):R===k.length-1?E(k[R]):z(M,k[k.indexOf(M)+1]).replace("@media","@media not all and")}return{keys:k,values:x,up:N,down:E,between:z,only:G,not:j,unit:p,...g}}function HZ(a,i){if(!a.containerQueries)return i;const p=Object.keys(i).filter(f=>f.startsWith("@container")).sort((f,g)=>{var k,N;const x=/min-width:\s*([0-9.]+)/;return+(((k=f.match(x))==null?void 0:k[1])||0)-+(((N=g.match(x))==null?void 0:N[1])||0)});return p.length?p.reduce((f,g)=>{const x=i[g];return delete f[g],f[g]=x,f},{...i}):i}function GZ(a,i){return i==="@"||i.startsWith("@")&&(a.some(p=>i.startsWith(`@${p}`))||!!i.match(/^@\d/))}function VZ(a,i){const p=i.match(/^@([^/]+)?\/?(.+)?$/);if(!p)return null;const[,f,g]=p,x=Number.isNaN(+f)?f||0:+f;return a.containerQueries(g).up(x)}function XZ(a){const i=(x,k)=>x.replace("@media",k?`@container ${k}`:"@container");function p(x,k){x.up=(...N)=>i(a.breakpoints.up(...N),k),x.down=(...N)=>i(a.breakpoints.down(...N),k),x.between=(...N)=>i(a.breakpoints.between(...N),k),x.only=(...N)=>i(a.breakpoints.only(...N),k),x.not=(...N)=>{const E=i(a.breakpoints.not(...N),k);return E.includes("not all and")?E.replace("not all and ","").replace("min-width:","width<").replace("max-width:","width>").replace("and","or"):E}}const f={},g=x=>(p(f,x),f);return p(g),{...a,containerQueries:g}}const ZZ={borderRadius:4};function yf(a,i){return i?Oa(a,i,{clone:!1}):a}const zb={xs:0,sm:600,md:900,lg:1200,xl:1536},ZO={keys:["xs","sm","md","lg","xl"],up:a=>`@media (min-width:${zb[a]}px)`},YZ={containerQueries:a=>({up:i=>{let p=typeof i=="number"?i:zb[i]||i;return typeof p=="number"&&(p=`${p}px`),a?`@container ${a} (min-width:${p})`:`@container (min-width:${p})`}})};function JA(a,i,p){const f=a.theme||{};if(Array.isArray(i)){const x=f.breakpoints||ZO;return i.reduce((k,N,E)=>(k[x.up(x.keys[E])]=p(i[E]),k),{})}if(typeof i=="object"){const x=f.breakpoints||ZO;return Object.keys(i).reduce((k,N)=>{if(GZ(x.keys,N)){const E=VZ(f.containerQueries?f:YZ,N);E&&(k[E]=p(i[N],N))}else if(Object.keys(x.values||zb).includes(N)){const E=x.up(N);k[E]=p(i[N],N)}else{const E=N;k[E]=i[E]}return k},{})}return p(i)}function UZ(a={}){var p;return((p=a.keys)==null?void 0:p.reduce((f,g)=>{const x=a.up(g);return f[x]={},f},{}))||{}}function QZ(a,i){return a.reduce((p,f)=>{const g=p[f];return(!g||Object.keys(g).length===0)&&delete p[f],p},i)}function tn(a){if(typeof a!="string")throw new Error(qA(7));return a.charAt(0).toUpperCase()+a.slice(1)}function Ob(a,i,p=!0){if(!i||typeof i!="string")return null;if(a&&a.vars&&p){const f=`vars.${i}`.split(".").reduce((g,x)=>g&&g[x]?g[x]:null,a);if(f!=null)return f}return i.split(".").reduce((f,g)=>f&&f[g]!=null?f[g]:null,a)}function Pb(a,i,p,f=p){let g;return typeof a=="function"?g=a(p):Array.isArray(a)?g=a[p]||f:g=Ob(a,p)||f,i&&(g=i(g,f,a)),g}function fs(a){const{prop:i,cssProperty:p=a.prop,themeKey:f,transform:g}=a,x=k=>{if(k[i]==null)return null;const N=k[i],E=k.theme,z=Ob(E,f)||{};return JA(k,N,j=>{let M=Pb(z,g,j);return j===M&&typeof j=="string"&&(M=Pb(z,g,`${i}${j==="default"?"":tn(j)}`,j)),p===!1?M:{[p]:M}})};return x.propTypes={},x.filterProps=[i],x}function KZ(a){const i={};return p=>(i[p]===void 0&&(i[p]=a(p)),i[p])}const qZ={m:"margin",p:"padding"},JZ={t:"Top",r:"Right",b:"Bottom",l:"Left",x:["Left","Right"],y:["Top","Bottom"]},YO={marginX:"mx",marginY:"my",paddingX:"px",paddingY:"py"},$Z=KZ(a=>{if(a.length>2)if(YO[a])a=YO[a];else return[a];const[i,p]=a.split(""),f=qZ[i],g=JZ[p]||"";return Array.isArray(g)?g.map(x=>f+x):[f+g]}),gk=["m","mt","mr","mb","ml","mx","my","margin","marginTop","marginRight","marginBottom","marginLeft","marginX","marginY","marginInline","marginInlineStart","marginInlineEnd","marginBlock","marginBlockStart","marginBlockEnd"],yk=["p","pt","pr","pb","pl","px","py","padding","paddingTop","paddingRight","paddingBottom","paddingLeft","paddingX","paddingY","paddingInline","paddingInlineStart","paddingInlineEnd","paddingBlock","paddingBlockStart","paddingBlockEnd"];[...gk,...yk];function bf(a,i,p,f){const g=Ob(a,i,!0)??p;return typeof g=="number"||typeof g=="string"?x=>typeof x=="string"?x:typeof g=="string"?`calc(${x} * ${g})`:g*x:Array.isArray(g)?x=>{if(typeof x=="string")return x;const k=Math.abs(x),N=g[k];return x>=0?N:typeof N=="number"?-N:`-${N}`}:typeof g=="function"?g:()=>{}}function bk(a){return bf(a,"spacing",8)}function vf(a,i){return typeof i=="string"||i==null?i:a(i)}function _Z(a,i){return p=>a.reduce((f,g)=>(f[g]=vf(i,p),f),{})}function eY(a,i,p,f){if(!i.includes(p))return null;const g=$Z(p),x=_Z(g,f),k=a[p];return JA(a,k,x)}function UO(a,i){const p=bk(a.theme);return Object.keys(a).map(f=>eY(a,i,f,p)).reduce(yf,{})}function ss(a){return UO(a,gk)}ss.propTypes={},ss.filterProps=gk;function as(a){return UO(a,yk)}as.propTypes={},as.filterProps=yk;function QO(a=8,i=bk({spacing:a})){if(a.mui)return a;const p=(...f)=>(f.length===0?[1]:f).map(x=>{const k=i(x);return typeof k=="number"?`${k}px`:k}).join(" ");return p.mui=!0,p}function Bb(...a){const i=a.reduce((f,g)=>(g.filterProps.forEach(x=>{f[x]=g}),f),{}),p=f=>Object.keys(f).reduce((g,x)=>i[x]?yf(g,i[x](f)):g,{});return p.propTypes={},p.filterProps=a.reduce((f,g)=>f.concat(g.filterProps),[]),p}function ci(a){return typeof a!="number"?a:`${a}px solid`}function di(a,i){return fs({prop:a,themeKey:"borders",transform:i})}const tY=di("border",ci),nY=di("borderTop",ci),rY=di("borderRight",ci),sY=di("borderBottom",ci),aY=di("borderLeft",ci),oY=di("borderColor"),iY=di("borderTopColor"),AY=di("borderRightColor"),lY=di("borderBottomColor"),uY=di("borderLeftColor"),cY=di("outline",ci),dY=di("outlineColor"),Fb=a=>{if(a.borderRadius!==void 0&&a.borderRadius!==null){const i=bf(a.theme,"shape.borderRadius",4),p=f=>({borderRadius:vf(i,f)});return JA(a,a.borderRadius,p)}return null};Fb.propTypes={},Fb.filterProps=["borderRadius"],Bb(tY,nY,rY,sY,aY,oY,iY,AY,lY,uY,Fb,cY,dY);const Lb=a=>{if(a.gap!==void 0&&a.gap!==null){const i=bf(a.theme,"spacing",8),p=f=>({gap:vf(i,f)});return JA(a,a.gap,p)}return null};Lb.propTypes={},Lb.filterProps=["gap"];const Rb=a=>{if(a.columnGap!==void 0&&a.columnGap!==null){const i=bf(a.theme,"spacing",8),p=f=>({columnGap:vf(i,f)});return JA(a,a.columnGap,p)}return null};Rb.propTypes={},Rb.filterProps=["columnGap"];const Wb=a=>{if(a.rowGap!==void 0&&a.rowGap!==null){const i=bf(a.theme,"spacing",8),p=f=>({rowGap:vf(i,f)});return JA(a,a.rowGap,p)}return null};Wb.propTypes={},Wb.filterProps=["rowGap"];const pY=fs({prop:"gridColumn"}),hY=fs({prop:"gridRow"}),fY=fs({prop:"gridAutoFlow"}),mY=fs({prop:"gridAutoColumns"}),gY=fs({prop:"gridAutoRows"}),yY=fs({prop:"gridTemplateColumns"}),bY=fs({prop:"gridTemplateRows"}),vY=fs({prop:"gridTemplateAreas"}),xY=fs({prop:"gridArea"});Bb(Lb,Rb,Wb,pY,hY,fY,mY,gY,yY,bY,vY,xY);function np(a,i){return i==="grey"?i:a}const wY=fs({prop:"color",themeKey:"palette",transform:np}),kY=fs({prop:"bgcolor",cssProperty:"backgroundColor",themeKey:"palette",transform:np}),CY=fs({prop:"backgroundColor",themeKey:"palette",transform:np});Bb(wY,kY,CY);function Go(a){return a<=1&&a!==0?`${a*100}%`:a}const IY=fs({prop:"width",transform:Go}),vk=a=>{if(a.maxWidth!==void 0&&a.maxWidth!==null){const i=p=>{var g,x,k,N,E;const f=((k=(x=(g=a.theme)==null?void 0:g.breakpoints)==null?void 0:x.values)==null?void 0:k[p])||zb[p];return f?((E=(N=a.theme)==null?void 0:N.breakpoints)==null?void 0:E.unit)!=="px"?{maxWidth:`${f}${a.theme.breakpoints.unit}`}:{maxWidth:f}:{maxWidth:Go(p)}};return JA(a,a.maxWidth,i)}return null};vk.filterProps=["maxWidth"];const SY=fs({prop:"minWidth",transform:Go}),NY=fs({prop:"height",transform:Go}),TY=fs({prop:"maxHeight",transform:Go}),MY=fs({prop:"minHeight",transform:Go});fs({prop:"size",cssProperty:"width",transform:Go}),fs({prop:"size",cssProperty:"height",transform:Go});const EY=fs({prop:"boxSizing"});Bb(IY,vk,SY,NY,TY,MY,EY);const xf={border:{themeKey:"borders",transform:ci},borderTop:{themeKey:"borders",transform:ci},borderRight:{themeKey:"borders",transform:ci},borderBottom:{themeKey:"borders",transform:ci},borderLeft:{themeKey:"borders",transform:ci},borderColor:{themeKey:"palette"},borderTopColor:{themeKey:"palette"},borderRightColor:{themeKey:"palette"},borderBottomColor:{themeKey:"palette"},borderLeftColor:{themeKey:"palette"},outline:{themeKey:"borders",transform:ci},outlineColor:{themeKey:"palette"},borderRadius:{themeKey:"shape.borderRadius",style:Fb},color:{themeKey:"palette",transform:np},bgcolor:{themeKey:"palette",cssProperty:"backgroundColor",transform:np},backgroundColor:{themeKey:"palette",transform:np},p:{style:as},pt:{style:as},pr:{style:as},pb:{style:as},pl:{style:as},px:{style:as},py:{style:as},padding:{style:as},paddingTop:{style:as},paddingRight:{style:as},paddingBottom:{style:as},paddingLeft:{style:as},paddingX:{style:as},paddingY:{style:as},paddingInline:{style:as},paddingInlineStart:{style:as},paddingInlineEnd:{style:as},paddingBlock:{style:as},paddingBlockStart:{style:as},paddingBlockEnd:{style:as},m:{style:ss},mt:{style:ss},mr:{style:ss},mb:{style:ss},ml:{style:ss},mx:{style:ss},my:{style:ss},margin:{style:ss},marginTop:{style:ss},marginRight:{style:ss},marginBottom:{style:ss},marginLeft:{style:ss},marginX:{style:ss},marginY:{style:ss},marginInline:{style:ss},marginInlineStart:{style:ss},marginInlineEnd:{style:ss},marginBlock:{style:ss},marginBlockStart:{style:ss},marginBlockEnd:{style:ss},displayPrint:{cssProperty:!1,transform:a=>({"@media print":{display:a}})},display:{},overflow:{},textOverflow:{},visibility:{},whiteSpace:{},flexBasis:{},flexDirection:{},flexWrap:{},justifyContent:{},alignItems:{},alignContent:{},order:{},flex:{},flexGrow:{},flexShrink:{},alignSelf:{},justifyItems:{},justifySelf:{},gap:{style:Lb},rowGap:{style:Wb},columnGap:{style:Rb},gridColumn:{},gridRow:{},gridAutoFlow:{},gridAutoColumns:{},gridAutoRows:{},gridTemplateColumns:{},gridTemplateRows:{},gridTemplateAreas:{},gridArea:{},position:{},zIndex:{themeKey:"zIndex"},top:{},right:{},bottom:{},left:{},boxShadow:{themeKey:"shadows"},width:{transform:Go},maxWidth:{style:vk},minWidth:{transform:Go},height:{transform:Go},maxHeight:{transform:Go},minHeight:{transform:Go},boxSizing:{},font:{themeKey:"font"},fontFamily:{themeKey:"typography"},fontSize:{themeKey:"typography"},fontStyle:{themeKey:"typography"},fontWeight:{themeKey:"typography"},letterSpacing:{},textTransform:{},lineHeight:{},textAlign:{},typography:{cssProperty:!1,themeKey:"typography"}};function DY(...a){const i=a.reduce((f,g)=>f.concat(Object.keys(g)),[]),p=new Set(i);return a.every(f=>p.size===Object.keys(f).length)}function zY(a,i){return typeof a=="function"?a(i):a}function OY(){function a(p,f,g,x){const k={[p]:f,theme:g},N=x[p];if(!N)return{[p]:f};const{cssProperty:E=p,themeKey:z,transform:G,style:j}=N;if(f==null)return null;if(z==="typography"&&f==="inherit")return{[p]:f};const M=Ob(g,z)||{};return j?j(k):JA(k,f,B=>{let P=Pb(M,G,B);return B===P&&typeof B=="string"&&(P=Pb(M,G,`${p}${B==="default"?"":tn(B)}`,B)),E===!1?P:{[E]:P}})}function i(p){const{sx:f,theme:g={}}=p||{};if(!f)return null;const x=g.unstable_sxConfig??xf;function k(N){let E=N;if(typeof N=="function")E=N(g);else if(typeof N!="object")return N;if(!E)return null;const z=UZ(g.breakpoints),G=Object.keys(z);let j=z;return Object.keys(E).forEach(M=>{const R=zY(E[M],g);if(R!=null)if(typeof R=="object")if(x[M])j=yf(j,a(M,R,g,x));else{const B=JA({theme:g},R,P=>({[M]:P}));DY(B,R)?j[M]=i({sx:R,theme:g}):j=yf(j,B)}else j=yf(j,a(M,R,g,x))}),HZ(g,QZ(G,j))}return Array.isArray(f)?f.map(k):k(f)}return i}const Ql=OY();Ql.filterProps=["sx"];function PY(a,i){var f;const p=this;if(p.vars){if(!((f=p.colorSchemes)!=null&&f[a])||typeof p.getColorSchemeSelector!="function")return{};let g=p.getColorSchemeSelector(a);return g==="&"?i:((g.includes("data-")||g.includes("."))&&(g=`*:where(${g.replace(/\s*&$/,"")}) &`),{[g]:i})}return p.palette.mode===a?i:{}}function xk(a={},...i){const{breakpoints:p={},palette:f={},spacing:g,shape:x={},...k}=a,N=jZ(p),E=QO(g);let z=Oa({breakpoints:N,direction:"ltr",components:{},palette:{mode:"light",...f},spacing:E,shape:{...ZZ,...x}},k);return z=XZ(z),z.applyStyles=PY,z=i.reduce((G,j)=>Oa(G,j),z),z.unstable_sxConfig={...xf,...k==null?void 0:k.unstable_sxConfig},z.unstable_sx=function(j){return Ql({sx:j,theme:this})},z}function BY(a){return Object.keys(a).length===0}function wk(a=null){const i=se.useContext(Eb);return!i||BY(i)?a:i}const FY=xk();function kk(a=FY){return wk(a)}function LY({styles:a,themeId:i,defaultTheme:p={}}){const f=kk(p),g=typeof a=="function"?a(i&&f[i]||f):a;return q.jsx(jO,{styles:g})}const RY=a=>{var f;const i={systemProps:{},otherProps:{}},p=((f=a==null?void 0:a.theme)==null?void 0:f.unstable_sxConfig)??xf;return Object.keys(a).forEach(g=>{p[g]?i.systemProps[g]=a[g]:i.otherProps[g]=a[g]}),i};function KO(a){const{sx:i,...p}=a,{systemProps:f,otherProps:g}=RY(p);let x;return Array.isArray(i)?x=[f,...i]:typeof i=="function"?x=(...k)=>{const N=i(...k);return hA(N)?{...f,...N}:f}:x={...f,...i},{...g,sx:x}}const qO=a=>a,JO=(()=>{let a=qO;return{configure(i){a=i},generate(i){return a(i)},reset(){a=qO}}})();function $O(a){var i,p,f="";if(typeof a=="string"||typeof a=="number")f+=a;else if(typeof a=="object")if(Array.isArray(a)){var g=a.length;for(i=0;i<g;i++)a[i]&&(p=$O(a[i]))&&(f&&(f+=" "),f+=p)}else for(p in a)a[p]&&(f&&(f+=" "),f+=p);return f}function fn(){for(var a,i,p=0,f="",g=arguments.length;p<g;p++)(a=arguments[p])&&(i=$O(a))&&(f&&(f+=" "),f+=i);return f}function WY(a={}){const{themeId:i,defaultTheme:p,defaultClassName:f="MuiBox-root",generateClassName:g}=a,x=HO("div",{shouldForwardProp:N=>N!=="theme"&&N!=="sx"&&N!=="as"})(Ql);return se.forwardRef(function(E,z){const G=kk(p),{className:j,component:M="div",...R}=KO(E);return q.jsx(x,{as:M,ref:z,className:fn(j,g?g(f):f),theme:i&&G[i]||G,...R})})}const jY={active:"active",checked:"checked",completed:"completed",disabled:"disabled",error:"error",expanded:"expanded",focused:"focused",focusVisible:"focusVisible",open:"open",readOnly:"readOnly",required:"required",selected:"selected"};function Xn(a,i,p="Mui"){const f=jY[i];return f?`${p}-${f}`:`${JO.generate(a)}-${i}`}function Ln(a,i,p="Mui"){const f={};return i.forEach(g=>{f[g]=Xn(a,g,p)}),f}var br={};/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Ck=Symbol.for("react.element"),Ik=Symbol.for("react.portal"),jb=Symbol.for("react.fragment"),Hb=Symbol.for("react.strict_mode"),Gb=Symbol.for("react.profiler"),Vb=Symbol.for("react.provider"),Xb=Symbol.for("react.context"),HY=Symbol.for("react.server_context"),Zb=Symbol.for("react.forward_ref"),Yb=Symbol.for("react.suspense"),Ub=Symbol.for("react.suspense_list"),Qb=Symbol.for("react.memo"),Kb=Symbol.for("react.lazy"),GY=Symbol.for("react.offscreen"),_O;_O=Symbol.for("react.module.reference");function pi(a){if(typeof a=="object"&&a!==null){var i=a.$$typeof;switch(i){case Ck:switch(a=a.type,a){case jb:case Gb:case Hb:case Yb:case Ub:return a;default:switch(a=a&&a.$$typeof,a){case HY:case Xb:case Zb:case Kb:case Qb:case Vb:return a;default:return i}}case Ik:return i}}}br.ContextConsumer=Xb,br.ContextProvider=Vb,br.Element=Ck,br.ForwardRef=Zb,br.Fragment=jb,br.Lazy=Kb,br.Memo=Qb,br.Portal=Ik,br.Profiler=Gb,br.StrictMode=Hb,br.Suspense=Yb,br.SuspenseList=Ub,br.isAsyncMode=function(){return!1},br.isConcurrentMode=function(){return!1},br.isContextConsumer=function(a){return pi(a)===Xb},br.isContextProvider=function(a){return pi(a)===Vb},br.isElement=function(a){return typeof a=="object"&&a!==null&&a.$$typeof===Ck},br.isForwardRef=function(a){return pi(a)===Zb},br.isFragment=function(a){return pi(a)===jb},br.isLazy=function(a){return pi(a)===Kb},br.isMemo=function(a){return pi(a)===Qb},br.isPortal=function(a){return pi(a)===Ik},br.isProfiler=function(a){return pi(a)===Gb},br.isStrictMode=function(a){return pi(a)===Hb},br.isSuspense=function(a){return pi(a)===Yb},br.isSuspenseList=function(a){return pi(a)===Ub},br.isValidElementType=function(a){return typeof a=="string"||typeof a=="function"||a===jb||a===Gb||a===Hb||a===Yb||a===Ub||a===GY||typeof a=="object"&&a!==null&&(a.$$typeof===Kb||a.$$typeof===Qb||a.$$typeof===Vb||a.$$typeof===Xb||a.$$typeof===Zb||a.$$typeof===_O||a.getModuleId!==void 0)},br.typeOf=pi;function eP(a){const{variants:i,...p}=a,f={variants:i,style:VO(p),isProcessed:!0};return f.style===p||i&&i.forEach(g=>{typeof g.style!="function"&&(g.style=VO(g.style))}),f}const VY=xk();function Sk(a){return a!=="ownerState"&&a!=="theme"&&a!=="sx"&&a!=="as"}function XY(a){return a?(i,p)=>p[a]:null}function ZY(a,i,p){a.theme=QY(a.theme)?p:a.theme[i]||a.theme}function qb(a,i){const p=typeof i=="function"?i(a):i;if(Array.isArray(p))return p.flatMap(f=>qb(a,f));if(Array.isArray(p==null?void 0:p.variants)){let f;if(p.isProcessed)f=p.style;else{const{variants:g,...x}=p;f=x}return tP(a,p.variants,[f])}return p!=null&&p.isProcessed?p.style:p}function tP(a,i,p=[]){var g;let f;e:for(let x=0;x<i.length;x+=1){const k=i[x];if(typeof k.props=="function"){if(f??(f={...a,...a.ownerState,ownerState:a.ownerState}),!k.props(f))continue}else for(const N in k.props)if(a[N]!==k.props[N]&&((g=a.ownerState)==null?void 0:g[N])!==k.props[N])continue e;typeof k.style=="function"?(f??(f={...a,...a.ownerState,ownerState:a.ownerState}),p.push(k.style(f))):p.push(k.style)}return p}function YY(a={}){const{themeId:i,defaultTheme:p=VY,rootShouldForwardProp:f=Sk,slotShouldForwardProp:g=Sk}=a;function x(N){ZY(N,i,p)}return(N,E={})=>{RZ(N,ae=>ae.filter(te=>te!==Ql));const{name:z,slot:G,skipVariantsResolver:j,skipSx:M,overridesResolver:R=XY(qY(G)),...B}=E,P=j!==void 0?j:G&&G!=="Root"&&G!=="root"||!1,H=M||!1;let C=Sk;G==="Root"||G==="root"?C=f:G?C=g:KY(N)&&(C=void 0);const O=HO(N,{shouldForwardProp:C,label:UY(),...B}),F=ae=>{if(typeof ae=="function"&&ae.__emotion_real!==ae)return function(oe){return qb(oe,ae)};if(hA(ae)){const te=eP(ae);return te.variants?function(fe){return qb(fe,te)}:te.style}return ae},Y=(...ae)=>{const te=[],oe=ae.map(F),fe=[];if(te.push(x),z&&R&&fe.push(function(pe){var Ie,je;const ke=(je=(Ie=pe.theme.components)==null?void 0:Ie[z])==null?void 0:je.styleOverrides;if(!ke)return null;const ie={};for(const xe in ke)ie[xe]=qb(pe,ke[xe]);return R(pe,ie)}),z&&!P&&fe.push(function(pe){var ie,Ie;const Q=pe.theme,ke=(Ie=(ie=Q==null?void 0:Q.components)==null?void 0:ie[z])==null?void 0:Ie.variants;return ke?tP(pe,ke):null}),H||fe.push(Ql),Array.isArray(oe[0])){const ye=oe.shift(),pe=new Array(te.length).fill(""),Q=new Array(fe.length).fill("");let ke;ke=[...pe,...ye,...Q],ke.raw=[...pe,...ye.raw,...Q],te.unshift(ke)}const ue=[...te,...oe,...fe],Z=O(...ue);return N.muiName&&(Z.muiName=N.muiName),Z};return O.withConfig&&(Y.withConfig=O.withConfig),Y}}function UY(a,i){return void 0}function QY(a){for(const i in a)return!1;return!0}function KY(a){return typeof a=="string"&&a.charCodeAt(0)>96}function qY(a){return a&&a.charAt(0).toLowerCase()+a.slice(1)}function wf(a,i){const p={...i};for(const f in a)if(Object.prototype.hasOwnProperty.call(a,f)){const g=f;if(g==="components"||g==="slots")p[g]={...a[g],...p[g]};else if(g==="componentsProps"||g==="slotProps"){const x=a[g],k=i[g];if(!k)p[g]=x||{};else if(!x)p[g]=k;else{p[g]={...k};for(const N in x)if(Object.prototype.hasOwnProperty.call(x,N)){const E=N;p[g][E]=wf(x[E],k[E])}}}else p[g]===void 0&&(p[g]=a[g])}return p}function JY(a){const{theme:i,name:p,props:f}=a;return!i||!i.components||!i.components[p]||!i.components[p].defaultProps?f:wf(i.components[p].defaultProps,f)}const $A=typeof window<"u"?se.useLayoutEffect:se.useEffect;function $Y(a,i,p,f,g){const[x,k]=se.useState(()=>g&&p?p(a).matches:f?f(a).matches:i);return $A(()=>{if(!p)return;const N=p(a),E=()=>{k(N.matches)};return E(),N.addEventListener("change",E),()=>{N.removeEventListener("change",E)}},[a,p]),x}const nP={...Jg}.useSyncExternalStore;function _Y(a,i,p,f,g){const x=se.useCallback(()=>i,[i]),k=se.useMemo(()=>{if(g&&p)return()=>p(a).matches;if(f!==null){const{matches:G}=f(a);return()=>G}return x},[x,a,f,g,p]),[N,E]=se.useMemo(()=>{if(p===null)return[x,()=>()=>{}];const G=p(a);return[()=>G.matches,j=>(G.addEventListener("change",j),()=>{G.removeEventListener("change",j)})]},[x,p,a]);return nP(E,N,k)}function eU(a={}){const{themeId:i}=a;return function(f,g={}){let x=wk();x&&i&&(x=x[i]||x);const k=typeof window<"u"&&typeof window.matchMedia<"u",{defaultMatches:N=!1,matchMedia:E=k?window.matchMedia:null,ssrMatchMedia:z=null,noSsr:G=!1}=JY({name:"MuiUseMediaQuery",props:g,theme:x});let j=typeof f=="function"?f(x):f;return j=j.replace(/^@media( ?)/m,""),(nP!==void 0?_Y:$Y)(j,N,E,z,G)}}function tU(a,i=Number.MIN_SAFE_INTEGER,p=Number.MAX_SAFE_INTEGER){return Math.max(i,Math.min(a,p))}function Nk(a,i=0,p=1){return tU(a,i,p)}function nU(a){a=a.slice(1);const i=new RegExp(`.{1,${a.length>=6?2:1}}`,"g");let p=a.match(i);return p&&p[0].length===1&&(p=p.map(f=>f+f)),p?`rgb${p.length===4?"a":""}(${p.map((f,g)=>g<3?parseInt(f,16):Math.round(parseInt(f,16)/255*1e3)/1e3).join(", ")})`:""}function Kl(a){if(a.type)return a;if(a.charAt(0)==="#")return Kl(nU(a));const i=a.indexOf("("),p=a.substring(0,i);if(!["rgb","rgba","hsl","hsla","color"].includes(p))throw new Error(qA(9,a));let f=a.substring(i+1,a.length-1),g;if(p==="color"){if(f=f.split(" "),g=f.shift(),f.length===4&&f[3].charAt(0)==="/"&&(f[3]=f[3].slice(1)),!["srgb","display-p3","a98-rgb","prophoto-rgb","rec-2020"].includes(g))throw new Error(qA(10,g))}else f=f.split(",");return f=f.map(x=>parseFloat(x)),{type:p,values:f,colorSpace:g}}const rU=a=>{const i=Kl(a);return i.values.slice(0,3).map((p,f)=>i.type.includes("hsl")&&f!==0?`${p}%`:p).join(" ")},kf=(a,i)=>{try{return rU(a)}catch{return a}};function Jb(a){const{type:i,colorSpace:p}=a;let{values:f}=a;return i.includes("rgb")?f=f.map((g,x)=>x<3?parseInt(g,10):g):i.includes("hsl")&&(f[1]=`${f[1]}%`,f[2]=`${f[2]}%`),i.includes("color")?f=`${p} ${f.join(" ")}`:f=`${f.join(", ")}`,`${i}(${f})`}function rP(a){a=Kl(a);const{values:i}=a,p=i[0],f=i[1]/100,g=i[2]/100,x=f*Math.min(g,1-g),k=(z,G=(z+p/30)%12)=>g-x*Math.max(Math.min(G-3,9-G,1),-1);let N="rgb";const E=[Math.round(k(0)*255),Math.round(k(8)*255),Math.round(k(4)*255)];return a.type==="hsla"&&(N+="a",E.push(i[3])),Jb({type:N,values:E})}function Tk(a){a=Kl(a);let i=a.type==="hsl"||a.type==="hsla"?Kl(rP(a)).values:a.values;return i=i.map(p=>(a.type!=="color"&&(p/=255),p<=.03928?p/12.92:((p+.055)/1.055)**2.4)),Number((.2126*i[0]+.7152*i[1]+.0722*i[2]).toFixed(3))}function sU(a,i){const p=Tk(a),f=Tk(i);return(Math.max(p,f)+.05)/(Math.min(p,f)+.05)}function Pa(a,i){return a=Kl(a),i=Nk(i),(a.type==="rgb"||a.type==="hsl")&&(a.type+="a"),a.type==="color"?a.values[3]=`/${i}`:a.values[3]=i,Jb(a)}function $b(a,i,p){try{return Pa(a,i)}catch{return a}}function Cf(a,i){if(a=Kl(a),i=Nk(i),a.type.includes("hsl"))a.values[2]*=1-i;else if(a.type.includes("rgb")||a.type.includes("color"))for(let p=0;p<3;p+=1)a.values[p]*=1-i;return Jb(a)}function Cr(a,i,p){try{return Cf(a,i)}catch{return a}}function If(a,i){if(a=Kl(a),i=Nk(i),a.type.includes("hsl"))a.values[2]+=(100-a.values[2])*i;else if(a.type.includes("rgb"))for(let p=0;p<3;p+=1)a.values[p]+=(255-a.values[p])*i;else if(a.type.includes("color"))for(let p=0;p<3;p+=1)a.values[p]+=(1-a.values[p])*i;return Jb(a)}function Ir(a,i,p){try{return If(a,i)}catch{return a}}function sP(a,i=.15){return Tk(a)>.5?Cf(a,i):If(a,i)}function _b(a,i,p){try{return sP(a,i)}catch{return a}}function Mk(...a){return a.reduce((i,p)=>p==null?i:function(...g){i.apply(this,g),p.apply(this,g)},()=>{})}function aP(a,i=166){let p;function f(...g){const x=()=>{a.apply(this,g)};clearTimeout(p),p=setTimeout(x,i)}return f.clear=()=>{clearTimeout(p)},f}function Ek(a,i){var p,f,g;return se.isValidElement(a)&&i.indexOf(a.type.muiName??((g=(f=(p=a.type)==null?void 0:p._payload)==null?void 0:f.value)==null?void 0:g.muiName))!==-1}function go(a){return a&&a.ownerDocument||document}function _A(a){return go(a).defaultView||window}function Dk(a,i){typeof a=="function"?a(i):a&&(a.current=i)}let oP=0;function aU(a){const[i,p]=se.useState(a),f=a||i;return se.useEffect(()=>{i==null&&(oP+=1,p(`mui-${oP}`))},[i]),f}const iP={...Jg}.useId;function e0(a){if(iP!==void 0){const i=iP();return a??i}return aU(a)}function t0({controlled:a,default:i,name:p,state:f="value"}){const{current:g}=se.useRef(a!==void 0),[x,k]=se.useState(i),N=g?a:x,E=se.useCallback(z=>{g||k(z)},[]);return[N,E]}function el(a){const i=se.useRef(a);return $A(()=>{i.current=a}),se.useRef((...p)=>(0,i.current)(...p)).current}function js(...a){return se.useMemo(()=>a.every(i=>i==null)?null:i=>{a.forEach(p=>{Dk(p,i)})},a)}const AP={};function lP(a,i){const p=se.useRef(AP);return p.current===AP&&(p.current=a(i)),p}const oU=[];function iU(a){se.useEffect(a,oU)}class zk{constructor(){qs(this,"currentId",null);qs(this,"clear",()=>{this.currentId!==null&&(clearTimeout(this.currentId),this.currentId=null)});qs(this,"disposeEffect",()=>this.clear)}static create(){return new zk}start(i,p){this.clear(),this.currentId=setTimeout(()=>{this.currentId=null,p()},i)}}function Ok(){const a=lP(zk.create).current;return iU(a.disposeEffect),a}function uP(a){try{return a.matches(":focus-visible")}catch{}return!1}function cP(a=window){const i=a.document.documentElement.clientWidth;return a.innerWidth-i}function qn(a,i,p=void 0){const f={};for(const g in a){const x=a[g];let k="",N=!0;for(let E=0;E<x.length;E+=1){const z=x[E];z&&(k+=(N===!0?"":" ")+i(z),N=!1,p&&p[z]&&(k+=" "+p[z]))}f[g]=k}return f}function AU(a){return typeof a=="string"}function dP(a,i,p){return a===void 0||AU(a)?i:{...i,ownerState:{...i.ownerState,...p}}}function n0(a,i=[]){if(a===void 0)return{};const p={};return Object.keys(a).filter(f=>f.match(/^on[A-Z]/)&&typeof a[f]=="function"&&!i.includes(f)).forEach(f=>{p[f]=a[f]}),p}function pP(a){if(a===void 0)return{};const i={};return Object.keys(a).filter(p=>!(p.match(/^on[A-Z]/)&&typeof a[p]=="function")).forEach(p=>{i[p]=a[p]}),i}function hP(a){const{getSlotProps:i,additionalProps:p,externalSlotProps:f,externalForwardedProps:g,className:x}=a;if(!i){const R=fn(p==null?void 0:p.className,x,g==null?void 0:g.className,f==null?void 0:f.className),B={...p==null?void 0:p.style,...g==null?void 0:g.style,...f==null?void 0:f.style},P={...p,...g,...f};return R.length>0&&(P.className=R),Object.keys(B).length>0&&(P.style=B),{props:P,internalRef:void 0}}const k=n0({...g,...f}),N=pP(f),E=pP(g),z=i(k),G=fn(z==null?void 0:z.className,p==null?void 0:p.className,x,g==null?void 0:g.className,f==null?void 0:f.className),j={...z==null?void 0:z.style,...p==null?void 0:p.style,...g==null?void 0:g.style,...f==null?void 0:f.style},M={...z,...p,...E,...N};return G.length>0&&(M.className=G),Object.keys(j).length>0&&(M.style=j),{props:M,internalRef:z.ref}}function fP(a,i,p){return typeof a=="function"?a(i,p):a}function Pk(a){var j;const{elementType:i,externalSlotProps:p,ownerState:f,skipResolvingSlotProps:g=!1,...x}=a,k=g?{}:fP(p,f),{props:N,internalRef:E}=hP({...x,externalSlotProps:k}),z=js(E,k==null?void 0:k.ref,(j=a.additionalProps)==null?void 0:j.ref);return dP(i,{...N,ref:z},f)}function rp(a){var i;return parseInt(se.version,10)>=19?((i=a==null?void 0:a.props)==null?void 0:i.ref)||null:(a==null?void 0:a.ref)||null}const mP=se.createContext(null);function Bk(){return se.useContext(mP)}const lU=typeof Symbol=="function"&&Symbol.for?Symbol.for("mui.nested"):"__THEME_NESTED__";function uU(a,i){return typeof i=="function"?i(a):{...a,...i}}function cU(a){const{children:i,theme:p}=a,f=Bk(),g=se.useMemo(()=>{const x=f===null?{...p}:uU(f,p);return x!=null&&(x[lU]=f!==null),x},[p,f]);return q.jsx(mP.Provider,{value:g,children:i})}const gP=se.createContext();function dU({value:a,...i}){return q.jsx(gP.Provider,{value:a??!0,...i})}const pU=()=>se.useContext(gP)??!1,yP=se.createContext(void 0);function hU({value:a,children:i}){return q.jsx(yP.Provider,{value:a,children:i})}function fU(a){const{theme:i,name:p,props:f}=a;if(!i||!i.components||!i.components[p])return f;const g=i.components[p];return g.defaultProps?wf(g.defaultProps,f):!g.styleOverrides&&!g.variants?wf(g,f):f}function mU({props:a,name:i}){const p=se.useContext(yP);return fU({props:a,name:i,theme:{components:p}})}const bP={};function vP(a,i,p,f=!1){return se.useMemo(()=>{const g=a&&i[a]||i;if(typeof p=="function"){const x=p(g),k=a?{...i,[a]:x}:x;return f?()=>k:k}return a?{...i,[a]:p}:{...i,...p}},[a,i,p,f])}function xP(a){const{children:i,theme:p,themeId:f}=a,g=wk(bP),x=Bk()||bP,k=vP(f,g,p),N=vP(f,x,p,!0),E=(f?k[f]:k).direction==="rtl";return q.jsx(cU,{theme:N,children:q.jsx(Eb.Provider,{value:k,children:q.jsx(dU,{value:E,children:q.jsx(hU,{value:f?k[f].components:k.components,children:i})})})})}const wP={theme:void 0};function gU(a){let i,p;return function(g){let x=i;return(x===void 0||g.theme!==p)&&(wP.theme=g.theme,x=eP(a(wP)),i=x,p=g.theme),x}}const Fk="mode",Lk="color-scheme",yU="data-color-scheme";function bU(a){const{defaultMode:i="system",defaultLightColorScheme:p="light",defaultDarkColorScheme:f="dark",modeStorageKey:g=Fk,colorSchemeStorageKey:x=Lk,attribute:k=yU,colorSchemeNode:N="document.documentElement",nonce:E}=a||{};let z="",G=k;if(k==="class"&&(G=".%s"),k==="data"&&(G="[data-%s]"),G.startsWith(".")){const M=G.substring(1);z+=`${N}.classList.remove('${M}'.replace('%s', light), '${M}'.replace('%s', dark));
      ${N}.classList.add('${M}'.replace('%s', colorScheme));`}const j=G.match(/\[([^\]]+)\]/);if(j){const[M,R]=j[1].split("=");R||(z+=`${N}.removeAttribute('${M}'.replace('%s', light));
      ${N}.removeAttribute('${M}'.replace('%s', dark));`),z+=`
      ${N}.setAttribute('${M}'.replace('%s', colorScheme), ${R?`${R}.replace('%s', colorScheme)`:'""'});`}else z+=`${N}.setAttribute('${G}', colorScheme);`;return q.jsx("script",{suppressHydrationWarning:!0,nonce:typeof window>"u"?E:"",dangerouslySetInnerHTML:{__html:`(function() {
try {
  let colorScheme = '';
  const mode = localStorage.getItem('${g}') || '${i}';
  const dark = localStorage.getItem('${x}-dark') || '${f}';
  const light = localStorage.getItem('${x}-light') || '${p}';
  if (mode === 'system') {
    // handle system mode
    const mql = window.matchMedia('(prefers-color-scheme: dark)');
    if (mql.matches) {
      colorScheme = dark
    } else {
      colorScheme = light
    }
  }
  if (mode === 'light') {
    colorScheme = light;
  }
  if (mode === 'dark') {
    colorScheme = dark;
  }
  if (colorScheme) {
    ${z}
  }
} catch(e){}})();`}},"mui-color-scheme-init")}function kP(a){if(typeof window<"u"&&typeof window.matchMedia=="function"&&a==="system")return window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"}function CP(a,i){if(a.mode==="light"||a.mode==="system"&&a.systemMode==="light")return i("light");if(a.mode==="dark"||a.mode==="system"&&a.systemMode==="dark")return i("dark")}function vU(a){return CP(a,i=>{if(i==="light")return a.lightColorScheme;if(i==="dark")return a.darkColorScheme})}function Rk(a,i){if(typeof window>"u")return;let p;try{p=localStorage.getItem(a)||void 0,p||localStorage.setItem(a,i)}catch{}return p||i}function xU(a){const{defaultMode:i="light",defaultLightColorScheme:p,defaultDarkColorScheme:f,supportedColorSchemes:g=[],modeStorageKey:x=Fk,colorSchemeStorageKey:k=Lk,storageWindow:N=typeof window>"u"?void 0:window,noSsr:E=!1}=a,z=g.join(","),G=g.length>1,[j,M]=se.useState(()=>{const Y=Rk(x,i),ae=Rk(`${k}-light`,p),te=Rk(`${k}-dark`,f);return{mode:Y,systemMode:kP(Y),lightColorScheme:ae,darkColorScheme:te}}),[R,B]=se.useState(E||!G);se.useEffect(()=>{B(!0)},[]);const P=vU(j),H=se.useCallback(Y=>{M(ae=>{if(Y===ae.mode)return ae;const te=Y??i;try{localStorage.setItem(x,te)}catch{}return{...ae,mode:te,systemMode:kP(te)}})},[x,i]),C=se.useCallback(Y=>{Y?typeof Y=="string"?Y&&!z.includes(Y)?console.error(`\`${Y}\` does not exist in \`theme.colorSchemes\`.`):M(ae=>{const te={...ae};return CP(ae,oe=>{try{localStorage.setItem(`${k}-${oe}`,Y)}catch{}oe==="light"&&(te.lightColorScheme=Y),oe==="dark"&&(te.darkColorScheme=Y)}),te}):M(ae=>{const te={...ae},oe=Y.light===null?p:Y.light,fe=Y.dark===null?f:Y.dark;if(oe)if(!z.includes(oe))console.error(`\`${oe}\` does not exist in \`theme.colorSchemes\`.`);else{te.lightColorScheme=oe;try{localStorage.setItem(`${k}-light`,oe)}catch{}}if(fe)if(!z.includes(fe))console.error(`\`${fe}\` does not exist in \`theme.colorSchemes\`.`);else{te.darkColorScheme=fe;try{localStorage.setItem(`${k}-dark`,fe)}catch{}}return te}):M(ae=>{try{localStorage.setItem(`${k}-light`,p),localStorage.setItem(`${k}-dark`,f)}catch{}return{...ae,lightColorScheme:p,darkColorScheme:f}})},[z,k,p,f]),O=se.useCallback(Y=>{j.mode==="system"&&M(ae=>{const te=Y!=null&&Y.matches?"dark":"light";return ae.systemMode===te?ae:{...ae,systemMode:te}})},[j.mode]),F=se.useRef(O);return F.current=O,se.useEffect(()=>{if(typeof window.matchMedia!="function"||!G)return;const Y=(...te)=>F.current(...te),ae=window.matchMedia("(prefers-color-scheme: dark)");return ae.addListener(Y),Y(ae),()=>{ae.removeListener(Y)}},[G]),se.useEffect(()=>{if(N&&G){const Y=ae=>{const te=ae.newValue;typeof ae.key=="string"&&ae.key.startsWith(k)&&(!te||z.match(te))&&(ae.key.endsWith("light")&&C({light:te}),ae.key.endsWith("dark")&&C({dark:te})),ae.key===x&&(!te||["light","dark","system"].includes(te))&&H(te||i)};return N.addEventListener("storage",Y),()=>{N.removeEventListener("storage",Y)}}},[C,H,x,k,z,i,N,G]),{...j,mode:R?j.mode:void 0,systemMode:R?j.systemMode:void 0,colorScheme:R?P:void 0,setMode:H,setColorScheme:C}}const wU="*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";function kU(a){const{themeId:i,theme:p={},modeStorageKey:f=Fk,colorSchemeStorageKey:g=Lk,disableTransitionOnChange:x=!1,defaultColorScheme:k,resolveTheme:N}=a,E={allColorSchemes:[],colorScheme:void 0,darkColorScheme:void 0,lightColorScheme:void 0,mode:void 0,setColorScheme:()=>{},setMode:()=>{},systemMode:void 0},z=se.createContext(void 0),G=()=>se.useContext(z)||E;function j(P){var ht,Et,cn,jt,xn;const{children:H,theme:C,modeStorageKey:O=f,colorSchemeStorageKey:F=g,disableTransitionOnChange:Y=x,storageWindow:ae=typeof window>"u"?void 0:window,documentNode:te=typeof document>"u"?void 0:document,colorSchemeNode:oe=typeof document>"u"?void 0:document.documentElement,disableNestedContext:fe=!1,disableStyleSheetGeneration:ue=!1,defaultMode:Z="system",noSsr:ye}=P,pe=se.useRef(!1),Q=Bk(),ke=se.useContext(z),ie=!!ke&&!fe,Ie=se.useMemo(()=>C||(typeof p=="function"?p():p),[C]),je=Ie[i],{colorSchemes:xe={},components:We={},cssVarPrefix:Ke,...ut}=je||Ie,ge=Object.keys(xe).filter(yn=>!!xe[yn]).join(","),Qe=se.useMemo(()=>ge.split(","),[ge]),At=typeof k=="string"?k:k.light,dt=typeof k=="string"?k:k.dark,It=xe[At]&&xe[dt]?Z:((Et=(ht=xe[ut.defaultColorScheme])==null?void 0:ht.palette)==null?void 0:Et.mode)||((cn=ut.palette)==null?void 0:cn.mode),{mode:Ft,setMode:pn,systemMode:Yt,lightColorScheme:wt,darkColorScheme:Ht,colorScheme:Wt,setColorScheme:on}=xU({supportedColorSchemes:Qe,defaultLightColorScheme:At,defaultDarkColorScheme:dt,modeStorageKey:O,colorSchemeStorageKey:F,defaultMode:It,storageWindow:ae,noSsr:ye});let Rt=Ft,Mt=Wt;ie&&(Rt=ke.mode,Mt=ke.colorScheme);const Tn=Mt||ut.defaultColorScheme,Sn=((jt=ut.generateThemeVars)==null?void 0:jt.call(ut))||ut.vars,J={...ut,components:We,colorSchemes:xe,cssVarPrefix:Ke,vars:Sn};if(typeof J.generateSpacing=="function"&&(J.spacing=J.generateSpacing()),Tn){const yn=xe[Tn];yn&&typeof yn=="object"&&Object.keys(yn).forEach(pt=>{yn[pt]&&typeof yn[pt]=="object"?J[pt]={...J[pt],...yn[pt]}:J[pt]=yn[pt]})}const gn=ut.colorSchemeSelector;se.useEffect(()=>{if(Mt&&oe&&gn&&gn!=="media"){const yn=gn;let pt=gn;if(yn==="class"&&(pt=".%s"),yn==="data"&&(pt="[data-%s]"),yn!=null&&yn.startsWith("data-")&&!yn.includes("%s")&&(pt=`[${yn}="%s"]`),pt.startsWith("."))oe.classList.remove(...Qe.map(tt=>pt.substring(1).replace("%s",tt))),oe.classList.add(pt.substring(1).replace("%s",Mt));else{const tt=pt.replace("%s",Mt).match(/\[([^\]]+)\]/);if(tt){const[Oe,Tt]=tt[1].split("=");Tt||Qe.forEach(nn=>{oe.removeAttribute(Oe.replace(Mt,nn))}),oe.setAttribute(Oe,Tt?Tt.replace(/"|'/g,""):"")}else oe.setAttribute(pt,Mt)}}},[Mt,gn,oe,Qe]),se.useEffect(()=>{let yn;if(Y&&pe.current&&te){const pt=te.createElement("style");pt.appendChild(te.createTextNode(wU)),te.head.appendChild(pt),window.getComputedStyle(te.body),yn=setTimeout(()=>{te.head.removeChild(pt)},1)}return()=>{clearTimeout(yn)}},[Mt,Y,te]),se.useEffect(()=>(pe.current=!0,()=>{pe.current=!1}),[]);const rr=se.useMemo(()=>({allColorSchemes:Qe,colorScheme:Mt,darkColorScheme:Ht,lightColorScheme:wt,mode:Rt,setColorScheme:on,setMode:pn,systemMode:Yt}),[Qe,Mt,Ht,wt,Rt,on,pn,Yt,J.colorSchemeSelector]);let qt=!0;(ue||ut.cssVariables===!1||ie&&(Q==null?void 0:Q.cssVarPrefix)===Ke)&&(qt=!1);const Ye=q.jsxs(se.Fragment,{children:[q.jsx(xP,{themeId:je?i:void 0,theme:N?N(J):J,children:H}),qt&&q.jsx(jO,{styles:((xn=J.generateStyleSheets)==null?void 0:xn.call(J))||[]})]});return ie?Ye:q.jsx(z.Provider,{value:rr,children:Ye})}const M=typeof k=="string"?k:k.light,R=typeof k=="string"?k:k.dark;return{CssVarsProvider:j,useColorScheme:G,getInitColorSchemeScript:P=>bU({colorSchemeStorageKey:g,defaultLightColorScheme:M,defaultDarkColorScheme:R,modeStorageKey:f,...P})}}function CU(a=""){function i(...f){if(!f.length)return"";const g=f[0];return typeof g=="string"&&!g.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/)?`, var(--${a?`${a}-`:""}${g}${i(...f.slice(1))})`:`, ${g}`}return(f,...g)=>`var(--${a?`${a}-`:""}${f}${i(...g)})`}const IP=(a,i,p,f=[])=>{let g=a;i.forEach((x,k)=>{k===i.length-1?Array.isArray(g)?g[Number(x)]=p:g&&typeof g=="object"&&(g[x]=p):g&&typeof g=="object"&&(g[x]||(g[x]=f.includes(x)?[]:{}),g=g[x])})},IU=(a,i,p)=>{function f(g,x=[],k=[]){Object.entries(g).forEach(([N,E])=>{(!p||p&&!p([...x,N]))&&E!=null&&(typeof E=="object"&&Object.keys(E).length>0?f(E,[...x,N],Array.isArray(E)?[...k,N]:k):i([...x,N],E,k))})}f(a)},SU=(a,i)=>typeof i=="number"?["lineHeight","fontWeight","opacity","zIndex"].some(f=>a.includes(f))||a[a.length-1].toLowerCase().includes("opacity")?i:`${i}px`:i;function Wk(a,i){const{prefix:p,shouldSkipGeneratingVar:f}=i||{},g={},x={},k={};return IU(a,(N,E,z)=>{if((typeof E=="string"||typeof E=="number")&&(!f||!f(N,E))){const G=`--${p?`${p}-`:""}${N.join("-")}`,j=SU(N,E);Object.assign(g,{[G]:j}),IP(x,N,`var(${G})`,z),IP(k,N,`var(${G}, ${j})`,z)}},N=>N[0]==="vars"),{css:g,vars:x,varsWithDefaults:k}}function NU(a,i={}){const{getSelector:p=H,disableCssColorScheme:f,colorSchemeSelector:g}=i,{colorSchemes:x={},components:k,defaultColorScheme:N="light",...E}=a,{vars:z,css:G,varsWithDefaults:j}=Wk(E,i);let M=j;const R={},{[N]:B,...P}=x;if(Object.entries(P||{}).forEach(([F,Y])=>{const{vars:ae,css:te,varsWithDefaults:oe}=Wk(Y,i);M=Oa(M,oe),R[F]={css:te,vars:ae}}),B){const{css:F,vars:Y,varsWithDefaults:ae}=Wk(B,i);M=Oa(M,ae),R[N]={css:F,vars:Y}}function H(F,Y){var te,oe;let ae=g;if(g==="class"&&(ae=".%s"),g==="data"&&(ae="[data-%s]"),g!=null&&g.startsWith("data-")&&!g.includes("%s")&&(ae=`[${g}="%s"]`),F){if(ae==="media")return a.defaultColorScheme===F?":root":{[`@media (prefers-color-scheme: ${((oe=(te=x[F])==null?void 0:te.palette)==null?void 0:oe.mode)||F})`]:{":root":Y}};if(ae)return a.defaultColorScheme===F?`:root, ${ae.replace("%s",String(F))}`:ae.replace("%s",String(F))}return":root"}return{vars:M,generateThemeVars:()=>{let F={...z};return Object.entries(R).forEach(([,{vars:Y}])=>{F=Oa(F,Y)}),F},generateStyleSheets:()=>{var fe,ue;const F=[],Y=a.defaultColorScheme||"light";function ae(Z,ye){Object.keys(ye).length&&F.push(typeof Z=="string"?{[Z]:{...ye}}:Z)}ae(p(void 0,{...G}),G);const{[Y]:te,...oe}=R;if(te){const{css:Z}=te,ye=(ue=(fe=x[Y])==null?void 0:fe.palette)==null?void 0:ue.mode,pe=!f&&ye?{colorScheme:ye,...Z}:{...Z};ae(p(Y,{...pe}),pe)}return Object.entries(oe).forEach(([Z,{css:ye}])=>{var ke,ie;const pe=(ie=(ke=x[Z])==null?void 0:ke.palette)==null?void 0:ie.mode,Q=!f&&pe?{colorScheme:pe,...ye}:{...ye};ae(p(Z,{...Q}),Q)}),F}}}function TU(a){return function(p){return a==="media"?`@media (prefers-color-scheme: ${p})`:a?a.startsWith("data-")&&!a.includes("%s")?`[${a}="${p}"] &`:a==="class"?`.${p} &`:a==="data"?`[data-${p}] &`:`${a.replace("%s",p)} &`:"&"}}function SP(){return{text:{primary:"rgba(0, 0, 0, 0.87)",secondary:"rgba(0, 0, 0, 0.6)",disabled:"rgba(0, 0, 0, 0.38)"},divider:"rgba(0, 0, 0, 0.12)",background:{paper:cf.white,default:cf.white},action:{active:"rgba(0, 0, 0, 0.54)",hover:"rgba(0, 0, 0, 0.04)",hoverOpacity:.04,selected:"rgba(0, 0, 0, 0.08)",selectedOpacity:.08,disabled:"rgba(0, 0, 0, 0.26)",disabledBackground:"rgba(0, 0, 0, 0.12)",disabledOpacity:.38,focus:"rgba(0, 0, 0, 0.12)",focusOpacity:.12,activatedOpacity:.12}}}const MU=SP();function NP(){return{text:{primary:cf.white,secondary:"rgba(255, 255, 255, 0.7)",disabled:"rgba(255, 255, 255, 0.5)",icon:"rgba(255, 255, 255, 0.5)"},divider:"rgba(255, 255, 255, 0.12)",background:{paper:"#121212",default:"#121212"},action:{active:cf.white,hover:"rgba(255, 255, 255, 0.08)",hoverOpacity:.08,selected:"rgba(255, 255, 255, 0.16)",selectedOpacity:.16,disabled:"rgba(255, 255, 255, 0.3)",disabledBackground:"rgba(255, 255, 255, 0.12)",disabledOpacity:.38,focus:"rgba(255, 255, 255, 0.12)",focusOpacity:.12,activatedOpacity:.24}}}const TP=NP();function MP(a,i,p,f){const g=f.light||f,x=f.dark||f*1.5;a[i]||(a.hasOwnProperty(p)?a[i]=a[p]:i==="light"?a.light=If(a.main,g):i==="dark"&&(a.dark=Cf(a.main,x)))}function EU(a="light"){return a==="dark"?{main:qd[200],light:qd[50],dark:qd[400]}:{main:qd[700],light:qd[400],dark:qd[800]}}function DU(a="light"){return a==="dark"?{main:Kd[200],light:Kd[50],dark:Kd[400]}:{main:Kd[500],light:Kd[300],dark:Kd[700]}}function zU(a="light"){return a==="dark"?{main:Qd[500],light:Qd[300],dark:Qd[700]}:{main:Qd[700],light:Qd[400],dark:Qd[800]}}function OU(a="light"){return a==="dark"?{main:Jd[400],light:Jd[300],dark:Jd[700]}:{main:Jd[700],light:Jd[500],dark:Jd[900]}}function PU(a="light"){return a==="dark"?{main:$d[400],light:$d[300],dark:$d[700]}:{main:$d[800],light:$d[500],dark:$d[900]}}function BU(a="light"){return a==="dark"?{main:df[400],light:df[300],dark:df[700]}:{main:"#ed6c02",light:df[500],dark:df[900]}}function jk(a){const{mode:i="light",contrastThreshold:p=3,tonalOffset:f=.2,...g}=a,x=a.primary||EU(i),k=a.secondary||DU(i),N=a.error||zU(i),E=a.info||OU(i),z=a.success||PU(i),G=a.warning||BU(i);function j(P){return sU(P,TP.text.primary)>=p?TP.text.primary:MU.text.primary}const M=({color:P,name:H,mainShade:C=500,lightShade:O=300,darkShade:F=700})=>{if(P={...P},!P.main&&P[C]&&(P.main=P[C]),!P.hasOwnProperty("main"))throw new Error(qA(11,H?` (${H})`:"",C));if(typeof P.main!="string")throw new Error(qA(12,H?` (${H})`:"",JSON.stringify(P.main)));return MP(P,"light",O,f),MP(P,"dark",F,f),P.contrastText||(P.contrastText=j(P.main)),P};let R;return i==="light"?R=SP():i==="dark"&&(R=NP()),Oa({common:{...cf},mode:i,primary:M({color:x,name:"primary"}),secondary:M({color:k,name:"secondary",mainShade:"A400",lightShade:"A200",darkShade:"A700"}),error:M({color:N,name:"error"}),warning:M({color:G,name:"warning"}),info:M({color:E,name:"info"}),success:M({color:z,name:"success"}),grey:SX,contrastThreshold:p,getContrastText:j,augmentColor:M,tonalOffset:f,...R},g)}function FU(a){const i={};return Object.entries(a).forEach(f=>{const[g,x]=f;typeof x=="object"&&(i[g]=`${x.fontStyle?`${x.fontStyle} `:""}${x.fontVariant?`${x.fontVariant} `:""}${x.fontWeight?`${x.fontWeight} `:""}${x.fontStretch?`${x.fontStretch} `:""}${x.fontSize||""}${x.lineHeight?`/${x.lineHeight} `:""}${x.fontFamily||""}`)}),i}function LU(a,i){return{toolbar:{minHeight:56,[a.up("xs")]:{"@media (orientation: landscape)":{minHeight:48}},[a.up("sm")]:{minHeight:64}},...i}}function RU(a){return Math.round(a*1e5)/1e5}const EP={textTransform:"uppercase"},DP='"Roboto", "Helvetica", "Arial", sans-serif';function zP(a,i){const{fontFamily:p=DP,fontSize:f=14,fontWeightLight:g=300,fontWeightRegular:x=400,fontWeightMedium:k=500,fontWeightBold:N=700,htmlFontSize:E=16,allVariants:z,pxToRem:G,...j}=typeof i=="function"?i(a):i,M=f/14,R=G||(H=>`${H/E*M}rem`),B=(H,C,O,F,Y)=>({fontFamily:p,fontWeight:H,fontSize:R(C),lineHeight:O,...p===DP?{letterSpacing:`${RU(F/C)}em`}:{},...Y,...z}),P={h1:B(g,96,1.167,-1.5),h2:B(g,60,1.2,-.5),h3:B(x,48,1.167,0),h4:B(x,34,1.235,.25),h5:B(x,24,1.334,0),h6:B(k,20,1.6,.15),subtitle1:B(x,16,1.75,.15),subtitle2:B(k,14,1.57,.1),body1:B(x,16,1.5,.15),body2:B(x,14,1.43,.15),button:B(k,14,1.75,.4,EP),caption:B(x,12,1.66,.4),overline:B(x,12,2.66,1,EP),inherit:{fontFamily:"inherit",fontWeight:"inherit",fontSize:"inherit",lineHeight:"inherit",letterSpacing:"inherit"}};return Oa({htmlFontSize:E,pxToRem:R,fontFamily:p,fontSize:f,fontWeightLight:g,fontWeightRegular:x,fontWeightMedium:k,fontWeightBold:N,...P},j,{clone:!1})}const WU=.2,jU=.14,HU=.12;function Vr(...a){return[`${a[0]}px ${a[1]}px ${a[2]}px ${a[3]}px rgba(0,0,0,${WU})`,`${a[4]}px ${a[5]}px ${a[6]}px ${a[7]}px rgba(0,0,0,${jU})`,`${a[8]}px ${a[9]}px ${a[10]}px ${a[11]}px rgba(0,0,0,${HU})`].join(",")}const GU=["none",Vr(0,2,1,-1,0,1,1,0,0,1,3,0),Vr(0,3,1,-2,0,2,2,0,0,1,5,0),Vr(0,3,3,-2,0,3,4,0,0,1,8,0),Vr(0,2,4,-1,0,4,5,0,0,1,10,0),Vr(0,3,5,-1,0,5,8,0,0,1,14,0),Vr(0,3,5,-1,0,6,10,0,0,1,18,0),Vr(0,4,5,-2,0,7,10,1,0,2,16,1),Vr(0,5,5,-3,0,8,10,1,0,3,14,2),Vr(0,5,6,-3,0,9,12,1,0,3,16,2),Vr(0,6,6,-3,0,10,14,1,0,4,18,3),Vr(0,6,7,-4,0,11,15,1,0,4,20,3),Vr(0,7,8,-4,0,12,17,2,0,5,22,4),Vr(0,7,8,-4,0,13,19,2,0,5,24,4),Vr(0,7,9,-4,0,14,21,2,0,5,26,4),Vr(0,8,9,-5,0,15,22,2,0,6,28,5),Vr(0,8,10,-5,0,16,24,2,0,6,30,5),Vr(0,8,11,-5,0,17,26,2,0,6,32,5),Vr(0,9,11,-5,0,18,28,2,0,7,34,6),Vr(0,9,12,-6,0,19,29,2,0,7,36,6),Vr(0,10,13,-6,0,20,31,3,0,8,38,7),Vr(0,10,13,-6,0,21,33,3,0,8,40,7),Vr(0,10,14,-6,0,22,35,3,0,8,42,7),Vr(0,11,14,-7,0,23,36,3,0,9,44,8),Vr(0,11,15,-7,0,24,38,3,0,9,46,8)],VU={easeInOut:"cubic-bezier(0.4, 0, 0.2, 1)",easeOut:"cubic-bezier(0.0, 0, 0.2, 1)",easeIn:"cubic-bezier(0.4, 0, 1, 1)",sharp:"cubic-bezier(0.4, 0, 0.6, 1)"},XU={shortest:150,shorter:200,short:250,standard:300,complex:375,enteringScreen:225,leavingScreen:195};function OP(a){return`${Math.round(a)}ms`}function ZU(a){if(!a)return 0;const i=a/36;return Math.min(Math.round((4+15*i**.25+i/5)*10),3e3)}function YU(a){const i={...VU,...a.easing},p={...XU,...a.duration};return{getAutoHeightDuration:ZU,create:(g=["all"],x={})=>{const{duration:k=p.standard,easing:N=i.easeInOut,delay:E=0,...z}=x;return(Array.isArray(g)?g:[g]).map(G=>`${G} ${typeof k=="string"?k:OP(k)} ${N} ${typeof E=="string"?E:OP(E)}`).join(",")},...a,easing:i,duration:p}}const UU={mobileStepper:1e3,fab:1050,speedDial:1050,appBar:1100,drawer:1200,modal:1300,snackbar:1400,tooltip:1500};function QU(a){return hA(a)||typeof a>"u"||typeof a=="string"||typeof a=="boolean"||typeof a=="number"||Array.isArray(a)}function PP(a={}){const i={...a};function p(f){const g=Object.entries(f);for(let x=0;x<g.length;x++){const[k,N]=g[x];!QU(N)||k.startsWith("unstable_")?delete f[k]:hA(N)&&(f[k]={...N},p(f[k]))}}return p(i),`import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(i,null,2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`}function Hk(a={},...i){const{breakpoints:p,mixins:f={},spacing:g,palette:x={},transitions:k={},typography:N={},shape:E,...z}=a;if(a.vars)throw new Error(qA(20));const G=jk(x),j=xk(a);let M=Oa(j,{mixins:LU(j.breakpoints,f),palette:G,shadows:GU.slice(),typography:zP(G,N),transitions:YU(k),zIndex:{...UU}});return M=Oa(M,z),M=i.reduce((R,B)=>Oa(R,B),M),M.unstable_sxConfig={...xf,...z==null?void 0:z.unstable_sxConfig},M.unstable_sx=function(B){return Ql({sx:B,theme:this})},M.toRuntimeSource=PP,M}function Gk(a){let i;return a<1?i=5.11916*a**2:i=4.5*Math.log(a+1)+2,Math.round(i*10)/1e3}const KU=[...Array(25)].map((a,i)=>{if(i===0)return"none";const p=Gk(i);return`linear-gradient(rgba(255 255 255 / ${p}), rgba(255 255 255 / ${p}))`});function BP(a){return{inputPlaceholder:a==="dark"?.5:.42,inputUnderline:a==="dark"?.7:.42,switchTrackDisabled:a==="dark"?.2:.12,switchTrack:a==="dark"?.3:.38}}function FP(a){return a==="dark"?KU:[]}function qU(a){const{palette:i={mode:"light"},opacity:p,overlays:f,...g}=a,x=jk(i);return{palette:x,opacity:{...BP(x.mode),...p},overlays:f||FP(x.mode),...g}}function JU(a){var i;return!!a[0].match(/(cssVarPrefix|colorSchemeSelector|rootSelector|typography|mixins|breakpoints|direction|transitions)/)||!!a[0].match(/sxConfig$/)||a[0]==="palette"&&!!((i=a[1])!=null&&i.match(/(mode|contrastThreshold|tonalOffset)/))}const $U=a=>[...[...Array(25)].map((i,p)=>`--${a?`${a}-`:""}overlays-${p}`),`--${a?`${a}-`:""}palette-AppBar-darkBg`,`--${a?`${a}-`:""}palette-AppBar-darkColor`],_U=a=>(i,p)=>{const f=a.rootSelector||":root",g=a.colorSchemeSelector;let x=g;if(g==="class"&&(x=".%s"),g==="data"&&(x="[data-%s]"),g!=null&&g.startsWith("data-")&&!g.includes("%s")&&(x=`[${g}="%s"]`),a.defaultColorScheme===i){if(i==="dark"){const k={};return $U(a.cssVarPrefix).forEach(N=>{k[N]=p[N],delete p[N]}),x==="media"?{[f]:p,"@media (prefers-color-scheme: dark)":{[f]:k}}:x?{[x.replace("%s",i)]:k,[`${f}, ${x.replace("%s",i)}`]:p}:{[f]:{...p,...k}}}if(x&&x!=="media")return`${f}, ${x.replace("%s",String(i))}`}else if(i){if(x==="media")return{[`@media (prefers-color-scheme: ${String(i)})`]:{[f]:p}};if(x)return x.replace("%s",String(i))}return f};function eQ(a,i){i.forEach(p=>{a[p]||(a[p]={})})}function it(a,i,p){!a[i]&&p&&(a[i]=p)}function Sf(a){return!a||!a.startsWith("hsl")?a:rP(a)}function tl(a,i){`${i}Channel`in a||(a[`${i}Channel`]=kf(Sf(a[i]),`MUI: Can't create \`palette.${i}Channel\` because \`palette.${i}\` is not one of these formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().
To suppress this warning, you need to explicitly provide the \`palette.${i}Channel\` as a string (in rgb format, for example "12 12 12") or undefined if you want to remove the channel token.`))}function tQ(a){return typeof a=="number"?`${a}px`:typeof a=="string"||typeof a=="function"||Array.isArray(a)?a:"8px"}const fA=a=>{try{return a()}catch{}},nQ=(a="mui")=>CU(a);function Vk(a,i,p,f){if(!i)return;i=i===!0?{}:i;const g=f==="dark"?"dark":"light";if(!p){a[f]=qU({...i,palette:{mode:g,...i==null?void 0:i.palette}});return}const{palette:x,...k}=Hk({...p,palette:{mode:g,...i==null?void 0:i.palette}});return a[f]={...i,palette:x,opacity:{...BP(g),...i==null?void 0:i.opacity},overlays:(i==null?void 0:i.overlays)||FP(g)},k}function rQ(a={},...i){const{colorSchemes:p={light:!0},defaultColorScheme:f,disableCssColorScheme:g=!1,cssVarPrefix:x="mui",shouldSkipGeneratingVar:k=JU,colorSchemeSelector:N=p.light&&p.dark?"media":void 0,rootSelector:E=":root",...z}=a,G=Object.keys(p)[0],j=f||(p.light&&G!=="light"?"light":G),M=nQ(x),{[j]:R,light:B,dark:P,...H}=p,C={...H};let O=R;if((j==="dark"&&!("dark"in p)||j==="light"&&!("light"in p))&&(O=!0),!O)throw new Error(qA(21,j));const F=Vk(C,O,z,j);B&&!C.light&&Vk(C,B,void 0,"light"),P&&!C.dark&&Vk(C,P,void 0,"dark");let Y={defaultColorScheme:j,...F,cssVarPrefix:x,colorSchemeSelector:N,rootSelector:E,getCssVar:M,colorSchemes:C,font:{...FU(F.typography),...F.font},spacing:tQ(z.spacing)};Object.keys(Y.colorSchemes).forEach(ue=>{const Z=Y.colorSchemes[ue].palette,ye=pe=>{const Q=pe.split("-"),ke=Q[1],ie=Q[2];return M(pe,Z[ke][ie])};if(Z.mode==="light"&&(it(Z.common,"background","#fff"),it(Z.common,"onBackground","#000")),Z.mode==="dark"&&(it(Z.common,"background","#000"),it(Z.common,"onBackground","#fff")),eQ(Z,["Alert","AppBar","Avatar","Button","Chip","FilledInput","LinearProgress","Skeleton","Slider","SnackbarContent","SpeedDialAction","StepConnector","StepContent","Switch","TableCell","Tooltip"]),Z.mode==="light"){it(Z.Alert,"errorColor",Cr(Z.error.light,.6)),it(Z.Alert,"infoColor",Cr(Z.info.light,.6)),it(Z.Alert,"successColor",Cr(Z.success.light,.6)),it(Z.Alert,"warningColor",Cr(Z.warning.light,.6)),it(Z.Alert,"errorFilledBg",ye("palette-error-main")),it(Z.Alert,"infoFilledBg",ye("palette-info-main")),it(Z.Alert,"successFilledBg",ye("palette-success-main")),it(Z.Alert,"warningFilledBg",ye("palette-warning-main")),it(Z.Alert,"errorFilledColor",fA(()=>Z.getContrastText(Z.error.main))),it(Z.Alert,"infoFilledColor",fA(()=>Z.getContrastText(Z.info.main))),it(Z.Alert,"successFilledColor",fA(()=>Z.getContrastText(Z.success.main))),it(Z.Alert,"warningFilledColor",fA(()=>Z.getContrastText(Z.warning.main))),it(Z.Alert,"errorStandardBg",Ir(Z.error.light,.9)),it(Z.Alert,"infoStandardBg",Ir(Z.info.light,.9)),it(Z.Alert,"successStandardBg",Ir(Z.success.light,.9)),it(Z.Alert,"warningStandardBg",Ir(Z.warning.light,.9)),it(Z.Alert,"errorIconColor",ye("palette-error-main")),it(Z.Alert,"infoIconColor",ye("palette-info-main")),it(Z.Alert,"successIconColor",ye("palette-success-main")),it(Z.Alert,"warningIconColor",ye("palette-warning-main")),it(Z.AppBar,"defaultBg",ye("palette-grey-100")),it(Z.Avatar,"defaultBg",ye("palette-grey-400")),it(Z.Button,"inheritContainedBg",ye("palette-grey-300")),it(Z.Button,"inheritContainedHoverBg",ye("palette-grey-A100")),it(Z.Chip,"defaultBorder",ye("palette-grey-400")),it(Z.Chip,"defaultAvatarColor",ye("palette-grey-700")),it(Z.Chip,"defaultIconColor",ye("palette-grey-700")),it(Z.FilledInput,"bg","rgba(0, 0, 0, 0.06)"),it(Z.FilledInput,"hoverBg","rgba(0, 0, 0, 0.09)"),it(Z.FilledInput,"disabledBg","rgba(0, 0, 0, 0.12)"),it(Z.LinearProgress,"primaryBg",Ir(Z.primary.main,.62)),it(Z.LinearProgress,"secondaryBg",Ir(Z.secondary.main,.62)),it(Z.LinearProgress,"errorBg",Ir(Z.error.main,.62)),it(Z.LinearProgress,"infoBg",Ir(Z.info.main,.62)),it(Z.LinearProgress,"successBg",Ir(Z.success.main,.62)),it(Z.LinearProgress,"warningBg",Ir(Z.warning.main,.62)),it(Z.Skeleton,"bg",`rgba(${ye("palette-text-primaryChannel")} / 0.11)`),it(Z.Slider,"primaryTrack",Ir(Z.primary.main,.62)),it(Z.Slider,"secondaryTrack",Ir(Z.secondary.main,.62)),it(Z.Slider,"errorTrack",Ir(Z.error.main,.62)),it(Z.Slider,"infoTrack",Ir(Z.info.main,.62)),it(Z.Slider,"successTrack",Ir(Z.success.main,.62)),it(Z.Slider,"warningTrack",Ir(Z.warning.main,.62));const pe=_b(Z.background.default,.8);it(Z.SnackbarContent,"bg",pe),it(Z.SnackbarContent,"color",fA(()=>Z.getContrastText(pe))),it(Z.SpeedDialAction,"fabHoverBg",_b(Z.background.paper,.15)),it(Z.StepConnector,"border",ye("palette-grey-400")),it(Z.StepContent,"border",ye("palette-grey-400")),it(Z.Switch,"defaultColor",ye("palette-common-white")),it(Z.Switch,"defaultDisabledColor",ye("palette-grey-100")),it(Z.Switch,"primaryDisabledColor",Ir(Z.primary.main,.62)),it(Z.Switch,"secondaryDisabledColor",Ir(Z.secondary.main,.62)),it(Z.Switch,"errorDisabledColor",Ir(Z.error.main,.62)),it(Z.Switch,"infoDisabledColor",Ir(Z.info.main,.62)),it(Z.Switch,"successDisabledColor",Ir(Z.success.main,.62)),it(Z.Switch,"warningDisabledColor",Ir(Z.warning.main,.62)),it(Z.TableCell,"border",Ir($b(Z.divider,1),.88)),it(Z.Tooltip,"bg",$b(Z.grey[700],.92))}if(Z.mode==="dark"){it(Z.Alert,"errorColor",Ir(Z.error.light,.6)),it(Z.Alert,"infoColor",Ir(Z.info.light,.6)),it(Z.Alert,"successColor",Ir(Z.success.light,.6)),it(Z.Alert,"warningColor",Ir(Z.warning.light,.6)),it(Z.Alert,"errorFilledBg",ye("palette-error-dark")),it(Z.Alert,"infoFilledBg",ye("palette-info-dark")),it(Z.Alert,"successFilledBg",ye("palette-success-dark")),it(Z.Alert,"warningFilledBg",ye("palette-warning-dark")),it(Z.Alert,"errorFilledColor",fA(()=>Z.getContrastText(Z.error.dark))),it(Z.Alert,"infoFilledColor",fA(()=>Z.getContrastText(Z.info.dark))),it(Z.Alert,"successFilledColor",fA(()=>Z.getContrastText(Z.success.dark))),it(Z.Alert,"warningFilledColor",fA(()=>Z.getContrastText(Z.warning.dark))),it(Z.Alert,"errorStandardBg",Cr(Z.error.light,.9)),it(Z.Alert,"infoStandardBg",Cr(Z.info.light,.9)),it(Z.Alert,"successStandardBg",Cr(Z.success.light,.9)),it(Z.Alert,"warningStandardBg",Cr(Z.warning.light,.9)),it(Z.Alert,"errorIconColor",ye("palette-error-main")),it(Z.Alert,"infoIconColor",ye("palette-info-main")),it(Z.Alert,"successIconColor",ye("palette-success-main")),it(Z.Alert,"warningIconColor",ye("palette-warning-main")),it(Z.AppBar,"defaultBg",ye("palette-grey-900")),it(Z.AppBar,"darkBg",ye("palette-background-paper")),it(Z.AppBar,"darkColor",ye("palette-text-primary")),it(Z.Avatar,"defaultBg",ye("palette-grey-600")),it(Z.Button,"inheritContainedBg",ye("palette-grey-800")),it(Z.Button,"inheritContainedHoverBg",ye("palette-grey-700")),it(Z.Chip,"defaultBorder",ye("palette-grey-700")),it(Z.Chip,"defaultAvatarColor",ye("palette-grey-300")),it(Z.Chip,"defaultIconColor",ye("palette-grey-300")),it(Z.FilledInput,"bg","rgba(255, 255, 255, 0.09)"),it(Z.FilledInput,"hoverBg","rgba(255, 255, 255, 0.13)"),it(Z.FilledInput,"disabledBg","rgba(255, 255, 255, 0.12)"),it(Z.LinearProgress,"primaryBg",Cr(Z.primary.main,.5)),it(Z.LinearProgress,"secondaryBg",Cr(Z.secondary.main,.5)),it(Z.LinearProgress,"errorBg",Cr(Z.error.main,.5)),it(Z.LinearProgress,"infoBg",Cr(Z.info.main,.5)),it(Z.LinearProgress,"successBg",Cr(Z.success.main,.5)),it(Z.LinearProgress,"warningBg",Cr(Z.warning.main,.5)),it(Z.Skeleton,"bg",`rgba(${ye("palette-text-primaryChannel")} / 0.13)`),it(Z.Slider,"primaryTrack",Cr(Z.primary.main,.5)),it(Z.Slider,"secondaryTrack",Cr(Z.secondary.main,.5)),it(Z.Slider,"errorTrack",Cr(Z.error.main,.5)),it(Z.Slider,"infoTrack",Cr(Z.info.main,.5)),it(Z.Slider,"successTrack",Cr(Z.success.main,.5)),it(Z.Slider,"warningTrack",Cr(Z.warning.main,.5));const pe=_b(Z.background.default,.98);it(Z.SnackbarContent,"bg",pe),it(Z.SnackbarContent,"color",fA(()=>Z.getContrastText(pe))),it(Z.SpeedDialAction,"fabHoverBg",_b(Z.background.paper,.15)),it(Z.StepConnector,"border",ye("palette-grey-600")),it(Z.StepContent,"border",ye("palette-grey-600")),it(Z.Switch,"defaultColor",ye("palette-grey-300")),it(Z.Switch,"defaultDisabledColor",ye("palette-grey-600")),it(Z.Switch,"primaryDisabledColor",Cr(Z.primary.main,.55)),it(Z.Switch,"secondaryDisabledColor",Cr(Z.secondary.main,.55)),it(Z.Switch,"errorDisabledColor",Cr(Z.error.main,.55)),it(Z.Switch,"infoDisabledColor",Cr(Z.info.main,.55)),it(Z.Switch,"successDisabledColor",Cr(Z.success.main,.55)),it(Z.Switch,"warningDisabledColor",Cr(Z.warning.main,.55)),it(Z.TableCell,"border",Cr($b(Z.divider,1),.68)),it(Z.Tooltip,"bg",$b(Z.grey[700],.92))}tl(Z.background,"default"),tl(Z.background,"paper"),tl(Z.common,"background"),tl(Z.common,"onBackground"),tl(Z,"divider"),Object.keys(Z).forEach(pe=>{const Q=Z[pe];Q&&typeof Q=="object"&&(Q.main&&it(Z[pe],"mainChannel",kf(Sf(Q.main))),Q.light&&it(Z[pe],"lightChannel",kf(Sf(Q.light))),Q.dark&&it(Z[pe],"darkChannel",kf(Sf(Q.dark))),Q.contrastText&&it(Z[pe],"contrastTextChannel",kf(Sf(Q.contrastText))),pe==="text"&&(tl(Z[pe],"primary"),tl(Z[pe],"secondary")),pe==="action"&&(Q.active&&tl(Z[pe],"active"),Q.selected&&tl(Z[pe],"selected")))})}),Y=i.reduce((ue,Z)=>Oa(ue,Z),Y);const ae={prefix:x,disableCssColorScheme:g,shouldSkipGeneratingVar:k,getSelector:_U(Y)},{vars:te,generateThemeVars:oe,generateStyleSheets:fe}=NU(Y,ae);return Y.vars=te,Object.entries(Y.colorSchemes[Y.defaultColorScheme]).forEach(([ue,Z])=>{Y[ue]=Z}),Y.generateThemeVars=oe,Y.generateStyleSheets=fe,Y.generateSpacing=function(){return QO(z.spacing,bk(this))},Y.getColorSchemeSelector=TU(N),Y.spacing=Y.generateSpacing(),Y.shouldSkipGeneratingVar=k,Y.unstable_sxConfig={...xf,...z==null?void 0:z.unstable_sxConfig},Y.unstable_sx=function(Z){return Ql({sx:Z,theme:this})},Y.toRuntimeSource=PP,Y}function LP(a,i,p){a.colorSchemes&&p&&(a.colorSchemes[i]={...p!==!0&&p,palette:jk({...p===!0?{}:p.palette,mode:i})})}function r0(a={},...i){const{palette:p,cssVariables:f=!1,colorSchemes:g=p?void 0:{light:!0},defaultColorScheme:x=p==null?void 0:p.mode,...k}=a,N=x||"light",E=g==null?void 0:g[N],z={...g,...p?{[N]:{...typeof E!="boolean"&&E,palette:p}}:void 0};if(f===!1){if(!("colorSchemes"in a))return Hk(a,...i);let G=p;"palette"in a||z[N]&&(z[N]!==!0?G=z[N].palette:N==="dark"&&(G={mode:"dark"}));const j=Hk({...a,palette:G},...i);return j.defaultColorScheme=N,j.colorSchemes=z,j.palette.mode==="light"&&(j.colorSchemes.light={...z.light!==!0&&z.light,palette:j.palette},LP(j,"dark",z.dark)),j.palette.mode==="dark"&&(j.colorSchemes.dark={...z.dark!==!0&&z.dark,palette:j.palette},LP(j,"light",z.light)),j}return!p&&!("light"in z)&&N==="light"&&(z.light=!0),rQ({...k,colorSchemes:z,defaultColorScheme:N,...typeof f!="boolean"&&f},...i)}const Xk=r0();function sp(){const a=kk(Xk);return a[Wi]||a}function RP(a){return a!=="ownerState"&&a!=="theme"&&a!=="sx"&&a!=="as"}const qa=a=>RP(a)&&a!=="classes",Lt=YY({themeId:Wi,defaultTheme:Xk,rootShouldForwardProp:qa});function WP({theme:a,...i}){const p=Wi in a?a[Wi]:void 0;return q.jsx(xP,{...i,themeId:p?Wi:void 0,theme:p||a})}const s0={attribute:"data-mui-color-scheme",colorSchemeStorageKey:"mui-color-scheme",defaultLightColorScheme:"light",defaultDarkColorScheme:"dark",modeStorageKey:"mui-mode"},{CssVarsProvider:sQ,useColorScheme:qbe,getInitColorSchemeScript:Jbe}=kU({themeId:Wi,theme:()=>r0({cssVariables:!0}),colorSchemeStorageKey:s0.colorSchemeStorageKey,modeStorageKey:s0.modeStorageKey,defaultColorScheme:{light:s0.defaultLightColorScheme,dark:s0.defaultDarkColorScheme},resolveTheme:a=>{const i={...a,typography:zP(a.palette,a.typography)};return i.unstable_sx=function(f){return Ql({sx:f,theme:this})},i}}),aQ=sQ;function oQ({theme:a,...i}){return typeof a=="function"?q.jsx(WP,{theme:a,...i}):"colorSchemes"in(Wi in a?a[Wi]:a)?q.jsx(aQ,{theme:a,...i}):q.jsx(WP,{theme:a,...i})}function iQ(a){return q.jsx(LY,{...a,defaultTheme:Xk,themeId:Wi})}function Zk(a){return function(p){return q.jsx(iQ,{styles:typeof a=="function"?f=>a({theme:f,...p}):a})}}function AQ(){return KO}const cr=gU;function tr(a){return mU(a)}function lQ(a){return Xn("MuiSvgIcon",a)}Ln("MuiSvgIcon",["root","colorPrimary","colorSecondary","colorAction","colorError","colorDisabled","fontSizeInherit","fontSizeSmall","fontSizeMedium","fontSizeLarge"]);const uQ=a=>{const{color:i,fontSize:p,classes:f}=a,g={root:["root",i!=="inherit"&&`color${tn(i)}`,`fontSize${tn(p)}`]};return qn(g,lQ,f)},cQ=Lt("svg",{name:"MuiSvgIcon",slot:"Root",overridesResolver:(a,i)=>{const{ownerState:p}=a;return[i.root,p.color!=="inherit"&&i[`color${tn(p.color)}`],i[`fontSize${tn(p.fontSize)}`]]}})(cr(({theme:a})=>{var i,p,f,g,x,k,N,E,z,G,j,M,R,B;return{userSelect:"none",width:"1em",height:"1em",display:"inline-block",flexShrink:0,transition:(g=(i=a.transitions)==null?void 0:i.create)==null?void 0:g.call(i,"fill",{duration:(f=(p=(a.vars??a).transitions)==null?void 0:p.duration)==null?void 0:f.shorter}),variants:[{props:P=>!P.hasSvgAsChild,style:{fill:"currentColor"}},{props:{fontSize:"inherit"},style:{fontSize:"inherit"}},{props:{fontSize:"small"},style:{fontSize:((k=(x=a.typography)==null?void 0:x.pxToRem)==null?void 0:k.call(x,20))||"1.25rem"}},{props:{fontSize:"medium"},style:{fontSize:((E=(N=a.typography)==null?void 0:N.pxToRem)==null?void 0:E.call(N,24))||"1.5rem"}},{props:{fontSize:"large"},style:{fontSize:((G=(z=a.typography)==null?void 0:z.pxToRem)==null?void 0:G.call(z,35))||"2.1875rem"}},...Object.entries((a.vars??a).palette).filter(([,P])=>P&&P.main).map(([P])=>{var H,C;return{props:{color:P},style:{color:(C=(H=(a.vars??a).palette)==null?void 0:H[P])==null?void 0:C.main}}}),{props:{color:"action"},style:{color:(M=(j=(a.vars??a).palette)==null?void 0:j.action)==null?void 0:M.active}},{props:{color:"disabled"},style:{color:(B=(R=(a.vars??a).palette)==null?void 0:R.action)==null?void 0:B.disabled}},{props:{color:"inherit"},style:{color:void 0}}]}})),a0=se.forwardRef(function(i,p){const f=tr({props:i,name:"MuiSvgIcon"}),{children:g,className:x,color:k="inherit",component:N="svg",fontSize:E="medium",htmlColor:z,inheritViewBox:G=!1,titleAccess:j,viewBox:M="0 0 24 24",...R}=f,B=se.isValidElement(g)&&g.type==="svg",P={...f,color:k,component:N,fontSize:E,instanceFontSize:i.fontSize,inheritViewBox:G,viewBox:M,hasSvgAsChild:B},H={};G||(H.viewBox=M);const C=uQ(P);return q.jsxs(cQ,{as:N,className:fn(C.root,x),focusable:"false",color:z,"aria-hidden":j?void 0:!0,role:j?"img":void 0,ref:p,...H,...R,...B&&g.props,ownerState:P,children:[B?g.props.children:g,j?q.jsx("title",{children:j}):null]})});a0&&(a0.muiName="SvgIcon");function nl(a,i){function p(f,g){return q.jsx(a0,{"data-testid":`${i}Icon`,ref:g,...f,children:a})}return p.muiName=a0.muiName,se.memo(se.forwardRef(p))}function jP(a,i){if(a==null)return{};var p={};for(var f in a)if({}.hasOwnProperty.call(a,f)){if(i.includes(f))continue;p[f]=a[f]}return p}function Yk(a,i){return Yk=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(p,f){return p.__proto__=f,p},Yk(a,i)}function HP(a,i){a.prototype=Object.create(i.prototype),a.prototype.constructor=a,Yk(a,i)}const GP={disabled:!1},o0=Ya.createContext(null);var dQ=function(i){return i.scrollTop},Nf="unmounted",pc="exited",hc="entering",ap="entered",Uk="exiting",mA=function(a){HP(i,a);function i(f,g){var x;x=a.call(this,f,g)||this;var k=g,N=k&&!k.isMounting?f.enter:f.appear,E;return x.appearStatus=null,f.in?N?(E=pc,x.appearStatus=hc):E=ap:f.unmountOnExit||f.mountOnEnter?E=Nf:E=pc,x.state={status:E},x.nextCallback=null,x}i.getDerivedStateFromProps=function(g,x){var k=g.in;return k&&x.status===Nf?{status:pc}:null};var p=i.prototype;return p.componentDidMount=function(){this.updateStatus(!0,this.appearStatus)},p.componentDidUpdate=function(g){var x=null;if(g!==this.props){var k=this.state.status;this.props.in?k!==hc&&k!==ap&&(x=hc):(k===hc||k===ap)&&(x=Uk)}this.updateStatus(!1,x)},p.componentWillUnmount=function(){this.cancelNextCallback()},p.getTimeouts=function(){var g=this.props.timeout,x,k,N;return x=k=N=g,g!=null&&typeof g!="number"&&(x=g.exit,k=g.enter,N=g.appear!==void 0?g.appear:k),{exit:x,enter:k,appear:N}},p.updateStatus=function(g,x){if(g===void 0&&(g=!1),x!==null)if(this.cancelNextCallback(),x===hc){if(this.props.unmountOnExit||this.props.mountOnEnter){var k=this.props.nodeRef?this.props.nodeRef.current:lb.findDOMNode(this);k&&dQ(k)}this.performEnter(g)}else this.performExit();else this.props.unmountOnExit&&this.state.status===pc&&this.setState({status:Nf})},p.performEnter=function(g){var x=this,k=this.props.enter,N=this.context?this.context.isMounting:g,E=this.props.nodeRef?[N]:[lb.findDOMNode(this),N],z=E[0],G=E[1],j=this.getTimeouts(),M=N?j.appear:j.enter;if(!g&&!k||GP.disabled){this.safeSetState({status:ap},function(){x.props.onEntered(z)});return}this.props.onEnter(z,G),this.safeSetState({status:hc},function(){x.props.onEntering(z,G),x.onTransitionEnd(M,function(){x.safeSetState({status:ap},function(){x.props.onEntered(z,G)})})})},p.performExit=function(){var g=this,x=this.props.exit,k=this.getTimeouts(),N=this.props.nodeRef?void 0:lb.findDOMNode(this);if(!x||GP.disabled){this.safeSetState({status:pc},function(){g.props.onExited(N)});return}this.props.onExit(N),this.safeSetState({status:Uk},function(){g.props.onExiting(N),g.onTransitionEnd(k.exit,function(){g.safeSetState({status:pc},function(){g.props.onExited(N)})})})},p.cancelNextCallback=function(){this.nextCallback!==null&&(this.nextCallback.cancel(),this.nextCallback=null)},p.safeSetState=function(g,x){x=this.setNextCallback(x),this.setState(g,x)},p.setNextCallback=function(g){var x=this,k=!0;return this.nextCallback=function(N){k&&(k=!1,x.nextCallback=null,g(N))},this.nextCallback.cancel=function(){k=!1},this.nextCallback},p.onTransitionEnd=function(g,x){this.setNextCallback(x);var k=this.props.nodeRef?this.props.nodeRef.current:lb.findDOMNode(this),N=g==null&&!this.props.addEndListener;if(!k||N){setTimeout(this.nextCallback,0);return}if(this.props.addEndListener){var E=this.props.nodeRef?[this.nextCallback]:[k,this.nextCallback],z=E[0],G=E[1];this.props.addEndListener(z,G)}g!=null&&setTimeout(this.nextCallback,g)},p.render=function(){var g=this.state.status;if(g===Nf)return null;var x=this.props,k=x.children;x.in,x.mountOnEnter,x.unmountOnExit,x.appear,x.enter,x.exit,x.timeout,x.addEndListener,x.onEnter,x.onEntering,x.onEntered,x.onExit,x.onExiting,x.onExited,x.nodeRef;var N=jP(x,["children","in","mountOnEnter","unmountOnExit","appear","enter","exit","timeout","addEndListener","onEnter","onEntering","onEntered","onExit","onExiting","onExited","nodeRef"]);return Ya.createElement(o0.Provider,{value:null},typeof k=="function"?k(g,N):Ya.cloneElement(Ya.Children.only(k),N))},i}(Ya.Component);mA.contextType=o0,mA.propTypes={};function op(){}mA.defaultProps={in:!1,mountOnEnter:!1,unmountOnExit:!1,appear:!1,enter:!0,exit:!0,onEnter:op,onEntering:op,onEntered:op,onExit:op,onExiting:op,onExited:op},mA.UNMOUNTED=Nf,mA.EXITED=pc,mA.ENTERING=hc,mA.ENTERED=ap,mA.EXITING=Uk;function pQ(a){if(a===void 0)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return a}function Qk(a,i){var p=function(x){return i&&se.isValidElement(x)?i(x):x},f=Object.create(null);return a&&se.Children.map(a,function(g){return g}).forEach(function(g){f[g.key]=p(g)}),f}function hQ(a,i){a=a||{},i=i||{};function p(G){return G in i?i[G]:a[G]}var f=Object.create(null),g=[];for(var x in a)x in i?g.length&&(f[x]=g,g=[]):g.push(x);var k,N={};for(var E in i){if(f[E])for(k=0;k<f[E].length;k++){var z=f[E][k];N[f[E][k]]=p(z)}N[E]=p(E)}for(k=0;k<g.length;k++)N[g[k]]=p(g[k]);return N}function fc(a,i,p){return p[i]!=null?p[i]:a.props[i]}function fQ(a,i){return Qk(a.children,function(p){return se.cloneElement(p,{onExited:i.bind(null,p),in:!0,appear:fc(p,"appear",a),enter:fc(p,"enter",a),exit:fc(p,"exit",a)})})}function mQ(a,i,p){var f=Qk(a.children),g=hQ(i,f);return Object.keys(g).forEach(function(x){var k=g[x];if(se.isValidElement(k)){var N=x in i,E=x in f,z=i[x],G=se.isValidElement(z)&&!z.props.in;E&&(!N||G)?g[x]=se.cloneElement(k,{onExited:p.bind(null,k),in:!0,exit:fc(k,"exit",a),enter:fc(k,"enter",a)}):!E&&N&&!G?g[x]=se.cloneElement(k,{in:!1}):E&&N&&se.isValidElement(z)&&(g[x]=se.cloneElement(k,{onExited:p.bind(null,k),in:z.props.in,exit:fc(k,"exit",a),enter:fc(k,"enter",a)}))}}),g}var gQ=Object.values||function(a){return Object.keys(a).map(function(i){return a[i]})},yQ={component:"div",childFactory:function(i){return i}},Kk=function(a){HP(i,a);function i(f,g){var x;x=a.call(this,f,g)||this;var k=x.handleExited.bind(pQ(x));return x.state={contextValue:{isMounting:!0},handleExited:k,firstRender:!0},x}var p=i.prototype;return p.componentDidMount=function(){this.mounted=!0,this.setState({contextValue:{isMounting:!1}})},p.componentWillUnmount=function(){this.mounted=!1},i.getDerivedStateFromProps=function(g,x){var k=x.children,N=x.handleExited,E=x.firstRender;return{children:E?fQ(g,N):mQ(g,k,N),firstRender:!1}},p.handleExited=function(g,x){var k=Qk(this.props.children);g.key in k||(g.props.onExited&&g.props.onExited(x),this.mounted&&this.setState(function(N){var E=ub({},N.children);return delete E[g.key],{children:E}}))},p.render=function(){var g=this.props,x=g.component,k=g.childFactory,N=jP(g,["component","childFactory"]),E=this.state.contextValue,z=gQ(this.state.children).map(k);return delete N.appear,delete N.enter,delete N.exit,x===null?Ya.createElement(o0.Provider,{value:E},z):Ya.createElement(o0.Provider,{value:E},Ya.createElement(x,N,z))},i}(Ya.Component);Kk.propTypes={},Kk.defaultProps=yQ;const VP=a=>a.scrollTop;function i0(a,i){const{timeout:p,easing:f,style:g={}}=a;return{duration:g.transitionDuration??(typeof p=="number"?p:p[i.mode]||0),easing:g.transitionTimingFunction??(typeof f=="object"?f[i.mode]:f),delay:g.transitionDelay}}function bQ(a){return Xn("MuiPaper",a)}Ln("MuiPaper",["root","rounded","outlined","elevation","elevation0","elevation1","elevation2","elevation3","elevation4","elevation5","elevation6","elevation7","elevation8","elevation9","elevation10","elevation11","elevation12","elevation13","elevation14","elevation15","elevation16","elevation17","elevation18","elevation19","elevation20","elevation21","elevation22","elevation23","elevation24"]);const vQ=a=>{const{square:i,elevation:p,variant:f,classes:g}=a,x={root:["root",f,!i&&"rounded",f==="elevation"&&`elevation${p}`]};return qn(x,bQ,g)},xQ=Lt("div",{name:"MuiPaper",slot:"Root",overridesResolver:(a,i)=>{const{ownerState:p}=a;return[i.root,i[p.variant],!p.square&&i.rounded,p.variant==="elevation"&&i[`elevation${p.elevation}`]]}})(cr(({theme:a})=>({backgroundColor:(a.vars||a).palette.background.paper,color:(a.vars||a).palette.text.primary,transition:a.transitions.create("box-shadow"),variants:[{props:({ownerState:i})=>!i.square,style:{borderRadius:a.shape.borderRadius}},{props:{variant:"outlined"},style:{border:`1px solid ${(a.vars||a).palette.divider}`}},{props:{variant:"elevation"},style:{boxShadow:"var(--Paper-shadow)",backgroundImage:"var(--Paper-overlay)"}}]}))),Tf=se.forwardRef(function(i,p){var R;const f=tr({props:i,name:"MuiPaper"}),g=sp(),{className:x,component:k="div",elevation:N=1,square:E=!1,variant:z="elevation",...G}=f,j={...f,component:k,elevation:N,square:E,variant:z},M=vQ(j);return q.jsx(xQ,{as:k,ownerState:j,className:fn(M.root,x),ref:p,...G,style:{...z==="elevation"&&{"--Paper-shadow":(g.vars||g).shadows[N],...g.vars&&{"--Paper-overlay":(R=g.vars.overlays)==null?void 0:R[N]},...!g.vars&&g.palette.mode==="dark"&&{"--Paper-overlay":`linear-gradient(${Pa("#fff",Gk(N))}, ${Pa("#fff",Gk(N))})`}},...G.style}})});function yo(a,i){const{className:p,elementType:f,ownerState:g,externalForwardedProps:x,getSlotOwnerState:k,internalForwardedProps:N,...E}=i,{component:z,slots:G={[a]:void 0},slotProps:j={[a]:void 0},...M}=x,R=G[a]||f,B=fP(j[a],g),{props:{component:P,...H},internalRef:C}=hP({className:p,...E,externalForwardedProps:a==="root"?M:void 0,externalSlotProps:B}),O=js(C,B==null?void 0:B.ref,i.ref),F=k?k(H):{},Y={...g,...F},ae=a==="root"?P||z:P,te=dP(R,{...a==="root"&&!z&&!G[a]&&N,...a!=="root"&&!G[a]&&N,...H,...ae&&{as:ae},ref:O},Y);return Object.keys(F).forEach(oe=>{delete te[oe]}),[R,te]}class A0{constructor(){qs(this,"mountEffect",()=>{this.shouldMount&&!this.didMount&&this.ref.current!==null&&(this.didMount=!0,this.mounted.resolve())});this.ref={current:null},this.mounted=null,this.didMount=!1,this.shouldMount=!1,this.setShouldMount=null}static create(){return new A0}static use(){const i=lP(A0.create).current,[p,f]=se.useState(!1);return i.shouldMount=p,i.setShouldMount=f,se.useEffect(i.mountEffect,[p]),i}mount(){return this.mounted||(this.mounted=kQ(),this.shouldMount=!0,this.setShouldMount(this.shouldMount)),this.mounted}start(...i){this.mount().then(()=>{var p;return(p=this.ref.current)==null?void 0:p.start(...i)})}stop(...i){this.mount().then(()=>{var p;return(p=this.ref.current)==null?void 0:p.stop(...i)})}pulsate(...i){this.mount().then(()=>{var p;return(p=this.ref.current)==null?void 0:p.pulsate(...i)})}}function wQ(){return A0.use()}function kQ(){let a,i;const p=new Promise((f,g)=>{a=f,i=g});return p.resolve=a,p.reject=i,p}function CQ(a){const{className:i,classes:p,pulsate:f=!1,rippleX:g,rippleY:x,rippleSize:k,in:N,onExited:E,timeout:z}=a,[G,j]=se.useState(!1),M=fn(i,p.ripple,p.rippleVisible,f&&p.ripplePulsate),R={width:k,height:k,top:-(k/2)+x,left:-(k/2)+g},B=fn(p.child,G&&p.childLeaving,f&&p.childPulsate);return!N&&!G&&j(!0),se.useEffect(()=>{if(!N&&E!=null){const P=setTimeout(E,z);return()=>{clearTimeout(P)}}},[E,N,z]),q.jsx("span",{className:M,style:R,children:q.jsx("span",{className:B})})}const hi=Ln("MuiTouchRipple",["root","ripple","rippleVisible","ripplePulsate","child","childLeaving","childPulsate"]),qk=550,IQ=80,SQ=fk`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`,NQ=fk`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`,TQ=fk`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`,MQ=Lt("span",{name:"MuiTouchRipple",slot:"Root"})({overflow:"hidden",pointerEvents:"none",position:"absolute",zIndex:0,top:0,right:0,bottom:0,left:0,borderRadius:"inherit"}),EQ=Lt(CQ,{name:"MuiTouchRipple",slot:"Ripple"})`
  opacity: 0;
  position: absolute;

  &.${hi.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${SQ};
    animation-duration: ${qk}ms;
    animation-timing-function: ${({theme:a})=>a.transitions.easing.easeInOut};
  }

  &.${hi.ripplePulsate} {
    animation-duration: ${({theme:a})=>a.transitions.duration.shorter}ms;
  }

  & .${hi.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${hi.childLeaving} {
    opacity: 0;
    animation-name: ${NQ};
    animation-duration: ${qk}ms;
    animation-timing-function: ${({theme:a})=>a.transitions.easing.easeInOut};
  }

  & .${hi.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${TQ};
    animation-duration: 2500ms;
    animation-timing-function: ${({theme:a})=>a.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`,DQ=se.forwardRef(function(i,p){const f=tr({props:i,name:"MuiTouchRipple"}),{center:g=!1,classes:x={},className:k,...N}=f,[E,z]=se.useState([]),G=se.useRef(0),j=se.useRef(null);se.useEffect(()=>{j.current&&(j.current(),j.current=null)},[E]);const M=se.useRef(!1),R=Ok(),B=se.useRef(null),P=se.useRef(null),H=se.useCallback(Y=>{const{pulsate:ae,rippleX:te,rippleY:oe,rippleSize:fe,cb:ue}=Y;z(Z=>[...Z,q.jsx(EQ,{classes:{ripple:fn(x.ripple,hi.ripple),rippleVisible:fn(x.rippleVisible,hi.rippleVisible),ripplePulsate:fn(x.ripplePulsate,hi.ripplePulsate),child:fn(x.child,hi.child),childLeaving:fn(x.childLeaving,hi.childLeaving),childPulsate:fn(x.childPulsate,hi.childPulsate)},timeout:qk,pulsate:ae,rippleX:te,rippleY:oe,rippleSize:fe},G.current)]),G.current+=1,j.current=ue},[x]),C=se.useCallback((Y={},ae={},te=()=>{})=>{const{pulsate:oe=!1,center:fe=g||ae.pulsate,fakeElement:ue=!1}=ae;if((Y==null?void 0:Y.type)==="mousedown"&&M.current){M.current=!1;return}(Y==null?void 0:Y.type)==="touchstart"&&(M.current=!0);const Z=ue?null:P.current,ye=Z?Z.getBoundingClientRect():{width:0,height:0,left:0,top:0};let pe,Q,ke;if(fe||Y===void 0||Y.clientX===0&&Y.clientY===0||!Y.clientX&&!Y.touches)pe=Math.round(ye.width/2),Q=Math.round(ye.height/2);else{const{clientX:ie,clientY:Ie}=Y.touches&&Y.touches.length>0?Y.touches[0]:Y;pe=Math.round(ie-ye.left),Q=Math.round(Ie-ye.top)}if(fe)ke=Math.sqrt((2*ye.width**2+ye.height**2)/3),ke%2===0&&(ke+=1);else{const ie=Math.max(Math.abs((Z?Z.clientWidth:0)-pe),pe)*2+2,Ie=Math.max(Math.abs((Z?Z.clientHeight:0)-Q),Q)*2+2;ke=Math.sqrt(ie**2+Ie**2)}Y!=null&&Y.touches?B.current===null&&(B.current=()=>{H({pulsate:oe,rippleX:pe,rippleY:Q,rippleSize:ke,cb:te})},R.start(IQ,()=>{B.current&&(B.current(),B.current=null)})):H({pulsate:oe,rippleX:pe,rippleY:Q,rippleSize:ke,cb:te})},[g,H,R]),O=se.useCallback(()=>{C({},{pulsate:!0})},[C]),F=se.useCallback((Y,ae)=>{if(R.clear(),(Y==null?void 0:Y.type)==="touchend"&&B.current){B.current(),B.current=null,R.start(0,()=>{F(Y,ae)});return}B.current=null,z(te=>te.length>0?te.slice(1):te),j.current=ae},[R]);return se.useImperativeHandle(p,()=>({pulsate:O,start:C,stop:F}),[O,C,F]),q.jsx(MQ,{className:fn(hi.root,x.root,k),ref:P,...N,children:q.jsx(Kk,{component:null,exit:!0,children:E})})});function zQ(a){return Xn("MuiButtonBase",a)}const OQ=Ln("MuiButtonBase",["root","disabled","focusVisible"]),PQ=a=>{const{disabled:i,focusVisible:p,focusVisibleClassName:f,classes:g}=a,k=qn({root:["root",i&&"disabled",p&&"focusVisible"]},zQ,g);return p&&f&&(k.root+=` ${f}`),k},BQ=Lt("button",{name:"MuiButtonBase",slot:"Root",overridesResolver:(a,i)=>i.root})({display:"inline-flex",alignItems:"center",justifyContent:"center",position:"relative",boxSizing:"border-box",WebkitTapHighlightColor:"transparent",backgroundColor:"transparent",outline:0,border:0,margin:0,borderRadius:0,padding:0,cursor:"pointer",userSelect:"none",verticalAlign:"middle",MozAppearance:"none",WebkitAppearance:"none",textDecoration:"none",color:"inherit","&::-moz-focus-inner":{borderStyle:"none"},[`&.${OQ.disabled}`]:{pointerEvents:"none",cursor:"default"},"@media print":{colorAdjust:"exact"}}),l0=se.forwardRef(function(i,p){const f=tr({props:i,name:"MuiButtonBase"}),{action:g,centerRipple:x=!1,children:k,className:N,component:E="button",disabled:z=!1,disableRipple:G=!1,disableTouchRipple:j=!1,focusRipple:M=!1,focusVisibleClassName:R,LinkComponent:B="a",onBlur:P,onClick:H,onContextMenu:C,onDragLeave:O,onFocus:F,onFocusVisible:Y,onKeyDown:ae,onKeyUp:te,onMouseDown:oe,onMouseLeave:fe,onMouseUp:ue,onTouchEnd:Z,onTouchMove:ye,onTouchStart:pe,tabIndex:Q=0,TouchRippleProps:ke,touchRippleRef:ie,type:Ie,...je}=f,xe=se.useRef(null),We=wQ(),Ke=js(We.ref,ie),[ut,ge]=se.useState(!1);z&&ut&&ge(!1),se.useImperativeHandle(g,()=>({focusVisible:()=>{ge(!0),xe.current.focus()}}),[]);const Qe=We.shouldMount&&!G&&!z;se.useEffect(()=>{ut&&M&&!G&&We.pulsate()},[G,M,ut,We]);function At(ht,Et,cn=j){return el(jt=>(Et&&Et(jt),cn||We[ht](jt),!0))}const dt=At("start",oe),It=At("stop",C),Ft=At("stop",O),pn=At("stop",ue),Yt=At("stop",ht=>{ut&&ht.preventDefault(),fe&&fe(ht)}),wt=At("start",pe),Ht=At("stop",Z),Wt=At("stop",ye),on=At("stop",ht=>{uP(ht.target)||ge(!1),P&&P(ht)},!1),Rt=el(ht=>{xe.current||(xe.current=ht.currentTarget),uP(ht.target)&&(ge(!0),Y&&Y(ht)),F&&F(ht)}),Mt=()=>{const ht=xe.current;return E&&E!=="button"&&!(ht.tagName==="A"&&ht.href)},Tn=el(ht=>{M&&!ht.repeat&&ut&&ht.key===" "&&We.stop(ht,()=>{We.start(ht)}),ht.target===ht.currentTarget&&Mt()&&ht.key===" "&&ht.preventDefault(),ae&&ae(ht),ht.target===ht.currentTarget&&Mt()&&ht.key==="Enter"&&!z&&(ht.preventDefault(),H&&H(ht))}),Sn=el(ht=>{M&&ht.key===" "&&ut&&!ht.defaultPrevented&&We.stop(ht,()=>{We.pulsate(ht)}),te&&te(ht),H&&ht.target===ht.currentTarget&&Mt()&&ht.key===" "&&!ht.defaultPrevented&&H(ht)});let J=E;J==="button"&&(je.href||je.to)&&(J=B);const gn={};J==="button"?(gn.type=Ie===void 0?"button":Ie,gn.disabled=z):(!je.href&&!je.to&&(gn.role="button"),z&&(gn["aria-disabled"]=z));const rr=js(p,xe),qt={...f,centerRipple:x,component:E,disabled:z,disableRipple:G,disableTouchRipple:j,focusRipple:M,tabIndex:Q,focusVisible:ut},Ye=PQ(qt);return q.jsxs(BQ,{as:J,className:fn(Ye.root,N),ownerState:qt,onBlur:on,onClick:H,onContextMenu:It,onFocus:Rt,onKeyDown:Tn,onKeyUp:Sn,onMouseDown:dt,onMouseLeave:Yt,onMouseUp:pn,onDragLeave:Ft,onTouchEnd:Ht,onTouchMove:Wt,onTouchStart:wt,ref:rr,tabIndex:z?-1:Q,type:Ie,...gn,...je,children:[k,Qe?q.jsx(DQ,{ref:Ke,center:x,...ke}):null]})});function FQ(a){return typeof a.main=="string"}function LQ(a,i=[]){if(!FQ(a))return!1;for(const p of i)if(!a.hasOwnProperty(p)||typeof a[p]!="string")return!1;return!0}function Vo(a=[]){return([,i])=>i&&LQ(i,a)}function RQ(a){return Xn("MuiAlert",a)}const XP=Ln("MuiAlert",["root","action","icon","message","filled","colorSuccess","colorInfo","colorWarning","colorError","filledSuccess","filledInfo","filledWarning","filledError","outlined","outlinedSuccess","outlinedInfo","outlinedWarning","outlinedError","standard","standardSuccess","standardInfo","standardWarning","standardError"]);function WQ(a){return Xn("MuiIconButton",a)}const jQ=Ln("MuiIconButton",["root","disabled","colorInherit","colorPrimary","colorSecondary","colorError","colorInfo","colorSuccess","colorWarning","edgeStart","edgeEnd","sizeSmall","sizeMedium","sizeLarge"]),HQ=a=>{const{classes:i,disabled:p,color:f,edge:g,size:x}=a,k={root:["root",p&&"disabled",f!=="default"&&`color${tn(f)}`,g&&`edge${tn(g)}`,`size${tn(x)}`]};return qn(k,WQ,i)},GQ=Lt(l0,{name:"MuiIconButton",slot:"Root",overridesResolver:(a,i)=>{const{ownerState:p}=a;return[i.root,p.color!=="default"&&i[`color${tn(p.color)}`],p.edge&&i[`edge${tn(p.edge)}`],i[`size${tn(p.size)}`]]}})(cr(({theme:a})=>({textAlign:"center",flex:"0 0 auto",fontSize:a.typography.pxToRem(24),padding:8,borderRadius:"50%",color:(a.vars||a).palette.action.active,transition:a.transitions.create("background-color",{duration:a.transitions.duration.shortest}),variants:[{props:i=>!i.disableRipple,style:{"--IconButton-hoverBg":a.vars?`rgba(${a.vars.palette.action.activeChannel} / ${a.vars.palette.action.hoverOpacity})`:Pa(a.palette.action.active,a.palette.action.hoverOpacity),"&:hover":{backgroundColor:"var(--IconButton-hoverBg)","@media (hover: none)":{backgroundColor:"transparent"}}}},{props:{edge:"start"},style:{marginLeft:-12}},{props:{edge:"start",size:"small"},style:{marginLeft:-3}},{props:{edge:"end"},style:{marginRight:-12}},{props:{edge:"end",size:"small"},style:{marginRight:-3}}]})),cr(({theme:a})=>({variants:[{props:{color:"inherit"},style:{color:"inherit"}},...Object.entries(a.palette).filter(Vo()).map(([i])=>({props:{color:i},style:{color:(a.vars||a).palette[i].main}})),...Object.entries(a.palette).filter(Vo()).map(([i])=>({props:{color:i},style:{"--IconButton-hoverBg":a.vars?`rgba(${(a.vars||a).palette[i].mainChannel} / ${a.vars.palette.action.hoverOpacity})`:Pa((a.vars||a).palette[i].main,a.palette.action.hoverOpacity)}})),{props:{size:"small"},style:{padding:5,fontSize:a.typography.pxToRem(18)}},{props:{size:"large"},style:{padding:12,fontSize:a.typography.pxToRem(28)}}],[`&.${jQ.disabled}`]:{backgroundColor:"transparent",color:(a.vars||a).palette.action.disabled}}))),ZP=se.forwardRef(function(i,p){const f=tr({props:i,name:"MuiIconButton"}),{edge:g=!1,children:x,className:k,color:N="default",disabled:E=!1,disableFocusRipple:z=!1,size:G="medium",...j}=f,M={...f,edge:g,color:N,disabled:E,disableFocusRipple:z,size:G},R=HQ(M);return q.jsx(GQ,{className:fn(R.root,k),centerRipple:!0,focusRipple:!z,disabled:E,ref:p,...j,ownerState:M,children:x})}),VQ=nl(q.jsx("path",{d:"M20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4C12.76,4 13.5,4.11 14.2, 4.31L15.77,2.74C14.61,2.26 13.34,2 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0, 0 22,12M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z"}),"SuccessOutlined"),XQ=nl(q.jsx("path",{d:"M12 5.99L19.53 19H4.47L12 5.99M12 2L1 21h22L12 2zm1 14h-2v2h2v-2zm0-6h-2v4h2v-4z"}),"ReportProblemOutlined"),ZQ=nl(q.jsx("path",{d:"M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"}),"ErrorOutline"),YQ=nl(q.jsx("path",{d:"M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20, 12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10, 10 0 0,0 12,2M11,17H13V11H11V17Z"}),"InfoOutlined"),UQ=nl(q.jsx("path",{d:"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"}),"Close"),QQ=a=>{const{variant:i,color:p,severity:f,classes:g}=a,x={root:["root",`color${tn(p||f)}`,`${i}${tn(p||f)}`,`${i}`],icon:["icon"],message:["message"],action:["action"]};return qn(x,RQ,g)},KQ=Lt(Tf,{name:"MuiAlert",slot:"Root",overridesResolver:(a,i)=>{const{ownerState:p}=a;return[i.root,i[p.variant],i[`${p.variant}${tn(p.color||p.severity)}`]]}})(cr(({theme:a})=>{const i=a.palette.mode==="light"?Cf:If,p=a.palette.mode==="light"?If:Cf;return{...a.typography.body2,backgroundColor:"transparent",display:"flex",padding:"6px 16px",variants:[...Object.entries(a.palette).filter(Vo(["light"])).map(([f])=>({props:{colorSeverity:f,variant:"standard"},style:{color:a.vars?a.vars.palette.Alert[`${f}Color`]:i(a.palette[f].light,.6),backgroundColor:a.vars?a.vars.palette.Alert[`${f}StandardBg`]:p(a.palette[f].light,.9),[`& .${XP.icon}`]:a.vars?{color:a.vars.palette.Alert[`${f}IconColor`]}:{color:a.palette[f].main}}})),...Object.entries(a.palette).filter(Vo(["light"])).map(([f])=>({props:{colorSeverity:f,variant:"outlined"},style:{color:a.vars?a.vars.palette.Alert[`${f}Color`]:i(a.palette[f].light,.6),border:`1px solid ${(a.vars||a).palette[f].light}`,[`& .${XP.icon}`]:a.vars?{color:a.vars.palette.Alert[`${f}IconColor`]}:{color:a.palette[f].main}}})),...Object.entries(a.palette).filter(Vo(["dark"])).map(([f])=>({props:{colorSeverity:f,variant:"filled"},style:{fontWeight:a.typography.fontWeightMedium,...a.vars?{color:a.vars.palette.Alert[`${f}FilledColor`],backgroundColor:a.vars.palette.Alert[`${f}FilledBg`]}:{backgroundColor:a.palette.mode==="dark"?a.palette[f].dark:a.palette[f].main,color:a.palette.getContrastText(a.palette[f].main)}}}))]}})),qQ=Lt("div",{name:"MuiAlert",slot:"Icon",overridesResolver:(a,i)=>i.icon})({marginRight:12,padding:"7px 0",display:"flex",fontSize:22,opacity:.9}),JQ=Lt("div",{name:"MuiAlert",slot:"Message",overridesResolver:(a,i)=>i.message})({padding:"8px 0",minWidth:0,overflow:"auto"}),YP=Lt("div",{name:"MuiAlert",slot:"Action",overridesResolver:(a,i)=>i.action})({display:"flex",alignItems:"flex-start",padding:"4px 0 0 16px",marginLeft:"auto",marginRight:-8}),UP={success:q.jsx(VQ,{fontSize:"inherit"}),warning:q.jsx(XQ,{fontSize:"inherit"}),error:q.jsx(ZQ,{fontSize:"inherit"}),info:q.jsx(YQ,{fontSize:"inherit"})},$Q=se.forwardRef(function(i,p){const f=tr({props:i,name:"MuiAlert"}),{action:g,children:x,className:k,closeText:N="Close",color:E,components:z={},componentsProps:G={},icon:j,iconMapping:M=UP,onClose:R,role:B="alert",severity:P="success",slotProps:H={},slots:C={},variant:O="standard",...F}=f,Y={...f,color:E,severity:P,variant:O,colorSeverity:E||P},ae=QQ(Y),te={slots:{closeButton:z.CloseButton,closeIcon:z.CloseIcon,...C},slotProps:{...G,...H}},[oe,fe]=yo("closeButton",{elementType:ZP,externalForwardedProps:te,ownerState:Y}),[ue,Z]=yo("closeIcon",{elementType:UQ,externalForwardedProps:te,ownerState:Y});return q.jsxs(KQ,{role:B,elevation:0,ownerState:Y,className:fn(ae.root,k),ref:p,...F,children:[j!==!1?q.jsx(qQ,{ownerState:Y,className:ae.icon,children:j||M[P]||UP[P]}):null,q.jsx(JQ,{ownerState:Y,className:ae.message,children:x}),g!=null?q.jsx(YP,{ownerState:Y,className:ae.action,children:g}):null,g==null&&R?q.jsx(YP,{ownerState:Y,className:ae.action,children:q.jsx(oe,{size:"small","aria-label":N,title:N,color:"inherit",onClick:R,...fe,children:q.jsx(ue,{fontSize:"small",...Z})})}):null]})});function _Q(a){return Xn("MuiTypography",a)}Ln("MuiTypography",["root","h1","h2","h3","h4","h5","h6","subtitle1","subtitle2","body1","body2","inherit","button","caption","overline","alignLeft","alignRight","alignCenter","alignJustify","noWrap","gutterBottom","paragraph"]);const eK={primary:!0,secondary:!0,error:!0,info:!0,success:!0,warning:!0,textPrimary:!0,textSecondary:!0,textDisabled:!0},tK=AQ(),nK=a=>{const{align:i,gutterBottom:p,noWrap:f,paragraph:g,variant:x,classes:k}=a,N={root:["root",x,a.align!=="inherit"&&`align${tn(i)}`,p&&"gutterBottom",f&&"noWrap",g&&"paragraph"]};return qn(N,_Q,k)},rK=Lt("span",{name:"MuiTypography",slot:"Root",overridesResolver:(a,i)=>{const{ownerState:p}=a;return[i.root,p.variant&&i[p.variant],p.align!=="inherit"&&i[`align${tn(p.align)}`],p.noWrap&&i.noWrap,p.gutterBottom&&i.gutterBottom,p.paragraph&&i.paragraph]}})(cr(({theme:a})=>{var i;return{margin:0,variants:[{props:{variant:"inherit"},style:{font:"inherit",lineHeight:"inherit",letterSpacing:"inherit"}},...Object.entries(a.typography).filter(([p,f])=>p!=="inherit"&&f&&typeof f=="object").map(([p,f])=>({props:{variant:p},style:f})),...Object.entries(a.palette).filter(Vo()).map(([p])=>({props:{color:p},style:{color:(a.vars||a).palette[p].main}})),...Object.entries(((i=a.palette)==null?void 0:i.text)||{}).filter(([,p])=>typeof p=="string").map(([p])=>({props:{color:`text${tn(p)}`},style:{color:(a.vars||a).palette.text[p]}})),{props:({ownerState:p})=>p.align!=="inherit",style:{textAlign:"var(--Typography-textAlign)"}},{props:({ownerState:p})=>p.noWrap,style:{overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"}},{props:({ownerState:p})=>p.gutterBottom,style:{marginBottom:"0.35em"}},{props:({ownerState:p})=>p.paragraph,style:{marginBottom:16}}]}})),QP={h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",h6:"h6",subtitle1:"h6",subtitle2:"h6",body1:"p",body2:"p",inherit:"p"},mn=se.forwardRef(function(i,p){const{color:f,...g}=tr({props:i,name:"MuiTypography"}),x=!eK[f],k=tK({...g,...x&&{color:f}}),{align:N="inherit",className:E,component:z,gutterBottom:G=!1,noWrap:j=!1,paragraph:M=!1,variant:R="body1",variantMapping:B=QP,...P}=k,H={...k,align:N,color:f,className:E,component:z,gutterBottom:G,noWrap:j,paragraph:M,variant:R,variantMapping:B},C=z||(M?"p":B[R]||QP[R])||"span",O=nK(H);return q.jsx(rK,{as:C,ref:p,className:fn(O.root,E),...P,ownerState:H,style:{...N!=="inherit"&&{"--Typography-textAlign":N},...P.style}})});function sK(a){return typeof a=="function"?a():a}const aK=se.forwardRef(function(i,p){const{children:f,container:g,disablePortal:x=!1}=i,[k,N]=se.useState(null),E=js(se.isValidElement(f)?rp(f):null,p);if($A(()=>{x||N(sK(g)||document.body)},[g,x]),$A(()=>{if(k&&!x)return Dk(p,k),()=>{Dk(p,null)}},[p,k,x]),x){if(se.isValidElement(f)){const z={ref:E};return se.cloneElement(f,z)}return q.jsx(se.Fragment,{children:f})}return q.jsx(se.Fragment,{children:k&&ak.createPortal(f,k)})});function u0(a){return parseInt(a,10)||0}const oK={shadow:{visibility:"hidden",position:"absolute",overflow:"hidden",height:0,top:0,left:0,transform:"translateZ(0)"}};function iK(a){return a==null||Object.keys(a).length===0||a.outerHeightStyle===0&&!a.overflowing}const AK=se.forwardRef(function(i,p){const{onChange:f,maxRows:g,minRows:x=1,style:k,value:N,...E}=i,{current:z}=se.useRef(N!=null),G=se.useRef(null),j=js(p,G),M=se.useRef(null),R=se.useRef(null),B=se.useCallback(()=>{const C=G.current,F=_A(C).getComputedStyle(C);if(F.width==="0px")return{outerHeightStyle:0,overflowing:!1};const Y=R.current;Y.style.width=F.width,Y.value=C.value||i.placeholder||"x",Y.value.slice(-1)===`
`&&(Y.value+=" ");const ae=F.boxSizing,te=u0(F.paddingBottom)+u0(F.paddingTop),oe=u0(F.borderBottomWidth)+u0(F.borderTopWidth),fe=Y.scrollHeight;Y.value="x";const ue=Y.scrollHeight;let Z=fe;x&&(Z=Math.max(Number(x)*ue,Z)),g&&(Z=Math.min(Number(g)*ue,Z)),Z=Math.max(Z,ue);const ye=Z+(ae==="border-box"?te+oe:0),pe=Math.abs(Z-fe)<=1;return{outerHeightStyle:ye,overflowing:pe}},[g,x,i.placeholder]),P=se.useCallback(()=>{const C=B();if(iK(C))return;const O=C.outerHeightStyle,F=G.current;M.current!==O&&(M.current=O,F.style.height=`${O}px`),F.style.overflow=C.overflowing?"hidden":""},[B]);$A(()=>{const C=()=>{P()};let O;const F=aP(C),Y=G.current,ae=_A(Y);ae.addEventListener("resize",F);let te;return typeof ResizeObserver<"u"&&(te=new ResizeObserver(C),te.observe(Y)),()=>{F.clear(),cancelAnimationFrame(O),ae.removeEventListener("resize",F),te&&te.disconnect()}},[B,P]),$A(()=>{P()});const H=C=>{z||P(),f&&f(C)};return q.jsxs(se.Fragment,{children:[q.jsx("textarea",{value:N,onChange:H,ref:j,rows:x,style:k,...E}),q.jsx("textarea",{"aria-hidden":!0,className:i.className,readOnly:!0,ref:R,tabIndex:-1,style:{...oK.shadow,...k,paddingTop:0,paddingBottom:0}})]})});function Jk(a){return typeof a=="string"}function ql({props:a,states:i,muiFormControl:p}){return i.reduce((f,g)=>(f[g]=a[g],p&&typeof a[g]>"u"&&(f[g]=p[g]),f),{})}const $k=se.createContext(void 0);function gA(){return se.useContext($k)}function KP(a){return a!=null&&!(Array.isArray(a)&&a.length===0)}function c0(a,i=!1){return a&&(KP(a.value)&&a.value!==""||i&&KP(a.defaultValue)&&a.defaultValue!=="")}function lK(a){return a.startAdornment}function uK(a){return Xn("MuiInputBase",a)}const ip=Ln("MuiInputBase",["root","formControl","focused","disabled","adornedStart","adornedEnd","error","sizeSmall","multiline","colorSecondary","fullWidth","hiddenLabel","readOnly","input","inputSizeSmall","inputMultiline","inputTypeSearch","inputAdornedStart","inputAdornedEnd","inputHiddenLabel"]);var qP;const d0=(a,i)=>{const{ownerState:p}=a;return[i.root,p.formControl&&i.formControl,p.startAdornment&&i.adornedStart,p.endAdornment&&i.adornedEnd,p.error&&i.error,p.size==="small"&&i.sizeSmall,p.multiline&&i.multiline,p.color&&i[`color${tn(p.color)}`],p.fullWidth&&i.fullWidth,p.hiddenLabel&&i.hiddenLabel]},p0=(a,i)=>{const{ownerState:p}=a;return[i.input,p.size==="small"&&i.inputSizeSmall,p.multiline&&i.inputMultiline,p.type==="search"&&i.inputTypeSearch,p.startAdornment&&i.inputAdornedStart,p.endAdornment&&i.inputAdornedEnd,p.hiddenLabel&&i.inputHiddenLabel]},cK=a=>{const{classes:i,color:p,disabled:f,error:g,endAdornment:x,focused:k,formControl:N,fullWidth:E,hiddenLabel:z,multiline:G,readOnly:j,size:M,startAdornment:R,type:B}=a,P={root:["root",`color${tn(p)}`,f&&"disabled",g&&"error",E&&"fullWidth",k&&"focused",N&&"formControl",M&&M!=="medium"&&`size${tn(M)}`,G&&"multiline",R&&"adornedStart",x&&"adornedEnd",z&&"hiddenLabel",j&&"readOnly"],input:["input",f&&"disabled",B==="search"&&"inputTypeSearch",G&&"inputMultiline",M==="small"&&"inputSizeSmall",z&&"inputHiddenLabel",R&&"inputAdornedStart",x&&"inputAdornedEnd",j&&"readOnly"]};return qn(P,uK,i)},h0=Lt("div",{name:"MuiInputBase",slot:"Root",overridesResolver:d0})(cr(({theme:a})=>({...a.typography.body1,color:(a.vars||a).palette.text.primary,lineHeight:"1.4375em",boxSizing:"border-box",position:"relative",cursor:"text",display:"inline-flex",alignItems:"center",[`&.${ip.disabled}`]:{color:(a.vars||a).palette.text.disabled,cursor:"default"},variants:[{props:({ownerState:i})=>i.multiline,style:{padding:"4px 0 5px"}},{props:({ownerState:i,size:p})=>i.multiline&&p==="small",style:{paddingTop:1}},{props:({ownerState:i})=>i.fullWidth,style:{width:"100%"}}]}))),f0=Lt("input",{name:"MuiInputBase",slot:"Input",overridesResolver:p0})(cr(({theme:a})=>{const i=a.palette.mode==="light",p={color:"currentColor",...a.vars?{opacity:a.vars.opacity.inputPlaceholder}:{opacity:i?.42:.5},transition:a.transitions.create("opacity",{duration:a.transitions.duration.shorter})},f={opacity:"0 !important"},g=a.vars?{opacity:a.vars.opacity.inputPlaceholder}:{opacity:i?.42:.5};return{font:"inherit",letterSpacing:"inherit",color:"currentColor",padding:"4px 0 5px",border:0,boxSizing:"content-box",background:"none",height:"1.4375em",margin:0,WebkitTapHighlightColor:"transparent",display:"block",minWidth:0,width:"100%","&::-webkit-input-placeholder":p,"&::-moz-placeholder":p,"&::-ms-input-placeholder":p,"&:focus":{outline:0},"&:invalid":{boxShadow:"none"},"&::-webkit-search-decoration":{WebkitAppearance:"none"},[`label[data-shrink=false] + .${ip.formControl} &`]:{"&::-webkit-input-placeholder":f,"&::-moz-placeholder":f,"&::-ms-input-placeholder":f,"&:focus::-webkit-input-placeholder":g,"&:focus::-moz-placeholder":g,"&:focus::-ms-input-placeholder":g},[`&.${ip.disabled}`]:{opacity:1,WebkitTextFillColor:(a.vars||a).palette.text.disabled},variants:[{props:({ownerState:x})=>!x.disableInjectingGlobalStyles,style:{animationName:"mui-auto-fill-cancel",animationDuration:"10ms","&:-webkit-autofill":{animationDuration:"5000s",animationName:"mui-auto-fill"}}},{props:{size:"small"},style:{paddingTop:1}},{props:({ownerState:x})=>x.multiline,style:{height:"auto",resize:"none",padding:0,paddingTop:0}},{props:{type:"search"},style:{MozAppearance:"textfield"}}]}})),JP=Zk({"@keyframes mui-auto-fill":{from:{display:"block"}},"@keyframes mui-auto-fill-cancel":{from:{display:"block"}}}),_k=se.forwardRef(function(i,p){const f=tr({props:i,name:"MuiInputBase"}),{"aria-describedby":g,autoComplete:x,autoFocus:k,className:N,color:E,components:z={},componentsProps:G={},defaultValue:j,disabled:M,disableInjectingGlobalStyles:R,endAdornment:B,error:P,fullWidth:H=!1,id:C,inputComponent:O="input",inputProps:F={},inputRef:Y,margin:ae,maxRows:te,minRows:oe,multiline:fe=!1,name:ue,onBlur:Z,onChange:ye,onClick:pe,onFocus:Q,onKeyDown:ke,onKeyUp:ie,placeholder:Ie,readOnly:je,renderSuffix:xe,rows:We,size:Ke,slotProps:ut={},slots:ge={},startAdornment:Qe,type:At="text",value:dt,...It}=f,Ft=F.value!=null?F.value:dt,{current:pn}=se.useRef(Ft!=null),Yt=se.useRef(),wt=se.useCallback(Oe=>{},[]),Ht=js(Yt,Y,F.ref,wt),[Wt,on]=se.useState(!1),Rt=gA(),Mt=ql({props:f,muiFormControl:Rt,states:["color","disabled","error","hiddenLabel","size","required","filled"]});Mt.focused=Rt?Rt.focused:Wt,se.useEffect(()=>{!Rt&&M&&Wt&&(on(!1),Z&&Z())},[Rt,M,Wt,Z]);const Tn=Rt&&Rt.onFilled,Sn=Rt&&Rt.onEmpty,J=se.useCallback(Oe=>{c0(Oe)?Tn&&Tn():Sn&&Sn()},[Tn,Sn]);$A(()=>{pn&&J({value:Ft})},[Ft,J,pn]);const gn=Oe=>{Q&&Q(Oe),F.onFocus&&F.onFocus(Oe),Rt&&Rt.onFocus?Rt.onFocus(Oe):on(!0)},rr=Oe=>{Z&&Z(Oe),F.onBlur&&F.onBlur(Oe),Rt&&Rt.onBlur?Rt.onBlur(Oe):on(!1)},qt=(Oe,...Tt)=>{if(!pn){const nn=Oe.target||Yt.current;if(nn==null)throw new Error(qA(1));J({value:nn.value})}F.onChange&&F.onChange(Oe,...Tt),ye&&ye(Oe,...Tt)};se.useEffect(()=>{J(Yt.current)},[]);const Ye=Oe=>{Yt.current&&Oe.currentTarget===Oe.target&&Yt.current.focus(),pe&&pe(Oe)};let ht=O,Et=F;fe&&ht==="input"&&(We?Et={type:void 0,minRows:We,maxRows:We,...Et}:Et={type:void 0,maxRows:te,minRows:oe,...Et},ht=AK);const cn=Oe=>{J(Oe.animationName==="mui-auto-fill-cancel"?Yt.current:{value:"x"})};se.useEffect(()=>{Rt&&Rt.setAdornedStart(!!Qe)},[Rt,Qe]);const jt={...f,color:Mt.color||"primary",disabled:Mt.disabled,endAdornment:B,error:Mt.error,focused:Mt.focused,formControl:Rt,fullWidth:H,hiddenLabel:Mt.hiddenLabel,multiline:fe,size:Mt.size,startAdornment:Qe,type:At},xn=cK(jt),yn=ge.root||z.Root||h0,pt=ut.root||G.root||{},tt=ge.input||z.Input||f0;return Et={...Et,...ut.input??G.input},q.jsxs(se.Fragment,{children:[!R&&typeof JP=="function"&&(qP||(qP=q.jsx(JP,{}))),q.jsxs(yn,{...pt,ref:p,onClick:Ye,...It,...!Jk(yn)&&{ownerState:{...jt,...pt.ownerState}},className:fn(xn.root,pt.className,N,je&&"MuiInputBase-readOnly"),children:[Qe,q.jsx($k.Provider,{value:null,children:q.jsx(tt,{"aria-invalid":Mt.error,"aria-describedby":g,autoComplete:x,autoFocus:k,defaultValue:j,disabled:Mt.disabled,id:C,onAnimationStart:cn,name:ue,placeholder:Ie,readOnly:je,required:Mt.required,rows:We,value:Ft,onKeyDown:ke,onKeyUp:ie,type:At,...Et,...!Jk(tt)&&{as:ht,ownerState:{...jt,...Et.ownerState}},ref:Ht,className:fn(xn.input,Et.className,je&&"MuiInputBase-readOnly"),onBlur:rr,onChange:qt,onFocus:gn})}),B,xe?xe({...Mt,startAdornment:Qe}):null]})]})});function dK(a){return Xn("MuiInput",a)}const Mf={...ip,...Ln("MuiInput",["root","underline","input"])};function pK(a){return Xn("MuiOutlinedInput",a)}const yA={...ip,...Ln("MuiOutlinedInput",["root","notchedOutline","input"])};function hK(a){return Xn("MuiFilledInput",a)}const mc={...ip,...Ln("MuiFilledInput",["root","underline","input","adornedStart","adornedEnd","sizeSmall","multiline","hiddenLabel"])},fK=nl(q.jsx("path",{d:"M7 10l5 5 5-5z"}),"ArrowDropDown"),mK={entering:{opacity:1},entered:{opacity:1}},$P=se.forwardRef(function(i,p){const f=sp(),g={enter:f.transitions.duration.enteringScreen,exit:f.transitions.duration.leavingScreen},{addEndListener:x,appear:k=!0,children:N,easing:E,in:z,onEnter:G,onEntered:j,onEntering:M,onExit:R,onExited:B,onExiting:P,style:H,timeout:C=g,TransitionComponent:O=mA,...F}=i,Y=se.useRef(null),ae=js(Y,rp(N),p),te=ke=>ie=>{if(ke){const Ie=Y.current;ie===void 0?ke(Ie):ke(Ie,ie)}},oe=te(M),fe=te((ke,ie)=>{VP(ke);const Ie=i0({style:H,timeout:C,easing:E},{mode:"enter"});ke.style.webkitTransition=f.transitions.create("opacity",Ie),ke.style.transition=f.transitions.create("opacity",Ie),G&&G(ke,ie)}),ue=te(j),Z=te(P),ye=te(ke=>{const ie=i0({style:H,timeout:C,easing:E},{mode:"exit"});ke.style.webkitTransition=f.transitions.create("opacity",ie),ke.style.transition=f.transitions.create("opacity",ie),R&&R(ke)}),pe=te(B),Q=ke=>{x&&x(Y.current,ke)};return q.jsx(O,{appear:k,in:z,nodeRef:Y,onEnter:fe,onEntered:ue,onEntering:oe,onExit:ye,onExited:pe,onExiting:Z,addEndListener:Q,timeout:C,...F,children:(ke,ie)=>se.cloneElement(N,{style:{opacity:0,visibility:ke==="exited"&&!z?"hidden":void 0,...mK[ke],...H,...N.props.style},ref:ae,...ie})})});function gK(a){return Xn("MuiBackdrop",a)}Ln("MuiBackdrop",["root","invisible"]);const yK=a=>{const{ownerState:i,...p}=a;return p},bK=a=>{const{classes:i,invisible:p}=a;return qn({root:["root",p&&"invisible"]},gK,i)},vK=Lt("div",{name:"MuiBackdrop",slot:"Root",overridesResolver:(a,i)=>{const{ownerState:p}=a;return[i.root,p.invisible&&i.invisible]}})({position:"fixed",display:"flex",alignItems:"center",justifyContent:"center",right:0,bottom:0,top:0,left:0,backgroundColor:"rgba(0, 0, 0, 0.5)",WebkitTapHighlightColor:"transparent",variants:[{props:{invisible:!0},style:{backgroundColor:"transparent"}}]}),_P=se.forwardRef(function(i,p){const f=tr({props:i,name:"MuiBackdrop"}),{children:g,className:x,component:k="div",invisible:N=!1,open:E,components:z={},componentsProps:G={},slotProps:j={},slots:M={},TransitionComponent:R,transitionDuration:B,...P}=f,H={...f,component:k,invisible:N},C=bK(H),O={transition:R,root:z.Root,...M},F={...G,...j},Y={slots:O,slotProps:F},[ae,te]=yo("root",{elementType:vK,externalForwardedProps:Y,className:fn(C.root,x),ownerState:H}),[oe,fe]=yo("transition",{elementType:$P,externalForwardedProps:Y,ownerState:H}),ue=yK(fe);return q.jsx(oe,{in:E,timeout:B,...P,...ue,children:q.jsx(ae,{"aria-hidden":!0,...te,classes:C,ref:p,children:g})})}),xK=Ln("MuiBox",["root"]),wK=r0(),ft=WY({themeId:Wi,defaultTheme:wK,defaultClassName:xK.root,generateClassName:JO.generate});function kK(a){return Xn("MuiButton",a)}const Ap=Ln("MuiButton",["root","text","textInherit","textPrimary","textSecondary","textSuccess","textError","textInfo","textWarning","outlined","outlinedInherit","outlinedPrimary","outlinedSecondary","outlinedSuccess","outlinedError","outlinedInfo","outlinedWarning","contained","containedInherit","containedPrimary","containedSecondary","containedSuccess","containedError","containedInfo","containedWarning","disableElevation","focusVisible","disabled","colorInherit","colorPrimary","colorSecondary","colorSuccess","colorError","colorInfo","colorWarning","textSizeSmall","textSizeMedium","textSizeLarge","outlinedSizeSmall","outlinedSizeMedium","outlinedSizeLarge","containedSizeSmall","containedSizeMedium","containedSizeLarge","sizeMedium","sizeSmall","sizeLarge","fullWidth","startIcon","endIcon","icon","iconSizeSmall","iconSizeMedium","iconSizeLarge"]),CK=se.createContext({}),IK=se.createContext(void 0),SK=a=>{const{color:i,disableElevation:p,fullWidth:f,size:g,variant:x,classes:k}=a,N={root:["root",x,`${x}${tn(i)}`,`size${tn(g)}`,`${x}Size${tn(g)}`,`color${tn(i)}`,p&&"disableElevation",f&&"fullWidth"],label:["label"],startIcon:["icon","startIcon",`iconSize${tn(g)}`],endIcon:["icon","endIcon",`iconSize${tn(g)}`]},E=qn(N,kK,k);return{...k,...E}},eB=[{props:{size:"small"},style:{"& > *:nth-of-type(1)":{fontSize:18}}},{props:{size:"medium"},style:{"& > *:nth-of-type(1)":{fontSize:20}}},{props:{size:"large"},style:{"& > *:nth-of-type(1)":{fontSize:22}}}],NK=Lt(l0,{shouldForwardProp:a=>qa(a)||a==="classes",name:"MuiButton",slot:"Root",overridesResolver:(a,i)=>{const{ownerState:p}=a;return[i.root,i[p.variant],i[`${p.variant}${tn(p.color)}`],i[`size${tn(p.size)}`],i[`${p.variant}Size${tn(p.size)}`],p.color==="inherit"&&i.colorInherit,p.disableElevation&&i.disableElevation,p.fullWidth&&i.fullWidth]}})(cr(({theme:a})=>{const i=a.palette.mode==="light"?a.palette.grey[300]:a.palette.grey[800],p=a.palette.mode==="light"?a.palette.grey.A100:a.palette.grey[700];return{...a.typography.button,minWidth:64,padding:"6px 16px",border:0,borderRadius:(a.vars||a).shape.borderRadius,transition:a.transitions.create(["background-color","box-shadow","border-color","color"],{duration:a.transitions.duration.short}),"&:hover":{textDecoration:"none"},[`&.${Ap.disabled}`]:{color:(a.vars||a).palette.action.disabled},variants:[{props:{variant:"contained"},style:{color:"var(--variant-containedColor)",backgroundColor:"var(--variant-containedBg)",boxShadow:(a.vars||a).shadows[2],"&:hover":{boxShadow:(a.vars||a).shadows[4],"@media (hover: none)":{boxShadow:(a.vars||a).shadows[2]}},"&:active":{boxShadow:(a.vars||a).shadows[8]},[`&.${Ap.focusVisible}`]:{boxShadow:(a.vars||a).shadows[6]},[`&.${Ap.disabled}`]:{color:(a.vars||a).palette.action.disabled,boxShadow:(a.vars||a).shadows[0],backgroundColor:(a.vars||a).palette.action.disabledBackground}}},{props:{variant:"outlined"},style:{padding:"5px 15px",border:"1px solid currentColor",borderColor:"var(--variant-outlinedBorder, currentColor)",backgroundColor:"var(--variant-outlinedBg)",color:"var(--variant-outlinedColor)",[`&.${Ap.disabled}`]:{border:`1px solid ${(a.vars||a).palette.action.disabledBackground}`}}},{props:{variant:"text"},style:{padding:"6px 8px",color:"var(--variant-textColor)",backgroundColor:"var(--variant-textBg)"}},...Object.entries(a.palette).filter(Vo()).map(([f])=>({props:{color:f},style:{"--variant-textColor":(a.vars||a).palette[f].main,"--variant-outlinedColor":(a.vars||a).palette[f].main,"--variant-outlinedBorder":a.vars?`rgba(${a.vars.palette[f].mainChannel} / 0.5)`:Pa(a.palette[f].main,.5),"--variant-containedColor":(a.vars||a).palette[f].contrastText,"--variant-containedBg":(a.vars||a).palette[f].main,"@media (hover: hover)":{"&:hover":{"--variant-containedBg":(a.vars||a).palette[f].dark,"--variant-textBg":a.vars?`rgba(${a.vars.palette[f].mainChannel} / ${a.vars.palette.action.hoverOpacity})`:Pa(a.palette[f].main,a.palette.action.hoverOpacity),"--variant-outlinedBorder":(a.vars||a).palette[f].main,"--variant-outlinedBg":a.vars?`rgba(${a.vars.palette[f].mainChannel} / ${a.vars.palette.action.hoverOpacity})`:Pa(a.palette[f].main,a.palette.action.hoverOpacity)}}}})),{props:{color:"inherit"},style:{color:"inherit",borderColor:"currentColor","--variant-containedBg":a.vars?a.vars.palette.Button.inheritContainedBg:i,"@media (hover: hover)":{"&:hover":{"--variant-containedBg":a.vars?a.vars.palette.Button.inheritContainedHoverBg:p,"--variant-textBg":a.vars?`rgba(${a.vars.palette.text.primaryChannel} / ${a.vars.palette.action.hoverOpacity})`:Pa(a.palette.text.primary,a.palette.action.hoverOpacity),"--variant-outlinedBg":a.vars?`rgba(${a.vars.palette.text.primaryChannel} / ${a.vars.palette.action.hoverOpacity})`:Pa(a.palette.text.primary,a.palette.action.hoverOpacity)}}}},{props:{size:"small",variant:"text"},style:{padding:"4px 5px",fontSize:a.typography.pxToRem(13)}},{props:{size:"large",variant:"text"},style:{padding:"8px 11px",fontSize:a.typography.pxToRem(15)}},{props:{size:"small",variant:"outlined"},style:{padding:"3px 9px",fontSize:a.typography.pxToRem(13)}},{props:{size:"large",variant:"outlined"},style:{padding:"7px 21px",fontSize:a.typography.pxToRem(15)}},{props:{size:"small",variant:"contained"},style:{padding:"4px 10px",fontSize:a.typography.pxToRem(13)}},{props:{size:"large",variant:"contained"},style:{padding:"8px 22px",fontSize:a.typography.pxToRem(15)}},{props:{disableElevation:!0},style:{boxShadow:"none","&:hover":{boxShadow:"none"},[`&.${Ap.focusVisible}`]:{boxShadow:"none"},"&:active":{boxShadow:"none"},[`&.${Ap.disabled}`]:{boxShadow:"none"}}},{props:{fullWidth:!0},style:{width:"100%"}}]}})),TK=Lt("span",{name:"MuiButton",slot:"StartIcon",overridesResolver:(a,i)=>{const{ownerState:p}=a;return[i.startIcon,i[`iconSize${tn(p.size)}`]]}})({display:"inherit",marginRight:8,marginLeft:-4,variants:[{props:{size:"small"},style:{marginLeft:-2}},...eB]}),MK=Lt("span",{name:"MuiButton",slot:"EndIcon",overridesResolver:(a,i)=>{const{ownerState:p}=a;return[i.endIcon,i[`iconSize${tn(p.size)}`]]}})({display:"inherit",marginRight:-4,marginLeft:8,variants:[{props:{size:"small"},style:{marginRight:-2}},...eB]}),eC=se.forwardRef(function(i,p){const f=se.useContext(CK),g=se.useContext(IK),x=wf(f,i),k=tr({props:x,name:"MuiButton"}),{children:N,color:E="primary",component:z="button",className:G,disabled:j=!1,disableElevation:M=!1,disableFocusRipple:R=!1,endIcon:B,focusVisibleClassName:P,fullWidth:H=!1,size:C="medium",startIcon:O,type:F,variant:Y="text",...ae}=k,te={...k,color:E,component:z,disabled:j,disableElevation:M,disableFocusRipple:R,fullWidth:H,size:C,type:F,variant:Y},oe=SK(te),fe=O&&q.jsx(TK,{className:oe.startIcon,ownerState:te,children:O}),ue=B&&q.jsx(MK,{className:oe.endIcon,ownerState:te,children:B}),Z=g||"";return q.jsxs(NK,{ownerState:te,className:fn(f.className,oe.root,G,Z),component:z,disabled:j,focusRipple:!R,focusVisibleClassName:fn(oe.focusVisible,P),ref:p,type:F,...ae,classes:oe,children:[fe,N,ue]})});function EK(a){return Xn("PrivateSwitchBase",a)}Ln("PrivateSwitchBase",["root","checked","disabled","input","edgeStart","edgeEnd"]);const DK=a=>{const{classes:i,checked:p,disabled:f,edge:g}=a,x={root:["root",p&&"checked",f&&"disabled",g&&`edge${tn(g)}`],input:["input"]};return qn(x,EK,i)},zK=Lt(l0)({padding:9,borderRadius:"50%",variants:[{props:{edge:"start",size:"small"},style:{marginLeft:-3}},{props:({edge:a,ownerState:i})=>a==="start"&&i.size!=="small",style:{marginLeft:-12}},{props:{edge:"end",size:"small"},style:{marginRight:-3}},{props:({edge:a,ownerState:i})=>a==="end"&&i.size!=="small",style:{marginRight:-12}}]}),OK=Lt("input",{shouldForwardProp:qa})({cursor:"inherit",position:"absolute",opacity:0,width:"100%",height:"100%",top:0,left:0,margin:0,padding:0,zIndex:1}),PK=se.forwardRef(function(i,p){const{autoFocus:f,checked:g,checkedIcon:x,className:k,defaultChecked:N,disabled:E,disableFocusRipple:z=!1,edge:G=!1,icon:j,id:M,inputProps:R,inputRef:B,name:P,onBlur:H,onChange:C,onFocus:O,readOnly:F,required:Y=!1,tabIndex:ae,type:te,value:oe,...fe}=i,[ue,Z]=t0({controlled:g,default:!!N,name:"SwitchBase",state:"checked"}),ye=gA(),pe=We=>{O&&O(We),ye&&ye.onFocus&&ye.onFocus(We)},Q=We=>{H&&H(We),ye&&ye.onBlur&&ye.onBlur(We)},ke=We=>{if(We.nativeEvent.defaultPrevented)return;const Ke=We.target.checked;Z(Ke),C&&C(We,Ke)};let ie=E;ye&&typeof ie>"u"&&(ie=ye.disabled);const Ie=te==="checkbox"||te==="radio",je={...i,checked:ue,disabled:ie,disableFocusRipple:z,edge:G},xe=DK(je);return q.jsxs(zK,{component:"span",className:fn(xe.root,k),centerRipple:!0,focusRipple:!z,disabled:ie,tabIndex:null,role:void 0,onFocus:pe,onBlur:Q,ownerState:je,ref:p,...fe,children:[q.jsx(OK,{autoFocus:f,checked:g,defaultChecked:N,className:xe.input,disabled:ie,id:Ie?M:void 0,name:P,onChange:ke,readOnly:F,ref:B,required:Y,ownerState:je,tabIndex:ae,type:te,...te==="checkbox"&&oe===void 0?{}:{value:oe},...R}),ue?x:j]})});function tB(a){return a.substring(2).toLowerCase()}function BK(a,i){return i.documentElement.clientWidth<a.clientX||i.documentElement.clientHeight<a.clientY}function FK(a){const{children:i,disableReactTree:p=!1,mouseEvent:f="onClick",onClickAway:g,touchEvent:x="onTouchEnd"}=a,k=se.useRef(!1),N=se.useRef(null),E=se.useRef(!1),z=se.useRef(!1);se.useEffect(()=>(setTimeout(()=>{E.current=!0},0),()=>{E.current=!1}),[]);const G=js(rp(i),N),j=el(B=>{const P=z.current;z.current=!1;const H=go(N.current);if(!E.current||!N.current||"clientX"in B&&BK(B,H))return;if(k.current){k.current=!1;return}let C;B.composedPath?C=B.composedPath().includes(N.current):C=!H.documentElement.contains(B.target)||N.current.contains(B.target),!C&&(p||!P)&&g(B)}),M=B=>P=>{z.current=!0;const H=i.props[B];H&&H(P)},R={ref:G};return x!==!1&&(R[x]=M(x)),se.useEffect(()=>{if(x!==!1){const B=tB(x),P=go(N.current),H=()=>{k.current=!0};return P.addEventListener(B,j),P.addEventListener("touchmove",H),()=>{P.removeEventListener(B,j),P.removeEventListener("touchmove",H)}}},[j,x]),f!==!1&&(R[f]=M(f)),se.useEffect(()=>{if(f!==!1){const B=tB(f),P=go(N.current);return P.addEventListener(B,j),()=>{P.removeEventListener(B,j)}}},[j,f]),q.jsx(se.Fragment,{children:se.cloneElement(i,R)})}const tC=typeof Zk({})=="function",LK=(a,i)=>({WebkitFontSmoothing:"antialiased",MozOsxFontSmoothing:"grayscale",boxSizing:"border-box",WebkitTextSizeAdjust:"100%",...i&&!a.vars&&{colorScheme:a.palette.mode}}),RK=a=>({color:(a.vars||a).palette.text.primary,...a.typography.body1,backgroundColor:(a.vars||a).palette.background.default,"@media print":{backgroundColor:(a.vars||a).palette.common.white}}),nB=(a,i=!1)=>{var x,k;const p={};i&&a.colorSchemes&&typeof a.getColorSchemeSelector=="function"&&Object.entries(a.colorSchemes).forEach(([N,E])=>{var G,j;const z=a.getColorSchemeSelector(N);z.startsWith("@")?p[z]={":root":{colorScheme:(G=E.palette)==null?void 0:G.mode}}:p[z.replace(/\s*&/,"")]={colorScheme:(j=E.palette)==null?void 0:j.mode}});let f={html:LK(a,i),"*, *::before, *::after":{boxSizing:"inherit"},"strong, b":{fontWeight:a.typography.fontWeightBold},body:{margin:0,...RK(a),"&::backdrop":{backgroundColor:(a.vars||a).palette.background.default}},...p};const g=(k=(x=a.components)==null?void 0:x.MuiCssBaseline)==null?void 0:k.styleOverrides;return g&&(f=[f,g]),f},m0="mui-ecs",WK=a=>{const i=nB(a,!1),p=Array.isArray(i)?i[0]:i;return!a.vars&&p&&(p.html[`:root:has(${m0})`]={colorScheme:a.palette.mode}),a.colorSchemes&&Object.entries(a.colorSchemes).forEach(([f,g])=>{var k,N;const x=a.getColorSchemeSelector(f);x.startsWith("@")?p[x]={[`:root:not(:has(.${m0}))`]:{colorScheme:(k=g.palette)==null?void 0:k.mode}}:p[x.replace(/\s*&/,"")]={[`&:not(:has(.${m0}))`]:{colorScheme:(N=g.palette)==null?void 0:N.mode}}}),i},jK=Zk(tC?({theme:a,enableColorScheme:i})=>nB(a,i):({theme:a})=>WK(a));function HK(a){const i=tr({props:a,name:"MuiCssBaseline"}),{children:p,enableColorScheme:f=!1}=i;return q.jsxs(se.Fragment,{children:[tC&&q.jsx(jK,{enableColorScheme:f}),!tC&&!f&&q.jsx("span",{className:m0,style:{display:"none"}}),p]})}function GK(a){const i=go(a);return i.body===a?_A(a).innerWidth>i.documentElement.clientWidth:a.scrollHeight>a.clientHeight}function Ef(a,i){i?a.setAttribute("aria-hidden","true"):a.removeAttribute("aria-hidden")}function rB(a){return parseInt(_A(a).getComputedStyle(a).paddingRight,10)||0}function VK(a){const p=["TEMPLATE","SCRIPT","STYLE","LINK","MAP","META","NOSCRIPT","PICTURE","COL","COLGROUP","PARAM","SLOT","SOURCE","TRACK"].includes(a.tagName),f=a.tagName==="INPUT"&&a.getAttribute("type")==="hidden";return p||f}function sB(a,i,p,f,g){const x=[i,p,...f];[].forEach.call(a.children,k=>{const N=!x.includes(k),E=!VK(k);N&&E&&Ef(k,g)})}function nC(a,i){let p=-1;return a.some((f,g)=>i(f)?(p=g,!0):!1),p}function XK(a,i){const p=[],f=a.container;if(!i.disableScrollLock){if(GK(f)){const k=cP(_A(f));p.push({value:f.style.paddingRight,property:"padding-right",el:f}),f.style.paddingRight=`${rB(f)+k}px`;const N=go(f).querySelectorAll(".mui-fixed");[].forEach.call(N,E=>{p.push({value:E.style.paddingRight,property:"padding-right",el:E}),E.style.paddingRight=`${rB(E)+k}px`})}let x;if(f.parentNode instanceof DocumentFragment)x=go(f).body;else{const k=f.parentElement,N=_A(f);x=(k==null?void 0:k.nodeName)==="HTML"&&N.getComputedStyle(k).overflowY==="scroll"?k:f}p.push({value:x.style.overflow,property:"overflow",el:x},{value:x.style.overflowX,property:"overflow-x",el:x},{value:x.style.overflowY,property:"overflow-y",el:x}),x.style.overflow="hidden"}return()=>{p.forEach(({value:x,el:k,property:N})=>{x?k.style.setProperty(N,x):k.style.removeProperty(N)})}}function ZK(a){const i=[];return[].forEach.call(a.children,p=>{p.getAttribute("aria-hidden")==="true"&&i.push(p)}),i}class YK{constructor(){this.modals=[],this.containers=[]}add(i,p){let f=this.modals.indexOf(i);if(f!==-1)return f;f=this.modals.length,this.modals.push(i),i.modalRef&&Ef(i.modalRef,!1);const g=ZK(p);sB(p,i.mount,i.modalRef,g,!0);const x=nC(this.containers,k=>k.container===p);return x!==-1?(this.containers[x].modals.push(i),f):(this.containers.push({modals:[i],container:p,restore:null,hiddenSiblings:g}),f)}mount(i,p){const f=nC(this.containers,x=>x.modals.includes(i)),g=this.containers[f];g.restore||(g.restore=XK(g,p))}remove(i,p=!0){const f=this.modals.indexOf(i);if(f===-1)return f;const g=nC(this.containers,k=>k.modals.includes(i)),x=this.containers[g];if(x.modals.splice(x.modals.indexOf(i),1),this.modals.splice(f,1),x.modals.length===0)x.restore&&x.restore(),i.modalRef&&Ef(i.modalRef,p),sB(x.container,i.mount,i.modalRef,x.hiddenSiblings,!1),this.containers.splice(g,1);else{const k=x.modals[x.modals.length-1];k.modalRef&&Ef(k.modalRef,!1)}return f}isTopModal(i){return this.modals.length>0&&this.modals[this.modals.length-1]===i}}const UK=["input","select","textarea","a[href]","button","[tabindex]","audio[controls]","video[controls]",'[contenteditable]:not([contenteditable="false"])'].join(",");function QK(a){const i=parseInt(a.getAttribute("tabindex")||"",10);return Number.isNaN(i)?a.contentEditable==="true"||(a.nodeName==="AUDIO"||a.nodeName==="VIDEO"||a.nodeName==="DETAILS")&&a.getAttribute("tabindex")===null?0:a.tabIndex:i}function KK(a){if(a.tagName!=="INPUT"||a.type!=="radio"||!a.name)return!1;const i=f=>a.ownerDocument.querySelector(`input[type="radio"]${f}`);let p=i(`[name="${a.name}"]:checked`);return p||(p=i(`[name="${a.name}"]`)),p!==a}function qK(a){return!(a.disabled||a.tagName==="INPUT"&&a.type==="hidden"||KK(a))}function JK(a){const i=[],p=[];return Array.from(a.querySelectorAll(UK)).forEach((f,g)=>{const x=QK(f);x===-1||!qK(f)||(x===0?i.push(f):p.push({documentOrder:g,tabIndex:x,node:f}))}),p.sort((f,g)=>f.tabIndex===g.tabIndex?f.documentOrder-g.documentOrder:f.tabIndex-g.tabIndex).map(f=>f.node).concat(i)}function $K(){return!0}function _K(a){const{children:i,disableAutoFocus:p=!1,disableEnforceFocus:f=!1,disableRestoreFocus:g=!1,getTabbable:x=JK,isEnabled:k=$K,open:N}=a,E=se.useRef(!1),z=se.useRef(null),G=se.useRef(null),j=se.useRef(null),M=se.useRef(null),R=se.useRef(!1),B=se.useRef(null),P=js(rp(i),B),H=se.useRef(null);se.useEffect(()=>{!N||!B.current||(R.current=!p)},[p,N]),se.useEffect(()=>{if(!N||!B.current)return;const F=go(B.current);return B.current.contains(F.activeElement)||(B.current.hasAttribute("tabIndex")||B.current.setAttribute("tabIndex","-1"),R.current&&B.current.focus()),()=>{g||(j.current&&j.current.focus&&(E.current=!0,j.current.focus()),j.current=null)}},[N]),se.useEffect(()=>{if(!N||!B.current)return;const F=go(B.current),Y=oe=>{H.current=oe,!(f||!k()||oe.key!=="Tab")&&F.activeElement===B.current&&oe.shiftKey&&(E.current=!0,G.current&&G.current.focus())},ae=()=>{var ue,Z;const oe=B.current;if(oe===null)return;if(!F.hasFocus()||!k()||E.current){E.current=!1;return}if(oe.contains(F.activeElement)||f&&F.activeElement!==z.current&&F.activeElement!==G.current)return;if(F.activeElement!==M.current)M.current=null;else if(M.current!==null)return;if(!R.current)return;let fe=[];if((F.activeElement===z.current||F.activeElement===G.current)&&(fe=x(B.current)),fe.length>0){const ye=!!((ue=H.current)!=null&&ue.shiftKey&&((Z=H.current)==null?void 0:Z.key)==="Tab"),pe=fe[0],Q=fe[fe.length-1];typeof pe!="string"&&typeof Q!="string"&&(ye?Q.focus():pe.focus())}else oe.focus()};F.addEventListener("focusin",ae),F.addEventListener("keydown",Y,!0);const te=setInterval(()=>{F.activeElement&&F.activeElement.tagName==="BODY"&&ae()},50);return()=>{clearInterval(te),F.removeEventListener("focusin",ae),F.removeEventListener("keydown",Y,!0)}},[p,f,g,k,N,x]);const C=F=>{j.current===null&&(j.current=F.relatedTarget),R.current=!0,M.current=F.target;const Y=i.props.onFocus;Y&&Y(F)},O=F=>{j.current===null&&(j.current=F.relatedTarget),R.current=!0};return q.jsxs(se.Fragment,{children:[q.jsx("div",{tabIndex:N?0:-1,onFocus:O,ref:z,"data-testid":"sentinelStart"}),se.cloneElement(i,{ref:P,onFocus:C}),q.jsx("div",{tabIndex:N?0:-1,onFocus:O,ref:G,"data-testid":"sentinelEnd"})]})}function eq(a){return typeof a=="function"?a():a}function tq(a){return a?a.props.hasOwnProperty("in"):!1}const g0=new YK;function nq(a){const{container:i,disableEscapeKeyDown:p=!1,disableScrollLock:f=!1,closeAfterTransition:g=!1,onTransitionEnter:x,onTransitionExited:k,children:N,onClose:E,open:z,rootRef:G}=a,j=se.useRef({}),M=se.useRef(null),R=se.useRef(null),B=js(R,G),[P,H]=se.useState(!z),C=tq(N);let O=!0;(a["aria-hidden"]==="false"||a["aria-hidden"]===!1)&&(O=!1);const F=()=>go(M.current),Y=()=>(j.current.modalRef=R.current,j.current.mount=M.current,j.current),ae=()=>{g0.mount(Y(),{disableScrollLock:f}),R.current&&(R.current.scrollTop=0)},te=el(()=>{const ie=eq(i)||F().body;g0.add(Y(),ie),R.current&&ae()}),oe=()=>g0.isTopModal(Y()),fe=el(ie=>{M.current=ie,ie&&(z&&oe()?ae():R.current&&Ef(R.current,O))}),ue=se.useCallback(()=>{g0.remove(Y(),O)},[O]);se.useEffect(()=>()=>{ue()},[ue]),se.useEffect(()=>{z?te():(!C||!g)&&ue()},[z,ue,C,g,te]);const Z=ie=>Ie=>{var je;(je=ie.onKeyDown)==null||je.call(ie,Ie),!(Ie.key!=="Escape"||Ie.which===229||!oe())&&(p||(Ie.stopPropagation(),E&&E(Ie,"escapeKeyDown")))},ye=ie=>Ie=>{var je;(je=ie.onClick)==null||je.call(ie,Ie),Ie.target===Ie.currentTarget&&E&&E(Ie,"backdropClick")};return{getRootProps:(ie={})=>{const Ie=n0(a);delete Ie.onTransitionEnter,delete Ie.onTransitionExited;const je={...Ie,...ie};return{role:"presentation",...je,onKeyDown:Z(je),ref:B}},getBackdropProps:(ie={})=>{const Ie=ie;return{"aria-hidden":!0,...Ie,onClick:ye(Ie),open:z}},getTransitionProps:()=>{const ie=()=>{H(!1),x&&x()},Ie=()=>{H(!0),k&&k(),g&&ue()};return{onEnter:Mk(ie,N==null?void 0:N.props.onEnter),onExited:Mk(Ie,N==null?void 0:N.props.onExited)}},rootRef:B,portalRef:fe,isTopModal:oe,exited:P,hasTransition:C}}function rq(a){return Xn("MuiModal",a)}Ln("MuiModal",["root","hidden","backdrop"]);const sq=a=>{const{open:i,exited:p,classes:f}=a;return qn({root:["root",!i&&p&&"hidden"],backdrop:["backdrop"]},rq,f)},aq=Lt("div",{name:"MuiModal",slot:"Root",overridesResolver:(a,i)=>{const{ownerState:p}=a;return[i.root,!p.open&&p.exited&&i.hidden]}})(cr(({theme:a})=>({position:"fixed",zIndex:(a.vars||a).zIndex.modal,right:0,bottom:0,top:0,left:0,variants:[{props:({ownerState:i})=>!i.open&&i.exited,style:{visibility:"hidden"}}]}))),oq=Lt(_P,{name:"MuiModal",slot:"Backdrop",overridesResolver:(a,i)=>i.backdrop})({zIndex:-1}),aB=se.forwardRef(function(i,p){const f=tr({name:"MuiModal",props:i}),{BackdropComponent:g=oq,BackdropProps:x,classes:k,className:N,closeAfterTransition:E=!1,children:z,container:G,component:j,components:M={},componentsProps:R={},disableAutoFocus:B=!1,disableEnforceFocus:P=!1,disableEscapeKeyDown:H=!1,disablePortal:C=!1,disableRestoreFocus:O=!1,disableScrollLock:F=!1,hideBackdrop:Y=!1,keepMounted:ae=!1,onBackdropClick:te,onClose:oe,onTransitionEnter:fe,onTransitionExited:ue,open:Z,slotProps:ye={},slots:pe={},theme:Q,...ke}=f,ie={...f,closeAfterTransition:E,disableAutoFocus:B,disableEnforceFocus:P,disableEscapeKeyDown:H,disablePortal:C,disableRestoreFocus:O,disableScrollLock:F,hideBackdrop:Y,keepMounted:ae},{getRootProps:Ie,getBackdropProps:je,getTransitionProps:xe,portalRef:We,isTopModal:Ke,exited:ut,hasTransition:ge}=nq({...ie,rootRef:p}),Qe={...ie,exited:ut},At=sq(Qe),dt={};if(z.props.tabIndex===void 0&&(dt.tabIndex="-1"),ge){const{onEnter:Wt,onExited:on}=xe();dt.onEnter=Wt,dt.onExited=on}const It={...ke,slots:{root:M.Root,backdrop:M.Backdrop,...pe},slotProps:{...R,...ye}},[Ft,pn]=yo("root",{elementType:aq,externalForwardedProps:It,getSlotProps:Ie,additionalProps:{ref:p,as:j},ownerState:Qe,className:fn(N,At==null?void 0:At.root,!Qe.open&&Qe.exited&&(At==null?void 0:At.hidden))}),[Yt,wt]=yo("backdrop",{elementType:g,externalForwardedProps:It,additionalProps:x,getSlotProps:Wt=>je({...Wt,onClick:on=>{te&&te(on),Wt!=null&&Wt.onClick&&Wt.onClick(on)}}),className:fn(x==null?void 0:x.className,At==null?void 0:At.backdrop),ownerState:Qe}),Ht=js(x==null?void 0:x.ref,wt.ref);return!ae&&!Z&&(!ge||ut)?null:q.jsx(aK,{ref:We,container:G,disablePortal:C,children:q.jsxs(Ft,{...pn,children:[!Y&&g?q.jsx(Yt,{...wt,ref:Ht}):null,q.jsx(_K,{disableEnforceFocus:P,disableAutoFocus:B,disableRestoreFocus:O,isEnabled:Ke,open:Z,children:se.cloneElement(z,dt)})]})})});function iq(a){return Xn("MuiDialog",a)}const rC=Ln("MuiDialog",["root","scrollPaper","scrollBody","container","paper","paperScrollPaper","paperScrollBody","paperWidthFalse","paperWidthXs","paperWidthSm","paperWidthMd","paperWidthLg","paperWidthXl","paperFullWidth","paperFullScreen"]),oB=se.createContext({}),Aq=Lt(_P,{name:"MuiDialog",slot:"Backdrop",overrides:(a,i)=>i.backdrop})({zIndex:-1}),lq=a=>{const{classes:i,scroll:p,maxWidth:f,fullWidth:g,fullScreen:x}=a,k={root:["root"],container:["container",`scroll${tn(p)}`],paper:["paper",`paperScroll${tn(p)}`,`paperWidth${tn(String(f))}`,g&&"paperFullWidth",x&&"paperFullScreen"]};return qn(k,iq,i)},uq=Lt(aB,{name:"MuiDialog",slot:"Root",overridesResolver:(a,i)=>i.root})({"@media print":{position:"absolute !important"}}),cq=Lt("div",{name:"MuiDialog",slot:"Container",overridesResolver:(a,i)=>{const{ownerState:p}=a;return[i.container,i[`scroll${tn(p.scroll)}`]]}})({height:"100%","@media print":{height:"auto"},outline:0,variants:[{props:{scroll:"paper"},style:{display:"flex",justifyContent:"center",alignItems:"center"}},{props:{scroll:"body"},style:{overflowY:"auto",overflowX:"hidden",textAlign:"center","&::after":{content:'""',display:"inline-block",verticalAlign:"middle",height:"100%",width:"0"}}}]}),dq=Lt(Tf,{name:"MuiDialog",slot:"Paper",overridesResolver:(a,i)=>{const{ownerState:p}=a;return[i.paper,i[`scrollPaper${tn(p.scroll)}`],i[`paperWidth${tn(String(p.maxWidth))}`],p.fullWidth&&i.paperFullWidth,p.fullScreen&&i.paperFullScreen]}})(cr(({theme:a})=>({margin:32,position:"relative",overflowY:"auto","@media print":{overflowY:"visible",boxShadow:"none"},variants:[{props:{scroll:"paper"},style:{display:"flex",flexDirection:"column",maxHeight:"calc(100% - 64px)"}},{props:{scroll:"body"},style:{display:"inline-block",verticalAlign:"middle",textAlign:"initial"}},{props:({ownerState:i})=>!i.maxWidth,style:{maxWidth:"calc(100% - 64px)"}},{props:{maxWidth:"xs"},style:{maxWidth:a.breakpoints.unit==="px"?Math.max(a.breakpoints.values.xs,444):`max(${a.breakpoints.values.xs}${a.breakpoints.unit}, 444px)`,[`&.${rC.paperScrollBody}`]:{[a.breakpoints.down(Math.max(a.breakpoints.values.xs,444)+32*2)]:{maxWidth:"calc(100% - 64px)"}}}},...Object.keys(a.breakpoints.values).filter(i=>i!=="xs").map(i=>({props:{maxWidth:i},style:{maxWidth:`${a.breakpoints.values[i]}${a.breakpoints.unit}`,[`&.${rC.paperScrollBody}`]:{[a.breakpoints.down(a.breakpoints.values[i]+32*2)]:{maxWidth:"calc(100% - 64px)"}}}})),{props:({ownerState:i})=>i.fullWidth,style:{width:"calc(100% - 64px)"}},{props:({ownerState:i})=>i.fullScreen,style:{margin:0,width:"100%",maxWidth:"100%",height:"100%",maxHeight:"none",borderRadius:0,[`&.${rC.paperScrollBody}`]:{margin:0,maxWidth:"100%"}}}]}))),pq=se.forwardRef(function(i,p){const f=tr({props:i,name:"MuiDialog"}),g=sp(),x={enter:g.transitions.duration.enteringScreen,exit:g.transitions.duration.leavingScreen},{"aria-describedby":k,"aria-labelledby":N,"aria-modal":E=!0,BackdropComponent:z,BackdropProps:G,children:j,className:M,disableEscapeKeyDown:R=!1,fullScreen:B=!1,fullWidth:P=!1,maxWidth:H="sm",onBackdropClick:C,onClick:O,onClose:F,open:Y,PaperComponent:ae=Tf,PaperProps:te={},scroll:oe="paper",TransitionComponent:fe=$P,transitionDuration:ue=x,TransitionProps:Z,...ye}=f,pe={...f,disableEscapeKeyDown:R,fullScreen:B,fullWidth:P,maxWidth:H,scroll:oe},Q=lq(pe),ke=se.useRef(),ie=We=>{ke.current=We.target===We.currentTarget},Ie=We=>{O&&O(We),ke.current&&(ke.current=null,C&&C(We),F&&F(We,"backdropClick"))},je=e0(N),xe=se.useMemo(()=>({titleId:je}),[je]);return q.jsx(uq,{className:fn(Q.root,M),closeAfterTransition:!0,components:{Backdrop:Aq},componentsProps:{backdrop:{transitionDuration:ue,as:z,...G}},disableEscapeKeyDown:R,onClose:F,open:Y,ref:p,onClick:Ie,ownerState:pe,...ye,children:q.jsx(fe,{appear:!0,in:Y,timeout:ue,role:"presentation",...Z,children:q.jsx(cq,{className:fn(Q.container),onMouseDown:ie,ownerState:pe,children:q.jsx(dq,{as:ae,elevation:24,role:"dialog","aria-describedby":k,"aria-labelledby":je,"aria-modal":E,...te,className:fn(Q.paper,te.className),ownerState:pe,children:q.jsx(oB.Provider,{value:xe,children:j})})})})})});function hq(a){return Xn("MuiDialogContent",a)}Ln("MuiDialogContent",["root","dividers"]);function fq(a){return Xn("MuiDialogTitle",a)}const mq=Ln("MuiDialogTitle",["root"]),gq=a=>{const{classes:i,dividers:p}=a;return qn({root:["root",p&&"dividers"]},hq,i)},yq=Lt("div",{name:"MuiDialogContent",slot:"Root",overridesResolver:(a,i)=>{const{ownerState:p}=a;return[i.root,p.dividers&&i.dividers]}})(cr(({theme:a})=>({flex:"1 1 auto",WebkitOverflowScrolling:"touch",overflowY:"auto",padding:"20px 24px",variants:[{props:({ownerState:i})=>i.dividers,style:{padding:"16px 24px",borderTop:`1px solid ${(a.vars||a).palette.divider}`,borderBottom:`1px solid ${(a.vars||a).palette.divider}`}},{props:({ownerState:i})=>!i.dividers,style:{[`.${mq.root} + &`]:{paddingTop:0}}}]}))),bq=se.forwardRef(function(i,p){const f=tr({props:i,name:"MuiDialogContent"}),{className:g,dividers:x=!1,...k}=f,N={...f,dividers:x},E=gq(N);return q.jsx(yq,{className:fn(E.root,g),ownerState:N,ref:p,...k})}),vq=a=>{const{classes:i}=a;return qn({root:["root"]},fq,i)},xq=Lt(mn,{name:"MuiDialogTitle",slot:"Root",overridesResolver:(a,i)=>i.root})({padding:"16px 24px",flex:"0 0 auto"}),wq=se.forwardRef(function(i,p){const f=tr({props:i,name:"MuiDialogTitle"}),{className:g,id:x,...k}=f,N=f,E=vq(N),{titleId:z=x}=se.useContext(oB);return q.jsx(xq,{component:"h2",className:fn(E.root,g),ownerState:N,ref:p,variant:"h6",id:x??z,...k})}),iB=Ln("MuiDivider",["root","absolute","fullWidth","inset","middle","flexItem","light","vertical","withChildren","withChildrenVertical","textAlignRight","textAlignLeft","wrapper","wrapperVertical"]),kq=a=>{const{classes:i,disableUnderline:p,startAdornment:f,endAdornment:g,size:x,hiddenLabel:k,multiline:N}=a,E={root:["root",!p&&"underline",f&&"adornedStart",g&&"adornedEnd",x==="small"&&`size${tn(x)}`,k&&"hiddenLabel",N&&"multiline"],input:["input"]},z=qn(E,hK,i);return{...i,...z}},Cq=Lt(h0,{shouldForwardProp:a=>qa(a)||a==="classes",name:"MuiFilledInput",slot:"Root",overridesResolver:(a,i)=>{const{ownerState:p}=a;return[...d0(a,i),!p.disableUnderline&&i.underline]}})(cr(({theme:a})=>{const i=a.palette.mode==="light",p=i?"rgba(0, 0, 0, 0.42)":"rgba(255, 255, 255, 0.7)",f=i?"rgba(0, 0, 0, 0.06)":"rgba(255, 255, 255, 0.09)",g=i?"rgba(0, 0, 0, 0.09)":"rgba(255, 255, 255, 0.13)",x=i?"rgba(0, 0, 0, 0.12)":"rgba(255, 255, 255, 0.12)";return{position:"relative",backgroundColor:a.vars?a.vars.palette.FilledInput.bg:f,borderTopLeftRadius:(a.vars||a).shape.borderRadius,borderTopRightRadius:(a.vars||a).shape.borderRadius,transition:a.transitions.create("background-color",{duration:a.transitions.duration.shorter,easing:a.transitions.easing.easeOut}),"&:hover":{backgroundColor:a.vars?a.vars.palette.FilledInput.hoverBg:g,"@media (hover: none)":{backgroundColor:a.vars?a.vars.palette.FilledInput.bg:f}},[`&.${mc.focused}`]:{backgroundColor:a.vars?a.vars.palette.FilledInput.bg:f},[`&.${mc.disabled}`]:{backgroundColor:a.vars?a.vars.palette.FilledInput.disabledBg:x},variants:[{props:({ownerState:k})=>!k.disableUnderline,style:{"&::after":{left:0,bottom:0,content:'""',position:"absolute",right:0,transform:"scaleX(0)",transition:a.transitions.create("transform",{duration:a.transitions.duration.shorter,easing:a.transitions.easing.easeOut}),pointerEvents:"none"},[`&.${mc.focused}:after`]:{transform:"scaleX(1) translateX(0)"},[`&.${mc.error}`]:{"&::before, &::after":{borderBottomColor:(a.vars||a).palette.error.main}},"&::before":{borderBottom:`1px solid ${a.vars?`rgba(${a.vars.palette.common.onBackgroundChannel} / ${a.vars.opacity.inputUnderline})`:p}`,left:0,bottom:0,content:'"\\00a0"',position:"absolute",right:0,transition:a.transitions.create("border-bottom-color",{duration:a.transitions.duration.shorter}),pointerEvents:"none"},[`&:hover:not(.${mc.disabled}, .${mc.error}):before`]:{borderBottom:`1px solid ${(a.vars||a).palette.text.primary}`},[`&.${mc.disabled}:before`]:{borderBottomStyle:"dotted"}}},...Object.entries(a.palette).filter(Vo()).map(([k])=>{var N;return{props:{disableUnderline:!1,color:k},style:{"&::after":{borderBottom:`2px solid ${(N=(a.vars||a).palette[k])==null?void 0:N.main}`}}}}),{props:({ownerState:k})=>k.startAdornment,style:{paddingLeft:12}},{props:({ownerState:k})=>k.endAdornment,style:{paddingRight:12}},{props:({ownerState:k})=>k.multiline,style:{padding:"25px 12px 8px"}},{props:({ownerState:k,size:N})=>k.multiline&&N==="small",style:{paddingTop:21,paddingBottom:4}},{props:({ownerState:k})=>k.multiline&&k.hiddenLabel,style:{paddingTop:16,paddingBottom:17}},{props:({ownerState:k})=>k.multiline&&k.hiddenLabel&&k.size==="small",style:{paddingTop:8,paddingBottom:9}}]}})),Iq=Lt(f0,{name:"MuiFilledInput",slot:"Input",overridesResolver:p0})(cr(({theme:a})=>({paddingTop:25,paddingRight:12,paddingBottom:8,paddingLeft:12,...!a.vars&&{"&:-webkit-autofill":{WebkitBoxShadow:a.palette.mode==="light"?null:"0 0 0 100px #266798 inset",WebkitTextFillColor:a.palette.mode==="light"?null:"#fff",caretColor:a.palette.mode==="light"?null:"#fff",borderTopLeftRadius:"inherit",borderTopRightRadius:"inherit"}},...a.vars&&{"&:-webkit-autofill":{borderTopLeftRadius:"inherit",borderTopRightRadius:"inherit"},[a.getColorSchemeSelector("dark")]:{"&:-webkit-autofill":{WebkitBoxShadow:"0 0 0 100px #266798 inset",WebkitTextFillColor:"#fff",caretColor:"#fff"}}},variants:[{props:{size:"small"},style:{paddingTop:21,paddingBottom:4}},{props:({ownerState:i})=>i.hiddenLabel,style:{paddingTop:16,paddingBottom:17}},{props:({ownerState:i})=>i.startAdornment,style:{paddingLeft:0}},{props:({ownerState:i})=>i.endAdornment,style:{paddingRight:0}},{props:({ownerState:i})=>i.hiddenLabel&&i.size==="small",style:{paddingTop:8,paddingBottom:9}},{props:({ownerState:i})=>i.multiline,style:{paddingTop:0,paddingBottom:0,paddingLeft:0,paddingRight:0}}]}))),y0=se.forwardRef(function(i,p){const f=tr({props:i,name:"MuiFilledInput"}),{disableUnderline:g=!1,components:x={},componentsProps:k,fullWidth:N=!1,hiddenLabel:E,inputComponent:z="input",multiline:G=!1,slotProps:j,slots:M={},type:R="text",...B}=f,P={...f,disableUnderline:g,fullWidth:N,inputComponent:z,multiline:G,type:R},H=kq(f),C={root:{ownerState:P},input:{ownerState:P}},O=j??k?Oa(C,j??k):C,F=M.root??x.Root??Cq,Y=M.input??x.Input??Iq;return q.jsx(_k,{slots:{root:F,input:Y},componentsProps:O,fullWidth:N,inputComponent:z,multiline:G,ref:p,type:R,...B,classes:H})});y0&&(y0.muiName="Input");function Sq(a){return Xn("MuiFormControl",a)}Ln("MuiFormControl",["root","marginNone","marginNormal","marginDense","fullWidth","disabled"]);const Nq=a=>{const{classes:i,margin:p,fullWidth:f}=a,g={root:["root",p!=="none"&&`margin${tn(p)}`,f&&"fullWidth"]};return qn(g,Sq,i)},Tq=Lt("div",{name:"MuiFormControl",slot:"Root",overridesResolver:({ownerState:a},i)=>({...i.root,...i[`margin${tn(a.margin)}`],...a.fullWidth&&i.fullWidth})})({display:"inline-flex",flexDirection:"column",position:"relative",minWidth:0,padding:0,margin:0,border:0,verticalAlign:"top",variants:[{props:{margin:"normal"},style:{marginTop:16,marginBottom:8}},{props:{margin:"dense"},style:{marginTop:8,marginBottom:4}},{props:{fullWidth:!0},style:{width:"100%"}}]}),Mq=se.forwardRef(function(i,p){const f=tr({props:i,name:"MuiFormControl"}),{children:g,className:x,color:k="primary",component:N="div",disabled:E=!1,error:z=!1,focused:G,fullWidth:j=!1,hiddenLabel:M=!1,margin:R="none",required:B=!1,size:P="medium",variant:H="outlined",...C}=f,O={...f,color:k,component:N,disabled:E,error:z,fullWidth:j,hiddenLabel:M,margin:R,required:B,size:P,variant:H},F=Nq(O),[Y,ae]=se.useState(()=>{let Q=!1;return g&&se.Children.forEach(g,ke=>{if(!Ek(ke,["Input","Select"]))return;const ie=Ek(ke,["Select"])?ke.props.input:ke;ie&&lK(ie.props)&&(Q=!0)}),Q}),[te,oe]=se.useState(()=>{let Q=!1;return g&&se.Children.forEach(g,ke=>{Ek(ke,["Input","Select"])&&(c0(ke.props,!0)||c0(ke.props.inputProps,!0))&&(Q=!0)}),Q}),[fe,ue]=se.useState(!1);E&&fe&&ue(!1);const Z=G!==void 0&&!E?G:fe;let ye;se.useRef(!1);const pe=se.useMemo(()=>({adornedStart:Y,setAdornedStart:ae,color:k,disabled:E,error:z,filled:te,focused:Z,fullWidth:j,hiddenLabel:M,size:P,onBlur:()=>{ue(!1)},onEmpty:()=>{oe(!1)},onFilled:()=>{oe(!0)},onFocus:()=>{ue(!0)},registerEffect:ye,required:B,variant:H}),[Y,k,E,z,te,Z,j,M,ye,B,P,H]);return q.jsx($k.Provider,{value:pe,children:q.jsx(Tq,{as:N,ownerState:O,className:fn(F.root,x),ref:p,...C,children:g})})});function Eq(a){return Xn("MuiFormControlLabel",a)}const Df=Ln("MuiFormControlLabel",["root","labelPlacementStart","labelPlacementTop","labelPlacementBottom","disabled","label","error","required","asterisk"]),Dq=a=>{const{classes:i,disabled:p,labelPlacement:f,error:g,required:x}=a,k={root:["root",p&&"disabled",`labelPlacement${tn(f)}`,g&&"error",x&&"required"],label:["label",p&&"disabled"],asterisk:["asterisk",g&&"error"]};return qn(k,Eq,i)},zq=Lt("label",{name:"MuiFormControlLabel",slot:"Root",overridesResolver:(a,i)=>{const{ownerState:p}=a;return[{[`& .${Df.label}`]:i.label},i.root,i[`labelPlacement${tn(p.labelPlacement)}`]]}})(cr(({theme:a})=>({display:"inline-flex",alignItems:"center",cursor:"pointer",verticalAlign:"middle",WebkitTapHighlightColor:"transparent",marginLeft:-11,marginRight:16,[`&.${Df.disabled}`]:{cursor:"default"},[`& .${Df.label}`]:{[`&.${Df.disabled}`]:{color:(a.vars||a).palette.text.disabled}},variants:[{props:{labelPlacement:"start"},style:{flexDirection:"row-reverse",marginRight:-11}},{props:{labelPlacement:"top"},style:{flexDirection:"column-reverse"}},{props:{labelPlacement:"bottom"},style:{flexDirection:"column"}},{props:({labelPlacement:i})=>i==="start"||i==="top"||i==="bottom",style:{marginLeft:16}}]}))),Oq=Lt("span",{name:"MuiFormControlLabel",slot:"Asterisk",overridesResolver:(a,i)=>i.asterisk})(cr(({theme:a})=>({[`&.${Df.error}`]:{color:(a.vars||a).palette.error.main}}))),sC=se.forwardRef(function(i,p){const f=tr({props:i,name:"MuiFormControlLabel"}),{checked:g,className:x,componentsProps:k={},control:N,disabled:E,disableTypography:z,inputRef:G,label:j,labelPlacement:M="end",name:R,onChange:B,required:P,slots:H={},slotProps:C={},value:O,...F}=f,Y=gA(),ae=E??N.props.disabled??(Y==null?void 0:Y.disabled),te=P??N.props.required,oe={disabled:ae,required:te};["checked","name","onChange","value","inputRef"].forEach(ie=>{typeof N.props[ie]>"u"&&typeof f[ie]<"u"&&(oe[ie]=f[ie])});const fe=ql({props:f,muiFormControl:Y,states:["error"]}),ue={...f,disabled:ae,labelPlacement:M,required:te,error:fe.error},Z=Dq(ue),ye={slots:H,slotProps:{...k,...C}},[pe,Q]=yo("typography",{elementType:mn,externalForwardedProps:ye,ownerState:ue});let ke=j;return ke!=null&&ke.type!==mn&&!z&&(ke=q.jsx(pe,{component:"span",...Q,className:fn(Z.label,Q==null?void 0:Q.className),children:ke})),q.jsxs(zq,{className:fn(Z.root,x),ownerState:ue,ref:p,...F,children:[se.cloneElement(N,oe),te?q.jsxs("div",{children:[ke,q.jsxs(Oq,{ownerState:ue,"aria-hidden":!0,className:Z.asterisk,children:["","*"]})]}):ke]})});function Pq(a){return Xn("MuiFormGroup",a)}Ln("MuiFormGroup",["root","row","error"]);const Bq=a=>{const{classes:i,row:p,error:f}=a;return qn({root:["root",p&&"row",f&&"error"]},Pq,i)},Fq=Lt("div",{name:"MuiFormGroup",slot:"Root",overridesResolver:(a,i)=>{const{ownerState:p}=a;return[i.root,p.row&&i.row]}})({display:"flex",flexDirection:"column",flexWrap:"wrap",variants:[{props:{row:!0},style:{flexDirection:"row"}}]}),Lq=se.forwardRef(function(i,p){const f=tr({props:i,name:"MuiFormGroup"}),{className:g,row:x=!1,...k}=f,N=gA(),E=ql({props:f,muiFormControl:N,states:["error"]}),z={...f,row:x,error:E.error},G=Bq(z);return q.jsx(Fq,{className:fn(G.root,g),ownerState:z,ref:p,...k})});function Rq(a){return Xn("MuiFormHelperText",a)}const AB=Ln("MuiFormHelperText",["root","error","disabled","sizeSmall","sizeMedium","contained","focused","filled","required"]);var lB;const Wq=a=>{const{classes:i,contained:p,size:f,disabled:g,error:x,filled:k,focused:N,required:E}=a,z={root:["root",g&&"disabled",x&&"error",f&&`size${tn(f)}`,p&&"contained",N&&"focused",k&&"filled",E&&"required"]};return qn(z,Rq,i)},jq=Lt("p",{name:"MuiFormHelperText",slot:"Root",overridesResolver:(a,i)=>{const{ownerState:p}=a;return[i.root,p.size&&i[`size${tn(p.size)}`],p.contained&&i.contained,p.filled&&i.filled]}})(cr(({theme:a})=>({color:(a.vars||a).palette.text.secondary,...a.typography.caption,textAlign:"left",marginTop:3,marginRight:0,marginBottom:0,marginLeft:0,[`&.${AB.disabled}`]:{color:(a.vars||a).palette.text.disabled},[`&.${AB.error}`]:{color:(a.vars||a).palette.error.main},variants:[{props:{size:"small"},style:{marginTop:4}},{props:({ownerState:i})=>i.contained,style:{marginLeft:14,marginRight:14}}]}))),Hq=se.forwardRef(function(i,p){const f=tr({props:i,name:"MuiFormHelperText"}),{children:g,className:x,component:k="p",disabled:N,error:E,filled:z,focused:G,margin:j,required:M,variant:R,...B}=f,P=gA(),H=ql({props:f,muiFormControl:P,states:["variant","size","disabled","error","filled","focused","required"]}),C={...f,component:k,contained:H.variant==="filled"||H.variant==="outlined",variant:H.variant,size:H.size,disabled:H.disabled,error:H.error,filled:H.filled,focused:H.focused,required:H.required};delete C.ownerState;const O=Wq(C);return q.jsx(jq,{as:k,className:fn(O.root,x),ref:p,...B,ownerState:C,children:g===" "?lB||(lB=q.jsx("span",{className:"notranslate",children:""})):g})});function Gq(a){return Xn("MuiFormLabel",a)}const zf=Ln("MuiFormLabel",["root","colorSecondary","focused","disabled","error","filled","required","asterisk"]),Vq=a=>{const{classes:i,color:p,focused:f,disabled:g,error:x,filled:k,required:N}=a,E={root:["root",`color${tn(p)}`,g&&"disabled",x&&"error",k&&"filled",f&&"focused",N&&"required"],asterisk:["asterisk",x&&"error"]};return qn(E,Gq,i)},Xq=Lt("label",{name:"MuiFormLabel",slot:"Root",overridesResolver:({ownerState:a},i)=>({...i.root,...a.color==="secondary"&&i.colorSecondary,...a.filled&&i.filled})})(cr(({theme:a})=>({color:(a.vars||a).palette.text.secondary,...a.typography.body1,lineHeight:"1.4375em",padding:0,position:"relative",variants:[...Object.entries(a.palette).filter(Vo()).map(([i])=>({props:{color:i},style:{[`&.${zf.focused}`]:{color:(a.vars||a).palette[i].main}}})),{props:{},style:{[`&.${zf.disabled}`]:{color:(a.vars||a).palette.text.disabled},[`&.${zf.error}`]:{color:(a.vars||a).palette.error.main}}}]}))),Zq=Lt("span",{name:"MuiFormLabel",slot:"Asterisk",overridesResolver:(a,i)=>i.asterisk})(cr(({theme:a})=>({[`&.${zf.error}`]:{color:(a.vars||a).palette.error.main}}))),Yq=se.forwardRef(function(i,p){const f=tr({props:i,name:"MuiFormLabel"}),{children:g,className:x,color:k,component:N="label",disabled:E,error:z,filled:G,focused:j,required:M,...R}=f,B=gA(),P=ql({props:f,muiFormControl:B,states:["color","required","focused","disabled","error","filled"]}),H={...f,color:P.color||"primary",component:N,disabled:P.disabled,error:P.error,filled:P.filled,focused:P.focused,required:P.required},C=Vq(H);return q.jsxs(Xq,{as:N,ownerState:H,className:fn(C.root,x),ref:p,...R,children:[g,P.required&&q.jsxs(Zq,{ownerState:H,"aria-hidden":!0,className:C.asterisk,children:["","*"]})]})});function aC(a){return`scale(${a}, ${a**2})`}const Uq={entering:{opacity:1,transform:aC(1)},entered:{opacity:1,transform:"none"}},oC=typeof navigator<"u"&&/^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent)&&/(os |version\/)15(.|_)4/i.test(navigator.userAgent),b0=se.forwardRef(function(i,p){const{addEndListener:f,appear:g=!0,children:x,easing:k,in:N,onEnter:E,onEntered:z,onEntering:G,onExit:j,onExited:M,onExiting:R,style:B,timeout:P="auto",TransitionComponent:H=mA,...C}=i,O=Ok(),F=se.useRef(),Y=sp(),ae=se.useRef(null),te=js(ae,rp(x),p),oe=ie=>Ie=>{if(ie){const je=ae.current;Ie===void 0?ie(je):ie(je,Ie)}},fe=oe(G),ue=oe((ie,Ie)=>{VP(ie);const{duration:je,delay:xe,easing:We}=i0({style:B,timeout:P,easing:k},{mode:"enter"});let Ke;P==="auto"?(Ke=Y.transitions.getAutoHeightDuration(ie.clientHeight),F.current=Ke):Ke=je,ie.style.transition=[Y.transitions.create("opacity",{duration:Ke,delay:xe}),Y.transitions.create("transform",{duration:oC?Ke:Ke*.666,delay:xe,easing:We})].join(","),E&&E(ie,Ie)}),Z=oe(z),ye=oe(R),pe=oe(ie=>{const{duration:Ie,delay:je,easing:xe}=i0({style:B,timeout:P,easing:k},{mode:"exit"});let We;P==="auto"?(We=Y.transitions.getAutoHeightDuration(ie.clientHeight),F.current=We):We=Ie,ie.style.transition=[Y.transitions.create("opacity",{duration:We,delay:je}),Y.transitions.create("transform",{duration:oC?We:We*.666,delay:oC?je:je||We*.333,easing:xe})].join(","),ie.style.opacity=0,ie.style.transform=aC(.75),j&&j(ie)}),Q=oe(M),ke=ie=>{P==="auto"&&O.start(F.current||0,ie),f&&f(ae.current,ie)};return q.jsx(H,{appear:g,in:N,nodeRef:ae,onEnter:ue,onEntered:Z,onEntering:fe,onExit:pe,onExited:Q,onExiting:ye,addEndListener:ke,timeout:P==="auto"?null:P,...C,children:(ie,Ie)=>se.cloneElement(x,{style:{opacity:0,transform:aC(.75),visibility:ie==="exited"&&!N?"hidden":void 0,...Uq[ie],...B,...x.props.style},ref:te,...Ie})})});b0&&(b0.muiSupportAuto=!0);const Qq=eU({themeId:Wi}),Kq=a=>{const{classes:i,disableUnderline:p}=a,g=qn({root:["root",!p&&"underline"],input:["input"]},dK,i);return{...i,...g}},qq=Lt(h0,{shouldForwardProp:a=>qa(a)||a==="classes",name:"MuiInput",slot:"Root",overridesResolver:(a,i)=>{const{ownerState:p}=a;return[...d0(a,i),!p.disableUnderline&&i.underline]}})(cr(({theme:a})=>{let p=a.palette.mode==="light"?"rgba(0, 0, 0, 0.42)":"rgba(255, 255, 255, 0.7)";return a.vars&&(p=`rgba(${a.vars.palette.common.onBackgroundChannel} / ${a.vars.opacity.inputUnderline})`),{position:"relative",variants:[{props:({ownerState:f})=>f.formControl,style:{"label + &":{marginTop:16}}},{props:({ownerState:f})=>!f.disableUnderline,style:{"&::after":{left:0,bottom:0,content:'""',position:"absolute",right:0,transform:"scaleX(0)",transition:a.transitions.create("transform",{duration:a.transitions.duration.shorter,easing:a.transitions.easing.easeOut}),pointerEvents:"none"},[`&.${Mf.focused}:after`]:{transform:"scaleX(1) translateX(0)"},[`&.${Mf.error}`]:{"&::before, &::after":{borderBottomColor:(a.vars||a).palette.error.main}},"&::before":{borderBottom:`1px solid ${p}`,left:0,bottom:0,content:'"\\00a0"',position:"absolute",right:0,transition:a.transitions.create("border-bottom-color",{duration:a.transitions.duration.shorter}),pointerEvents:"none"},[`&:hover:not(.${Mf.disabled}, .${Mf.error}):before`]:{borderBottom:`2px solid ${(a.vars||a).palette.text.primary}`,"@media (hover: none)":{borderBottom:`1px solid ${p}`}},[`&.${Mf.disabled}:before`]:{borderBottomStyle:"dotted"}}},...Object.entries(a.palette).filter(Vo()).map(([f])=>({props:{color:f,disableUnderline:!1},style:{"&::after":{borderBottom:`2px solid ${(a.vars||a).palette[f].main}`}}}))]}})),Jq=Lt(f0,{name:"MuiInput",slot:"Input",overridesResolver:p0})({}),v0=se.forwardRef(function(i,p){const f=tr({props:i,name:"MuiInput"}),{disableUnderline:g=!1,components:x={},componentsProps:k,fullWidth:N=!1,inputComponent:E="input",multiline:z=!1,slotProps:G,slots:j={},type:M="text",...R}=f,B=Kq(f),H={root:{ownerState:{disableUnderline:g}}},C=G??k?Oa(G??k,H):H,O=j.root??x.Root??qq,F=j.input??x.Input??Jq;return q.jsx(_k,{slots:{root:O,input:F},slotProps:C,fullWidth:N,inputComponent:E,multiline:z,ref:p,type:M,...R,classes:B})});v0&&(v0.muiName="Input");function $q(a){return Xn("MuiInputLabel",a)}Ln("MuiInputLabel",["root","focused","disabled","error","required","asterisk","formControl","sizeSmall","shrink","animated","standard","filled","outlined"]);const _q=a=>{const{classes:i,formControl:p,size:f,shrink:g,disableAnimation:x,variant:k,required:N}=a,E={root:["root",p&&"formControl",!x&&"animated",g&&"shrink",f&&f!=="normal"&&`size${tn(f)}`,k],asterisk:[N&&"asterisk"]},z=qn(E,$q,i);return{...i,...z}},eJ=Lt(Yq,{shouldForwardProp:a=>qa(a)||a==="classes",name:"MuiInputLabel",slot:"Root",overridesResolver:(a,i)=>{const{ownerState:p}=a;return[{[`& .${zf.asterisk}`]:i.asterisk},i.root,p.formControl&&i.formControl,p.size==="small"&&i.sizeSmall,p.shrink&&i.shrink,!p.disableAnimation&&i.animated,p.focused&&i.focused,i[p.variant]]}})(cr(({theme:a})=>({display:"block",transformOrigin:"top left",whiteSpace:"nowrap",overflow:"hidden",textOverflow:"ellipsis",maxWidth:"100%",variants:[{props:({ownerState:i})=>i.formControl,style:{position:"absolute",left:0,top:0,transform:"translate(0, 20px) scale(1)"}},{props:{size:"small"},style:{transform:"translate(0, 17px) scale(1)"}},{props:({ownerState:i})=>i.shrink,style:{transform:"translate(0, -1.5px) scale(0.75)",transformOrigin:"top left",maxWidth:"133%"}},{props:({ownerState:i})=>!i.disableAnimation,style:{transition:a.transitions.create(["color","transform","max-width"],{duration:a.transitions.duration.shorter,easing:a.transitions.easing.easeOut})}},{props:{variant:"filled"},style:{zIndex:1,pointerEvents:"none",transform:"translate(12px, 16px) scale(1)",maxWidth:"calc(100% - 24px)"}},{props:{variant:"filled",size:"small"},style:{transform:"translate(12px, 13px) scale(1)"}},{props:({variant:i,ownerState:p})=>i==="filled"&&p.shrink,style:{userSelect:"none",pointerEvents:"auto",transform:"translate(12px, 7px) scale(0.75)",maxWidth:"calc(133% - 24px)"}},{props:({variant:i,ownerState:p,size:f})=>i==="filled"&&p.shrink&&f==="small",style:{transform:"translate(12px, 4px) scale(0.75)"}},{props:{variant:"outlined"},style:{zIndex:1,pointerEvents:"none",transform:"translate(14px, 16px) scale(1)",maxWidth:"calc(100% - 24px)"}},{props:{variant:"outlined",size:"small"},style:{transform:"translate(14px, 9px) scale(1)"}},{props:({variant:i,ownerState:p})=>i==="outlined"&&p.shrink,style:{userSelect:"none",pointerEvents:"auto",maxWidth:"calc(133% - 32px)",transform:"translate(14px, -9px) scale(0.75)"}}]}))),tJ=se.forwardRef(function(i,p){const f=tr({name:"MuiInputLabel",props:i}),{disableAnimation:g=!1,margin:x,shrink:k,variant:N,className:E,...z}=f,G=gA();let j=k;typeof j>"u"&&G&&(j=G.filled||G.focused||G.adornedStart);const M=ql({props:f,muiFormControl:G,states:["size","variant","required","focused"]}),R={...f,disableAnimation:g,formControl:G,shrink:j,size:M.size,variant:M.variant,required:M.required,focused:M.focused},B=_q(R);return q.jsx(eJ,{"data-shrink":j,ref:p,className:fn(B.root,E),...z,ownerState:R,classes:B})}),iC=se.createContext({});function nJ(a){return Xn("MuiList",a)}Ln("MuiList",["root","padding","dense","subheader"]);const rJ=a=>{const{classes:i,disablePadding:p,dense:f,subheader:g}=a;return qn({root:["root",!p&&"padding",f&&"dense",g&&"subheader"]},nJ,i)},sJ=Lt("ul",{name:"MuiList",slot:"Root",overridesResolver:(a,i)=>{const{ownerState:p}=a;return[i.root,!p.disablePadding&&i.padding,p.dense&&i.dense,p.subheader&&i.subheader]}})({listStyle:"none",margin:0,padding:0,position:"relative",variants:[{props:({ownerState:a})=>!a.disablePadding,style:{paddingTop:8,paddingBottom:8}},{props:({ownerState:a})=>a.subheader,style:{paddingTop:0}}]}),aJ=se.forwardRef(function(i,p){const f=tr({props:i,name:"MuiList"}),{children:g,className:x,component:k="ul",dense:N=!1,disablePadding:E=!1,subheader:z,...G}=f,j=se.useMemo(()=>({dense:N}),[N]),M={...f,component:k,dense:N,disablePadding:E},R=rJ(M);return q.jsx(iC.Provider,{value:j,children:q.jsxs(sJ,{as:k,className:fn(R.root,x),ref:p,ownerState:M,...G,children:[z,g]})})}),uB=Ln("MuiListItemIcon",["root","alignItemsFlexStart"]),cB=Ln("MuiListItemText",["root","multiline","dense","inset","primary","secondary"]);function AC(a,i,p){return a===i?a.firstChild:i&&i.nextElementSibling?i.nextElementSibling:p?null:a.firstChild}function dB(a,i,p){return a===i?p?a.firstChild:a.lastChild:i&&i.previousElementSibling?i.previousElementSibling:p?null:a.lastChild}function pB(a,i){if(i===void 0)return!0;let p=a.innerText;return p===void 0&&(p=a.textContent),p=p.trim().toLowerCase(),p.length===0?!1:i.repeating?p[0]===i.keys[0]:p.startsWith(i.keys.join(""))}function Of(a,i,p,f,g,x){let k=!1,N=g(a,i,i?p:!1);for(;N;){if(N===a.firstChild){if(k)return!1;k=!0}const E=f?!1:N.disabled||N.getAttribute("aria-disabled")==="true";if(!N.hasAttribute("tabindex")||!pB(N,x)||E)N=g(a,N,p);else return N.focus(),!0}return!1}const oJ=se.forwardRef(function(i,p){const{actions:f,autoFocus:g=!1,autoFocusItem:x=!1,children:k,className:N,disabledItemsFocusable:E=!1,disableListWrap:z=!1,onKeyDown:G,variant:j="selectedMenu",...M}=i,R=se.useRef(null),B=se.useRef({keys:[],repeating:!0,previousKeyMatched:!0,lastTime:null});$A(()=>{g&&R.current.focus()},[g]),se.useImperativeHandle(f,()=>({adjustStyleForScrollbar:(F,{direction:Y})=>{const ae=!R.current.style.width;if(F.clientHeight<R.current.clientHeight&&ae){const te=`${cP(_A(F))}px`;R.current.style[Y==="rtl"?"paddingLeft":"paddingRight"]=te,R.current.style.width=`calc(100% + ${te})`}return R.current}}),[]);const P=F=>{const Y=R.current,ae=F.key;if(F.ctrlKey||F.metaKey||F.altKey){G&&G(F);return}const oe=go(Y).activeElement;if(ae==="ArrowDown")F.preventDefault(),Of(Y,oe,z,E,AC);else if(ae==="ArrowUp")F.preventDefault(),Of(Y,oe,z,E,dB);else if(ae==="Home")F.preventDefault(),Of(Y,null,z,E,AC);else if(ae==="End")F.preventDefault(),Of(Y,null,z,E,dB);else if(ae.length===1){const fe=B.current,ue=ae.toLowerCase(),Z=performance.now();fe.keys.length>0&&(Z-fe.lastTime>500?(fe.keys=[],fe.repeating=!0,fe.previousKeyMatched=!0):fe.repeating&&ue!==fe.keys[0]&&(fe.repeating=!1)),fe.lastTime=Z,fe.keys.push(ue);const ye=oe&&!fe.repeating&&pB(oe,fe);fe.previousKeyMatched&&(ye||Of(Y,oe,!1,E,AC,fe))?F.preventDefault():fe.previousKeyMatched=!1}G&&G(F)},H=js(R,p);let C=-1;se.Children.forEach(k,(F,Y)=>{if(!se.isValidElement(F)){C===Y&&(C+=1,C>=k.length&&(C=-1));return}F.props.disabled||(j==="selectedMenu"&&F.props.selected||C===-1)&&(C=Y),C===Y&&(F.props.disabled||F.props.muiSkipListHighlight||F.type.muiSkipListHighlight)&&(C+=1,C>=k.length&&(C=-1))});const O=se.Children.map(k,(F,Y)=>{if(Y===C){const ae={};return x&&(ae.autoFocus=!0),F.props.tabIndex===void 0&&j==="selectedMenu"&&(ae.tabIndex=0),se.cloneElement(F,ae)}return F});return q.jsx(aJ,{role:"menu",ref:H,className:N,onKeyDown:P,tabIndex:g?0:-1,...M,children:O})});function iJ(a){return Xn("MuiPopover",a)}Ln("MuiPopover",["root","paper"]);function hB(a,i){let p=0;return typeof i=="number"?p=i:i==="center"?p=a.height/2:i==="bottom"&&(p=a.height),p}function fB(a,i){let p=0;return typeof i=="number"?p=i:i==="center"?p=a.width/2:i==="right"&&(p=a.width),p}function mB(a){return[a.horizontal,a.vertical].map(i=>typeof i=="number"?`${i}px`:i).join(" ")}function lC(a){return typeof a=="function"?a():a}const AJ=a=>{const{classes:i}=a;return qn({root:["root"],paper:["paper"]},iJ,i)},lJ=Lt(aB,{name:"MuiPopover",slot:"Root",overridesResolver:(a,i)=>i.root})({}),gB=Lt(Tf,{name:"MuiPopover",slot:"Paper",overridesResolver:(a,i)=>i.paper})({position:"absolute",overflowY:"auto",overflowX:"hidden",minWidth:16,minHeight:16,maxWidth:"calc(100% - 32px)",maxHeight:"calc(100% - 32px)",outline:0}),uJ=se.forwardRef(function(i,p){const f=tr({props:i,name:"MuiPopover"}),{action:g,anchorEl:x,anchorOrigin:k={vertical:"top",horizontal:"left"},anchorPosition:N,anchorReference:E="anchorEl",children:z,className:G,container:j,elevation:M=8,marginThreshold:R=16,open:B,PaperProps:P={},slots:H={},slotProps:C={},transformOrigin:O={vertical:"top",horizontal:"left"},TransitionComponent:F=b0,transitionDuration:Y="auto",TransitionProps:{onEntering:ae,...te}={},disableScrollLock:oe=!1,...fe}=f,ue=(C==null?void 0:C.paper)??P,Z=se.useRef(),ye={...f,anchorOrigin:k,anchorReference:E,elevation:M,marginThreshold:R,externalPaperSlotProps:ue,transformOrigin:O,TransitionComponent:F,transitionDuration:Y,TransitionProps:te},pe=AJ(ye),Q=se.useCallback(()=>{if(E==="anchorPosition")return N;const wt=lC(x),Wt=(wt&&wt.nodeType===1?wt:go(Z.current).body).getBoundingClientRect();return{top:Wt.top+hB(Wt,k.vertical),left:Wt.left+fB(Wt,k.horizontal)}},[x,k.horizontal,k.vertical,N,E]),ke=se.useCallback(wt=>({vertical:hB(wt,O.vertical),horizontal:fB(wt,O.horizontal)}),[O.horizontal,O.vertical]),ie=se.useCallback(wt=>{const Ht={width:wt.offsetWidth,height:wt.offsetHeight},Wt=ke(Ht);if(E==="none")return{top:null,left:null,transformOrigin:mB(Wt)};const on=Q();let Rt=on.top-Wt.vertical,Mt=on.left-Wt.horizontal;const Tn=Rt+Ht.height,Sn=Mt+Ht.width,J=_A(lC(x)),gn=J.innerHeight-R,rr=J.innerWidth-R;if(R!==null&&Rt<R){const qt=Rt-R;Rt-=qt,Wt.vertical+=qt}else if(R!==null&&Tn>gn){const qt=Tn-gn;Rt-=qt,Wt.vertical+=qt}if(R!==null&&Mt<R){const qt=Mt-R;Mt-=qt,Wt.horizontal+=qt}else if(Sn>rr){const qt=Sn-rr;Mt-=qt,Wt.horizontal+=qt}return{top:`${Math.round(Rt)}px`,left:`${Math.round(Mt)}px`,transformOrigin:mB(Wt)}},[x,E,Q,ke,R]),[Ie,je]=se.useState(B),xe=se.useCallback(()=>{const wt=Z.current;if(!wt)return;const Ht=ie(wt);Ht.top!==null&&wt.style.setProperty("top",Ht.top),Ht.left!==null&&(wt.style.left=Ht.left),wt.style.transformOrigin=Ht.transformOrigin,je(!0)},[ie]);se.useEffect(()=>(oe&&window.addEventListener("scroll",xe),()=>window.removeEventListener("scroll",xe)),[x,oe,xe]);const We=(wt,Ht)=>{ae&&ae(wt,Ht),xe()},Ke=()=>{je(!1)};se.useEffect(()=>{B&&xe()}),se.useImperativeHandle(g,()=>B?{updatePosition:()=>{xe()}}:null,[B,xe]),se.useEffect(()=>{if(!B)return;const wt=aP(()=>{xe()}),Ht=_A(x);return Ht.addEventListener("resize",wt),()=>{wt.clear(),Ht.removeEventListener("resize",wt)}},[x,B,xe]);let ut=Y;Y==="auto"&&!F.muiSupportAuto&&(ut=void 0);const ge=j||(x?go(lC(x)).body:void 0),Qe={slots:H,slotProps:{...C,paper:ue}},[At,dt]=yo("paper",{elementType:gB,externalForwardedProps:Qe,additionalProps:{elevation:M,className:fn(pe.paper,ue==null?void 0:ue.className),style:Ie?ue.style:{...ue.style,opacity:0}},ownerState:ye}),[It,{slotProps:Ft,...pn}]=yo("root",{elementType:lJ,externalForwardedProps:Qe,additionalProps:{slotProps:{backdrop:{invisible:!0}},container:ge,open:B},ownerState:ye,className:fn(pe.root,G)}),Yt=js(Z,dt.ref);return q.jsx(It,{...pn,...!Jk(It)&&{slotProps:Ft,disableScrollLock:oe},...fe,ref:p,children:q.jsx(F,{appear:!0,in:B,onEntering:We,onExited:Ke,timeout:ut,...te,children:q.jsx(At,{...dt,ref:Yt,children:z})})})});function cJ(a){return Xn("MuiMenu",a)}Ln("MuiMenu",["root","paper","list"]);const dJ={vertical:"top",horizontal:"right"},pJ={vertical:"top",horizontal:"left"},hJ=a=>{const{classes:i}=a;return qn({root:["root"],paper:["paper"],list:["list"]},cJ,i)},fJ=Lt(uJ,{shouldForwardProp:a=>qa(a)||a==="classes",name:"MuiMenu",slot:"Root",overridesResolver:(a,i)=>i.root})({}),mJ=Lt(gB,{name:"MuiMenu",slot:"Paper",overridesResolver:(a,i)=>i.paper})({maxHeight:"calc(100% - 96px)",WebkitOverflowScrolling:"touch"}),gJ=Lt(oJ,{name:"MuiMenu",slot:"List",overridesResolver:(a,i)=>i.list})({outline:0}),yJ=se.forwardRef(function(i,p){const f=tr({props:i,name:"MuiMenu"}),{autoFocus:g=!0,children:x,className:k,disableAutoFocusItem:N=!1,MenuListProps:E={},onClose:z,open:G,PaperProps:j={},PopoverClasses:M,transitionDuration:R="auto",TransitionProps:{onEntering:B,...P}={},variant:H="selectedMenu",slots:C={},slotProps:O={},...F}=f,Y=pU(),ae={...f,autoFocus:g,disableAutoFocusItem:N,MenuListProps:E,onEntering:B,PaperProps:j,transitionDuration:R,TransitionProps:P,variant:H},te=hJ(ae),oe=g&&!N&&G,fe=se.useRef(null),ue=(Ie,je)=>{fe.current&&fe.current.adjustStyleForScrollbar(Ie,{direction:Y?"rtl":"ltr"}),B&&B(Ie,je)},Z=Ie=>{Ie.key==="Tab"&&(Ie.preventDefault(),z&&z(Ie,"tabKeyDown"))};let ye=-1;se.Children.map(x,(Ie,je)=>{se.isValidElement(Ie)&&(Ie.props.disabled||(H==="selectedMenu"&&Ie.props.selected||ye===-1)&&(ye=je))});const pe=C.paper??mJ,Q=O.paper??j,ke=Pk({elementType:C.root,externalSlotProps:O.root,ownerState:ae,className:[te.root,k]}),ie=Pk({elementType:pe,externalSlotProps:Q,ownerState:ae,className:te.paper});return q.jsx(fJ,{onClose:z,anchorOrigin:{vertical:"bottom",horizontal:Y?"right":"left"},transformOrigin:Y?dJ:pJ,slots:{paper:pe,root:C.root},slotProps:{root:ke,paper:ie},open:G,ref:p,transitionDuration:R,TransitionProps:{onEntering:ue,...P},ownerState:ae,...F,classes:M,children:q.jsx(gJ,{onKeyDown:Z,actions:fe,autoFocus:g&&(ye===-1||N),autoFocusItem:oe,variant:H,...E,className:fn(te.list,E.className),children:x})})});function bJ(a){return Xn("MuiMenuItem",a)}const Pf=Ln("MuiMenuItem",["root","focusVisible","dense","disabled","divider","gutters","selected"]),vJ=(a,i)=>{const{ownerState:p}=a;return[i.root,p.dense&&i.dense,p.divider&&i.divider,!p.disableGutters&&i.gutters]},xJ=a=>{const{disabled:i,dense:p,divider:f,disableGutters:g,selected:x,classes:k}=a,E=qn({root:["root",p&&"dense",i&&"disabled",!g&&"gutters",f&&"divider",x&&"selected"]},bJ,k);return{...k,...E}},wJ=Lt(l0,{shouldForwardProp:a=>qa(a)||a==="classes",name:"MuiMenuItem",slot:"Root",overridesResolver:vJ})(cr(({theme:a})=>({...a.typography.body1,display:"flex",justifyContent:"flex-start",alignItems:"center",position:"relative",textDecoration:"none",minHeight:48,paddingTop:6,paddingBottom:6,boxSizing:"border-box",whiteSpace:"nowrap","&:hover":{textDecoration:"none",backgroundColor:(a.vars||a).palette.action.hover,"@media (hover: none)":{backgroundColor:"transparent"}},[`&.${Pf.selected}`]:{backgroundColor:a.vars?`rgba(${a.vars.palette.primary.mainChannel} / ${a.vars.palette.action.selectedOpacity})`:Pa(a.palette.primary.main,a.palette.action.selectedOpacity),[`&.${Pf.focusVisible}`]:{backgroundColor:a.vars?`rgba(${a.vars.palette.primary.mainChannel} / calc(${a.vars.palette.action.selectedOpacity} + ${a.vars.palette.action.focusOpacity}))`:Pa(a.palette.primary.main,a.palette.action.selectedOpacity+a.palette.action.focusOpacity)}},[`&.${Pf.selected}:hover`]:{backgroundColor:a.vars?`rgba(${a.vars.palette.primary.mainChannel} / calc(${a.vars.palette.action.selectedOpacity} + ${a.vars.palette.action.hoverOpacity}))`:Pa(a.palette.primary.main,a.palette.action.selectedOpacity+a.palette.action.hoverOpacity),"@media (hover: none)":{backgroundColor:a.vars?`rgba(${a.vars.palette.primary.mainChannel} / ${a.vars.palette.action.selectedOpacity})`:Pa(a.palette.primary.main,a.palette.action.selectedOpacity)}},[`&.${Pf.focusVisible}`]:{backgroundColor:(a.vars||a).palette.action.focus},[`&.${Pf.disabled}`]:{opacity:(a.vars||a).palette.action.disabledOpacity},[`& + .${iB.root}`]:{marginTop:a.spacing(1),marginBottom:a.spacing(1)},[`& + .${iB.inset}`]:{marginLeft:52},[`& .${cB.root}`]:{marginTop:0,marginBottom:0},[`& .${cB.inset}`]:{paddingLeft:36},[`& .${uB.root}`]:{minWidth:36},variants:[{props:({ownerState:i})=>!i.disableGutters,style:{paddingLeft:16,paddingRight:16}},{props:({ownerState:i})=>i.divider,style:{borderBottom:`1px solid ${(a.vars||a).palette.divider}`,backgroundClip:"padding-box"}},{props:({ownerState:i})=>!i.dense,style:{[a.breakpoints.up("sm")]:{minHeight:"auto"}}},{props:({ownerState:i})=>i.dense,style:{minHeight:32,paddingTop:4,paddingBottom:4,...a.typography.body2,[`& .${uB.root} svg`]:{fontSize:"1.25rem"}}}]}))),kJ=se.forwardRef(function(i,p){const f=tr({props:i,name:"MuiMenuItem"}),{autoFocus:g=!1,component:x="li",dense:k=!1,divider:N=!1,disableGutters:E=!1,focusVisibleClassName:z,role:G="menuitem",tabIndex:j,className:M,...R}=f,B=se.useContext(iC),P=se.useMemo(()=>({dense:k||B.dense||!1,disableGutters:E}),[B.dense,k,E]),H=se.useRef(null);$A(()=>{g&&H.current&&H.current.focus()},[g]);const C={...f,dense:P.dense,divider:N,disableGutters:E},O=xJ(f),F=js(H,p);let Y;return f.disabled||(Y=j!==void 0?j:-1),q.jsx(iC.Provider,{value:P,children:q.jsx(wJ,{ref:F,role:G,tabIndex:Y,component:x,focusVisibleClassName:fn(O.focusVisible,z),className:fn(O.root,M),...R,ownerState:C,classes:O})})});function CJ(a){return Xn("MuiNativeSelect",a)}const uC=Ln("MuiNativeSelect",["root","select","multiple","filled","outlined","standard","disabled","icon","iconOpen","iconFilled","iconOutlined","iconStandard","nativeInput","error"]),IJ=a=>{const{classes:i,variant:p,disabled:f,multiple:g,open:x,error:k}=a,N={select:["select",p,f&&"disabled",g&&"multiple",k&&"error"],icon:["icon",`icon${tn(p)}`,x&&"iconOpen",f&&"disabled"]};return qn(N,CJ,i)},yB=Lt("select")(({theme:a})=>({MozAppearance:"none",WebkitAppearance:"none",userSelect:"none",borderRadius:0,cursor:"pointer","&:focus":{borderRadius:0},[`&.${uC.disabled}`]:{cursor:"default"},"&[multiple]":{height:"auto"},"&:not([multiple]) option, &:not([multiple]) optgroup":{backgroundColor:(a.vars||a).palette.background.paper},variants:[{props:({ownerState:i})=>i.variant!=="filled"&&i.variant!=="outlined",style:{"&&&":{paddingRight:24,minWidth:16}}},{props:{variant:"filled"},style:{"&&&":{paddingRight:32}}},{props:{variant:"outlined"},style:{borderRadius:(a.vars||a).shape.borderRadius,"&:focus":{borderRadius:(a.vars||a).shape.borderRadius},"&&&":{paddingRight:32}}}]})),SJ=Lt(yB,{name:"MuiNativeSelect",slot:"Select",shouldForwardProp:qa,overridesResolver:(a,i)=>{const{ownerState:p}=a;return[i.select,i[p.variant],p.error&&i.error,{[`&.${uC.multiple}`]:i.multiple}]}})({}),bB=Lt("svg")(({theme:a})=>({position:"absolute",right:0,top:"calc(50% - .5em)",pointerEvents:"none",color:(a.vars||a).palette.action.active,[`&.${uC.disabled}`]:{color:(a.vars||a).palette.action.disabled},variants:[{props:({ownerState:i})=>i.open,style:{transform:"rotate(180deg)"}},{props:{variant:"filled"},style:{right:7}},{props:{variant:"outlined"},style:{right:7}}]})),NJ=Lt(bB,{name:"MuiNativeSelect",slot:"Icon",overridesResolver:(a,i)=>{const{ownerState:p}=a;return[i.icon,p.variant&&i[`icon${tn(p.variant)}`],p.open&&i.iconOpen]}})({}),TJ=se.forwardRef(function(i,p){const{className:f,disabled:g,error:x,IconComponent:k,inputRef:N,variant:E="standard",...z}=i,G={...i,disabled:g,variant:E,error:x},j=IJ(G);return q.jsxs(se.Fragment,{children:[q.jsx(SJ,{ownerState:G,className:fn(j.select,f),disabled:g,ref:N||p,...z}),i.multiple?null:q.jsx(NJ,{as:k,ownerState:G,className:j.icon})]})});var vB;const MJ=Lt("fieldset",{shouldForwardProp:qa})({textAlign:"left",position:"absolute",bottom:0,right:0,top:-5,left:0,margin:0,padding:"0 8px",pointerEvents:"none",borderRadius:"inherit",borderStyle:"solid",borderWidth:1,overflow:"hidden",minWidth:"0%"}),EJ=Lt("legend",{shouldForwardProp:qa})(cr(({theme:a})=>({float:"unset",width:"auto",overflow:"hidden",variants:[{props:({ownerState:i})=>!i.withLabel,style:{padding:0,lineHeight:"11px",transition:a.transitions.create("width",{duration:150,easing:a.transitions.easing.easeOut})}},{props:({ownerState:i})=>i.withLabel,style:{display:"block",padding:0,height:11,fontSize:"0.75em",visibility:"hidden",maxWidth:.01,transition:a.transitions.create("max-width",{duration:50,easing:a.transitions.easing.easeOut}),whiteSpace:"nowrap","& > span":{paddingLeft:5,paddingRight:5,display:"inline-block",opacity:0,visibility:"visible"}}},{props:({ownerState:i})=>i.withLabel&&i.notched,style:{maxWidth:"100%",transition:a.transitions.create("max-width",{duration:100,easing:a.transitions.easing.easeOut,delay:50})}}]})));function DJ(a){const{children:i,classes:p,className:f,label:g,notched:x,...k}=a,N=g!=null&&g!=="",E={...a,notched:x,withLabel:N};return q.jsx(MJ,{"aria-hidden":!0,className:f,ownerState:E,...k,children:q.jsx(EJ,{ownerState:E,children:N?q.jsx("span",{children:g}):vB||(vB=q.jsx("span",{className:"notranslate",children:""}))})})}const zJ=a=>{const{classes:i}=a,f=qn({root:["root"],notchedOutline:["notchedOutline"],input:["input"]},pK,i);return{...i,...f}},OJ=Lt(h0,{shouldForwardProp:a=>qa(a)||a==="classes",name:"MuiOutlinedInput",slot:"Root",overridesResolver:d0})(cr(({theme:a})=>{const i=a.palette.mode==="light"?"rgba(0, 0, 0, 0.23)":"rgba(255, 255, 255, 0.23)";return{position:"relative",borderRadius:(a.vars||a).shape.borderRadius,[`&:hover .${yA.notchedOutline}`]:{borderColor:(a.vars||a).palette.text.primary},"@media (hover: none)":{[`&:hover .${yA.notchedOutline}`]:{borderColor:a.vars?`rgba(${a.vars.palette.common.onBackgroundChannel} / 0.23)`:i}},[`&.${yA.focused} .${yA.notchedOutline}`]:{borderWidth:2},variants:[...Object.entries(a.palette).filter(Vo()).map(([p])=>({props:{color:p},style:{[`&.${yA.focused} .${yA.notchedOutline}`]:{borderColor:(a.vars||a).palette[p].main}}})),{props:{},style:{[`&.${yA.error} .${yA.notchedOutline}`]:{borderColor:(a.vars||a).palette.error.main},[`&.${yA.disabled} .${yA.notchedOutline}`]:{borderColor:(a.vars||a).palette.action.disabled}}},{props:({ownerState:p})=>p.startAdornment,style:{paddingLeft:14}},{props:({ownerState:p})=>p.endAdornment,style:{paddingRight:14}},{props:({ownerState:p})=>p.multiline,style:{padding:"16.5px 14px"}},{props:({ownerState:p,size:f})=>p.multiline&&f==="small",style:{padding:"8.5px 14px"}}]}})),PJ=Lt(DJ,{name:"MuiOutlinedInput",slot:"NotchedOutline",overridesResolver:(a,i)=>i.notchedOutline})(cr(({theme:a})=>{const i=a.palette.mode==="light"?"rgba(0, 0, 0, 0.23)":"rgba(255, 255, 255, 0.23)";return{borderColor:a.vars?`rgba(${a.vars.palette.common.onBackgroundChannel} / 0.23)`:i}})),BJ=Lt(f0,{name:"MuiOutlinedInput",slot:"Input",overridesResolver:p0})(cr(({theme:a})=>({padding:"16.5px 14px",...!a.vars&&{"&:-webkit-autofill":{WebkitBoxShadow:a.palette.mode==="light"?null:"0 0 0 100px #266798 inset",WebkitTextFillColor:a.palette.mode==="light"?null:"#fff",caretColor:a.palette.mode==="light"?null:"#fff",borderRadius:"inherit"}},...a.vars&&{"&:-webkit-autofill":{borderRadius:"inherit"},[a.getColorSchemeSelector("dark")]:{"&:-webkit-autofill":{WebkitBoxShadow:"0 0 0 100px #266798 inset",WebkitTextFillColor:"#fff",caretColor:"#fff"}}},variants:[{props:{size:"small"},style:{padding:"8.5px 14px"}},{props:({ownerState:i})=>i.multiline,style:{padding:0}},{props:({ownerState:i})=>i.startAdornment,style:{paddingLeft:0}},{props:({ownerState:i})=>i.endAdornment,style:{paddingRight:0}}]}))),x0=se.forwardRef(function(i,p){var f;const g=tr({props:i,name:"MuiOutlinedInput"}),{components:x={},fullWidth:k=!1,inputComponent:N="input",label:E,multiline:z=!1,notched:G,slots:j={},type:M="text",...R}=g,B=zJ(g),P=gA(),H=ql({props:g,muiFormControl:P,states:["color","disabled","error","focused","hiddenLabel","size","required"]}),C={...g,color:H.color||"primary",disabled:H.disabled,error:H.error,focused:H.focused,formControl:P,fullWidth:k,hiddenLabel:H.hiddenLabel,multiline:z,size:H.size,type:M},O=j.root??x.Root??OJ,F=j.input??x.Input??BJ;return q.jsx(_k,{slots:{root:O,input:F},renderSuffix:Y=>q.jsx(PJ,{ownerState:C,className:B.notchedOutline,label:E!=null&&E!==""&&H.required?f||(f=q.jsxs(se.Fragment,{children:[E,"","*"]})):E,notched:typeof G<"u"?G:!!(Y.startAdornment||Y.filled||Y.focused)}),fullWidth:k,inputComponent:N,multiline:z,ref:p,type:M,...R,classes:{...B,notchedOutline:null}})});x0&&(x0.muiName="Input");const FJ=nl(q.jsx("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"}),"RadioButtonUnchecked"),LJ=nl(q.jsx("path",{d:"M8.465 8.465C9.37 7.56 10.62 7 12 7C14.76 7 17 9.24 17 12C17 13.38 16.44 14.63 15.535 15.535C14.63 16.44 13.38 17 12 17C9.24 17 7 14.76 7 12C7 10.62 7.56 9.37 8.465 8.465Z"}),"RadioButtonChecked"),RJ=Lt("span",{shouldForwardProp:qa})({position:"relative",display:"flex"}),WJ=Lt(FJ)({transform:"scale(1)"}),jJ=Lt(LJ)(cr(({theme:a})=>({left:0,position:"absolute",transform:"scale(0)",transition:a.transitions.create("transform",{easing:a.transitions.easing.easeIn,duration:a.transitions.duration.shortest}),variants:[{props:{checked:!0},style:{transform:"scale(1)",transition:a.transitions.create("transform",{easing:a.transitions.easing.easeOut,duration:a.transitions.duration.shortest})}}]})));function xB(a){const{checked:i=!1,classes:p={},fontSize:f}=a,g={...a,checked:i};return q.jsxs(RJ,{className:p.root,ownerState:g,children:[q.jsx(WJ,{fontSize:f,className:p.background,ownerState:g}),q.jsx(jJ,{fontSize:f,className:p.dot,ownerState:g})]})}const wB=se.createContext(void 0);function HJ(){return se.useContext(wB)}function GJ(a){return Xn("MuiRadio",a)}const kB=Ln("MuiRadio",["root","checked","disabled","colorPrimary","colorSecondary","sizeSmall"]),VJ=a=>{const{classes:i,color:p,size:f}=a,g={root:["root",`color${tn(p)}`,f!=="medium"&&`size${tn(f)}`]};return{...i,...qn(g,GJ,i)}},XJ=Lt(PK,{shouldForwardProp:a=>qa(a)||a==="classes",name:"MuiRadio",slot:"Root",overridesResolver:(a,i)=>{const{ownerState:p}=a;return[i.root,p.size!=="medium"&&i[`size${tn(p.size)}`],i[`color${tn(p.color)}`]]}})(cr(({theme:a})=>({color:(a.vars||a).palette.text.secondary,[`&.${kB.disabled}`]:{color:(a.vars||a).palette.action.disabled},variants:[{props:{color:"default",disabled:!1,disableRipple:!1},style:{"&:hover":{backgroundColor:a.vars?`rgba(${a.vars.palette.action.activeChannel} / ${a.vars.palette.action.hoverOpacity})`:Pa(a.palette.action.active,a.palette.action.hoverOpacity)}}},...Object.entries(a.palette).filter(Vo()).map(([i])=>({props:{color:i,disabled:!1,disableRipple:!1},style:{"&:hover":{backgroundColor:a.vars?`rgba(${a.vars.palette[i].mainChannel} / ${a.vars.palette.action.hoverOpacity})`:Pa(a.palette[i].main,a.palette.action.hoverOpacity)}}})),...Object.entries(a.palette).filter(Vo()).map(([i])=>({props:{color:i,disabled:!1},style:{[`&.${kB.checked}`]:{color:(a.vars||a).palette[i].main}}})),{props:{disableRipple:!1},style:{"&:hover":{"@media (hover: none)":{backgroundColor:"transparent"}}}}]})));function ZJ(a,i){return typeof i=="object"&&i!==null?a===i:String(a)===String(i)}const CB=q.jsx(xB,{checked:!0}),IB=q.jsx(xB,{}),cC=se.forwardRef(function(i,p){const f=tr({props:i,name:"MuiRadio"}),{checked:g,checkedIcon:x=CB,color:k="primary",icon:N=IB,name:E,onChange:z,size:G="medium",className:j,disabled:M,disableRipple:R=!1,...B}=f,P=gA();let H=M;P&&typeof H>"u"&&(H=P.disabled),H??(H=!1);const C={...f,disabled:H,disableRipple:R,color:k,size:G},O=VJ(C),F=HJ();let Y=g;const ae=Mk(z,F&&F.onChange);let te=E;return F&&(typeof Y>"u"&&(Y=ZJ(F.value,f.value)),typeof te>"u"&&(te=F.name)),q.jsx(XJ,{type:"radio",icon:se.cloneElement(N,{fontSize:IB.props.fontSize??G}),checkedIcon:se.cloneElement(x,{fontSize:CB.props.fontSize??G}),disabled:H,ownerState:C,classes:O,name:te,checked:Y,onChange:ae,ref:p,className:fn(O.root,j),...B})});function YJ(a){return Xn("MuiRadioGroup",a)}Ln("MuiRadioGroup",["root","row","error"]);const UJ=a=>{const{classes:i,row:p,error:f}=a;return qn({root:["root",p&&"row",f&&"error"]},YJ,i)},dC=se.forwardRef(function(i,p){const{actions:f,children:g,className:x,defaultValue:k,name:N,onChange:E,value:z,...G}=i,j=se.useRef(null),M=UJ(i),[R,B]=t0({controlled:z,default:k,name:"RadioGroup"});se.useImperativeHandle(f,()=>({focus:()=>{let O=j.current.querySelector("input:not(:disabled):checked");O||(O=j.current.querySelector("input:not(:disabled)")),O&&O.focus()}}),[]);const P=js(p,j),H=e0(N),C=se.useMemo(()=>({name:H,onChange(O){B(O.target.value),E&&E(O,O.target.value)},value:R}),[H,E,B,R]);return q.jsx(wB.Provider,{value:C,children:q.jsx(Lq,{role:"radiogroup",ref:P,className:fn(M.root,x),...G,children:g})})});function QJ(a){return Xn("MuiSelect",a)}const Bf=Ln("MuiSelect",["root","select","multiple","filled","outlined","standard","disabled","focused","icon","iconOpen","iconFilled","iconOutlined","iconStandard","nativeInput","error"]);var SB;const KJ=Lt(yB,{name:"MuiSelect",slot:"Select",overridesResolver:(a,i)=>{const{ownerState:p}=a;return[{[`&.${Bf.select}`]:i.select},{[`&.${Bf.select}`]:i[p.variant]},{[`&.${Bf.error}`]:i.error},{[`&.${Bf.multiple}`]:i.multiple}]}})({[`&.${Bf.select}`]:{height:"auto",minHeight:"1.4375em",textOverflow:"ellipsis",whiteSpace:"nowrap",overflow:"hidden"}}),qJ=Lt(bB,{name:"MuiSelect",slot:"Icon",overridesResolver:(a,i)=>{const{ownerState:p}=a;return[i.icon,p.variant&&i[`icon${tn(p.variant)}`],p.open&&i.iconOpen]}})({}),JJ=Lt("input",{shouldForwardProp:a=>RP(a)&&a!=="classes",name:"MuiSelect",slot:"NativeInput",overridesResolver:(a,i)=>i.nativeInput})({bottom:0,left:0,position:"absolute",opacity:0,pointerEvents:"none",width:"100%",boxSizing:"border-box"});function NB(a,i){return typeof i=="object"&&i!==null?a===i:String(a)===String(i)}function $J(a){return a==null||typeof a=="string"&&!a.trim()}const _J=a=>{const{classes:i,variant:p,disabled:f,multiple:g,open:x,error:k}=a,N={select:["select",p,f&&"disabled",g&&"multiple",k&&"error"],icon:["icon",`icon${tn(p)}`,x&&"iconOpen",f&&"disabled"],nativeInput:["nativeInput"]};return qn(N,QJ,i)},e$=se.forwardRef(function(i,p){var nn;const{"aria-describedby":f,"aria-label":g,autoFocus:x,autoWidth:k,children:N,className:E,defaultOpen:z,defaultValue:G,disabled:j,displayEmpty:M,error:R=!1,IconComponent:B,inputRef:P,labelId:H,MenuProps:C={},multiple:O,name:F,onBlur:Y,onChange:ae,onClose:te,onFocus:oe,onOpen:fe,open:ue,readOnly:Z,renderValue:ye,SelectDisplayProps:pe={},tabIndex:Q,type:ke,value:ie,variant:Ie="standard",...je}=i,[xe,We]=t0({controlled:ie,default:G,name:"Select"}),[Ke,ut]=t0({controlled:ue,default:z,name:"Select"}),ge=se.useRef(null),Qe=se.useRef(null),[At,dt]=se.useState(null),{current:It}=se.useRef(ue!=null),[Ft,pn]=se.useState(),Yt=js(p,P),wt=se.useCallback(mt=>{Qe.current=mt,mt&&dt(mt)},[]),Ht=At==null?void 0:At.parentNode;se.useImperativeHandle(Yt,()=>({focus:()=>{Qe.current.focus()},node:ge.current,value:xe}),[xe]),se.useEffect(()=>{z&&Ke&&At&&!It&&(pn(k?null:Ht.clientWidth),Qe.current.focus())},[At,k]),se.useEffect(()=>{x&&Qe.current.focus()},[x]),se.useEffect(()=>{if(!H)return;const mt=go(Qe.current).getElementById(H);if(mt){const Dt=()=>{getSelection().isCollapsed&&Qe.current.focus()};return mt.addEventListener("click",Dt),()=>{mt.removeEventListener("click",Dt)}}},[H]);const Wt=(mt,Dt)=>{mt?fe&&fe(Dt):te&&te(Dt),It||(pn(k?null:Ht.clientWidth),ut(mt))},on=mt=>{mt.button===0&&(mt.preventDefault(),Qe.current.focus(),Wt(!0,mt))},Rt=mt=>{Wt(!1,mt)},Mt=se.Children.toArray(N),Tn=mt=>{const Dt=Mt.find(rn=>rn.props.value===mt.target.value);Dt!==void 0&&(We(Dt.props.value),ae&&ae(mt,Dt))},Sn=mt=>Dt=>{let rn;if(Dt.currentTarget.hasAttribute("tabindex")){if(O){rn=Array.isArray(xe)?xe.slice():[];const Gn=xe.indexOf(mt.props.value);Gn===-1?rn.push(mt.props.value):rn.splice(Gn,1)}else rn=mt.props.value;if(mt.props.onClick&&mt.props.onClick(Dt),xe!==rn&&(We(rn),ae)){const Gn=Dt.nativeEvent||Dt,kt=new Gn.constructor(Gn.type,Gn);Object.defineProperty(kt,"target",{writable:!0,value:{value:rn,name:F}}),ae(kt,mt)}O||Wt(!1,Dt)}},J=mt=>{Z||[" ","ArrowUp","ArrowDown","Enter"].includes(mt.key)&&(mt.preventDefault(),Wt(!0,mt))},gn=At!==null&&Ke,rr=mt=>{!gn&&Y&&(Object.defineProperty(mt,"target",{writable:!0,value:{value:xe,name:F}}),Y(mt))};delete je["aria-invalid"];let qt,Ye;const ht=[];let Et=!1;(c0({value:xe})||M)&&(ye?qt=ye(xe):Et=!0);const cn=Mt.map(mt=>{if(!se.isValidElement(mt))return null;let Dt;if(O){if(!Array.isArray(xe))throw new Error(qA(2));Dt=xe.some(rn=>NB(rn,mt.props.value)),Dt&&Et&&ht.push(mt.props.children)}else Dt=NB(xe,mt.props.value),Dt&&Et&&(Ye=mt.props.children);return se.cloneElement(mt,{"aria-selected":Dt?"true":"false",onClick:Sn(mt),onKeyUp:rn=>{rn.key===" "&&rn.preventDefault(),mt.props.onKeyUp&&mt.props.onKeyUp(rn)},role:"option",selected:Dt,value:void 0,"data-value":mt.props.value})});Et&&(O?ht.length===0?qt=null:qt=ht.reduce((mt,Dt,rn)=>(mt.push(Dt),rn<ht.length-1&&mt.push(", "),mt),[]):qt=Ye);let jt=Ft;!k&&It&&At&&(jt=Ht.clientWidth);let xn;typeof Q<"u"?xn=Q:xn=j?null:0;const yn=pe.id||(F?`mui-component-select-${F}`:void 0),pt={...i,variant:Ie,value:xe,open:gn,error:R},tt=_J(pt),Oe={...C.PaperProps,...(nn=C.slotProps)==null?void 0:nn.paper},Tt=e0();return q.jsxs(se.Fragment,{children:[q.jsx(KJ,{as:"div",ref:wt,tabIndex:xn,role:"combobox","aria-controls":Tt,"aria-disabled":j?"true":void 0,"aria-expanded":gn?"true":"false","aria-haspopup":"listbox","aria-label":g,"aria-labelledby":[H,yn].filter(Boolean).join(" ")||void 0,"aria-describedby":f,onKeyDown:J,onMouseDown:j||Z?null:on,onBlur:rr,onFocus:oe,...pe,ownerState:pt,className:fn(pe.className,tt.select,E),id:yn,children:$J(qt)?SB||(SB=q.jsx("span",{className:"notranslate",children:""})):qt}),q.jsx(JJ,{"aria-invalid":R,value:Array.isArray(xe)?xe.join(","):xe,name:F,ref:ge,"aria-hidden":!0,onChange:Tn,tabIndex:-1,disabled:j,className:tt.nativeInput,autoFocus:x,...je,ownerState:pt}),q.jsx(qJ,{as:B,className:tt.icon,ownerState:pt}),q.jsx(yJ,{id:`menu-${F||""}`,anchorEl:Ht,open:gn,onClose:Rt,anchorOrigin:{vertical:"bottom",horizontal:"center"},transformOrigin:{vertical:"top",horizontal:"center"},...C,MenuListProps:{"aria-labelledby":H,role:"listbox","aria-multiselectable":O?"true":void 0,disableListWrap:!0,id:Tt,...C.MenuListProps},slotProps:{...C.slotProps,paper:{...Oe,style:{minWidth:jt,...Oe!=null?Oe.style:null}}},children:cn})]})}),t$=a=>{const{classes:i}=a;return i},pC={name:"MuiSelect",overridesResolver:(a,i)=>i.root,shouldForwardProp:a=>qa(a)&&a!=="variant",slot:"Root"},n$=Lt(v0,pC)(""),r$=Lt(x0,pC)(""),s$=Lt(y0,pC)(""),hC=se.forwardRef(function(i,p){const f=tr({name:"MuiSelect",props:i}),{autoWidth:g=!1,children:x,classes:k={},className:N,defaultOpen:E=!1,displayEmpty:z=!1,IconComponent:G=fK,id:j,input:M,inputProps:R,label:B,labelId:P,MenuProps:H,multiple:C=!1,native:O=!1,onClose:F,onOpen:Y,open:ae,renderValue:te,SelectDisplayProps:oe,variant:fe="outlined",...ue}=f,Z=O?TJ:e$,ye=gA(),pe=ql({props:f,muiFormControl:ye,states:["variant","error"]}),Q=pe.variant||fe,ke={...f,variant:Q,classes:k},ie=t$(ke),{root:Ie,...je}=ie,xe=M||{standard:q.jsx(n$,{ownerState:ke}),outlined:q.jsx(r$,{label:B,ownerState:ke}),filled:q.jsx(s$,{ownerState:ke})}[Q],We=js(p,rp(xe));return q.jsx(se.Fragment,{children:se.cloneElement(xe,{inputComponent:Z,inputProps:{children:x,error:pe.error,IconComponent:G,variant:Q,type:void 0,multiple:C,...O?{id:j}:{autoWidth:g,defaultOpen:E,displayEmpty:z,labelId:P,MenuProps:H,onClose:F,onOpen:Y,open:ae,renderValue:te,SelectDisplayProps:{id:j,...oe}},...R,classes:R?Oa(je,R.classes):je,...M?M.props.inputProps:{}},...(C&&O||z)&&Q==="outlined"?{notched:!0}:{},ref:We,className:fn(xe.props.className,N,ie.root),...!M&&{variant:Q},...ue})})});hC.muiName="Select";function a$(a={}){const{autoHideDuration:i=null,disableWindowBlurListener:p=!1,onClose:f,open:g,resumeHideDuration:x}=a,k=Ok();se.useEffect(()=>{if(!g)return;function C(O){O.defaultPrevented||O.key==="Escape"&&(f==null||f(O,"escapeKeyDown"))}return document.addEventListener("keydown",C),()=>{document.removeEventListener("keydown",C)}},[g,f]);const N=el((C,O)=>{f==null||f(C,O)}),E=el(C=>{!f||C==null||k.start(C,()=>{N(null,"timeout")})});se.useEffect(()=>(g&&E(i),k.clear),[g,i,E,k]);const z=C=>{f==null||f(C,"clickaway")},G=k.clear,j=se.useCallback(()=>{i!=null&&E(x??i*.5)},[i,x,E]),M=C=>O=>{const F=C.onBlur;F==null||F(O),j()},R=C=>O=>{const F=C.onFocus;F==null||F(O),G()},B=C=>O=>{const F=C.onMouseEnter;F==null||F(O),G()},P=C=>O=>{const F=C.onMouseLeave;F==null||F(O),j()};return se.useEffect(()=>{if(!p&&g)return window.addEventListener("focus",j),window.addEventListener("blur",G),()=>{window.removeEventListener("focus",j),window.removeEventListener("blur",G)}},[p,g,j,G]),{getRootProps:(C={})=>{const O={...n0(a),...n0(C)};return{role:"presentation",...C,...O,onBlur:M(O),onFocus:R(O),onMouseEnter:B(O),onMouseLeave:P(O)}},onClickAway:z}}function o$(a){return Xn("MuiSnackbarContent",a)}Ln("MuiSnackbarContent",["root","message","action"]);const i$=a=>{const{classes:i}=a;return qn({root:["root"],action:["action"],message:["message"]},o$,i)},A$=Lt(Tf,{name:"MuiSnackbarContent",slot:"Root",overridesResolver:(a,i)=>i.root})(cr(({theme:a})=>{const i=a.palette.mode==="light"?.8:.98,p=sP(a.palette.background.default,i);return{...a.typography.body2,color:a.vars?a.vars.palette.SnackbarContent.color:a.palette.getContrastText(p),backgroundColor:a.vars?a.vars.palette.SnackbarContent.bg:p,display:"flex",alignItems:"center",flexWrap:"wrap",padding:"6px 16px",borderRadius:(a.vars||a).shape.borderRadius,flexGrow:1,[a.breakpoints.up("sm")]:{flexGrow:"initial",minWidth:288}}})),l$=Lt("div",{name:"MuiSnackbarContent",slot:"Message",overridesResolver:(a,i)=>i.message})({padding:"8px 0"}),u$=Lt("div",{name:"MuiSnackbarContent",slot:"Action",overridesResolver:(a,i)=>i.action})({display:"flex",alignItems:"center",marginLeft:"auto",paddingLeft:16,marginRight:-8}),c$=se.forwardRef(function(i,p){const f=tr({props:i,name:"MuiSnackbarContent"}),{action:g,className:x,message:k,role:N="alert",...E}=f,z=f,G=i$(z);return q.jsxs(A$,{role:N,square:!0,elevation:6,className:fn(G.root,x),ownerState:z,ref:p,...E,children:[q.jsx(l$,{className:G.message,ownerState:z,children:k}),g?q.jsx(u$,{className:G.action,ownerState:z,children:g}):null]})});function d$(a){return Xn("MuiSnackbar",a)}Ln("MuiSnackbar",["root","anchorOriginTopCenter","anchorOriginBottomCenter","anchorOriginTopRight","anchorOriginBottomRight","anchorOriginTopLeft","anchorOriginBottomLeft"]);const p$=a=>{const{classes:i,anchorOrigin:p}=a,f={root:["root",`anchorOrigin${tn(p.vertical)}${tn(p.horizontal)}`]};return qn(f,d$,i)},TB=Lt("div",{name:"MuiSnackbar",slot:"Root",overridesResolver:(a,i)=>{const{ownerState:p}=a;return[i.root,i[`anchorOrigin${tn(p.anchorOrigin.vertical)}${tn(p.anchorOrigin.horizontal)}`]]}})(cr(({theme:a})=>({zIndex:(a.vars||a).zIndex.snackbar,position:"fixed",display:"flex",left:8,right:8,justifyContent:"center",alignItems:"center",variants:[{props:({ownerState:i})=>i.anchorOrigin.vertical==="top",style:{top:8,[a.breakpoints.up("sm")]:{top:24}}},{props:({ownerState:i})=>i.anchorOrigin.vertical!=="top",style:{bottom:8,[a.breakpoints.up("sm")]:{bottom:24}}},{props:({ownerState:i})=>i.anchorOrigin.horizontal==="left",style:{justifyContent:"flex-start",[a.breakpoints.up("sm")]:{left:24,right:"auto"}}},{props:({ownerState:i})=>i.anchorOrigin.horizontal==="right",style:{justifyContent:"flex-end",[a.breakpoints.up("sm")]:{right:24,left:"auto"}}},{props:({ownerState:i})=>i.anchorOrigin.horizontal==="center",style:{[a.breakpoints.up("sm")]:{left:"50%",right:"auto",transform:"translateX(-50%)"}}}]}))),h$=se.forwardRef(function(i,p){const f=tr({props:i,name:"MuiSnackbar"}),g=sp(),x={enter:g.transitions.duration.enteringScreen,exit:g.transitions.duration.leavingScreen},{action:k,anchorOrigin:{vertical:N,horizontal:E}={vertical:"bottom",horizontal:"left"},autoHideDuration:z=null,children:G,className:j,ClickAwayListenerProps:M,ContentProps:R,disableWindowBlurListener:B=!1,message:P,onBlur:H,onClose:C,onFocus:O,onMouseEnter:F,onMouseLeave:Y,open:ae,resumeHideDuration:te,TransitionComponent:oe=b0,transitionDuration:fe=x,TransitionProps:{onEnter:ue,onExited:Z,...ye}={},...pe}=f,Q={...f,anchorOrigin:{vertical:N,horizontal:E},autoHideDuration:z,disableWindowBlurListener:B,TransitionComponent:oe,transitionDuration:fe},ke=p$(Q),{getRootProps:ie,onClickAway:Ie}=a$({...Q}),[je,xe]=se.useState(!0),We=Pk({elementType:TB,getSlotProps:ie,externalForwardedProps:pe,ownerState:Q,additionalProps:{ref:p},className:[ke.root,j]}),Ke=ge=>{xe(!0),Z&&Z(ge)},ut=(ge,Qe)=>{xe(!1),ue&&ue(ge,Qe)};return!ae&&je?null:q.jsx(FK,{onClickAway:Ie,...M,children:q.jsx(TB,{...We,children:q.jsx(oe,{appear:!0,in:ae,timeout:fe,direction:N==="top"?"down":"up",onEnter:ut,onExited:Ke,...ye,children:G||q.jsx(c$,{message:P,action:k,...R})})})})});function f$(a){return Xn("MuiTextField",a)}Ln("MuiTextField",["root"]);const m$={standard:v0,filled:y0,outlined:x0},g$=a=>{const{classes:i}=a;return qn({root:["root"]},f$,i)},y$=Lt(Mq,{name:"MuiTextField",slot:"Root",overridesResolver:(a,i)=>i.root})({}),fC=se.forwardRef(function(i,p){const f=tr({props:i,name:"MuiTextField"}),{autoComplete:g,autoFocus:x=!1,children:k,className:N,color:E="primary",defaultValue:z,disabled:G=!1,error:j=!1,FormHelperTextProps:M,fullWidth:R=!1,helperText:B,id:P,InputLabelProps:H,inputProps:C,InputProps:O,inputRef:F,label:Y,maxRows:ae,minRows:te,multiline:oe=!1,name:fe,onBlur:ue,onChange:Z,onFocus:ye,placeholder:pe,required:Q=!1,rows:ke,select:ie=!1,SelectProps:Ie,slots:je={},slotProps:xe={},type:We,value:Ke,variant:ut="outlined",...ge}=f,Qe={...f,autoFocus:x,color:E,disabled:G,error:j,fullWidth:R,multiline:oe,required:Q,select:ie,variant:ut},At=g$(Qe),dt=e0(P),It=B&&dt?`${dt}-helper-text`:void 0,Ft=Y&&dt?`${dt}-label`:void 0,pn=m$[ut],Yt={slots:je,slotProps:{input:O,inputLabel:H,htmlInput:C,formHelperText:M,select:Ie,...xe}},wt={},Ht=Yt.slotProps.inputLabel;ut==="outlined"&&(Ht&&typeof Ht.shrink<"u"&&(wt.notched=Ht.shrink),wt.label=Y),ie&&((!Ie||!Ie.native)&&(wt.id=void 0),wt["aria-describedby"]=void 0);const[Wt,on]=yo("input",{elementType:pn,externalForwardedProps:Yt,additionalProps:wt,ownerState:Qe}),[Rt,Mt]=yo("inputLabel",{elementType:tJ,externalForwardedProps:Yt,ownerState:Qe}),[Tn,Sn]=yo("htmlInput",{elementType:"input",externalForwardedProps:Yt,ownerState:Qe}),[J,gn]=yo("formHelperText",{elementType:Hq,externalForwardedProps:Yt,ownerState:Qe}),[rr,qt]=yo("select",{elementType:hC,externalForwardedProps:Yt,ownerState:Qe}),Ye=q.jsx(Wt,{"aria-describedby":It,autoComplete:g,autoFocus:x,defaultValue:z,fullWidth:R,multiline:oe,name:fe,rows:ke,maxRows:ae,minRows:te,type:We,value:Ke,id:dt,inputRef:F,onBlur:ue,onChange:Z,onFocus:ye,placeholder:pe,inputProps:Sn,slots:{input:je.htmlInput?Tn:void 0},...on});return q.jsxs(y$,{className:fn(At.root,N),disabled:G,error:j,fullWidth:R,ref:p,required:Q,color:E,variant:ut,ownerState:Qe,...ge,children:[Y!=null&&Y!==""&&q.jsx(Rt,{htmlFor:dt,id:Ft,...Mt,children:Y}),ie?q.jsx(rr,{"aria-describedby":It,id:dt,labelId:Ft,value:Ke,input:Ye,...qt,children:k}):Ye,B&&q.jsx(J,{id:It,...gn,children:B})]})}),Xr={root:{minHeight:"100vh"},heading:{color:"#616161",textAlign:{xs:"center",md:"left"},fontSize:{xs:"18px",md:"40px"},fontStyle:"normal",fontWeight:400,lineHeight:"normal",textTransform:"lowercase","--leading-trim":"both","--text-edge":"cap"},subHeading:{color:"#616161",fontSize:{xs:"16px",md:"26px"},fontStyle:"normal",fontWeight:500,textAlign:{xs:"center",md:"left"},paddingBottom:{xs:"8px",md:"40px"},lineHeight:"normal"},inputContainer:{display:"flex",flexDirection:"column",alignItems:{xs:"center",md:"center"},justifyContent:{xs:"center",md:"center"},width:"100%",padding:{xs:"0px",md:"0 66px"}},infoBox:{display:"flex",justifyContent:"space-between",alignItems:"center",width:{xs:"159px",md:"300px"},flexShrink:0,borderRadius:"8px",background:"#C6E2CF",padding:{xs:"10px",md:"20px"},fontSize:{xs:"11px",md:"14px"},gap:{xs:"5px",md:"25px"},flexDirection:{xs:"column",md:"column"},textAlign:"center"},inputContainer2:{display:"flex",flexDirection:"column",alignItems:{xs:"center",md:"flex-start"},justifyContent:{xs:"center",md:"flex-start"},width:"100%"},productContainer:{display:"flex",height:{xs:"210px",md:"600px"},width:{xs:"150px",md:"400px"},padding:{xs:"2px",md:"20px"},flexDirection:"column",justifyContent:"space-between",alignItems:"center",gap:{xs:"6px",md:"10px"},alignSelf:"stretch",borderRadius:{xs:"5px",md:"21px"}},addToCartButton:{padding:"3px 20px",justifyContent:"center",alignItems:"center",gap:"10px",color:"#fff",textAlign:"center",background:"#F3665D",fontSize:{xs:"10px",md:"15px"},fontStyle:"normal",fontWeight:500,lineHeight:"normal",letterSpacing:"0.8px",height:{xs:"22px",md:"50px"},width:"90%"},rangeBox:{display:"flex",width:{xs:"70px",md:"100px"},height:{xs:"70px",md:"100px"},flexDirection:"column",justifyContent:"center",padding:"2px",alignItems:"center",flexShrink:0,borderRadius:"100px"}},MB=se.createContext(void 0),b$=({children:a})=>{const[i,p]=se.useState("HomePage"),[f,g]=se.useState(null),[x,k]=se.useState({name:"",age:"22",skin:"",gender:"",phone:"",email:""}),[N,E]=se.useState([]),[z,G]=se.useState([]),[j,M]=se.useState(null),[R,B]=se.useState(null),[P,H]=se.useState({}),[C,O]=se.useState(""),F=()=>{g(null),k({name:"",age:"22",skin:"",gender:"",phone:"",email:""}),M(null),E([]),G([]),p("HomePage"),H({}),O("")};return q.jsx(MB.Provider,{value:{view:i,setView:p,sessionId:f,setSessionId:g,userInfo:x,setUserInfo:k,outputScore:N,setOutputScore:E,recommendations:z,setRecommendations:G,capturedPic:j,setCapturedPic:M,snackbar:R,setSnackbar:B,clear:F,annotations:P,setAnnotations:H,inputImage:C,setInputImage:O},children:a})},Jl=()=>{const a=se.useContext(MB);if(!a)throw new Error("useView must be used within a ViewProvider");return a};class Ff{constructor(i=null){Ju(this,j0);qs(this,"sessionId",null);Ju(this,W0,async()=>{try{const i=await fetch("https://api.ipify.org?format=json");if(!i.ok)throw new Error("Failed to fetch IP address");return(await i.json()).ip}catch(i){return console.error("Error fetching IP address:",i),"127.0.0.1"}});this.sessionId=i}setSessionId(i){this.sessionId=i}getHeaders(){const i={"Content-Type":"application/json","x-client-id":"68397b318979c7182cd9110b","x-api-key":"C1D8266ECB52DCDBF477BE142B7A4"};return this.sessionId&&(i["x-session-id"]=this.sessionId),i}async request(i,p="GET",f){try{const g=`https://api.gateway.orbo.ai/demo/supertouch/skin/v1${i}`,x={method:p,headers:this.getHeaders()};f&&p!=="GET"&&(x.body=JSON.stringify(f));const k=await fetch(g,x);if(!k.ok)try{const E=await k.json();throw new Error(E)}catch{const E=await k.text();throw new Error(`API Error (${k.status}): ${E}`)}const N=await k.json();if(!N.success)throw new Error(`API Error: ${N.message||"Unknown error"}`);return N}catch(g){throw g instanceof Error?(console.error(`Request failed: ${g.message}`),g):new Error("Unknown error occurred during API request")}}async createSession(i,p){try{const f=await Js(this,W0).call(this),g={device:i,ip:f,browser:p,device_id:"web",platform:"WEB"},k=(await this.request("/session","POST",g)).data.sessionId;return this.setSessionId(k),k}catch(f){throw console.error("Failed to create session:",f),f.message||"Failed to create session."}}async uploadImage(i){try{const p=await _H(this,j0,eG).call(this),f=await fetch(p,{method:"PUT",body:i});if(!f.ok)throw new Error(`Failed to upload image: ${f.statusText}`);return!0}catch(p){throw console.error("Failed to upload image:",p),p}}async sendOtp(i,p){try{if(!this.sessionId)throw new Error("Session ID is required. Please create a session first.");const f={phone:i,name:"BNN-User-Name",...p&&{email:p}};return(await this.request("/auth/otp","POST",f)).success}catch(f){throw console.error("Failed to send OTP:",f),f}}async verifyOtp(i){try{if(!this.sessionId)throw new Error("Session ID is required. Please create a session first.");const p={otp:i};return(await this.request("/auth/verify","POST",p)).data}catch(p){throw console.error("Failed to verify OTP:",p),p}}async getSkinAnalysis(){try{if(!this.sessionId)throw new Error("Session ID is required. Please create a session first.");return(await this.request("/analysis")).data}catch(i){throw console.error("Failed to get skin analysis:",i),{message:"Face not detected. Please try again"}}}async getUserProfiles(){try{if(!this.sessionId)throw new Error("Session ID is required. Please create a session first.");return(await this.request("/profile")).data}catch(i){throw console.error("Failed to get user profiles:",i),i}}async updateUserProfile(i){try{if(!this.sessionId)throw new Error("Session ID is required. Please create a session first.");return(await this.request("/profile","PUT",{...i,gender:"other"})).success}catch(p){throw console.error("Failed to update user profile:",p),p}}async getProductRecommendations(){try{if(!this.sessionId)throw new Error("Session ID is required. Please create a session first.");return(await this.request("/recommendation")).data}catch(i){throw console.error("Failed to get product recommendations:",i),i}}async submitFeedback(i){try{if(!this.sessionId)throw new Error("Session ID is required. Please create a session first.");const p={feedback:i};await this.request("/feedback","POST",p)}catch(p){throw console.error("Failed to save feedback:",p),p}}async getSkinScores(i){try{if(!this.sessionId)throw new Error("Session ID is required. Please create a session first.");return(await this.request(`/profile/scores?profile_id=${i}`,"GET")).data}catch(p){throw console.error("Failed to get skin scores:",p),p}}async updateSession(i,p,f,g,x,k){try{if(!this.sessionId)throw new Error("Session ID is required. Please create a session first.");const N={};i&&(N.name=i),p!==void 0&&(N.age=p),f&&(N.skin_type=f),g&&(N.gender=g),x&&(N.phone=x),k&&(N.email=k),await this.request("/session","PATCH",N)}catch(N){throw console.error("Failed to update session:",N),N}}}W0=new WeakMap,j0=new WeakSet,eG=async function(){try{if(!this.sessionId)throw new Error("Session ID is required. Please create a session first.");return(await this.request("/image?file_ext=png")).data.uploadSignedUrl}catch(i){throw console.error("Failed to get image upload URL:",i),i}};const EB="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAADV4AAAuMCAYAAAA8twe3AAAACXBIWXMAAC4jAAAuIwF4pT92AAAgAElEQVR4nOzboU7WcRiG4ZdvH8ENZIyOJsdmM1o8EAqn4RF4JHYPwGIx2igm8AwEN4MGK7sr4fdnXtcRPOWJ98Hlp89XM/NyAAAAAAAAAAAAAAAAAJiZudnPzNXMvFs8BAAAAAAAAAAAAAAAAGArvuxWLwAAAAAAAAAAAAAAAADYGuEVAAAAAAAAAAAAAAAAQAivAAAAAAAAAAAAAAAAAEJ4BQAAAAAAAAAAAAAAABDCKwAAAAAAAAAAAAAAAIAQXgEAAAAAAAAAAAAAAACE8AoAAAAAAAAAAAAAAAAghFcAAAAAAAAAAAAAAAAAIbwCAAAAAAAAAAAAAAAACOEVAAAAAAAAAAAAAAAAQAivAAAAAAAAAAAAAAAAAEJ4BQAAAAAAAAAAAAAAABDCKwAAAAAAAAAAAAAAAIAQXgEAAAAAAAAAAAAAAACE8AoAAAAAAAAAAAAAAAAghFcAAAAAAAAAAAAAAAAAIbwCAAAAAAAAAAAAAAAACOEVAAAAAAAAAAAAAAAAQAivAAAAAAAAAAAAAAAAAEJ4BQAAAAAAAAAAAAAAABDCKwAAAAAAAAAAAAAAAIAQXgEAAAAAAAAAAAAAAACE8AoAAAAAAAAAAAAAAAAghFcAAAAAAAAAAAAAAAAAIbwCAAAAAAAAAAAAAAAACOEVAAAAAAAAAAAAAAAAQAivAAAAAAAAAAAAAAAAAEJ4BQAAAAAAAAAAAAAAABDCKwAAAAAAAAAAAAAAAIAQXgEAAAAAAAAAAAAAAACE8AoAAAAAAAAAAAAAAAAghFcAAAAAAAAAAAAAAAAAIbwCAAAAAAAAAAAAAAAACOEVAAAAAAAAAAAAAAAAQAivAAAAAAAAAAAAAAAAAEJ4BQAAAAAAAAAAAAAAABDCKwAAAAAAAAAAAAAAAIAQXgEAAAAAAAAAAAAAAACE8AoAAAAAAAAAAAAAAAAghFcAAAAAAAAAAAAAAAAAIbwCAAAAAAAAAAAAAAAACOEVAAAAAAAAAAAAAAAAQAivAAAAAAAAAAAAAAAAAEJ4BQAAAAAAAAAAAAAAABDCKwAAAAAAAAAAAAAAAIAQXgEAAAAAAAAAAAAAAACE8AoAAAAAAAAAAAAAAAAghFcAAAAAAAAAAAAAAAAAIbwCAAAAAAAAAAAAAAAACOEVAAAAAAAAAAAAAAAAQAivAAAAAAAAAAAAAAAAAEJ4BQAAAAAAAAAAAAAAABDCKwAAAAAAAAAAAAAAAIAQXgEAAAAAAAAAAAAAAACE8AoAAAAAAAAAAAAAAAAghFcAAAAAAAAAAAAAAAAAIbwCAAAAAAAAAAAAAAAACOEVAAAAAAAAAAAAAAAAQAivAAAAAAAAAAAAAAAAAEJ4BQAAAAAAAAAAAAAAABDCKwAAAAAAAAAAAAAAAIAQXgEAAAAAAAAAAAAAAACE8AoAAAAAAAAAAAAAAAAghFcAAAAAAAAAAAAAAAAAIbwCAAAAAAAAAAAAAAAACOEVAAAAAAAAAAAAAAAAQAivAAAAAAAAAAAAAAAAAEJ4BQAAAAAAAAAAAAAAABDCKwAAAAAAAAAAAAAAAIAQXgEAAAAAAAAAAAAAAACE8AoAAAAAAAAAAAAAAAAghFcAAAAAAAAAAAAAAAAAIbwCAAAAAAAAAAAAAAAACOEVAAAAAAAAAAAAAAAAQAivAAAAAAAAAAAAAAAAAEJ4BQAAAAAAAAAAAAAAABDCKwAAAAAAAAAAAAAAAIAQXgEAAAAAAAAAAAAAAACE8AoAAAAAAAAAAAAAAAAghFcAAAAAAAAAAAAAAAAAIbwCAAAAAAAAAAAAAAAACOEVAAAAAAAAAAAAAAAAQAivAAAAAAAAAAAAAAAAAEJ4BQAAAAAAAAAAAAAAABDCKwAAAAAAAAAAAAAAAIAQXgEAAAAAAAAAAAAAAACE8AoAAAAAAAAAAAAAAAAghFcAAAAAAAAAAAAAAAAAIbwCAAAAAAAAAAAAAAAACOEVAAAAAAAAAAAAAAAAQAivAAAAAAAAAAAAAAAAAEJ4BQAAAAAAAAAAAAAAABDCKwAAAAAAAAAAAAAAAIAQXgEAAAAAAAAAAAAAAACE8AoAAAAAAAAAAAAAAAAghFcAAAAAAAAAAAAAAAAAIbwCAAAAAAAAAAAAAAAACOEVAAAAAAAAAAAAAAAAQAivAAAAAAAAAAAAAAAAAEJ4BQAAAAAAAAAAAAAAABDCKwAAAAAAAAAAAAAAAIAQXgEAAAAAAAAAAAAAAACE8AoAAAAAAAAAAAAAAAAghFcAAAAAAAAAAAAAAAAAIbwCAAAAAAAAAAAAAAAACOEVAAAAAAAAAAAAAAAAQAivAAAAAAAAAAAAAAAAAEJ4BQAAAAAAAAAAAAAAABDCKwAAAAAAAAAAAAAAAIAQXgEAAAAAAAAAAAAAAACE8AoAAAAAAAAAAAAAAAAghFcAAAAAAAAAAAAAAAAAIbwCAAAAAAAAAAAAAAAACOEVAAAAAAAAAAAAAAAAQAivAAAAAAAAAAAAAAAAAEJ4BQAAAAAAAAAAAAAAABDCKwAAAAAAAAAAAAAAAIAQXgEAAAAAAAAAAAAAAACE8AoAAAAAAAAAAAAAAAAghFcAAAAAAAAAAAAAAAAAIbwCAAAAAAAAAAAAAAAACOEVAAAAAAAAAAAAAAAAQAivAAAAAAAAAAAAAAAAAEJ4BQAAAAAAAAAAAAAAABDCKwAAAAAAAAAAAAAAAIAQXgEAAAAAAAAAAAAAAACE8AoAAAAAAAAAAAAAAAAghFcAAAAAAAAAAAAAAAAAIbwCAAAAAAAAAAAAAAAACOEVAAAAAAAAAAAAAAAAQAivAAAAAAAAAAAAAAAAAEJ4BQAAAAAAAAAAAAAAABDCKwAAAAAAAAAAAAAAAIAQXgEAAAAAAAAAAAAAAACE8AoAAAAAAAAAAAAAAAAghFcAAAAAAAAAAAAAAAAAIbwCAAAAAAAAAAAAAAAACOEVAAAAAAAAAAAAAAAAQAivAAAAAAAAAAAAAAAAAEJ4BQAAAAAAAAAAAAAAABDCKwAAAAAAAAAAAAAAAIAQXgEAAAAAAAAAAAAAAACE8AoAAAAAAAAAAAAAAAAghFcAAAAAAAAAAAAAAAAAIbwCAAAAAAAAAAAAAAAACOEVAAAAAAAAAAAAAAAAQAivAAAAAAAAAAAAAAAAAEJ4BQAAAAAAAAAAAAAAABDCKwAAAAAAAAAAAAAAAIAQXgEAAAAAAAAAAAAAAACE8AoAAAAAAAAAAAAAAAAghFcAAAAAAAAAAAAAAAAAIbwCAAAAAAAAAAAAAAAACOEVAAAAAAAAAAAAAAAAQAivAAAAAAAAAAAAAAAAAEJ4BQAAAAAAAAAAAAAAABDCKwAAAAAAAAAAAAAAAIAQXgEAAAAAAAAAAAAAAACE8AoAAAAAAAAAAAAAAAAghFcAAAAAAAAAAAAAAAAAIbwCAAAAAAAAAAAAAAAACOEVAAAAAAAAAAAAAAAAQAivAAAAAAAAAAAAAAAAAEJ4BQAAAAAAAAAAAAAAABDCKwAAAAAA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4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQqFjygAACAASURBVAAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAsW/HAgAAAACD/K33j6E8AgAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAiH07FgAAAAAY5G+9fwzlEQAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAokorygAAIABJREFUAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAA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CgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAAzBeJigAAIABJREFURrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAACA2LdjAQAAAIBB/tb7x1AeAQAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAAAAAAAAAAAAAAAAACNeAQAAAAAAAAAAAAAAAIx4BQAAAAAAAAAAAAAAADDiFQAAAAAAAAAAAAAAAMCIVwAAAAAAAAAAAAAAAAAjXgEAAAAAAAAAAAAAAACMeAUAAAAAAAAAAAAAAAAw4hUAAAAAAAAAAAAAAADAiFcAAAAAAAAAAAAAAAAAI14BAAAAAAAAAAAAAAAAjHgFAAAAAAAAAAAAAAAAMOIVAAAAAAAAAAAAAAAAwIhXAACxb8cCAAAAAIP8rfePoTwCAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCtGfpoeAAAarElEQVQAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAAAAAAYMQrAAAAAAAAAAAAAAAAgBGvAAAAAAAAAAAAAAAAAEa8AgAAAAAAAAAAAAAAABjxCgAAAAAAAAAAAAAAAGDEKwAAAAAAAAAAAAAAAIARrwAAAAAAAAAAAAAAAABGvAIAAAAAAAAAAAAAAAAY8QoAAAAAAAAAAAAAAABgxCsAAAAAAAAAAAAAAACAEa8AAAAAAAAAAAAAAAAARrwCAAAAAAAAAAAAAAAAGPEKAAAAAAAAAAAA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AAAAAABACK8AAAAAAAAAAAAAAAAAQngFAAAAAAAAAAAAAAAAEMIrAAAAAAAAAAAAAAAAgBBeAQAAAAAAAAAAAAAAAITwCgAAAAAAAAAAAAAAACCEVwAAAAAAAAAAAAAAAAAhvAIAAAAAAAAAAAAAAAAI4RUAAAAAAAAAAAAAAABACK8AAAAAAAAAAAAAAAAAQngFAAAAAAAAAAAAAAAAEMIrAAAAAAAAAAAAAAAAgBBeAQAAAAAAAAAAAAAAAITwCgAAAAAAAAAAAAAAACCEVwAAAAAAAAAAAAAAAAAhvAIAAAAAAAAAAAAAAAAI4RUAAAAAAAAAAAAAAABACK8AAAAAAAAAAAAAAAAAQngFAAAAAAAAAAAAAAAAEMIrAAAAAAAAAAAAAAAAgBBeAQAAAAAAAAAAAAAAAITwCgAAAAAAAAAAAAAAACCEVwAAAAAAAAAAAAAAAAAhvAIAAAAAAAAAAAAAAAAI4RUAAAAAAAAAAAAAAABACK8AAAAAAAAAAAAAAAAAQngFAAAAAAAAAAAAAAAAEMIrAAAAAAAAAAAAAAAAgBBeAQAAAAAAAAAAAAAAAITwCgAAAAAAAAAAAAAAACCEVwAAAAAAAAAAAAAAAAAhvAIAAAAAAAAAAAAAAAAI4RUAAAAAAAAAAAAAAABACK8AAAAAAAAAAAAAAAAAQngFAAAAAAAAAAAAAAAAEMIrAAAAAAAAAAAAAAAAgBBeAQAAAAAAAAAAAAAAAITwCgAAAAAAAAAAAAAAACCEVwAAAAAAAAAAAAAAAAAhvAIAAAAAAAAAAAAAAAAI4RUAAAAAAAAAAAAAAABACK8AAAAAAAAAAAAAAAAAQngFAAAAAAAAAAAAAAAAEMIrAAAAAAAAAAAAAAAAgBBeAQAAAAAAAAAAAAAAAITwCgAAAAAAAAAAAAAAACCEVwAAAAAAAAAAAAAAAAAhvAIAAAAAAAAAAAAAAAAI4RUAAAAAAAAAAAAAAABACK8AAAAAAAAAAAAAAAAAQngFAAAAAAAAAAAAAAAAEMIrAAAAAAAAAAAAAAAAgBBeAQAAAAAAAAAAAAAAAITwCgAAAAAAAAAAAAAAACCEVwAAAAAAAAAAAAAAAAAhvAIAAAAAAAAAAAAAAAAI4RUAAAAAAAAAAAAAAABACK8AAAAAAAAAAAAAAAAAQngFAAAAAAAAAAAAAAAAEMIrAAAAAAAAAAAAAAAAgBBeAQAAAAAAAAAAAAAAAITwCgAAAAAAAAAAAAAAACCEVwAAAAAAAAAAAAAAAAAhvAIAAAAAAAAAAAAAAAAI4RUAAAAAAAAAAAAAAABACK8AAAAAAAAAAAAAAAAAQngFAAAAAAAAAAAAAAAAEMIrAAAAAAAAAAAAAAAAgBBeAQAAAAAAAAAAAAAAAITwCgAAAAAAAAAAAAAAACCEVwAAAAAAAAAAAAAAAAAhvAIAAAAAAAAAAAAAAAAI4RUAAAAAAAAAAAAAAABACK8AAAAAAAAAAAAAAAAAQngFAAAAAAAAAAAAAAAAEMIrAAAAAAAAAAAAAAAAgBBeAQAAAAAAAAAAAAAAAITwCgAAAAAAAAAAAAAAACCEVwAAAAAAAAAAAAAAAAAhvAIAAAAAAAAAAAAAAAAI4RUAAAAAAAAAAAAAAABACK8AAAAAAAAAAAAAAAAAQngFAAAAAAAAAAAAAAAAEMIrAAAAAAAAAAAAAAAAgBBeAQAAAAAAAAAAAAAAAITwCgAAAAAAAAAAAAAAACCEVwAAAAAAAAAAAAAAAAAhvAIAAAAAAAAAAAAAAAAI4RUAAAAAAAAAAAAAAABACK8AAAAAAAAAAAAAAAAAQngFAAAAAAAAAAAAAAAAEMIrAAAAAAAAAAAAAAAAgBBeAQAAAAAAAAAAAAAAAITwCgAAAAAAAAAAAAAAACCEVwAAAAAAAAAAAAAAAAAhvAIAAAAAAAAAAAAAAAAI4RUAAAAAAAAAAAAAAABACK8AAAAAAAAAAAAAAAAAQngFAAAAAAAAAAAAAAAAEMIrAAAAAAAAAAAAAAAAgBBeAQAAAAAAAAAAAAAAAITwCgAAAAAAAAAAAAAAACCEVwAAAAAAAAAAAAAAAAAhvAIAAAAAAAAAAAAAAAAI4RUAAAAAAAAAAAAAAABACK8AAAAAAAAAAAAAAAAAQngFAAAAAAAAAAAAAAAAEMIrAAAAAAAAAAAAAAAAgBBeAQAAAAAAAAAAAAAAAITwCgAAAAAAAAAAAAAAACCEVwAAAAAAAAAAAAAAAAAhvAIAAAAAAAAAAAAAAAAI4RUAAAAAAAAAAAAAAABACK8AAAAAAAAAAAAAAAAAQngFAAAAAAAAAAAAAAAAEMIrAAAAAAAAAAAAAAAAgBBeAQAAAAAAAAAAAAAAAITwCgAAAAAAAAAAAAAAACCEVwAAAAAAAAAAAAAAAAAhvAIAAAAAAAAAAAAAAAAI4RUAAAAAAAAAAAAAAABACK8AAAAAAAAAAAAAAAAAQngFAAAAAAAAAAAAAAAAEMIrAAAAAAAAAAAAAAAAgBBeAQAAAAAAAAAAAAAAAITwCgAAAAAAAAAAAAAAACCEVwAAAAAAAAAAAAAAAAAhvAIAAAAAAAAAAAAAAAAI4RUAAAAAAAAAAAAAAABACK8AAAAAAAAAAAAAAAAAQngFAAAAAAAAAAAAAAAAEMIrAAAAAAAAAAAAAAAAgBBeAQAAAAAAAAAAAAAAAITwCgAAAAAAAAAAAAAAACCEVwAAAAAAAAAAAAAAAAAhvAIAAAAAAAAAAAAAAAAI4RUAAAAAAAAAAAAAAABACK8AAAAAAAAAAAAAAAAAQngFAAAAAAAAAAAAAAAAEMIrAAAAAAAAAAAAAAAAgBBeAQAAAAAAAAAAAAAAAITwCgAAAAAAAAAAAAAAACCEVwAAAAAAAAAAAAAAAAAhvAIAAAAAAAAAAAAAAAAI4RUAAAAAAAAAAAAAAABACK8AAAAAAAAAAAAAAAAAQngFAAAAAAAAAAAAAAAAEMIrAAAAAAAAAAAAAAAAgBBeAQAAAAAAAAAAAAAAAITwCgAAAAAAAAAAAAAAACCEVwAAAAAAAAAAAAAAAAAhvAIAAACA3/btmAAAEAhi2A3414AUpCCF/Qw8Q6KgBgoAAAAAAAAAAMV4BQAAAAAAAAAAAAAAAFCMVwAAAAAAAAAAAAAAAADFeAUAAAAAAAAAAAAAAABQVpKd5MxmAAAAAAAAAAAAAAAAAHzjPrf30FzAv3tDAAAAAElFTkSuQmCC",DB="data:image/png;base64,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3uv2xHtV9zJOc3pmkXrreV122WUt3nrrrVZPPPHEeyeddFKt3FZTex+1figU+mwUsBwKhUKh0MeQwWpDCai1+bm65XsNo0eP9jEM7uQ2krIDXnu/1YQJEzq/9957De++++5iL776apeJ99zT/YUXXlhp1qxZo2fOnLnCW7Nnt7TlrrDF555//vlrb7TRRk+uvvrqb9p6S06dOrX9jjvu+HrHjh3fuPzyy1u1a9eussMOO7xbhEKhz0wBy6FQKBRa5JXDr3dt9R6QC9zaj3P9orjFmcubwHjw4MHVa665ZrEll1yyusUWW8ymHQPclv/617+WOfPMM/e+c+zYXdq0adN57ty5HarV6uJF43dya9bv0KHD62v36fPo0ksv/YxB9Crdu3e/8e133lls5gsvDGjbps2MSkPDG++8884qtmz7hoaGZ5ZbbrknXn755VVbtGjx3pAhQ6ba4/RjjjnmxiIUCv3XClgOhUKh0CInD8eA7vwiDbzngHnOU089tZg5v3MHDBgwB7e5KB1jt8y8UaNGtbUf286ePXuWQWyrn/zkJ9888OCDl+zYvv3jt9xyy/8+/8ILg3bcfvuxvXv3Hj9+4sT1x40du5G5w++88cYbDQa8c62tJX9w1FGXWBvzDIZpswVQvvjiixfz5s3rwYYWW2yxYrXVVnvJnOb7p0yZsm7btm1XbN++/ay33367l4HyDZ07d77se9/73vdPOumkmUUoFPrUClgOhUKh0EIvnx3Of+bZA2+ddVvPmDGD2ETbddZZ561WrVq1fuWVV1otu+yyc3v16lVMmzatYcyYMbXnn3++ag7ue3fddVdhULukrfearV4t20jQjHP8u9/9rp+5yuNsm7PNRV73uuuuO2D11Vd/xdqadcWll/7JYHjFb++99zV33nHHxjfffPNWrVu3bmmPqrW/mMFwzSB37pw5cwpzm4HtFvZeYesU5iSn/vK79bEwR7p48sknOz0xY8aO5jQ3tGvXbu7TTz/dsWXLlksuv/zyc2fOnLnH308/fZ0999rr188+/fQq5mK/efTRR5+zww47vFGEQqGPrYDlUCgUCi1U+ohBdfo5watfLgNoOcK1qVOnFrfddttar7/++koGn4tvuOGG19rPb7/44ourP/zww3MNVN98t6Gh8uxtt724++67zx00aNCce++9t40B9BIbb7zxm7R72WWX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",v$="data:image/svg+xml,%3csvg%20width='429'%20height='866'%20viewBox='0%200%20429%20866'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M370.192%201H59.3404C27.2631%201%201.25%2027.0675%201.25%2059.2109V806.325C1.25%20838.469%2027.2631%20864.536%2059.3404%20864.536H370.192C402.269%20864.536%20428.282%20838.469%20428.282%20806.325V59.2109C428.282%2027.0675%20402.269%201%20370.192%201Z'%20stroke='%2361B0BC'%20stroke-miterlimit='10'/%3e%3cpath%20d='M422.597%2060.6272V806.058C422.597%20808.676%20422.4%20811.258%20422.019%20813.783C421.915%20814.405%20421.811%20815.04%20421.696%20815.639C421.095%20818.775%20420.206%20821.807%20419.062%20824.713C418.842%20825.312%20418.588%20825.912%20418.334%20826.488C416.717%20830.154%20414.673%20833.602%20412.281%20836.772C412.05%20837.06%20411.808%20837.383%20411.577%20837.671C409.925%20839.781%20408.077%20841.73%20406.125%20843.563C405.328%20844.301%20404.508%20845.004%20403.664%20845.684C403.376%20845.938%20403.064%20846.18%20402.763%20846.399C401.862%20847.102%20400.938%20847.771%20399.98%20848.417C399.922%20848.463%20399.864%20848.509%20399.806%20848.543C399.217%20848.912%20398.628%20849.293%20398.051%20849.65C397.392%20850.054%20396.722%20850.434%20396.052%20850.815C395.371%20851.172%20394.689%20851.541%20393.996%20851.875C393.661%20852.037%20393.303%20852.21%20392.968%20852.371C392.622%20852.544%20392.263%20852.705%20391.917%20852.855C390.854%20853.328%20389.768%20853.743%20388.671%20854.147C387.943%20854.412%20387.204%20854.665%20386.465%20854.884C386.095%20855%20385.714%20855.115%20385.344%20855.219C384.212%20855.519%20383.057%20855.818%20381.891%20856.049C381.521%20856.13%20381.128%20856.21%20380.724%20856.28C380.32%20856.349%20379.938%20856.418%20379.546%20856.475C378.76%20856.602%20377.963%20856.718%20377.166%20856.798C376.6%20856.879%20376.046%20856.914%20375.48%20856.96C375.006%20856.994%20374.544%20857.017%20374.07%20857.04C373.193%20857.087%20372.326%20857.11%20371.437%20857.11H60.0657C59.1647%20857.11%2058.2868%20857.087%2057.4089%20857.04C56.9353%20857.017%2056.4733%20856.994%2055.9997%20856.96C55.0872%20856.891%2054.1862%20856.81%2053.2621%20856.706C53.6086%20856.741%2053.9552%20856.764%2054.3017%20856.798C28.7853%20853.928%208.88281%20832.264%208.88281%20806.047V60.6272C8.88281%2033.3722%2030.414%2011.0171%2057.4089%209.63363H57.4436C58.3099%209.58751%2059.1762%209.56445%2060.0657%209.56445H371.425C372.315%209.56445%20373.169%209.58751%20374.047%209.63363H374.059C374.533%209.65669%20374.995%209.67975%20375.468%209.71433C375.919%209.74892%20376.381%209.79504%20376.843%209.82962C402.509%2012.5505%20422.597%2034.2946%20422.597%2060.6272Z'%20stroke='%2361B0BC'%20stroke-miterlimit='10'/%3e%3c/svg%3e",os="https://idoxdey.sufydely.com/eQUtAajpcF/skin-analysis-recommendations/images",ya={normalSkinIcon_female:`${os}/female/normalSkin.png`,drySkinIcon_female:`${os}/female/DrySkin.png`,combinationSkinIcon_female:`${os}/female/CombinationSkin.png`,oilySkinIcon_female:`${os}/female/oilyskin.png`,sensitiveSkinIcon_female:`${os}/female/SensitiveSkin.png`,normalSkinIcon_male:`${os}/male/NormalSkin.png`,drySkinIcon_male:`${os}/male/DrySkin.png`,combinationSkinIcon_male:`${os}/male/CombinationSkin.png`,oilySkinIcon_male:`${os}/male/OilySkin.png`,sensitiveSkinIcon_male:`${os}/male/SensitiveSkin.png`,normalSkinArtIcon:`${os}/normalSkinArt.svg`,drySkinArtIcon:`${os}/DrySkinArt.svg`,combinationSkinArtIcon:`${os}/CombinationSkinArt.svg`,oilySkinArtIcon:`${os}/oilyskinArt.svg`,sensitiveSkinArtIcon:`${os}/SensitiveSkinArt.svg`,model1:`${os}/model1.png`,logo1:`${os}/logo1.png`,maleIcon:`${os}/male.svg`,femaleIcon:`${os}/female.svg`,cameraIcon:`${os}/camera.svg`,uploadIcon:`${os}/upload.svg`,model_home:`${os}/model_home.png`};var bo=function(){return bo=Object.assign||function(i){for(var p,f=1,g=arguments.length;f<g;f++){p=arguments[f];for(var x in p)Object.prototype.hasOwnProperty.call(p,x)&&(i[x]=p[x])}return i},bo.apply(this,arguments)};function w0(a,i,p){if(p||arguments.length===2)for(var f=0,g=i.length,x;f<g;f++)(x||!(f in i))&&(x||(x=Array.prototype.slice.call(i,0,f)),x[f]=i[f]);return a.concat(x||Array.prototype.slice.call(i))}typeof SuppressedError=="function"&&SuppressedError;var Fr="-ms-",Lf="-moz-",dr="-webkit-",zB="comm",k0="rule",mC="decl",x$="@import",OB="@keyframes",w$="@layer",PB=Math.abs,gC=String.fromCharCode,yC=Object.assign;function k$(a,i){return ta(a,0)^45?(((i<<2^ta(a,0))<<2^ta(a,1))<<2^ta(a,2))<<2^ta(a,3):0}function BB(a){return a.trim()}function rl(a,i){return(a=i.exec(a))?a[0]:a}function On(a,i,p){return a.replace(i,p)}function C0(a,i,p){return a.indexOf(i,p)}function ta(a,i){return a.charCodeAt(i)|0}function lp(a,i,p){return a.slice(i,p)}function bA(a){return a.length}function FB(a){return a.length}function Rf(a,i){return i.push(a),a}function C$(a,i){return a.map(i).join("")}function LB(a,i){return a.filter(function(p){return!rl(p,i)})}var I0=1,up=1,RB=0,fi=0,Is=0,cp="";function S0(a,i,p,f,g,x,k,N){return{value:a,root:i,parent:p,type:f,props:g,children:x,line:I0,column:up,length:k,return:"",siblings:N}}function $l(a,i){return yC(S0("",null,null,"",null,null,0,a.siblings),a,{length:-a.length},i)}function dp(a){for(;a.root;)a=$l(a.root,{children:[a]});Rf(a,a.siblings)}function I$(){return Is}function S$(){return Is=fi>0?ta(cp,--fi):0,up--,Is===10&&(up=1,I0--),Is}function ji(){return Is=fi<RB?ta(cp,fi++):0,up++,Is===10&&(up=1,I0++),Is}function gc(){return ta(cp,fi)}function N0(){return fi}function T0(a,i){return lp(cp,a,i)}function bC(a){switch(a){case 0:case 9:case 10:case 13:case 32:return 5;case 33:case 43:case 44:case 47:case 62:case 64:case 126:case 59:case 123:case 125:return 4;case 58:return 3;case 34:case 39:case 40:case 91:return 2;case 41:case 93:return 1}return 0}function N$(a){return I0=up=1,RB=bA(cp=a),fi=0,[]}function T$(a){return cp="",a}function vC(a){return BB(T0(fi-1,xC(a===91?a+2:a===40?a+1:a)))}function M$(a){for(;(Is=gc())&&Is<33;)ji();return bC(a)>2||bC(Is)>3?"":" "}function E$(a,i){for(;--i&&ji()&&!(Is<48||Is>102||Is>57&&Is<65||Is>70&&Is<97););return T0(a,N0()+(i<6&&gc()==32&&ji()==32))}function xC(a){for(;ji();)switch(Is){case a:return fi;case 34:case 39:a!==34&&a!==39&&xC(Is);break;case 40:a===41&&xC(a);break;case 92:ji();break}return fi}function D$(a,i){for(;ji()&&a+Is!==57;)if(a+Is===84&&gc()===47)break;return"/*"+T0(i,fi-1)+"*"+gC(a===47?a:ji())}function z$(a){for(;!bC(gc());)ji();return T0(a,fi)}function O$(a){return T$(M0("",null,null,null,[""],a=N$(a),0,[0],a))}function M0(a,i,p,f,g,x,k,N,E){for(var z=0,G=0,j=k,M=0,R=0,B=0,P=1,H=1,C=1,O=0,F="",Y=g,ae=x,te=f,oe=F;H;)switch(B=O,O=ji()){case 40:if(B!=108&&ta(oe,j-1)==58){C0(oe+=On(vC(O),"&","&\f"),"&\f",PB(z?N[z-1]:0))!=-1&&(C=-1);break}case 34:case 39:case 91:oe+=vC(O);break;case 9:case 10:case 13:case 32:oe+=M$(B);break;case 92:oe+=E$(N0()-1,7);continue;case 47:switch(gc()){case 42:case 47:Rf(P$(D$(ji(),N0()),i,p,E),E);break;default:oe+="/"}break;case 123*P:N[z++]=bA(oe)*C;case 125*P:case 59:case 0:switch(O){case 0:case 125:H=0;case 59+G:C==-1&&(oe=On(oe,/\f/g,"")),R>0&&bA(oe)-j&&Rf(R>32?jB(oe+";",f,p,j-1,E):jB(On(oe," ","")+";",f,p,j-2,E),E);break;case 59:oe+=";";default:if(Rf(te=WB(oe,i,p,z,G,g,N,F,Y=[],ae=[],j,x),x),O===123)if(G===0)M0(oe,i,te,te,Y,x,j,N,ae);else switch(M===99&&ta(oe,3)===110?100:M){case 100:case 108:case 109:case 115:M0(a,te,te,f&&Rf(WB(a,te,te,0,0,g,N,F,g,Y=[],j,ae),ae),g,ae,j,N,f?Y:ae);break;default:M0(oe,te,te,te,[""],ae,0,N,ae)}}z=G=R=0,P=C=1,F=oe="",j=k;break;case 58:j=1+bA(oe),R=B;default:if(P<1){if(O==123)--P;else if(O==125&&P++==0&&S$()==125)continue}switch(oe+=gC(O),O*P){case 38:C=G>0?1:(oe+="\f",-1);break;case 44:N[z++]=(bA(oe)-1)*C,C=1;break;case 64:gc()===45&&(oe+=vC(ji())),M=gc(),G=j=bA(F=oe+=z$(N0())),O++;break;case 45:B===45&&bA(oe)==2&&(P=0)}}return x}function WB(a,i,p,f,g,x,k,N,E,z,G,j){for(var M=g-1,R=g===0?x:[""],B=FB(R),P=0,H=0,C=0;P<f;++P)for(var O=0,F=lp(a,M+1,M=PB(H=k[P])),Y=a;O<B;++O)(Y=BB(H>0?R[O]+" "+F:On(F,/&\f/g,R[O])))&&(E[C++]=Y);return S0(a,i,p,g===0?k0:N,E,z,G,j)}function P$(a,i,p,f){return S0(a,i,p,zB,gC(I$()),lp(a,2,-2),0,f)}function jB(a,i,p,f,g){return S0(a,i,p,mC,lp(a,0,f),lp(a,f+1,-1),f,g)}function HB(a,i,p){switch(k$(a,i)){case 5103:return dr+"print-"+a+a;case 5737:case 4201:case 3177:case 3433:case 1641:case 4457:case 2921:case 5572:case 6356:case 5844:case 3191:case 6645:case 3005:case 6391:case 5879:case 5623:case 6135:case 4599:case 4855:case 4215:case 6389:case 5109:case 5365:case 5621:case 3829:return dr+a+a;case 4789:return Lf+a+a;case 5349:case 4246:case 4810:case 6968:case 2756:return dr+a+Lf+a+Fr+a+a;case 5936:switch(ta(a,i+11)){case 114:return dr+a+Fr+On(a,/[svh]\w+-[tblr]{2}/,"tb")+a;case 108:return dr+a+Fr+On(a,/[svh]\w+-[tblr]{2}/,"tb-rl")+a;case 45:return dr+a+Fr+On(a,/[svh]\w+-[tblr]{2}/,"lr")+a}case 6828:case 4268:case 2903:return dr+a+Fr+a+a;case 6165:return dr+a+Fr+"flex-"+a+a;case 5187:return dr+a+On(a,/(\w+).+(:[^]+)/,dr+"box-$1$2"+Fr+"flex-$1$2")+a;case 5443:return dr+a+Fr+"flex-item-"+On(a,/flex-|-self/g,"")+(rl(a,/flex-|baseline/)?"":Fr+"grid-row-"+On(a,/flex-|-self/g,""))+a;case 4675:return dr+a+Fr+"flex-line-pack"+On(a,/align-content|flex-|-self/g,"")+a;case 5548:return dr+a+Fr+On(a,"shrink","negative")+a;case 5292:return dr+a+Fr+On(a,"basis","preferred-size")+a;case 6060:return dr+"box-"+On(a,"-grow","")+dr+a+Fr+On(a,"grow","positive")+a;case 4554:return dr+On(a,/([^-])(transform)/g,"$1"+dr+"$2")+a;case 6187:return On(On(On(a,/(zoom-|grab)/,dr+"$1"),/(image-set)/,dr+"$1"),a,"")+a;case 5495:case 3959:return On(a,/(image-set\([^]*)/,dr+"$1$`$1");case 4968:return On(On(a,/(.+:)(flex-)?(.*)/,dr+"box-pack:$3"+Fr+"flex-pack:$3"),/s.+-b[^;]+/,"justify")+dr+a+a;case 4200:if(!rl(a,/flex-|baseline/))return Fr+"grid-column-align"+lp(a,i)+a;break;case 2592:case 3360:return Fr+On(a,"template-","")+a;case 4384:case 3616:return p&&p.some(function(f,g){return i=g,rl(f.props,/grid-\w+-end/)})?~C0(a+(p=p[i].value),"span",0)?a:Fr+On(a,"-start","")+a+Fr+"grid-row-span:"+(~C0(p,"span",0)?rl(p,/\d+/):+rl(p,/\d+/)-+rl(a,/\d+/))+";":Fr+On(a,"-start","")+a;case 4896:case 4128:return p&&p.some(function(f){return rl(f.props,/grid-\w+-start/)})?a:Fr+On(On(a,"-end","-span"),"span ","")+a;case 4095:case 3583:case 4068:case 2532:return On(a,/(.+)-inline(.+)/,dr+"$1$2")+a;case 8116:case 7059:case 5753:case 5535:case 5445:case 5701:case 4933:case 4677:case 5533:case 5789:case 5021:case 4765:if(bA(a)-1-i>6)switch(ta(a,i+1)){case 109:if(ta(a,i+4)!==45)break;case 102:return On(a,/(.+:)(.+)-([^]+)/,"$1"+dr+"$2-$3$1"+Lf+(ta(a,i+3)==108?"$3":"$2-$3"))+a;case 115:return~C0(a,"stretch",0)?HB(On(a,"stretch","fill-available"),i,p)+a:a}break;case 5152:case 5920:return On(a,/(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/,function(f,g,x,k,N,E,z){return Fr+g+":"+x+z+(k?Fr+g+"-span:"+(N?E:+E-+x)+z:"")+a});case 4949:if(ta(a,i+6)===121)return On(a,":",":"+dr)+a;break;case 6444:switch(ta(a,ta(a,14)===45?18:11)){case 120:return On(a,/(.+:)([^;\s!]+)(;|(\s+)?!.+)?/,"$1"+dr+(ta(a,14)===45?"inline-":"")+"box$3$1"+dr+"$2$3$1"+Fr+"$2box$3")+a;case 100:return On(a,":",":"+Fr)+a}break;case 5719:case 2647:case 2135:case 3927:case 2391:return On(a,"scroll-","scroll-snap-")+a}return a}function E0(a,i){for(var p="",f=0;f<a.length;f++)p+=i(a[f],f,a,i)||"";return p}function B$(a,i,p,f){switch(a.type){case w$:if(a.children.length)break;case x$:case mC:return a.return=a.return||a.value;case zB:return"";case OB:return a.return=a.value+"{"+E0(a.children,f)+"}";case k0:if(!bA(a.value=a.props.join(",")))return""}return bA(p=E0(a.children,f))?a.return=a.value+"{"+p+"}":""}function F$(a){var i=FB(a);return function(p,f,g,x){for(var k="",N=0;N<i;N++)k+=a[N](p,f,g,x)||"";return k}}function L$(a){return function(i){i.root||(i=i.return)&&a(i)}}function R$(a,i,p,f){if(a.length>-1&&!a.return)switch(a.type){case mC:a.return=HB(a.value,a.length,p);return;case OB:return E0([$l(a,{value:On(a.value,"@","@"+dr)})],f);case k0:if(a.length)return C$(p=a.props,function(g){switch(rl(g,f=/(::plac\w+|:read-\w+)/)){case":read-only":case":read-write":dp($l(a,{props:[On(g,/:(read-\w+)/,":"+Lf+"$1")]})),dp($l(a,{props:[g]})),yC(a,{props:LB(p,f)});break;case"::placeholder":dp($l(a,{props:[On(g,/:(plac\w+)/,":"+dr+"input-$1")]})),dp($l(a,{props:[On(g,/:(plac\w+)/,":"+Lf+"$1")]})),dp($l(a,{props:[On(g,/:(plac\w+)/,Fr+"input-$1")]})),dp($l(a,{props:[g]})),yC(a,{props:LB(p,f)});break}return""})}}var W$={animationIterationCount:1,aspectRatio:1,borderImageOutset:1,borderImageSlice:1,borderImageWidth:1,boxFlex:1,boxFlexGroup:1,boxOrdinalGroup:1,columnCount:1,columns:1,flex:1,flexGrow:1,flexPositive:1,flexShrink:1,flexNegative:1,flexOrder:1,gridRow:1,gridRowEnd:1,gridRowSpan:1,gridRowStart:1,gridColumn:1,gridColumnEnd:1,gridColumnSpan:1,gridColumnStart:1,msGridRow:1,msGridRowSpan:1,msGridColumn:1,msGridColumnSpan:1,fontWeight:1,lineHeight:1,opacity:1,order:1,orphans:1,tabSize:1,widows:1,zIndex:1,zoom:1,WebkitLineClamp:1,fillOpacity:1,floodOpacity:1,stopOpacity:1,strokeDasharray:1,strokeDashoffset:1,strokeMiterlimit:1,strokeOpacity:1,strokeWidth:1},pp=typeof process<"u"&&process.env!==void 0&&(process.env.REACT_APP_SC_ATTR||process.env.SC_ATTR)||"data-styled",GB="active",VB="data-styled-version",D0="6.1.18",wC=`/*!sc*/
`,z0=typeof window<"u"&&typeof document<"u",j$=!!(typeof SC_DISABLE_SPEEDY=="boolean"?SC_DISABLE_SPEEDY:typeof process<"u"&&process.env!==void 0&&process.env.REACT_APP_SC_DISABLE_SPEEDY!==void 0&&process.env.REACT_APP_SC_DISABLE_SPEEDY!==""?process.env.REACT_APP_SC_DISABLE_SPEEDY!=="false"&&process.env.REACT_APP_SC_DISABLE_SPEEDY:typeof process<"u"&&process.env!==void 0&&process.env.SC_DISABLE_SPEEDY!==void 0&&process.env.SC_DISABLE_SPEEDY!==""&&process.env.SC_DISABLE_SPEEDY!=="false"&&process.env.SC_DISABLE_SPEEDY),O0=Object.freeze([]),hp=Object.freeze({});function H$(a,i,p){return p===void 0&&(p=hp),a.theme!==p.theme&&a.theme||i||p.theme}var XB=new Set(["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","big","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","keygen","label","legend","li","link","main","map","mark","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","small","source","span","strong","style","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","tr","track","u","ul","use","var","video","wbr","circle","clipPath","defs","ellipse","foreignObject","g","image","line","linearGradient","marker","mask","path","pattern","polygon","polyline","radialGradient","rect","stop","svg","text","tspan"]),G$=/[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g,V$=/(^-|-$)/g;function ZB(a){return a.replace(G$,"-").replace(V$,"")}var X$=/(a)(d)/gi,P0=52,YB=function(a){return String.fromCharCode(a+(a>25?39:97))};function kC(a){var i,p="";for(i=Math.abs(a);i>P0;i=i/P0|0)p=YB(i%P0)+p;return(YB(i%P0)+p).replace(X$,"$1-$2")}var CC,UB=5381,fp=function(a,i){for(var p=i.length;p;)a=33*a^i.charCodeAt(--p);return a},QB=function(a){return fp(UB,a)};function Z$(a){return kC(QB(a)>>>0)}function Y$(a){return a.displayName||a.name||"Component"}function IC(a){return typeof a=="string"&&!0}var KB=typeof Symbol=="function"&&Symbol.for,qB=KB?Symbol.for("react.memo"):60115,U$=KB?Symbol.for("react.forward_ref"):60112,Q$={childContextTypes:!0,contextType:!0,contextTypes:!0,defaultProps:!0,displayName:!0,getDefaultProps:!0,getDerivedStateFromError:!0,getDerivedStateFromProps:!0,mixins:!0,propTypes:!0,type:!0},K$={name:!0,length:!0,prototype:!0,caller:!0,callee:!0,arguments:!0,arity:!0},JB={$$typeof:!0,compare:!0,defaultProps:!0,displayName:!0,propTypes:!0,type:!0},q$=((CC={})[U$]={$$typeof:!0,render:!0,defaultProps:!0,displayName:!0,propTypes:!0},CC[qB]=JB,CC);function $B(a){return("type"in(i=a)&&i.type.$$typeof)===qB?JB:"$$typeof"in a?q$[a.$$typeof]:Q$;var i}var J$=Object.defineProperty,$$=Object.getOwnPropertyNames,_B=Object.getOwnPropertySymbols,_$=Object.getOwnPropertyDescriptor,e_=Object.getPrototypeOf,e7=Object.prototype;function t7(a,i,p){if(typeof i!="string"){if(e7){var f=e_(i);f&&f!==e7&&t7(a,f,p)}var g=$$(i);_B&&(g=g.concat(_B(i)));for(var x=$B(a),k=$B(i),N=0;N<g.length;++N){var E=g[N];if(!(E in K$||p&&p[E]||k&&E in k||x&&E in x)){var z=_$(i,E);try{J$(a,E,z)}catch{}}}}return a}function mp(a){return typeof a=="function"}function SC(a){return typeof a=="object"&&"styledComponentId"in a}function yc(a,i){return a&&i?"".concat(a," ").concat(i):a||i||""}function n7(a,i){if(a.length===0)return"";for(var p=a[0],f=1;f<a.length;f++)p+=a[f];return p}function Wf(a){return a!==null&&typeof a=="object"&&a.constructor.name===Object.name&&!("props"in a&&a.$$typeof)}function NC(a,i,p){if(p===void 0&&(p=!1),!p&&!Wf(a)&&!Array.isArray(a))return i;if(Array.isArray(i))for(var f=0;f<i.length;f++)a[f]=NC(a[f],i[f]);else if(Wf(i))for(var f in i)a[f]=NC(a[f],i[f]);return a}function TC(a,i){Object.defineProperty(a,"toString",{value:i})}function jf(a){for(var i=[],p=1;p<arguments.length;p++)i[p-1]=arguments[p];return new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(a," for more information.").concat(i.length>0?" Args: ".concat(i.join(", ")):""))}var t_=function(){function a(i){this.groupSizes=new Uint32Array(512),this.length=512,this.tag=i}return a.prototype.indexOfGroup=function(i){for(var p=0,f=0;f<i;f++)p+=this.groupSizes[f];return p},a.prototype.insertRules=function(i,p){if(i>=this.groupSizes.length){for(var f=this.groupSizes,g=f.length,x=g;i>=x;)if((x<<=1)<0)throw jf(16,"".concat(i));this.groupSizes=new Uint32Array(x),this.groupSizes.set(f),this.length=x;for(var k=g;k<x;k++)this.groupSizes[k]=0}for(var N=this.indexOfGroup(i+1),E=(k=0,p.length);k<E;k++)this.tag.insertRule(N,p[k])&&(this.groupSizes[i]++,N++)},a.prototype.clearGroup=function(i){if(i<this.length){var p=this.groupSizes[i],f=this.indexOfGroup(i),g=f+p;this.groupSizes[i]=0;for(var x=f;x<g;x++)this.tag.deleteRule(f)}},a.prototype.getGroup=function(i){var p="";if(i>=this.length||this.groupSizes[i]===0)return p;for(var f=this.groupSizes[i],g=this.indexOfGroup(i),x=g+f,k=g;k<x;k++)p+="".concat(this.tag.getRule(k)).concat(wC);return p},a}(),B0=new Map,F0=new Map,L0=1,R0=function(a){if(B0.has(a))return B0.get(a);for(;F0.has(L0);)L0++;var i=L0++;return B0.set(a,i),F0.set(i,a),i},n_=function(a,i){L0=i+1,B0.set(a,i),F0.set(i,a)},r_="style[".concat(pp,"][").concat(VB,'="').concat(D0,'"]'),s_=new RegExp("^".concat(pp,'\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')),a_=function(a,i,p){for(var f,g=p.split(","),x=0,k=g.length;x<k;x++)(f=g[x])&&a.registerName(i,f)},o_=function(a,i){for(var p,f=((p=i.textContent)!==null&&p!==void 0?p:"").split(wC),g=[],x=0,k=f.length;x<k;x++){var N=f[x].trim();if(N){var E=N.match(s_);if(E){var z=0|parseInt(E[1],10),G=E[2];z!==0&&(n_(G,z),a_(a,G,E[3]),a.getTag().insertRules(z,g)),g.length=0}else g.push(N)}}},r7=function(a){for(var i=document.querySelectorAll(r_),p=0,f=i.length;p<f;p++){var g=i[p];g&&g.getAttribute(pp)!==GB&&(o_(a,g),g.parentNode&&g.parentNode.removeChild(g))}};function i_(){return typeof __webpack_nonce__<"u"?__webpack_nonce__:null}var s7=function(a){var i=document.head,p=a||i,f=document.createElement("style"),g=function(N){var E=Array.from(N.querySelectorAll("style[".concat(pp,"]")));return E[E.length-1]}(p),x=g!==void 0?g.nextSibling:null;f.setAttribute(pp,GB),f.setAttribute(VB,D0);var k=i_();return k&&f.setAttribute("nonce",k),p.insertBefore(f,x),f},A_=function(){function a(i){this.element=s7(i),this.element.appendChild(document.createTextNode("")),this.sheet=function(p){if(p.sheet)return p.sheet;for(var f=document.styleSheets,g=0,x=f.length;g<x;g++){var k=f[g];if(k.ownerNode===p)return k}throw jf(17)}(this.element),this.length=0}return a.prototype.insertRule=function(i,p){try{return this.sheet.insertRule(p,i),this.length++,!0}catch{return!1}},a.prototype.deleteRule=function(i){this.sheet.deleteRule(i),this.length--},a.prototype.getRule=function(i){var p=this.sheet.cssRules[i];return p&&p.cssText?p.cssText:""},a}(),l_=function(){function a(i){this.element=s7(i),this.nodes=this.element.childNodes,this.length=0}return a.prototype.insertRule=function(i,p){if(i<=this.length&&i>=0){var f=document.createTextNode(p);return this.element.insertBefore(f,this.nodes[i]||null),this.length++,!0}return!1},a.prototype.deleteRule=function(i){this.element.removeChild(this.nodes[i]),this.length--},a.prototype.getRule=function(i){return i<this.length?this.nodes[i].textContent:""},a}(),u_=function(){function a(i){this.rules=[],this.length=0}return a.prototype.insertRule=function(i,p){return i<=this.length&&(this.rules.splice(i,0,p),this.length++,!0)},a.prototype.deleteRule=function(i){this.rules.splice(i,1),this.length--},a.prototype.getRule=function(i){return i<this.length?this.rules[i]:""},a}(),a7=z0,c_={isServer:!z0,useCSSOMInjection:!j$},o7=function(){function a(i,p,f){i===void 0&&(i=hp),p===void 0&&(p={});var g=this;this.options=bo(bo({},c_),i),this.gs=p,this.names=new Map(f),this.server=!!i.isServer,!this.server&&z0&&a7&&(a7=!1,r7(this)),TC(this,function(){return function(x){for(var k=x.getTag(),N=k.length,E="",z=function(j){var M=function(C){return F0.get(C)}(j);if(M===void 0)return"continue";var R=x.names.get(M),B=k.getGroup(j);if(R===void 0||!R.size||B.length===0)return"continue";var P="".concat(pp,".g").concat(j,'[id="').concat(M,'"]'),H="";R!==void 0&&R.forEach(function(C){C.length>0&&(H+="".concat(C,","))}),E+="".concat(B).concat(P,'{content:"').concat(H,'"}').concat(wC)},G=0;G<N;G++)z(G);return E}(g)})}return a.registerId=function(i){return R0(i)},a.prototype.rehydrate=function(){!this.server&&z0&&r7(this)},a.prototype.reconstructWithOptions=function(i,p){return p===void 0&&(p=!0),new a(bo(bo({},this.options),i),this.gs,p&&this.names||void 0)},a.prototype.allocateGSInstance=function(i){return this.gs[i]=(this.gs[i]||0)+1},a.prototype.getTag=function(){return this.tag||(this.tag=(i=function(p){var f=p.useCSSOMInjection,g=p.target;return p.isServer?new u_(g):f?new A_(g):new l_(g)}(this.options),new t_(i)));var i},a.prototype.hasNameForId=function(i,p){return this.names.has(i)&&this.names.get(i).has(p)},a.prototype.registerName=function(i,p){if(R0(i),this.names.has(i))this.names.get(i).add(p);else{var f=new Set;f.add(p),this.names.set(i,f)}},a.prototype.insertRules=function(i,p,f){this.registerName(i,p),this.getTag().insertRules(R0(i),f)},a.prototype.clearNames=function(i){this.names.has(i)&&this.names.get(i).clear()},a.prototype.clearRules=function(i){this.getTag().clearGroup(R0(i)),this.clearNames(i)},a.prototype.clearTag=function(){this.tag=void 0},a}(),d_=/&/g,p_=/^\s*\/\/.*$/gm;function i7(a,i){return a.map(function(p){return p.type==="rule"&&(p.value="".concat(i," ").concat(p.value),p.value=p.value.replaceAll(",",",".concat(i," ")),p.props=p.props.map(function(f){return"".concat(i," ").concat(f)})),Array.isArray(p.children)&&p.type!=="@keyframes"&&(p.children=i7(p.children,i)),p})}function h_(a){var i,p,f,g=hp,x=g.options,k=x===void 0?hp:x,N=g.plugins,E=N===void 0?O0:N,z=function(M,R,B){return B.startsWith(p)&&B.endsWith(p)&&B.replaceAll(p,"").length>0?".".concat(i):M},G=E.slice();G.push(function(M){M.type===k0&&M.value.includes("&")&&(M.props[0]=M.props[0].replace(d_,p).replace(f,z))}),k.prefix&&G.push(R$),G.push(B$);var j=function(M,R,B,P){R===void 0&&(R=""),B===void 0&&(B=""),P===void 0&&(P="&"),i=P,p=R,f=new RegExp("\\".concat(p,"\\b"),"g");var H=M.replace(p_,""),C=O$(B||R?"".concat(B," ").concat(R," { ").concat(H," }"):H);k.namespace&&(C=i7(C,k.namespace));var O=[];return E0(C,F$(G.concat(L$(function(F){return O.push(F)})))),O};return j.hash=E.length?E.reduce(function(M,R){return R.name||jf(15),fp(M,R.name)},UB).toString():"",j}var f_=new o7,MC=h_(),A7=Ya.createContext({shouldForwardProp:void 0,styleSheet:f_,stylis:MC});A7.Consumer,Ya.createContext(void 0);function l7(){return se.useContext(A7)}var m_=function(){function a(i,p){var f=this;this.inject=function(g,x){x===void 0&&(x=MC);var k=f.name+x.hash;g.hasNameForId(f.id,k)||g.insertRules(f.id,k,x(f.rules,k,"@keyframes"))},this.name=i,this.id="sc-keyframes-".concat(i),this.rules=p,TC(this,function(){throw jf(12,String(f.name))})}return a.prototype.getName=function(i){return i===void 0&&(i=MC),this.name+i.hash},a}(),g_=function(a){return a>="A"&&a<="Z"};function u7(a){for(var i="",p=0;p<a.length;p++){var f=a[p];if(p===1&&f==="-"&&a[0]==="-")return a;g_(f)?i+="-"+f.toLowerCase():i+=f}return i.startsWith("ms-")?"-"+i:i}var c7=function(a){return a==null||a===!1||a===""},d7=function(a){var i,p,f=[];for(var g in a){var x=a[g];a.hasOwnProperty(g)&&!c7(x)&&(Array.isArray(x)&&x.isCss||mp(x)?f.push("".concat(u7(g),":"),x,";"):Wf(x)?f.push.apply(f,w0(w0(["".concat(g," {")],d7(x),!1),["}"],!1)):f.push("".concat(u7(g),": ").concat((i=g,(p=x)==null||typeof p=="boolean"||p===""?"":typeof p!="number"||p===0||i in W$||i.startsWith("--")?String(p).trim():"".concat(p,"px")),";")))}return f};function bc(a,i,p,f){if(c7(a))return[];if(SC(a))return[".".concat(a.styledComponentId)];if(mp(a)){if(!mp(x=a)||x.prototype&&x.prototype.isReactComponent||!i)return[a];var g=a(i);return bc(g,i,p,f)}var x;return a instanceof m_?p?(a.inject(p,f),[a.getName(f)]):[a]:Wf(a)?d7(a):Array.isArray(a)?Array.prototype.concat.apply(O0,a.map(function(k){return bc(k,i,p,f)})):[a.toString()]}function y_(a){for(var i=0;i<a.length;i+=1){var p=a[i];if(mp(p)&&!SC(p))return!1}return!0}var b_=QB(D0),v_=function(){function a(i,p,f){this.rules=i,this.staticRulesId="",this.isStatic=(f===void 0||f.isStatic)&&y_(i),this.componentId=p,this.baseHash=fp(b_,p),this.baseStyle=f,o7.registerId(p)}return a.prototype.generateAndInjectStyles=function(i,p,f){var g=this.baseStyle?this.baseStyle.generateAndInjectStyles(i,p,f):"";if(this.isStatic&&!f.hash)if(this.staticRulesId&&p.hasNameForId(this.componentId,this.staticRulesId))g=yc(g,this.staticRulesId);else{var x=n7(bc(this.rules,i,p,f)),k=kC(fp(this.baseHash,x)>>>0);if(!p.hasNameForId(this.componentId,k)){var N=f(x,".".concat(k),void 0,this.componentId);p.insertRules(this.componentId,k,N)}g=yc(g,k),this.staticRulesId=k}else{for(var E=fp(this.baseHash,f.hash),z="",G=0;G<this.rules.length;G++){var j=this.rules[G];if(typeof j=="string")z+=j;else if(j){var M=n7(bc(j,i,p,f));E=fp(E,M+G),z+=M}}if(z){var R=kC(E>>>0);p.hasNameForId(this.componentId,R)||p.insertRules(this.componentId,R,f(z,".".concat(R),void 0,this.componentId)),g=yc(g,R)}}return g},a}(),p7=Ya.createContext(void 0);p7.Consumer;var EC={};function x_(a,i,p){var f=SC(a),g=a,x=!IC(a),k=i.attrs,N=k===void 0?O0:k,E=i.componentId,z=E===void 0?function(Y,ae){var te=typeof Y!="string"?"sc":ZB(Y);EC[te]=(EC[te]||0)+1;var oe="".concat(te,"-").concat(Z$(D0+te+EC[te]));return ae?"".concat(ae,"-").concat(oe):oe}(i.displayName,i.parentComponentId):E,G=i.displayName,j=G===void 0?function(Y){return IC(Y)?"styled.".concat(Y):"Styled(".concat(Y$(Y),")")}(a):G,M=i.displayName&&i.componentId?"".concat(ZB(i.displayName),"-").concat(i.componentId):i.componentId||z,R=f&&g.attrs?g.attrs.concat(N).filter(Boolean):N,B=i.shouldForwardProp;if(f&&g.shouldForwardProp){var P=g.shouldForwardProp;if(i.shouldForwardProp){var H=i.shouldForwardProp;B=function(Y,ae){return P(Y,ae)&&H(Y,ae)}}else B=P}var C=new v_(p,M,f?g.componentStyle:void 0);function O(Y,ae){return function(te,oe,fe){var ue=te.attrs,Z=te.componentStyle,ye=te.defaultProps,pe=te.foldedComponentIds,Q=te.styledComponentId,ke=te.target,ie=Ya.useContext(p7),Ie=l7(),je=te.shouldForwardProp||Ie.shouldForwardProp,xe=H$(oe,ie,ye)||hp,We=function(dt,It,Ft){for(var pn,Yt=bo(bo({},It),{className:void 0,theme:Ft}),wt=0;wt<dt.length;wt+=1){var Ht=mp(pn=dt[wt])?pn(Yt):pn;for(var Wt in Ht)Yt[Wt]=Wt==="className"?yc(Yt[Wt],Ht[Wt]):Wt==="style"?bo(bo({},Yt[Wt]),Ht[Wt]):Ht[Wt]}return It.className&&(Yt.className=yc(Yt.className,It.className)),Yt}(ue,oe,xe),Ke=We.as||ke,ut={};for(var ge in We)We[ge]===void 0||ge[0]==="$"||ge==="as"||ge==="theme"&&We.theme===xe||(ge==="forwardedAs"?ut.as=We.forwardedAs:je&&!je(ge,Ke)||(ut[ge]=We[ge]));var Qe=function(dt,It){var Ft=l7(),pn=dt.generateAndInjectStyles(It,Ft.styleSheet,Ft.stylis);return pn}(Z,We),At=yc(pe,Q);return Qe&&(At+=" "+Qe),We.className&&(At+=" "+We.className),ut[IC(Ke)&&!XB.has(Ke)?"class":"className"]=At,fe&&(ut.ref=fe),se.createElement(Ke,ut)}(F,Y,ae)}O.displayName=j;var F=Ya.forwardRef(O);return F.attrs=R,F.componentStyle=C,F.displayName=j,F.shouldForwardProp=B,F.foldedComponentIds=f?yc(g.foldedComponentIds,g.styledComponentId):"",F.styledComponentId=M,F.target=f?g.target:a,Object.defineProperty(F,"defaultProps",{get:function(){return this._foldedDefaultProps},set:function(Y){this._foldedDefaultProps=f?function(ae){for(var te=[],oe=1;oe<arguments.length;oe++)te[oe-1]=arguments[oe];for(var fe=0,ue=te;fe<ue.length;fe++)NC(ae,ue[fe],!0);return ae}({},g.defaultProps,Y):Y}}),TC(F,function(){return".".concat(F.styledComponentId)}),x&&t7(F,a,{attrs:!0,componentStyle:!0,displayName:!0,foldedComponentIds:!0,shouldForwardProp:!0,styledComponentId:!0,target:!0}),F}function h7(a,i){for(var p=[a[0]],f=0,g=i.length;f<g;f+=1)p.push(i[f],a[f+1]);return p}var f7=function(a){return Object.assign(a,{isCss:!0})};function w_(a){for(var i=[],p=1;p<arguments.length;p++)i[p-1]=arguments[p];if(mp(a)||Wf(a))return f7(bc(h7(O0,w0([a],i,!0))));var f=a;return i.length===0&&f.length===1&&typeof f[0]=="string"?bc(f):f7(bc(h7(f,i)))}function DC(a,i,p){if(p===void 0&&(p=hp),!i)throw jf(1,i);var f=function(g){for(var x=[],k=1;k<arguments.length;k++)x[k-1]=arguments[k];return a(i,p,w_.apply(void 0,w0([g],x,!1)))};return f.attrs=function(g){return DC(a,i,bo(bo({},p),{attrs:Array.prototype.concat(p.attrs,g).filter(Boolean)}))},f.withConfig=function(g){return DC(a,i,bo(bo({},p),g))},f}var m7=function(a){return DC(x_,a)},g7=m7;XB.forEach(function(a){g7[a]=m7(a)});const k_=g7.img`
  height: 6rem;
  object-fit: contain;
`,vc=Lt(eC)(({theme:a})=>({borderRadius:"0px",background:"#939598",color:"#fff",width:"100%",height:"40px",fontSize:"16px",fontWeight:"700",lineHeight:"132%",maxWidth:"100%",[a.breakpoints.up("xs")]:{width:"306px",height:"26px",fontSize:"14px"},[a.breakpoints.up("md")]:{width:"422px",height:"46px",fontSize:"24px"},"&:hover":{background:"#4FA2AE"}})),C_=Lt("img")({maxWidth:"100%",height:"auto"}),I_=Lt("img")({maxWidth:"100%",height:"auto"}),S_=a=>a.includes("Chrome")?"Chrome":a.includes("Firefox")?"Firefox":a.includes("Safari")?"Safari":a.includes("Edge")?"Edge":"Unknown",N_=a=>a.includes("Windows")?"Windows":a.includes("Mac")?"Mac":a.includes("iPhone")||a.includes("iPad")?"iOS":a.includes("Android")?"Android":"Unknown",T_=()=>{const{setView:a,sessionId:i,setSessionId:p,setSnackbar:f}=Jl(),g=async()=>{if(i){a("Gender");return}try{const x=navigator.userAgent,k=S_(x),N=N_(x),E=await new Ff().createSession(N,k);p(E),a("Gender"),console.log("Session created:",E)}catch(x){console.error(x),f({snackbarOpen:!0,snackbarMessage:"Oops! Something went wrong. Please try again later.",snackbarSeverity:"error"})}};return q.jsxs(ft,{sx:{display:"flex",flexDirection:{xs:"column",md:"row"},alignItems:"center",justifyContent:"space-between",width:"100vw",minHeight:"100%",height:"100vh"},children:[q.jsxs(ft,{sx:{width:{xs:"100%",md:"50%"},display:"flex",flexDirection:"column",justifyContent:"space-around",alignItems:"center",padding:"2rem",gap:"2rem",textAlign:"center",flexBasis:"50%"},children:[q.jsx(k_,{src:EB,alt:"Company Logo"}),q.jsx(ft,{sx:{width:{xs:"15rem",sm:"20rem",md:"35rem"}},children:q.jsx(mn,{variant:"body1",sx:{fontSize:{xs:"1.3rem",md:"2rem"},lineHeight:1.8,color:"#616161",fontWeight:500},component:"div",children:"Get under the skin and say goodbye to guesswork with our advanced skin analyser"})}),q.jsx(vc,{onClick:()=>g(),children:"Try Now"})]}),q.jsxs(ft,{sx:{width:{xs:"100%",md:"50%"},display:"flex",flexDirection:"column",justifyContent:"center",alignItems:"center",position:"relative"},children:[q.jsx(C_,{sx:{height:"auto",maxHeight:"70%",width:"auto",objectFit:"contain"},src:DB,alt:"Home illustration"}),q.jsx(I_,{src:v$,alt:"Home illustration",sx:{display:"none",position:"absolute",top:"50%",left:"50%"}})]})]})},M_=[["Normal",ya.normalSkinIcon_female,ya.normalSkinIcon_male,"normal","Smooth, even-toned skin with fewer breakouts.",ya.normalSkinArtIcon],["Dry",ya.drySkinIcon_female,ya.drySkinIcon_male,"dry","Tight, flaky, small pores, and irritation.",ya.drySkinArtIcon],["Sensitive",ya.sensitiveSkinIcon_female,ya.sensitiveSkinIcon_male,"sensitive","Weakened barrier, irritation, redness, and dryness.",ya.sensitiveSkinArtIcon],["Oily",ya.oilySkinIcon_female,ya.oilySkinIcon_male,"oily","Greasy-looking enlarged pores, and frequent breakouts.",ya.oilySkinArtIcon],["Combination",ya.combinationSkinIcon_female,ya.combinationSkinIcon_male,"combination","Typically with an oily T-zone and dry cheeks.",ya.combinationSkinArtIcon]],E_=[["male","male"],["female","female"]],D_=[["Camera",ya.cameraIcon,"camera"],["Upload",ya.uploadIcon,"upload"]],z_=()=>{const a=se.useRef(null),{view:i,setView:p,userInfo:f,setUserInfo:g,sessionId:x,setSnackbar:k,setCapturedPic:N,setOutputScore:E,setRecommendations:z,setAnnotations:G,setInputImage:j}=Jl(),[M,R]=se.useState(f.skin),[B,P]=se.useState(Number(f.age)),[H,C]=se.useState(f.gender),[O,F]=se.useState(""),[Y,ae]=se.useState({skin:"",gender:"",imgSelection:""}),te=()=>x?!0:(k({snackbarOpen:!0,snackbarMessage:"We hit a snag. Restarting the process should fix it.",snackbarSeverity:"error"}),!1),oe=()=>{if(!te())return!1;let ie=!0;const Ie={skin:"",gender:"",age:"",imgSelection:""};return M.trim()||(Ie.skin="Skin type is required.",ie=!1),H.trim()||(Ie.gender="Gender is required.",ie=!1),ae(Ie),ie||k({snackbarOpen:!0,snackbarMessage:"Please select an option",snackbarSeverity:"warning"}),ie},fe=ie=>{R(ie),p("CaptureUpload")},ue=ie=>{C(ie),p("Age")},Z=ie=>{F(ie),ie&&ae(Ie=>({...Ie,imgSelection:""}))},ye=ie=>{var Ie;ie==="upload"?(Z(ie),(Ie=a.current)==null||Ie.click()):(Z(ie),ke())},pe=async ie=>{const Ie=await window.OrboSmartCapture.cropAndValidateFace(ie);if(!Ie.isValid){let je="Something went wrong. Please choose another image";return Ie.validationResult.faceFound||(je="Face not found. Please choose another image"),Ie.validationResult.noSufficientLite&&(je="Use photo with naturally lit face for best results."),Ie.validationResult.misAligned&&(je="Select photo with face well aligned."),Ie.validationResult.outsideGuide&&(je="Seems face is not well aligned in this image."),Ie.validationResult.close&&(je="Face too small in this image."),k({snackbarOpen:!0,snackbarMessage:je,snackbarSeverity:"error"}),!1}return Ie.image},Q=async ie=>{var je;const Ie=(je=ie.target.files)==null?void 0:je[0];if(Ie){const xe=await pe(Ie);if(!xe)return;N(xe);const We=new Ff(x);await We.updateSession("DUMMY-NAME-WEB",parseInt(f.age),M,H,f.phone,f.email),await We.uploadImage(Ie);const Ke=await We.getSkinAnalysis();E(Ke.output_score),G(Ke.annotations),j(Ke.input_image);const ut=await We.getProductRecommendations();E(Ke.output_score),z(ut),p("Scores")}},ke=async()=>{oe()&&(g({skin:M,gender:H,age:String(B),name:"",email:f.email,phone:f.phone}),p("PicCapture"))};return q.jsxs(q.Fragment,{children:[i==="Gender"&&q.jsx(ft,{sx:{display:"flex",flexDirection:"column",gap:{xs:"40px",md:"100px"},alignItems:{xs:"center",md:"center"},justifyContent:{xs:"space-between",md:"center"},height:"90vh",padding:"16px"},children:q.jsx(ft,{sx:{display:"flex",flexDirection:"column",gap:{xs:"20px",md:"100px"},alignItems:{xs:"center",md:"center"},justifyContent:{xs:"center",md:"center"}},children:q.jsxs(ft,{sx:{display:"flex",flexDirection:"column",alignItems:"center",gap:{xs:"40px",md:"100px"}},children:[q.jsx(mn,{sx:Xr.heading,children:"how do you identify yourself ?"}),q.jsx(ft,{sx:Xr.inputContainer,children:q.jsx(dC,{row:!0,value:H,onChange:ie=>ue(ie.target.value),sx:{display:"flex",gap:{xs:"24px",md:"100px"},flexDirection:{xs:"column",md:"row"},justifyContent:{xs:"center",md:"flex-start"},alignItems:{xs:"center",md:"flex-start"}},children:E_.map(([ie,Ie])=>q.jsxs(ft,{sx:{display:"flex",flexDirection:"column",alignItems:"center",gap:{xs:"8px",md:"20px"}},children:[q.jsx(ft,{sx:{display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",width:"220px",height:"243px",padding:{xs:"2px",md:"4px"},border:H===Ie?"2px solid #2F3750":"2px solid #61B0BC",borderColor:Y.gender&&"#d32f2f",borderWidth:Y.gender&&"3px",cursor:"pointer",flexShrink:0,gap:{xs:"8px",md:"40px"},position:"relative"},onClick:()=>ue(Ie),children:Ie==="male"?q.jsx("svg",{width:"150",height:"150",viewBox:"0 0 150 150",fill:"none",xmlns:"http://www.w3.org/2000/svg",children:q.jsx("path",{d:"M150 0H102.053V18.7369H118.014L102.147 34.6045C77.0887 15.9575 41.4885 18.0037 18.7452 40.7471C-6.24839 65.7407 -6.24839 106.263 18.7452 131.255C43.7387 156.248 84.2605 156.249 109.253 131.255C131.995 108.513 134.043 72.9115 115.396 47.8532L131.263 31.9856V47.9471H150V0ZM95.9498 117.951C78.3047 135.597 49.6955 135.597 32.0494 117.951C14.4033 100.305 14.4033 71.6965 32.0494 54.0503C49.6955 36.4042 78.3037 36.4042 95.9498 54.0503C113.596 71.6965 113.596 100.305 95.9498 117.951Z",fill:`${H===Ie?"#2F3750":"#61B0BC"}`})}):q.jsx("svg",{width:"109",height:"150",viewBox:"0 0 109 150",fill:"none",xmlns:"http://www.w3.org/2000/svg",children:q.jsx("path",{d:"M108.999 54.6246C108.999 24.5846 84.5985 0.231445 54.4991 0.231445C24.3998 0.231445 0 24.5846 0 54.6246C0 81.9607 20.2044 104.586 46.5221 108.438V121.431H34.0849V137.356H46.5221V149.769H62.4779V137.356H74.9151V121.431H62.4779V108.438C88.7956 104.585 109 81.9607 109 54.6246H108.999ZM16.022 54.6246C16.022 33.4157 33.2489 16.2214 54.5 16.2214C75.7511 16.2214 92.978 33.4148 92.978 54.6246C92.978 75.8344 75.7511 93.0278 54.5 93.0278C33.2489 93.0278 16.022 75.8344 16.022 54.6246Z",fill:`${H===Ie?"#2F3750":"#61B0BC"}`})})}),q.jsx(sC,{value:Ie,control:q.jsx(cC,{sx:{display:"none"}}),label:ie,sx:{textAlign:"center",fontSize:{xs:"14px",md:"30px"},lineHeight:"32px",margin:0,"& .MuiTypography-root":{fontWeight:400,fontSize:{xs:"14px",md:"18px"}}}})]},ie))})})]})})}),i==="Age"&&q.jsxs(ft,{sx:{display:"flex",flexDirection:"column",gap:{xs:"100px",md:"100px"},alignItems:{xs:"center",md:"center"},justifyContent:{xs:"space-between",md:"center"},height:"90vh",padding:"16px"},children:[q.jsx(ft,{sx:{display:"flex",flexDirection:"column",gap:{xs:"40px",md:"100px"},alignItems:{xs:"center",md:"center"},justifyContent:{xs:"center",md:"center"}},children:q.jsxs(ft,{sx:{display:"flex",flexDirection:"column",alignItems:"center",gap:"100px"},children:[q.jsx(mn,{sx:Xr.heading,children:"Could you tell us your age?"}),q.jsxs(ft,{sx:Xr.inputContainer,children:[q.jsxs(ft,{sx:{position:"relative",width:"220px",height:"243px",flexShrink:0,border:"2px solid #61B0BC",display:"flex",justifyContent:"center",alignItems:"center"},children:[q.jsx(mn,{sx:{color:"#61B0BC",textAlign:"center",fontSize:"80px",fontStyle:"normal",fontWeight:400,lineHeight:"32px",textRendering:"geometricPrecision"},children:B}),q.jsx(ft,{sx:{position:"absolute",top:"50%",left:0,transform:"translate(-50%, -50%)",width:"50px",height:"50px",flexShrink:0,backgroundColor:"#fff",border:"1.5px solid #61B0BC",borderRadius:"50%",display:"flex",justifyContent:"center",alignItems:"center",overflow:"hidden"},children:q.jsx(eC,{className:"center",disabled:B===1,sx:{width:"100%",height:"100%"},onClick:()=>B>1&&P(B-1),children:q.jsx("svg",{width:"19",height:"2",viewBox:"0 0 19 2",fill:"none",xmlns:"http://www.w3.org/2000/svg",children:q.jsx("rect",{x:"18.4001",width:"2",height:"18",rx:"1",transform:"rotate(90 18.4001 0)",fill:"#61B0BC"})})})}),q.jsx(ft,{sx:{position:"absolute",top:"50%",right:0,transform:"translate(50%, -50%)",width:"50px",height:"50px",flexShrink:0,backgroundColor:"#fff",border:"1.5px solid #61B0BC",borderRadius:"50%",display:"flex",justifyContent:"center",alignItems:"center",overflow:"hidden"},children:q.jsx(eC,{onClick:()=>B<100&&P(B+1),className:"center",disabled:B===100,sx:{width:"100%",height:"100%"},children:q.jsxs("svg",{width:"19",height:"18",viewBox:"0 0 19 18",fill:"none",xmlns:"http://www.w3.org/2000/svg",children:[q.jsx("rect",{x:"8.40015",width:"2",height:"18",rx:"1",fill:"#61B0BC"}),q.jsx("rect",{x:"18.4001",y:"8",width:"2",height:"18",rx:"1",transform:"rotate(90 18.4001 8)",fill:"#61B0BC"})]})})})]}),q.jsx(mn,{sx:{color:"#616161",textAlign:"center",fontSize:"28px",fontStyle:"normal",lineHeight:"32px",letterSpacing:"1.4px",textTransform:"lowercase",paddingTop:"20px"},children:"Age"})]})]})}),q.jsx(ft,{sx:{display:"flex",justifyContent:"center",alignItems:"center",width:"100%"},children:q.jsx(vc,{onClick:()=>p("SkinType"),children:"Next"})})]}),i==="SkinType"&&q.jsx(ft,{sx:{display:"flex",flexDirection:"column",gap:{xs:"50px",md:"90px"},alignItems:{xs:"center",md:"center"},justifyContent:{xs:"space-between",md:"center"}},children:q.jsx(ft,{sx:{display:"flex",flexDirection:"column",gap:{xs:"20px",md:"50px"},alignItems:{xs:"center",md:"center"},justifyContent:{xs:"center",md:"center"}},children:q.jsxs(ft,{sx:{display:"flex",alignItems:"center",flexDirection:"column",gap:{xs:"30px",md:"100px"}},children:[q.jsx(mn,{sx:Xr.heading,children:"What type of skin do you have?"}),q.jsx(ft,{sx:Xr.inputContainer,children:q.jsx(dC,{row:!0,value:M,onChange:ie=>fe(ie.target.value),sx:{display:"flex",flexDirection:{xs:"row",md:"row"},columnGap:{xs:"30px",md:"60px"},rowGap:{xs:"22px",md:"60px"},justifyContent:{xs:"center",md:"center"},alignItems:{xs:"flex-start",md:"flex-start"}},children:M_.map(([ie,Ie,je,xe,We,Ke])=>q.jsxs(ft,{sx:{width:{xs:"125px",md:"170px"},display:"flex",flexDirection:"column",justifyContent:"flex-start",alignItems:"center",gap:{xs:"20px",md:"40px"}},children:[q.jsx(ft,{sx:{display:"flex",flexDirection:"column",alignItems:"center",flexWrap:"wrap",justifyContent:{xs:"flex-end",md:"flex-end"},width:{xs:"103px",md:"170px"},height:{xs:"118px",md:"205px"},padding:{xs:"4px",md:"4px"},border:M===xe?"3px solid #2F3750":"3px solid #61B0BC",borderColor:Y.skin&&"#d32f2f",borderWidth:Y.skin&&"3px",backgroundImage:`url(${H==="male"?je:Ie})`,backgroundPosition:"center",backgroundSize:"contain",backgroundRepeat:"no-repeat",cursor:"pointer",flexShrink:0,gap:{xs:"18px",md:"28px"},position:"relative"},onClick:()=>fe(xe),children:q.jsx(ft,{sx:{position:{xs:"absolute",md:"absolute"},bottom:{xs:"-12px",md:"-30px"},left:{xs:"-11.5px",md:"-40px"},width:{xs:"23px",md:"80px"},height:{xs:"23px",md:"80px"},backgroundImage:`url(${Ke})`,backgroundSize:"contain",backgroundRepeat:"no-repeat",backgroundPosition:"center",borderRadius:"50%",flexShrink:0,zIndex:2}})}),q.jsx(sC,{value:xe,control:q.jsx(cC,{sx:{display:"none"}}),label:ie,sx:{zIndex:2,colors:"#000",textAlign:"center",fontSize:{xs:"14px",md:"22px"},fontWeight:400,paddingLeft:ie==="Combination"?{xs:"20px",md:"32px"}:0,lineHeight:"32px",margin:0,textTransform:M===xe?"capitalize":"none","& .MuiTypography-root":{fontWeight:400,fontSize:{xs:"14px",md:"17px"}}}}),q.jsx(mn,{sx:{color:"#000",textAlign:"center",fontFamily:"Inter",fontSize:{xs:"12px",md:"20px"},fontStyle:"normal",fontWeight:400,lineHeight:"normal",textEdge:"cap",leadingTrim:"both"},children:We})]},xe))})})]})})}),i==="CaptureUpload"&&q.jsx(ft,{sx:{display:"flex",flexDirection:"column",gap:{xs:"50px",md:"100px"},alignItems:{xs:"center",md:"center"},justifyContent:{xs:"space-between",md:"center"},height:"90vh",padding:"16px"},children:q.jsx(ft,{sx:{display:"flex",flexDirection:"column",gap:{xs:"20px",md:"100px"},alignItems:{xs:"center",md:"center"},justifyContent:{xs:"center",md:"center"}},children:q.jsxs(ft,{sx:{display:"flex",flexDirection:"column",alignItems:"center",gap:{xs:"60px",md:"100px"}},children:[q.jsx(mn,{sx:Xr.heading,children:"Capture or Upload Your Photo For Skin Analysis"}),q.jsxs(ft,{sx:Xr.inputContainer,children:[q.jsx(dC,{row:!0,value:O,sx:{display:"flex",flexDirection:{xs:"column",md:"row"},gap:{xs:"60px",md:"100px"},justifyContent:{xs:"center",md:"flex-start"},alignItems:{xs:"center",md:"flex-start"}},children:D_.map(([ie,Ie,je])=>q.jsxs(ft,{sx:{display:"flex",flexDirection:"column",alignItems:"center",gap:{xs:"8px",md:"20px"}},children:[q.jsx(ft,{sx:{display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",width:{xs:"150px",md:"170px"},height:{xs:"180px",md:"205px"},padding:{xs:"2px",md:"4px"},border:O===je?"1.5px solid #000":"1.5px solid #61B0BC",cursor:"pointer",backgroundSize:"contain",flexShrink:0,gap:{xs:"30px",md:"40px"}},onClick:()=>ye(je),children:q.jsx(ft,{sx:{width:{xs:"90px",md:"90px"},height:{xs:"90px",md:"90px"},backgroundImage:`url(${Ie})`,backgroundSize:"contain",backgroundRepeat:"no-repeat",backgroundPosition:"center",flexShrink:0}})}),q.jsx(sC,{value:je,control:q.jsx(cC,{sx:{display:"none"}}),label:ie,sx:{zIndex:2,color:"#000",textAlign:"center",fontSize:{xs:"14px",md:"28px"},fontWeight:400,lineHeight:"32px",margin:0,textTransform:"capitalize","& .MuiTypography-root":{fontWeight:400,fontSize:{xs:"14px",md:"18px"}}}})]},ie))}),q.jsx("input",{type:"file",accept:"image/*",ref:a,style:{display:"none"},onChange:ie=>Q(ie)})]})]})})})]})};/*! For license information please see orbo-smart-capture.js.LICENSE.txt */(function(a,i){typeof Hn=="object"&&typeof module=="object"?module.exports=i():typeof define=="function"&&define.amd?define([],i):typeof Hn=="object"?Hn.OrboSmartCapture=i():a.OrboSmartCapture=i()})(self,()=>(()=>{var a={392:g=>{var x,k=(x=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0,function(N){var E,z;(N=N||{})||(N=N!==void 0?N:{}),N.ready=new Promise(function(ve,be){E=ve,z=be});var G,j={};for(G in N)N.hasOwnProperty(G)&&(j[G]=N[G]);var M="./this.program",R="";typeof document<"u"&&document.currentScript&&(R=document.currentScript.src),x&&(R=x),R=R.indexOf("blob:")!==0?R.substr(0,R.lastIndexOf("/")+1):"";var B,P,H=N.print||console.log.bind(console),C=N.printErr||console.warn.bind(console);for(G in j)j.hasOwnProperty(G)&&(N[G]=j[G]);j=null,N.arguments&&N.arguments,N.thisProgram&&(M=N.thisProgram),N.quit&&N.quit,N.wasmBinary&&(B=N.wasmBinary),N.noExitRuntime,typeof WebAssembly!="object"&&Wt("no native wasm support detected");var O=!1,F=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function Y(ve,be,Le){for(var at=be+Le,lt=be;ve[lt]&&!(lt>=at);)++lt;if(lt-be>16&&ve.subarray&&F)return F.decode(ve.subarray(be,lt));for(var ct="";be<lt;){var St=ve[be++];if(128&St){var nt=63&ve[be++];if((224&St)!=192){var Ot=63&ve[be++];if((St=(240&St)==224?(15&St)<<12|nt<<6|Ot:(7&St)<<18|nt<<12|Ot<<6|63&ve[be++])<65536)ct+=String.fromCharCode(St);else{var Pt=St-65536;ct+=String.fromCharCode(55296|Pt>>10,56320|1023&Pt)}}else ct+=String.fromCharCode((31&St)<<6|nt)}else ct+=String.fromCharCode(St)}return ct}function ae(ve,be){return ve?Y(Z,ve,be):""}function te(ve,be,Le,at){if(!(at>0))return 0;for(var lt=Le,ct=Le+at-1,St=0;St<ve.length;++St){var nt=ve.charCodeAt(St);if(nt>=55296&&nt<=57343&&(nt=65536+((1023&nt)<<10)|1023&ve.charCodeAt(++St)),nt<=127){if(Le>=ct)break;be[Le++]=nt}else if(nt<=2047){if(Le+1>=ct)break;be[Le++]=192|nt>>6,be[Le++]=128|63&nt}else if(nt<=65535){if(Le+2>=ct)break;be[Le++]=224|nt>>12,be[Le++]=128|nt>>6&63,be[Le++]=128|63&nt}else{if(Le+3>=ct)break;be[Le++]=240|nt>>18,be[Le++]=128|nt>>12&63,be[Le++]=128|nt>>6&63,be[Le++]=128|63&nt}}return be[Le]=0,Le-lt}function oe(ve){for(var be=0,Le=0;Le<ve.length;++Le){var at=ve.charCodeAt(Le);at>=55296&&at<=57343&&(at=65536+((1023&at)<<10)|1023&ve.charCodeAt(++Le)),at<=127?++be:be+=at<=2047?2:at<=65535?3:4}return be}var fe,ue,Z,ye,pe,Q,ke,ie,Ie,je=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0;function xe(ve,be){for(var Le=ve,at=Le>>1,lt=at+be/2;!(at>=lt)&&pe[at];)++at;if((Le=at<<1)-ve>32&&je)return je.decode(Z.subarray(ve,Le));for(var ct="",St=0;!(St>=be/2);++St){var nt=ye[ve+2*St>>1];if(nt==0)break;ct+=String.fromCharCode(nt)}return ct}function We(ve,be,Le){if(Le===void 0&&(Le=2147483647),Le<2)return 0;for(var at=be,lt=(Le-=2)<2*ve.length?Le/2:ve.length,ct=0;ct<lt;++ct){var St=ve.charCodeAt(ct);ye[be>>1]=St,be+=2}return ye[be>>1]=0,be-at}function Ke(ve){return 2*ve.length}function ut(ve,be){for(var Le=0,at="";!(Le>=be/4);){var lt=Q[ve+4*Le>>2];if(lt==0)break;if(++Le,lt>=65536){var ct=lt-65536;at+=String.fromCharCode(55296|ct>>10,56320|1023&ct)}else at+=String.fromCharCode(lt)}return at}function ge(ve,be,Le){if(Le===void 0&&(Le=2147483647),Le<4)return 0;for(var at=be,lt=at+Le-4,ct=0;ct<ve.length;++ct){var St=ve.charCodeAt(ct);if(St>=55296&&St<=57343&&(St=65536+((1023&St)<<10)|1023&ve.charCodeAt(++ct)),Q[be>>2]=St,(be+=4)+4>lt)break}return Q[be>>2]=0,be-at}function Qe(ve){for(var be=0,Le=0;Le<ve.length;++Le){var at=ve.charCodeAt(Le);at>=55296&&at<=57343&&++Le,be+=4}return be}function At(ve){fe=ve,N.HEAP8=ue=new Int8Array(ve),N.HEAP16=ye=new Int16Array(ve),N.HEAP32=Q=new Int32Array(ve),N.HEAPU8=Z=new Uint8Array(ve),N.HEAPU16=pe=new Uint16Array(ve),N.HEAPU32=ke=new Uint32Array(ve),N.HEAPF32=ie=new Float32Array(ve),N.HEAPF64=Ie=new Float64Array(ve)}N.INITIAL_MEMORY;var dt,It=[],Ft=[],pn=[],Yt=[];Ft.push({func:function(){Lr()}});var wt=0,Ht=null;function Wt(ve){N.onAbort&&N.onAbort(ve),C(ve+=""),O=!0,ve="abort("+ve+"). Build with -s ASSERTIONS=1 for more info.";var be=new WebAssembly.RuntimeError(ve);throw z(be),be}function on(ve){return be=ve,Le="data:application/octet-stream;base64,",String.prototype.startsWith?be.startsWith(Le):be.indexOf(Le)===0;var be,Le}N.preloadedImages={},N.preloadedAudios={};var Rt,Mt="orbo-smart-capture.wasm";function Tn(ve){try{if(ve==Mt&&B)return new Uint8Array(B);throw"both async and sync fetching of the wasm failed"}catch(be){Wt(be)}}function Sn(ve){for(;ve.length>0;){var be=ve.shift();if(typeof be!="function"){var Le=be.func;typeof Le=="number"?be.arg===void 0?dt.get(Le)():dt.get(Le)(be.arg):Le(be.arg===void 0?null:be.arg)}else be(N)}}on(Mt)||(Rt=Mt,Mt=N.locateFile?N.locateFile(Rt,R):R+Rt);function J(ve){this.excPtr=ve,this.ptr=ve-16,this.set_type=function(be){Q[this.ptr+8>>2]=be},this.get_type=function(){return Q[this.ptr+8>>2]},this.set_destructor=function(be){Q[this.ptr+0>>2]=be},this.get_destructor=function(){return Q[this.ptr+0>>2]},this.set_refcount=function(be){Q[this.ptr+4>>2]=be},this.set_caught=function(be){be=be?1:0,ue[this.ptr+12|0]=be},this.get_caught=function(){return ue[this.ptr+12|0]!=0},this.set_rethrown=function(be){be=be?1:0,ue[this.ptr+13|0]=be},this.get_rethrown=function(){return ue[this.ptr+13|0]!=0},this.init=function(be,Le){this.set_type(be),this.set_destructor(Le),this.set_refcount(0),this.set_caught(!1),this.set_rethrown(!1)},this.add_ref=function(){var be=Q[this.ptr+4>>2];Q[this.ptr+4>>2]=be+1},this.release_ref=function(){var be=Q[this.ptr+4>>2];return Q[this.ptr+4>>2]=be-1,be===1}}var gn={};function rr(ve){for(;ve.length;){var be=ve.pop();ve.pop()(be)}}function qt(ve){return this.fromWireType(ke[ve>>2])}var Ye={},ht={},Et={};function cn(ve){if(ve===void 0)return"_unknown";var be=(ve=ve.replace(/[^a-zA-Z0-9_]/g,"$")).charCodeAt(0);return be>=48&&be<=57?"_"+ve:ve}function jt(ve,be){return ve=cn(ve),new Function("body","return function "+ve+`() {
    "use strict";    return body.apply(this, arguments);
};
`)(be)}function xn(ve,be){var Le=jt(be,function(at){this.name=be,this.message=at;var lt=new Error(at).stack;lt!==void 0&&(this.stack=this.toString()+`
`+lt.replace(/^Error(:[^\n]*)?\n/,""))});return Le.prototype=Object.create(ve.prototype),Le.prototype.constructor=Le,Le.prototype.toString=function(){return this.message===void 0?this.name:this.name+": "+this.message},Le}var yn=void 0;function pt(ve){throw new yn(ve)}function tt(ve,be,Le){function at(nt){var Ot=Le(nt);Ot.length!==ve.length&&pt("Mismatched type converter count");for(var Pt=0;Pt<ve.length;++Pt)rn(ve[Pt],Ot[Pt])}ve.forEach(function(nt){Et[nt]=be});var lt=new Array(be.length),ct=[],St=0;be.forEach(function(nt,Ot){ht.hasOwnProperty(nt)?lt[Ot]=ht[nt]:(ct.push(nt),Ye.hasOwnProperty(nt)||(Ye[nt]=[]),Ye[nt].push(function(){lt[Ot]=ht[nt],++St===ct.length&&at(lt)}))}),ct.length===0&&at(lt)}function Oe(ve){switch(ve){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new TypeError("Unknown type size: "+ve)}}var Tt=void 0;function nn(ve){for(var be="",Le=ve;Z[Le];)be+=Tt[Z[Le++]];return be}var mt=void 0;function Dt(ve){throw new mt(ve)}function rn(ve,be,Le){if(Le=Le||{},!("argPackAdvance"in be))throw new TypeError("registerType registeredInstance requires argPackAdvance");var at=be.name;if(ve||Dt('type "'+at+'" must have a positive integer typeid pointer'),ht.hasOwnProperty(ve)){if(Le.ignoreDuplicateRegistrations)return;Dt("Cannot register type '"+at+"' twice")}if(ht[ve]=be,delete Et[ve],Ye.hasOwnProperty(ve)){var lt=Ye[ve];delete Ye[ve],lt.forEach(function(ct){ct()})}}var Gn=[],kt=[{},{value:void 0},{value:null},{value:!0},{value:!1}];function Ba(ve){ve>4&&--kt[ve].refcount==0&&(kt[ve]=void 0,Gn.push(ve))}function ba(ve){switch(ve){case void 0:return 1;case null:return 2;case!0:return 3;case!1:return 4;default:var be=Gn.length?Gn.pop():kt.length;return kt[be]={refcount:1,value:ve},be}}function Je(ve){if(ve===null)return"null";var be=typeof ve;return be==="object"||be==="array"||be==="function"?ve.toString():""+ve}function bn(ve,be){switch(be){case 2:return function(Le){return this.fromWireType(ie[Le>>2])};case 3:return function(Le){return this.fromWireType(Ie[Le>>3])};default:throw new TypeError("Unknown float type: "+ve)}}function vr(ve,be){var Le,at,lt,ct=(ve=nn(ve)).indexOf("j")!=-1?(Le=ve,at=be,lt=[],function(){lt.length=arguments.length;for(var St=0;St<arguments.length;St++)lt[St]=arguments[St];return function(nt,Ot,Pt){return nt.indexOf("j")!=-1?function(Bt,Pn,Zn){var Rr=N["dynCall_"+Bt];return Zn&&Zn.length?Rr.apply(null,[Pn].concat(Zn)):Rr.call(null,Pn)}(nt,Ot,Pt):dt.get(Ot).apply(null,Pt)}(Le,at,lt)}):dt.get(be);return typeof ct!="function"&&Dt("unknown function pointer with signature "+ve+": "+be),ct}var kn=void 0;function Mr(ve){var be=sl(ve),Le=nn(be);return na(be),Le}function Ss(ve,be,Le){switch(be){case 0:return Le?function(at){return ue[at]}:function(at){return Z[at]};case 1:return Le?function(at){return ye[at>>1]}:function(at){return pe[at>>1]};case 2:return Le?function(at){return Q[at>>2]}:function(at){return ke[at>>2]};default:throw new TypeError("Unknown integer type: "+ve)}}function Xo(ve){try{return P.grow(ve-fe.byteLength+65535>>>16),At(P.buffer),1}catch{}}var ms={};function is(){if(!is.strings){var ve={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:M||"./this.program"};for(var be in ms)ve[be]=ms[be];var Le=[];for(var be in ve)Le.push(be+"="+ve[be]);is.strings=Le}return is.strings}var Nn={mappings:{},buffers:[null,[],[]],printChar:function(ve,be){var Le=Nn.buffers[ve];be===0||be===10?((ve===1?H:C)(Y(Le,0)),Le.length=0):Le.push(be)},varargs:void 0,get:function(){return Nn.varargs+=4,Q[Nn.varargs-4>>2]},getStr:function(ve){return ae(ve)},get64:function(ve,be){return ve}};function Zr(ve){return ve%4==0&&(ve%100!=0||ve%400==0)}function vo(ve,be){for(var Le=0,at=0;at<=be;Le+=ve[at++]);return Le}var As=[31,29,31,30,31,30,31,31,30,31,30,31],Er=[31,28,31,30,31,30,31,31,30,31,30,31];function mi(ve,be){for(var Le=new Date(ve.getTime());be>0;){var at=Zr(Le.getFullYear()),lt=Le.getMonth(),ct=(at?As:Er)[lt];if(!(be>ct-Le.getDate()))return Le.setDate(Le.getDate()+be),Le;be-=ct-Le.getDate()+1,Le.setDate(1),lt<11?Le.setMonth(lt+1):(Le.setMonth(0),Le.setFullYear(Le.getFullYear()+1))}return Le}yn=N.InternalError=xn(Error,"InternalError"),function(){for(var ve=new Array(256),be=0;be<256;++be)ve[be]=String.fromCharCode(be);Tt=ve}(),mt=N.BindingError=xn(Error,"BindingError"),N.count_emval_handles=function(){for(var ve=0,be=5;be<kt.length;++be)kt[be]!==void 0&&++ve;return ve},N.get_first_emval=function(){for(var ve=5;ve<kt.length;++ve)if(kt[ve]!==void 0)return kt[ve];return null},kn=N.UnboundTypeError=xn(Error,"UnboundTypeError");var st,gi={g:function(ve){return vA(ve+16)+16},f:function(ve,be,Le){throw new J(ve).init(be,Le),ve},q:function(ve){var be=gn[ve];delete gn[ve];var Le=be.rawConstructor,at=be.rawDestructor,lt=be.fields;tt([ve],lt.map(function(ct){return ct.getterReturnType}).concat(lt.map(function(ct){return ct.setterArgumentType})),function(ct){var St={};return lt.forEach(function(nt,Ot){var Pt=nt.fieldName,Bt=ct[Ot],Pn=nt.getter,Zn=nt.getterContext,Rr=ct[Ot+lt.length],$r=nt.setter,gs=nt.setterContext;St[Pt]={read:function(sr){return Bt.fromWireType(Pn(Zn,sr))},write:function(sr,vn){var va=[];$r(gs,sr,Rr.toWireType(va,vn)),rr(va)}}}),[{name:be.name,fromWireType:function(nt){var Ot={};for(var Pt in St)Ot[Pt]=St[Pt].read(nt);return at(nt),Ot},toWireType:function(nt,Ot){for(var Pt in St)if(!(Pt in Ot))throw new TypeError('Missing field:  "'+Pt+'"');var Bt=Le();for(Pt in St)St[Pt].write(Bt,Ot[Pt]);return nt!==null&&nt.push(at,Bt),Bt},argPackAdvance:8,readValueFromPointer:qt,destructorFunction:at}]})},B:function(ve,be,Le,at,lt){var ct=Oe(Le);rn(ve,{name:be=nn(be),fromWireType:function(St){return!!St},toWireType:function(St,nt){return nt?at:lt},argPackAdvance:8,readValueFromPointer:function(St){var nt;if(Le===1)nt=ue;else if(Le===2)nt=ye;else{if(Le!==4)throw new TypeError("Unknown boolean type size: "+be);nt=Q}return this.fromWireType(nt[St>>ct])},destructorFunction:null})},A:function(ve,be){rn(ve,{name:be=nn(be),fromWireType:function(Le){var at=kt[Le].value;return Ba(Le),at},toWireType:function(Le,at){return ba(at)},argPackAdvance:8,readValueFromPointer:qt,destructorFunction:null})},n:function(ve,be,Le){var at=Oe(Le);rn(ve,{name:be=nn(be),fromWireType:function(lt){return lt},toWireType:function(lt,ct){if(typeof ct!="number"&&typeof ct!="boolean")throw new TypeError('Cannot convert "'+Je(ct)+'" to '+this.name);return ct},argPackAdvance:8,readValueFromPointer:bn(be,at),destructorFunction:null})},e:function(ve,be,Le,at,lt,ct){var St=function(nt,Ot){for(var Pt=[],Bt=0;Bt<nt;Bt++)Pt.push(Q[(Ot>>2)+Bt]);return Pt}(be,Le);ve=nn(ve),lt=vr(at,lt),function(nt,Ot,Pt){N.hasOwnProperty(nt)?((Pt===void 0||N[nt].overloadTable!==void 0&&N[nt].overloadTable[Pt]!==void 0)&&Dt("Cannot register public name '"+nt+"' twice"),function(Bt,Pn,Zn){if(Bt[Pn].overloadTable===void 0){var Rr=Bt[Pn];Bt[Pn]=function(){return Bt[Pn].overloadTable.hasOwnProperty(arguments.length)||Dt("Function '"+Zn+"' called with an invalid number of arguments ("+arguments.length+") - expects one of ("+Bt[Pn].overloadTable+")!"),Bt[Pn].overloadTable[arguments.length].apply(this,arguments)},Bt[Pn].overloadTable=[],Bt[Pn].overloadTable[Rr.argCount]=Rr}}(N,nt,nt),N.hasOwnProperty(Pt)&&Dt("Cannot register multiple overloads of a function with the same number of arguments ("+Pt+")!"),N[nt].overloadTable[Pt]=Ot):(N[nt]=Ot,Pt!==void 0&&(N[nt].numArguments=Pt))}(ve,function(){(function(nt,Ot){var Pt=[],Bt={};throw Ot.forEach(function Pn(Zn){Bt[Zn]||ht[Zn]||(Et[Zn]?Et[Zn].forEach(Pn):(Pt.push(Zn),Bt[Zn]=!0))}),new kn(nt+": "+Pt.map(Mr).join([", "]))})("Cannot call "+ve+" due to unbound types",St)},be-1),tt([],St,function(nt){var Ot=[nt[0],null].concat(nt.slice(1));return function(Pt,Bt,Pn){N.hasOwnProperty(Pt)||pt("Replacing nonexistant public symbol"),N[Pt].overloadTable!==void 0&&Pn!==void 0?N[Pt].overloadTable[Pn]=Bt:(N[Pt]=Bt,N[Pt].argCount=Pn)}(ve,function(Pt,Bt,Pn,Zn,Rr){var $r=Bt.length;$r<2&&Dt("argTypes array size mismatch! Must at least get return value and 'this' types!");for(var gs=Bt[1]!==null&&Pn!==null,sr=!1,vn=1;vn<Bt.length;++vn)if(Bt[vn]!==null&&Bt[vn].destructorFunction===void 0){sr=!0;break}var va=Bt[0].name!=="void",Gi="",ra="";for(vn=0;vn<$r-2;++vn)Gi+=(vn!==0?", ":"")+"arg"+vn,ra+=(vn!==0?", ":"")+"arg"+vn+"Wired";var Wr="return function "+cn(Pt)+"("+Gi+`) {
if (arguments.length !== `+($r-2)+`) {
throwBindingError('function `+Pt+" called with ' + arguments.length + ' arguments, expected "+($r-2)+` args!');
}
`;sr&&(Wr+=`var destructors = [];
`);var xa=sr?"destructors":"null",Fa=["throwBindingError","invoker","fn","runDestructors","retType","classParam"],$=[Dt,Zn,Rr,rr,Bt[0],Bt[1]];for(gs&&(Wr+="var thisWired = classParam.toWireType("+xa+`, this);
`),vn=0;vn<$r-2;++vn)Wr+="var arg"+vn+"Wired = argType"+vn+".toWireType("+xa+", arg"+vn+"); // "+Bt[vn+2].name+`
`,Fa.push("argType"+vn),$.push(Bt[vn+2]);if(gs&&(ra="thisWired"+(ra.length>0?", ":"")+ra),Wr+=(va?"var rv = ":"")+"invoker(fn"+(ra.length>0?", ":"")+ra+`);
`,sr)Wr+=`runDestructors(destructors);
`;else for(vn=gs?1:2;vn<Bt.length;++vn){var ne=vn===1?"thisWired":"arg"+(vn-2)+"Wired";Bt[vn].destructorFunction!==null&&(Wr+=ne+"_dtor("+ne+"); // "+Bt[vn].name+`
`,Fa.push(ne+"_dtor"),$.push(Bt[vn].destructorFunction))}return va&&(Wr+=`var ret = retType.fromWireType(rv);
return ret;
`),Wr+=`}
`,Fa.push(Wr),function(Ce,He){if(!(Ce instanceof Function))throw new TypeError("new_ called with constructor type "+typeof Ce+" which is not a function");var _e=jt(Ce.name||"unknownFunctionName",function(){});_e.prototype=Ce.prototype;var $e=new _e,xt=Ce.apply($e,He);return xt instanceof Object?xt:$e}(Function,Fa).apply(null,$)}(ve,Ot,null,lt,ct),be-1),[]})},b:function(ve,be,Le,at,lt){be=nn(be),lt===-1&&(lt=4294967295);var ct=Oe(Le),St=function(Pt){return Pt};if(at===0){var nt=32-8*Le;St=function(Pt){return Pt<<nt>>>nt}}var Ot=be.indexOf("unsigned")!=-1;rn(ve,{name:be,fromWireType:St,toWireType:function(Pt,Bt){if(typeof Bt!="number"&&typeof Bt!="boolean")throw new TypeError('Cannot convert "'+Je(Bt)+'" to '+this.name);if(Bt<at||Bt>lt)throw new TypeError('Passing a number "'+Je(Bt)+'" from JS side to C/C++ side to an argument of type "'+be+'", which is outside the valid range ['+at+", "+lt+"]!");return Ot?Bt>>>0:0|Bt},argPackAdvance:8,readValueFromPointer:Ss(be,ct,at!==0),destructorFunction:null})},a:function(ve,be,Le){var at=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array][be];function lt(ct){var St=ke,nt=St[ct>>=2],Ot=St[ct+1];return new at(fe,Ot,nt)}rn(ve,{name:Le=nn(Le),fromWireType:lt,argPackAdvance:8,readValueFromPointer:lt},{ignoreDuplicateRegistrations:!0})},o:function(ve,be){var Le=(be=nn(be))==="std::string";rn(ve,{name:be,fromWireType:function(at){var lt,ct=ke[at>>2];if(Le)for(var St=at+4,nt=0;nt<=ct;++nt){var Ot=at+4+nt;if(nt==ct||Z[Ot]==0){var Pt=ae(St,Ot-St);lt===void 0?lt=Pt:(lt+="\0",lt+=Pt),St=Ot+1}}else{var Bt=new Array(ct);for(nt=0;nt<ct;++nt)Bt[nt]=String.fromCharCode(Z[at+4+nt]);lt=Bt.join("")}return na(at),lt},toWireType:function(at,lt){lt instanceof ArrayBuffer&&(lt=new Uint8Array(lt));var ct=typeof lt=="string";ct||lt instanceof Uint8Array||lt instanceof Uint8ClampedArray||lt instanceof Int8Array||Dt("Cannot pass non-string to std::string");var St=(Le&&ct?function(){return oe(lt)}:function(){return lt.length})(),nt=vA(4+St+1);if(ke[nt>>2]=St,Le&&ct)te(lt,Z,nt+4,St+1);else if(ct)for(var Ot=0;Ot<St;++Ot){var Pt=lt.charCodeAt(Ot);Pt>255&&(na(nt),Dt("String has UTF-16 code units that do not fit in 8 bits")),Z[nt+4+Ot]=Pt}else for(Ot=0;Ot<St;++Ot)Z[nt+4+Ot]=lt[Ot];return at!==null&&at.push(na,nt),nt},argPackAdvance:8,readValueFromPointer:qt,destructorFunction:function(at){na(at)}})},h:function(ve,be,Le){var at,lt,ct,St,nt;Le=nn(Le),be===2?(at=xe,lt=We,St=Ke,ct=function(){return pe},nt=1):be===4&&(at=ut,lt=ge,St=Qe,ct=function(){return ke},nt=2),rn(ve,{name:Le,fromWireType:function(Ot){for(var Pt,Bt=ke[Ot>>2],Pn=ct(),Zn=Ot+4,Rr=0;Rr<=Bt;++Rr){var $r=Ot+4+Rr*be;if(Rr==Bt||Pn[$r>>nt]==0){var gs=at(Zn,$r-Zn);Pt===void 0?Pt=gs:(Pt+="\0",Pt+=gs),Zn=$r+be}}return na(Ot),Pt},toWireType:function(Ot,Pt){typeof Pt!="string"&&Dt("Cannot pass non-string to C++ string type "+Le);var Bt=St(Pt),Pn=vA(4+Bt+be);return ke[Pn>>2]=Bt>>nt,lt(Pt,Pn+4,Bt+be),Ot!==null&&Ot.push(na,Pn),Pn},argPackAdvance:8,readValueFromPointer:qt,destructorFunction:function(Ot){na(Ot)}})},w:function(ve,be,Le,at,lt,ct){gn[ve]={name:nn(be),rawConstructor:vr(Le,at),rawDestructor:vr(lt,ct),fields:[]}},d:function(ve,be,Le,at,lt,ct,St,nt,Ot,Pt){gn[ve].fields.push({fieldName:nn(be),getterReturnType:Le,getter:vr(at,lt),getterContext:ct,setterArgumentType:St,setter:vr(nt,Ot),setterContext:Pt})},p:function(ve,be){rn(ve,{isVoid:!0,name:be=nn(be),argPackAdvance:0,fromWireType:function(){},toWireType:function(Le,at){}})},j:Ba,k:function(ve){ve>4&&(kt[ve].refcount+=1)},i:function(ve,be){var Le,at;return(at=ht[Le=ve])===void 0&&Dt("_emval_take_value has unknown type "+Mr(Le)),ba((ve=at).readValueFromPointer(be))},m:function(){Wt()},s:function(ve,be,Le){Z.copyWithin(ve,be,be+Le)},c:function(ve){var be,Le=Z.length,at=2147483648;if(ve>at)return!1;for(var lt=1;lt<=4;lt*=2){var ct=Le*(1+.2/lt);if(ct=Math.min(ct,ve+100663296),Xo(Math.min(at,((be=Math.max(ve,ct))%65536>0&&(be+=65536-be%65536),be))))return!0}return!1},u:function(ve,be){var Le=0;return is().forEach(function(at,lt){var ct=be+Le;Q[ve+4*lt>>2]=ct,function(St,nt){for(var Ot=0;Ot<St.length;++Ot)ue[0|nt++]=St.charCodeAt(Ot);ue[0|nt]=0}(at,ct),Le+=at.length+1}),0},v:function(ve,be){var Le=is();Q[ve>>2]=Le.length;var at=0;return Le.forEach(function(lt){at+=lt.length+1}),Q[be>>2]=at,0},z:function(ve){return 0},x:function(ve,be,Le,at){var lt=Nn.getStreamFromFD(ve),ct=Nn.doReadv(lt,be,Le);return Q[at>>2]=ct,0},r:function(ve,be,Le,at,lt){},y:function(ve,be,Le,at){for(var lt=0,ct=0;ct<Le;ct++){for(var St=Q[be+8*ct>>2],nt=Q[be+(8*ct+4)>>2],Ot=0;Ot<nt;Ot++)Nn.printChar(ve,Z[St+Ot]);lt+=nt}return Q[at>>2]=lt,0},l:function(ve){},t:function(ve,be,Le,at){return function(lt,ct,St,nt){var Ot=Q[nt+40>>2],Pt={tm_sec:Q[nt>>2],tm_min:Q[nt+4>>2],tm_hour:Q[nt+8>>2],tm_mday:Q[nt+12>>2],tm_mon:Q[nt+16>>2],tm_year:Q[nt+20>>2],tm_wday:Q[nt+24>>2],tm_yday:Q[nt+28>>2],tm_isdst:Q[nt+32>>2],tm_gmtoff:Q[nt+36>>2],tm_zone:Ot?ae(Ot):""},Bt=ae(St),Pn={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var Zn in Pn)Bt=Bt.replace(new RegExp(Zn,"g"),Pn[Zn]);var Rr=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],$r=["January","February","March","April","May","June","July","August","September","October","November","December"];function gs(ne,Ce,He){for(var _e=typeof ne=="number"?ne.toString():ne||"";_e.length<Ce;)_e=He[0]+_e;return _e}function sr(ne,Ce){return gs(ne,Ce,"0")}function vn(ne,Ce){function He($e){return $e<0?-1:$e>0?1:0}var _e;return(_e=He(ne.getFullYear()-Ce.getFullYear()))===0&&(_e=He(ne.getMonth()-Ce.getMonth()))===0&&(_e=He(ne.getDate()-Ce.getDate())),_e}function va(ne){switch(ne.getDay()){case 0:return new Date(ne.getFullYear()-1,11,29);case 1:return ne;case 2:return new Date(ne.getFullYear(),0,3);case 3:return new Date(ne.getFullYear(),0,2);case 4:return new Date(ne.getFullYear(),0,1);case 5:return new Date(ne.getFullYear()-1,11,31);case 6:return new Date(ne.getFullYear()-1,11,30)}}function Gi(ne){var Ce=mi(new Date(ne.tm_year+1900,0,1),ne.tm_yday),He=new Date(Ce.getFullYear(),0,4),_e=new Date(Ce.getFullYear()+1,0,4),$e=va(He),xt=va(_e);return vn($e,Ce)<=0?vn(xt,Ce)<=0?Ce.getFullYear()+1:Ce.getFullYear():Ce.getFullYear()-1}var ra={"%a":function(ne){return Rr[ne.tm_wday].substring(0,3)},"%A":function(ne){return Rr[ne.tm_wday]},"%b":function(ne){return $r[ne.tm_mon].substring(0,3)},"%B":function(ne){return $r[ne.tm_mon]},"%C":function(ne){return sr((ne.tm_year+1900)/100|0,2)},"%d":function(ne){return sr(ne.tm_mday,2)},"%e":function(ne){return gs(ne.tm_mday,2," ")},"%g":function(ne){return Gi(ne).toString().substring(2)},"%G":function(ne){return Gi(ne)},"%H":function(ne){return sr(ne.tm_hour,2)},"%I":function(ne){var Ce=ne.tm_hour;return Ce==0?Ce=12:Ce>12&&(Ce-=12),sr(Ce,2)},"%j":function(ne){return sr(ne.tm_mday+vo(Zr(ne.tm_year+1900)?As:Er,ne.tm_mon-1),3)},"%m":function(ne){return sr(ne.tm_mon+1,2)},"%M":function(ne){return sr(ne.tm_min,2)},"%n":function(){return`
`},"%p":function(ne){return ne.tm_hour>=0&&ne.tm_hour<12?"AM":"PM"},"%S":function(ne){return sr(ne.tm_sec,2)},"%t":function(){return"	"},"%u":function(ne){return ne.tm_wday||7},"%U":function(ne){var Ce=new Date(ne.tm_year+1900,0,1),He=Ce.getDay()===0?Ce:mi(Ce,7-Ce.getDay()),_e=new Date(ne.tm_year+1900,ne.tm_mon,ne.tm_mday);if(vn(He,_e)<0){var $e=vo(Zr(_e.getFullYear())?As:Er,_e.getMonth()-1)-31,xt=31-He.getDate()+$e+_e.getDate();return sr(Math.ceil(xt/7),2)}return vn(He,Ce)===0?"01":"00"},"%V":function(ne){var Ce,He=new Date(ne.tm_year+1900,0,4),_e=new Date(ne.tm_year+1901,0,4),$e=va(He),xt=va(_e),sn=mi(new Date(ne.tm_year+1900,0,1),ne.tm_yday);return vn(sn,$e)<0?"53":vn(xt,sn)<=0?"01":(Ce=$e.getFullYear()<ne.tm_year+1900?ne.tm_yday+32-$e.getDate():ne.tm_yday+1-$e.getDate(),sr(Math.ceil(Ce/7),2))},"%w":function(ne){return ne.tm_wday},"%W":function(ne){var Ce=new Date(ne.tm_year,0,1),He=Ce.getDay()===1?Ce:mi(Ce,Ce.getDay()===0?1:7-Ce.getDay()+1),_e=new Date(ne.tm_year+1900,ne.tm_mon,ne.tm_mday);if(vn(He,_e)<0){var $e=vo(Zr(_e.getFullYear())?As:Er,_e.getMonth()-1)-31,xt=31-He.getDate()+$e+_e.getDate();return sr(Math.ceil(xt/7),2)}return vn(He,Ce)===0?"01":"00"},"%y":function(ne){return(ne.tm_year+1900).toString().substring(2)},"%Y":function(ne){return ne.tm_year+1900},"%z":function(ne){var Ce=ne.tm_gmtoff,He=Ce>=0;return Ce=(Ce=Math.abs(Ce)/60)/60*100+Ce%60,(He?"+":"-")+("0000"+Ce).slice(-4)},"%Z":function(ne){return ne.tm_zone},"%%":function(){return"%"}};for(var Zn in ra)Bt.indexOf(Zn)>=0&&(Bt=Bt.replace(new RegExp(Zn,"g"),ra[Zn](Pt)));var Wr,xa,Fa,$=(xa=oe(Wr=Bt)+1,te(Wr,Fa=new Array(xa),0,Fa.length),Fa);return $.length>ct?0:(function(ne,Ce){ue.set(ne,Ce)}($,lt),$.length-1)}(ve,be,Le,at)}},Lr=(function(){var ve={a:gi};function be(lt,ct){var St=lt.exports;N.asm=St,At((P=N.asm.C).buffer),dt=N.asm.E,function(){if(wt--,N.monitorRunDependencies&&N.monitorRunDependencies(wt),wt==0&&Ht){var nt=Ht;Ht=null,nt()}}()}function Le(lt){be(lt.instance)}function at(lt){return(B||typeof fetch!="function"?Promise.resolve().then(function(){return Tn(Mt)}):fetch(Mt,{credentials:"same-origin"}).then(function(ct){if(!ct.ok)throw"failed to load wasm binary file at '"+Mt+"'";return ct.arrayBuffer()}).catch(function(){return Tn(Mt)})).then(function(ct){return WebAssembly.instantiate(ct,ve)}).then(lt,function(ct){C("failed to asynchronously prepare wasm: "+ct),Wt(ct)})}if(wt++,N.monitorRunDependencies&&N.monitorRunDependencies(wt),N.instantiateWasm)try{return N.instantiateWasm(ve,be)}catch(lt){return C("Module.instantiateWasm callback failed with error: "+lt),!1}(B||typeof WebAssembly.instantiateStreaming!="function"||on(Mt)||typeof fetch!="function"?at(Le):fetch(Mt,{credentials:"same-origin"}).then(function(lt){return WebAssembly.instantiateStreaming(lt,ve).then(Le,function(ct){return C("wasm streaming compile failed: "+ct),C("falling back to ArrayBuffer instantiation"),at(Le)})})).catch(z)}(),N.___wasm_call_ctors=function(){return(Lr=N.___wasm_call_ctors=N.asm.D).apply(null,arguments)}),vA=N._malloc=function(){return(vA=N._malloc=N.asm.F).apply(null,arguments)},na=N._free=function(){return(na=N._free=N.asm.G).apply(null,arguments)},sl=N.___getTypeName=function(){return(sl=N.___getTypeName=N.asm.H).apply(null,arguments)};function Hi(ve){function be(){st||(st=!0,N.calledRun=!0,O||(Sn(Ft),Sn(pn),E(N),N.onRuntimeInitialized&&N.onRuntimeInitialized(),function(){if(N.postRun)for(typeof N.postRun=="function"&&(N.postRun=[N.postRun]);N.postRun.length;)Le=N.postRun.shift(),Yt.unshift(Le);var Le;Sn(Yt)}()))}wt>0||(function(){if(N.preRun)for(typeof N.preRun=="function"&&(N.preRun=[N.preRun]);N.preRun.length;)Le=N.preRun.shift(),It.unshift(Le);var Le;Sn(It)}(),wt>0||(N.setStatus?(N.setStatus("Running..."),setTimeout(function(){setTimeout(function(){N.setStatus("")},1),be()},1)):be()))}if(N.___embind_register_native_and_builtin_types=function(){return(N.___embind_register_native_and_builtin_types=N.asm.I).apply(null,arguments)},N.dynCall_ji=function(){return(N.dynCall_ji=N.asm.J).apply(null,arguments)},N.dynCall_viijii=function(){return(N.dynCall_viijii=N.asm.K).apply(null,arguments)},N.dynCall_jiji=function(){return(N.dynCall_jiji=N.asm.L).apply(null,arguments)},N.dynCall_iiiiiijj=function(){return(N.dynCall_iiiiiijj=N.asm.M).apply(null,arguments)},N.dynCall_iiiiij=function(){return(N.dynCall_iiiiij=N.asm.N).apply(null,arguments)},N.dynCall_iiiiijj=function(){return(N.dynCall_iiiiijj=N.asm.O).apply(null,arguments)},Ht=function ve(){st||Hi(),st||(Ht=ve)},N.run=Hi,N.preInit)for(typeof N.preInit=="function"&&(N.preInit=[N.preInit]);N.preInit.length>0;)N.preInit.pop()();return Hi(),N.ready});g.exports=k},357:g=>{function x(k,N){const E=document.createElement("canvas");return E.width=k,E.height=N,{canvas:E,ctx:E.getContext("2d")}}g.exports={resizeImage:async function(k,N,E,z){if(!(k&&N&&E&&z))throw new Error("Missing required parameters");const G=await async function(ie){const Ie=new Image,je=URL.createObjectURL(ie);try{return await new Promise((xe,We)=>{Ie.onload=xe,Ie.onerror=()=>We(new Error("Failed to load image")),Ie.src=je}),Ie}finally{URL.revokeObjectURL(je)}}(k),j=z/E,{width:M,height:R}=function(ie,Ie,je,xe){const We=ie[32][0]-ie[0][0],Ke=.4*We;let ut=We+2*Ke,ge=(2*Ke+We)*xe;return ut=Math.min(ut,Ie),ut=Math.max(ut,.3*Ie),ge=Math.min(ge,je),ge=Math.max(ge,.3*je),{width:ut,height:ge}}(N,G.width,G.height,j),{x:B,y:P}=function(ie,Ie,je){const xe=ie[43][0],We=ie.reduce((Ke,ut)=>Ke+ut[1],0)/ie.length;return{x:xe,y:Math.max(.5*Ie,Math.min(We,je-.5*Ie-1))}}(N,R,G.height),{startX:H,startY:C,endX:O,endY:F}=function(ie,Ie,je,xe,We,Ke){const ut=Math.max(0,ie-.5*je),ge=Math.max(0,Ie-.5*xe);return{startX:ut,startY:ge,endX:Math.min(We,ut+je),endY:Math.min(Ke,ge+xe)}}(B,P,M,R,G.width,G.height),{canvas:Y,ctx:ae}=x(O-H,F-C);ae.drawImage(G,H,C,Y.width,Y.height,0,0,Y.width,Y.height);const te=function(ie,Ie,je,xe,We){return ie.map(Ke=>[(Ke[0]-Ie)/xe,(Ke[1]-je)/We])}(N,H,C,Y.width,Y.height),oe=Math.min(z/Y.height,E/Y.width),fe=Math.round(Y.width*oe),ue=Math.round(Y.height*oe),Z=(E-fe)/2,ye=(z-ue)/2,{canvas:pe,ctx:Q}=x(E,z);Q.fillStyle="white",Q.fillRect(0,0,E,z),Q.drawImage(Y,0,0,Y.width,Y.height,Z,ye,fe,ue),te.forEach(ie=>{ie[0]=ie[0]*fe+Z,ie[1]=ie[1]*ue+ye}),Q.fillStyle="red",te.forEach((ie,Ie)=>{Q.beginPath(),Q.arc(ie[0],ie[1],2,0,2*Math.PI),Q.fill()});const ke=function(ie,Ie,je){return ie[0][0]<=0||ie[0][0]<0||ie[32][0]>Ie||ie[16][1]>je||ie[110][1]<0?1:0}(te,E,z);return{image:await new Promise(ie=>{pe.toBlob(ie,"image/png")}),imageData:Q.getImageData(0,0,E,z),landmarks:te,status:ke}}}},417:(g,x,k)=>{var N,E=(N=(N=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(z){function G(){return ge.buffer!=dt&&Sn(ge.buffer),It}function j(){return ge.buffer!=dt&&Sn(ge.buffer),Ft}function M(){return ge.buffer!=dt&&Sn(ge.buffer),pn}function R(){return ge.buffer!=dt&&Sn(ge.buffer),Yt}function B(){return ge.buffer!=dt&&Sn(ge.buffer),wt}var P,H,C=(z=z||{})!==void 0?z:{};C.ready=new Promise(function($,ne){P=$,H=ne});var O,F={};for(O in C)C.hasOwnProperty(O)&&(F[O]=C[O]);var Y,ae,te,oe,fe=function($,ne){throw ne};Y=typeof window=="object",ae=typeof importScripts=="function",te=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",oe=!Y&&!te&&!ae;var ue=C.ENVIRONMENT_IS_PTHREAD||!1;ue&&(dt=C.buffer);var Z,ye,pe,Q,ke,ie="";function Ie($){return C.locateFile?C.locateFile($,ie):ie+$}if(te){var je;ie=ae?k(281).dirname(ie)+"/":"//",Z=function($,ne){return Q||(Q=k(893)),ke||(ke=k(281)),$=ke.normalize($),Q.readFileSync($,ne?null:"utf8")},pe=function($){var ne=Z($,!0);return ne.buffer||(ne=new Uint8Array(ne)),Wt(ne.buffer),ne},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function($){if(!($ instanceof xa))throw $}),process.on("unhandledRejection",xn),fe=function($){process.exit($)},C.inspect=function(){return"[Emscripten Module object]"};try{je=k(556)}catch($){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),$}k.g.Worker=je.Worker}else oe?(typeof read<"u"&&(Z=function($){return read($)}),pe=function($){var ne;return typeof readbuffer=="function"?new Uint8Array(readbuffer($)):(Wt(typeof(ne=read($,"binary"))=="object"),ne)},typeof scriptArgs<"u"&&scriptArgs,typeof quit=="function"&&(fe=function($){quit($)}),typeof print<"u"&&(typeof console>"u"&&(console={}),console.log=print,console.warn=console.error=typeof printErr<"u"?printErr:print)):(Y||ae)&&(ae?ie=self.location.href:typeof document<"u"&&document.currentScript&&(ie=document.currentScript.src),N!==void 0&&N&&(ie=N),ie=ie.indexOf("blob:")!==0?ie.substr(0,ie.lastIndexOf("/")+1):"",te?(Z=function($,ne){return Q||(Q=k(893)),ke||(ke=k(281)),$=ke.normalize($),Q.readFileSync($,ne?null:"utf8")},pe=function($){var ne=Z($,!0);return ne.buffer||(ne=new Uint8Array(ne)),Wt(ne.buffer),ne}):(Z=function($){var ne=new XMLHttpRequest;return ne.open("GET",$,!1),ne.send(null),ne.responseText},ae&&(pe=function($){var ne=new XMLHttpRequest;return ne.open("GET",$,!1),ne.responseType="arraybuffer",ne.send(null),new Uint8Array(ne.response)}),ye=function($,ne,Ce){var He=new XMLHttpRequest;He.open("GET",$,!0),He.responseType="arraybuffer",He.onload=function(){He.status==200||He.status==0&&He.response?ne(He.response):Ce()},He.onerror=Ce,He.send(null)}));te&&typeof performance>"u"&&(k.g.performance=k(244).performance);var xe,We=C.print||console.log.bind(console),Ke=C.printErr||console.warn.bind(console);for(O in F)F.hasOwnProperty(O)&&(C[O]=F[O]);function ut($){ut.shown||(ut.shown={}),ut.shown[$]||(ut.shown[$]=1,Ke($))}F=null,C.arguments&&C.arguments,C.thisProgram&&C.thisProgram,C.quit&&(fe=C.quit),C.wasmBinary&&(xe=C.wasmBinary);var ge,Qe,At=C.noExitRuntime||!0;typeof WebAssembly!="object"&&xn("no native wasm support detected");var dt,It,Ft,pn,Yt,wt,Ht=!1;function Wt($,ne){$||xn("Assertion failed: "+ne)}function on($){var ne=C["_"+$];return Wt(ne,"Cannot call unknown function "+$+", make sure it is exported"),ne}function Rt($,ne,Ce){for(var He=ne+Ce,_e="";!(ne>=He);){var $e=$[ne++];if(!$e)return _e;if(128&$e){var xt=63&$[ne++];if((224&$e)!=192){var sn=63&$[ne++];if(($e=(240&$e)==224?(15&$e)<<12|xt<<6|sn:(7&$e)<<18|xt<<12|sn<<6|63&$[ne++])<65536)_e+=String.fromCharCode($e);else{var Cn=$e-65536;_e+=String.fromCharCode(55296|Cn>>10,56320|1023&Cn)}}else _e+=String.fromCharCode((31&$e)<<6|xt)}else _e+=String.fromCharCode($e)}return _e}function Mt($,ne){return $?Rt(j(),$,ne):""}function Tn($,ne,Ce){return function(He,_e,$e,xt){if(!(xt>0))return 0;for(var sn=$e,Cn=$e+xt-1,ar=0;ar<He.length;++ar){var Jn=He.charCodeAt(ar);if(Jn>=55296&&Jn<=57343&&(Jn=65536+((1023&Jn)<<10)|1023&He.charCodeAt(++ar)),Jn<=127){if($e>=Cn)break;_e[$e++]=Jn}else if(Jn<=2047){if($e+1>=Cn)break;_e[$e++]=192|Jn>>6,_e[$e++]=128|63&Jn}else if(Jn<=65535){if($e+2>=Cn)break;_e[$e++]=224|Jn>>12,_e[$e++]=128|Jn>>6&63,_e[$e++]=128|63&Jn}else{if($e+3>=Cn)break;_e[$e++]=240|Jn>>18,_e[$e++]=128|Jn>>12&63,_e[$e++]=128|Jn>>6&63,_e[$e++]=128|63&Jn}}return _e[$e]=0,$e-sn}($,j(),ne,Ce)}function Sn($){dt=$,C.HEAP8=It=new Int8Array($),C.HEAP16=new Int16Array($),C.HEAP32=pn=new Int32Array($),C.HEAPU8=Ft=new Uint8Array($),C.HEAPU16=new Uint16Array($),C.HEAPU32=Yt=new Uint32Array($),C.HEAPF32=new Float32Array($),C.HEAPF64=wt=new Float64Array($)}var J,gn=C.INITIAL_MEMORY||16777216;if(ue)ge=C.wasmMemory,dt=C.buffer;else if(C.wasmMemory)ge=C.wasmMemory;else if(!((ge=new WebAssembly.Memory({initial:gn/65536,maximum:32768,shared:!0})).buffer instanceof SharedArrayBuffer))throw Ke("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),te&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");ge&&(dt=ge.buffer),gn=dt.byteLength,Sn(dt);var rr=[],qt=[],Ye=[],ht=[];function Et(){ue||mt(qt)}ue||qt.push({func:function(){ve()}});var cn=0,jt=null;function xn($){C.onAbort&&C.onAbort($),ue&&console.error("Pthread aborting at "+new Error().stack),Ke($+=""),Ht=!0,$="abort("+$+"). Build with -s ASSERTIONS=1 for more info.";var ne=new WebAssembly.RuntimeError($);throw H(ne),ne}function yn($,ne){return String.prototype.startsWith?$.startsWith(ne):$.indexOf(ne)===0}function pt($){return yn($,"data:application/octet-stream;base64,")}function tt($){return yn($,"file://")}C.preloadedImages={},C.preloadedAudios={};var Oe="tfjs-backend-wasm-threaded-simd.wasm";function Tt($){try{if($==Oe&&xe)return new Uint8Array(xe);if(pe)return pe($);throw"both async and sync fetching of the wasm failed"}catch(ne){xn(ne)}}pt(Oe)||(Oe=Ie(Oe));var nn={10520:function(){throw"Canceled!"},10538:function($,ne){setTimeout(function(){Bt($,ne)},0)}};function mt($){for(;$.length>0;){var ne=$.shift();if(typeof ne!="function"){var Ce=ne.func;typeof Ce=="number"?ne.arg===void 0?J.get(Ce)():J.get(Ce)(ne.arg):Ce(ne.arg===void 0?null:ne.arg)}else ne(C)}}function Dt($,ne){if($<=0||$>G().length||!0&$||ne<0)return-28;if(ne==0)return 0;ne>=2147483647&&(ne=1/0);var Ce=Atomics.load(M(),Wr>>2),He=0;if(Ce==$&&Atomics.compareExchange(M(),Wr>>2,Ce,0)==Ce&&(He=1,--ne<=0))return 1;var _e=Atomics.notify(M(),$>>2,ne);if(_e>=0)return _e+He;throw"Atomics.notify returned an unexpected value "+_e}function rn($){if(ue)throw"Internal Error! cleanupThread() can only ever be called from main application thread!";if(!$)throw"Internal Error! Null pthread_ptr in cleanupThread!";var ne=kt.pthreads[$];if(ne){M()[$+12>>2]=0;var Ce=ne.worker;kt.returnWorkerToPool(Ce)}}C._emscripten_futex_wake=Dt;var Gn,kt={unusedWorkers:[],runningWorkers:[],initMainThreadBlock:function(){for(var $=0;$<8;++$)kt.allocateUnusedWorker()},initRuntime:function(){for(var $=be(228),ne=0;ne<57;++ne)R()[$/4+ne]=0;M()[$+12>>2]=$;var Ce=$+152;M()[Ce>>2]=Ce;var He=be(512);for(ne=0;ne<128;++ne)R()[He/4+ne]=0;Atomics.store(R(),$+100>>2,He),Atomics.store(R(),$+40>>2,$),$r($,!ae,1),Ot($)},initWorker:function(){},pthreads:{},threadExitHandlers:[],setThreadStatus:function(){},runExitHandlers:function(){for(;kt.threadExitHandlers.length>0;)kt.threadExitHandlers.pop()();ue&&ct()&&St()},runExitHandlersAndDeinitThread:function($,ne){Atomics.store(R(),$+56>>2,1),Atomics.store(R(),$+60>>2,0),kt.runExitHandlers(),Atomics.store(R(),$+4>>2,ne),Atomics.store(R(),$+0>>2,1),Dt($+0,2147483647),$r(0,0,0)},threadExit:function($){var ne=ct();ne&&(kt.runExitHandlersAndDeinitThread(ne,$),ue&&postMessage({cmd:"exit"}))},threadCancel:function(){kt.runExitHandlersAndDeinitThread(ct(),-1),postMessage({cmd:"cancelDone"})},terminateAllThreads:function(){for(var $ in kt.pthreads)(He=kt.pthreads[$])&&He.worker&&kt.returnWorkerToPool(He.worker);kt.pthreads={};for(var ne=0;ne<kt.unusedWorkers.length;++ne)(Ce=kt.unusedWorkers[ne]).terminate();for(kt.unusedWorkers=[],ne=0;ne<kt.runningWorkers.length;++ne){var Ce,He=(Ce=kt.runningWorkers[ne]).pthread;kt.freeThreadData(He),Ce.terminate()}kt.runningWorkers=[]},freeThreadData:function($){if($){if($.threadInfoStruct){var ne=M()[$.threadInfoStruct+100>>2];M()[$.threadInfoStruct+100>>2]=0,Le(ne),Le($.threadInfoStruct)}$.threadInfoStruct=0,$.allocatedOwnStack&&$.stackBase&&Le($.stackBase),$.stackBase=0,$.worker&&($.worker.pthread=null)}},returnWorkerToPool:function($){kt.runWithoutMainThreadQueuedCalls(function(){delete kt.pthreads[$.pthread.threadInfoStruct],kt.unusedWorkers.push($),kt.runningWorkers.splice(kt.runningWorkers.indexOf($),1),kt.freeThreadData($.pthread),$.pthread=void 0})},runWithoutMainThreadQueuedCalls:function($){M()[ra>>2]=0;try{$()}finally{M()[ra>>2]=1}},receiveObjectTransfer:function($){},loadWasmModuleToWorker:function($,ne){$.onmessage=function(Ce){var He=Ce.data,_e=He.cmd;if($.pthread&&(kt.currentProxiedOperationCallerThread=$.pthread.threadInfoStruct),He.targetThread&&He.targetThread!=ct()){var $e=kt.pthreads[He.targetThread];return $e?$e.worker.postMessage(Ce.data,He.transferList):console.error('Internal error! Worker sent a message "'+_e+'" to target pthread '+He.targetThread+", but that thread no longer exists!"),void(kt.currentProxiedOperationCallerThread=void 0)}if(_e==="processQueuedMainThreadWork")nt();else if(_e==="spawnThread")st(Ce.data);else if(_e==="cleanupThread")rn(He.thread);else if(_e==="killThread")(function(xt){if(ue)throw"Internal Error! killThread() can only ever be called from main application thread!";if(!xt)throw"Internal Error! Null pthread_ptr in killThread!";M()[xt+12>>2]=0;var sn=kt.pthreads[xt];sn.worker.terminate(),kt.freeThreadData(sn),kt.runningWorkers.splice(kt.runningWorkers.indexOf(sn.worker),1),sn.worker.pthread=void 0})(He.thread);else if(_e==="cancelThread")(function(xt){if(ue)throw"Internal Error! cancelThread() can only ever be called from main application thread!";if(!xt)throw"Internal Error! Null pthread_ptr in cancelThread!";kt.pthreads[xt].worker.postMessage({cmd:"cancel"})})(He.thread);else if(_e==="loaded")$.loaded=!0,ne&&ne($),$.runPthread&&($.runPthread(),delete $.runPthread);else if(_e==="print")We("Thread "+He.threadId+": "+He.text);else if(_e==="printErr")Ke("Thread "+He.threadId+": "+He.text);else if(_e==="alert")alert("Thread "+He.threadId+": "+He.text);else if(_e==="exit")$.pthread&&Atomics.load(R(),$.pthread.threadInfoStruct+64>>2)&&kt.returnWorkerToPool($);else if(_e==="exitProcess")try{(function(xt){if(ue)throw postMessage({cmd:"exitProcess",returnCode:xt}),new xa(xt);At||(kt.terminateAllThreads(),C.onExit&&C.onExit(xt),Ht=!0),fe(xt,new xa(xt))})(He.returnCode)}catch(xt){if(xt instanceof xa)return;throw xt}else _e==="cancelDone"?kt.returnWorkerToPool($):_e==="objectTransfer"?kt.receiveObjectTransfer(Ce.data):Ce.data.target==="setimmediate"?$.postMessage(Ce.data):Ke("worker sent an unknown command "+_e);kt.currentProxiedOperationCallerThread=void 0},$.onerror=function(Ce){Ke("pthread sent an error! "+Ce.filename+":"+Ce.lineno+": "+Ce.message)},te&&($.on("message",function(Ce){$.onmessage({data:Ce})}),$.on("error",function(Ce){$.onerror(Ce)}),$.on("exit",function(Ce){})),$.postMessage({cmd:"load",urlOrBlob:C.mainScriptUrlOrBlob||N,wasmMemory:ge,wasmModule:Qe})},allocateUnusedWorker:function(){var $=Ie("tfjs-backend-wasm-threaded-simd.worker.js");kt.unusedWorkers.push(new Worker($))},getNewWorker:function(){return kt.unusedWorkers.length==0&&(kt.allocateUnusedWorker(),kt.loadWasmModuleToWorker(kt.unusedWorkers[0])),kt.unusedWorkers.length>0?kt.unusedWorkers.pop():null},busySpinWait:function($){for(var ne=performance.now()+$;performance.now()<ne;);}};function Ba($,ne,Ce){if($<=0||$>G().length||!0&$)return-28;if(Y){if(Atomics.load(M(),$>>2)!=ne)return-6;var He=performance.now(),_e=He+Ce;for(Atomics.exchange(M(),Wr>>2,$);;){if((He=performance.now())>_e)return Atomics.exchange(M(),Wr>>2,0),-73;if(Atomics.exchange(M(),Wr>>2,0)==0)break;if(nt(),Atomics.load(M(),$>>2)!=ne)return-6;Atomics.exchange(M(),Wr>>2,$)}return 0}var $e=Atomics.wait(M(),$>>2,ne,Ce);if($e==="timed-out")return-73;if($e==="not-equal")return-6;if($e==="ok")return 0;throw"Atomics.wait returned an unexpected value "+$e}function ba($,ne){for(var Ce=arguments.length-2,He=gs(),_e=Ce,$e=vn(8*_e),xt=$e>>3,sn=0;sn<Ce;sn++){var Cn=arguments[2+sn];B()[xt+sn]=Cn}var ar=Zn($,_e,$e,ne);return sr(He),ar}C.establishStackSpace=function($,ne){va($,ne),sr($)},C.getNoExitRuntime=function(){return At},C.invokeEntryPoint=function($,ne){return J.get($)(ne)},Gn=te?function(){var $=process.hrtime();return 1e3*$[0]+$[1]/1e6}:ue?function(){return performance.now()-C.__performance_now_clock_drift}:typeof dateNow<"u"?dateNow:function(){return performance.now()};var Je=[],bn=[];function vr($){try{return ge.grow($-dt.byteLength+65535>>>16),Sn(ge.buffer),1}catch{}}var kn={inEventHandler:0,removeAllEventListeners:function(){for(var $=kn.eventHandlers.length-1;$>=0;--$)kn._removeHandler($);kn.eventHandlers=[],kn.deferredCalls=[]},registerRemoveEventListeners:function(){kn.removeEventListenersRegistered||(kn.removeEventListenersRegistered=!0)},deferredCalls:[],deferCall:function($,ne,Ce){function He(xt,sn){if(xt.length!=sn.length)return!1;for(var Cn in xt)if(xt[Cn]!=sn[Cn])return!1;return!0}for(var _e in kn.deferredCalls){var $e=kn.deferredCalls[_e];if($e.targetFunction==$&&He($e.argsList,Ce))return}kn.deferredCalls.push({targetFunction:$,precedence:ne,argsList:Ce}),kn.deferredCalls.sort(function(xt,sn){return xt.precedence<sn.precedence})},removeDeferredCalls:function($){for(var ne=0;ne<kn.deferredCalls.length;++ne)kn.deferredCalls[ne].targetFunction==$&&(kn.deferredCalls.splice(ne,1),--ne)},canPerformEventHandlerRequests:function(){return kn.inEventHandler&&kn.currentEventHandler.allowsDeferredCalls},runDeferredCalls:function(){if(kn.canPerformEventHandlerRequests())for(var $=0;$<kn.deferredCalls.length;++$){var ne=kn.deferredCalls[$];kn.deferredCalls.splice($,1),--$,ne.targetFunction.apply(null,ne.argsList)}},eventHandlers:[],removeAllHandlersOnTarget:function($,ne){for(var Ce=0;Ce<kn.eventHandlers.length;++Ce)kn.eventHandlers[Ce].target!=$||ne&&ne!=kn.eventHandlers[Ce].eventTypeString||kn._removeHandler(Ce--)},_removeHandler:function($){var ne=kn.eventHandlers[$];ne.target.removeEventListener(ne.eventTypeString,ne.eventListenerFunc,ne.useCapture),kn.eventHandlers.splice($,1)},registerOrRemoveHandler:function($){var ne=function(He){++kn.inEventHandler,kn.currentEventHandler=$,kn.runDeferredCalls(),$.handlerFunc(He),kn.runDeferredCalls(),--kn.inEventHandler};if($.callbackfunc)$.eventListenerFunc=ne,$.target.addEventListener($.eventTypeString,ne,$.useCapture),kn.eventHandlers.push($),kn.registerRemoveEventListeners();else for(var Ce=0;Ce<kn.eventHandlers.length;++Ce)kn.eventHandlers[Ce].target==$.target&&kn.eventHandlers[Ce].eventTypeString==$.eventTypeString&&kn._removeHandler(Ce--)},queueEventHandlerOnThread_iiii:function($,ne,Ce,He,_e){var $e=gs(),xt=vn(12);M()[xt>>2]=Ce,M()[xt+4>>2]=He,M()[xt+8>>2]=_e,Rr(0,$,637534208,ne,He,xt),sr($e)},getTargetThreadForEventCallback:function($){switch($){case 1:return 0;case 2:return kt.currentProxiedOperationCallerThread;default:return $}},getNodeNameForTarget:function($){return $?$==window?"#window":$==screen?"#screen":$&&$.nodeName?$.nodeName:"":""},fullscreenEnabled:function(){return document.fullscreenEnabled||document.webkitFullscreenEnabled}},Mr=[0,typeof document<"u"?document:0,typeof window<"u"?window:0];function Ss($){return function(ne){var Ce;return ne=(Ce=ne)>2?Mt(Ce):Ce,Mr[ne]||(typeof document<"u"?document.querySelector(ne):void 0)}($)}function Xo($,ne,Ce){var He=Ss($);if(!He)return-4;if(He.canvasSharedPtr&&(M()[He.canvasSharedPtr>>2]=ne,M()[He.canvasSharedPtr+4>>2]=Ce),!He.offscreenCanvas&&He.controlTransferredOffscreen)return He.canvasSharedPtr?(function(xt,sn,Cn,ar){(function(Jn,Ja,xo,Zo){var xA,Vi,sa,wA=gs(),wo=vn(12),al=0;Ja&&(Vi=function(xc){for(var ol=0,_l=0;_l<xc.length;++_l){var Yo=xc.charCodeAt(_l);Yo>=55296&&Yo<=57343&&(Yo=65536+((1023&Yo)<<10)|1023&xc.charCodeAt(++_l)),Yo<=127?++ol:ol+=Yo<=2047?2:Yo<=65535?3:4}return ol}(xA=Ja)+1,Tn(xA,sa=be(Vi),Vi),al=sa),M()[wo>>2]=al,M()[wo+4>>2]=xo,M()[wo+8>>2]=Zo,Rr(0,Jn,657457152,0,al,wo),sr(wA)})(xt,sn=sn?Mt(sn):"",Cn,ar)}(M()[He.canvasSharedPtr+8>>2],$,ne,Ce),1):-4;He.offscreenCanvas&&(He=He.offscreenCanvas);var _e=!1;if(He.GLctxObject&&He.GLctxObject.GLctx){var $e=He.GLctxObject.GLctx.getParameter(2978);_e=$e[0]===0&&$e[1]===0&&$e[2]===He.width&&$e[3]===He.height}return He.width=ne,He.height=Ce,_e&&He.GLctxObject.GLctx.viewport(0,0,ne,Ce),0}function ms($,ne,Ce){return ue?ba(2,1,$,ne,Ce):Xo($,ne,Ce)}var is,Nn={counter:1,buffers:[],programs:[],framebuffers:[],renderbuffers:[],textures:[],uniforms:[],shaders:[],vaos:[],contexts:{},offscreenCanvases:{},timerQueriesEXT:[],programInfos:{},stringCache:{},unpackAlignment:4,recordError:function($){Nn.lastError||(Nn.lastError=$)},getNewId:function($){for(var ne=Nn.counter++,Ce=$.length;Ce<ne;Ce++)$[Ce]=null;return ne},getSource:function($,ne,Ce,He){for(var _e="",$e=0;$e<ne;++$e){var xt=He?M()[He+4*$e>>2]:-1;_e+=Mt(M()[Ce+4*$e>>2],xt<0?void 0:xt)}return _e},createContext:function($,ne){var Ce=$.getContext("webgl",ne);return Ce?Nn.registerContext(Ce,ne):0},registerContext:function($,ne){var Ce=be(8);M()[Ce+4>>2]=ct();var He={handle:Ce,attributes:ne,version:ne.majorVersion,GLctx:$};return $.canvas&&($.canvas.GLctxObject=He),Nn.contexts[Ce]=He,(ne.enableExtensionsByDefault===void 0||ne.enableExtensionsByDefault)&&Nn.initExtensions(He),Ce},makeContextCurrent:function($){return Nn.currentContext=Nn.contexts[$],C.ctx=is=Nn.currentContext&&Nn.currentContext.GLctx,!($&&!is)},getContext:function($){return Nn.contexts[$]},deleteContext:function($){Nn.currentContext===Nn.contexts[$]&&(Nn.currentContext=null),typeof kn=="object"&&kn.removeAllHandlersOnTarget(Nn.contexts[$].GLctx.canvas),Nn.contexts[$]&&Nn.contexts[$].GLctx.canvas&&(Nn.contexts[$].GLctx.canvas.GLctxObject=void 0),Le(Nn.contexts[$].handle),Nn.contexts[$]=null},initExtensions:function($){if($||($=Nn.currentContext),!$.initExtensionsDone){$.initExtensionsDone=!0;var ne,Ce=$.GLctx;(function(He){var _e=He.getExtension("ANGLE_instanced_arrays");_e&&(He.vertexAttribDivisor=function($e,xt){_e.vertexAttribDivisorANGLE($e,xt)},He.drawArraysInstanced=function($e,xt,sn,Cn){_e.drawArraysInstancedANGLE($e,xt,sn,Cn)},He.drawElementsInstanced=function($e,xt,sn,Cn,ar){_e.drawElementsInstancedANGLE($e,xt,sn,Cn,ar)})})(Ce),function(He){var _e=He.getExtension("OES_vertex_array_object");_e&&(He.createVertexArray=function(){return _e.createVertexArrayOES()},He.deleteVertexArray=function($e){_e.deleteVertexArrayOES($e)},He.bindVertexArray=function($e){_e.bindVertexArrayOES($e)},He.isVertexArray=function($e){return _e.isVertexArrayOES($e)})}(Ce),function(He){var _e=He.getExtension("WEBGL_draw_buffers");_e&&(He.drawBuffers=function($e,xt){_e.drawBuffersWEBGL($e,xt)})}(Ce),Ce.disjointTimerQueryExt=Ce.getExtension("EXT_disjoint_timer_query"),(ne=Ce).multiDrawWebgl=ne.getExtension("WEBGL_multi_draw"),(Ce.getSupportedExtensions()||[]).forEach(function(He){He.indexOf("lose_context")<0&&He.indexOf("debug")<0&&Ce.getExtension(He)})}},populateUniformTable:function($){for(var ne=Nn.programs[$],Ce=Nn.programInfos[$]={uniforms:{},maxUniformLength:0,maxAttributeLength:-1,maxUniformBlockNameLength:-1},He=Ce.uniforms,_e=is.getProgramParameter(ne,35718),$e=0;$e<_e;++$e){var xt=is.getActiveUniform(ne,$e),sn=xt.name;Ce.maxUniformLength=Math.max(Ce.maxUniformLength,sn.length+1),sn.slice(-1)=="]"&&(sn=sn.slice(0,sn.lastIndexOf("[")));var Cn=is.getUniformLocation(ne,sn);if(Cn){var ar=Nn.getNewId(Nn.uniforms);He[sn]=[xt.size,ar],Nn.uniforms[ar]=Cn;for(var Jn=1;Jn<xt.size;++Jn){var Ja=sn+"["+Jn+"]";Cn=is.getUniformLocation(ne,Ja),ar=Nn.getNewId(Nn.uniforms),Nn.uniforms[ar]=Cn}}}}},Zr=["default","low-power","high-performance"],vo={mappings:{},buffers:[null,[],[]],printChar:function($,ne){var Ce=vo.buffers[$];ne===0||ne===10?(($===1?We:Ke)(Rt(Ce,0)),Ce.length=0):Ce.push(ne)},varargs:void 0,get:function(){return vo.varargs+=4,M()[vo.varargs-4>>2]},getStr:function($){return Mt($)},get64:function($,ne){return $}};function As($){return ue?ba(3,1,$):0}function Er($,ne,Ce,He,_e){if(ue)return ba(4,1,$,ne,Ce,He,_e)}function mi($,ne,Ce,He){if(ue)return ba(5,1,$,ne,Ce,He);for(var _e=0,$e=0;$e<Ce;$e++){for(var xt=M()[ne+8*$e>>2],sn=M()[ne+(8*$e+4)>>2],Cn=0;Cn<sn;Cn++)vo.printChar($,j()[xt+Cn]);_e+=sn}return M()[He>>2]=_e,0}function st($){if(ue)throw"Internal Error! spawnThread() can only ever be called from main application thread!";var ne=kt.getNewWorker();if(ne.pthread!==void 0)throw"Internal error!";if(!$.pthread_ptr)throw"Internal error, no pthread ptr!";kt.runningWorkers.push(ne);for(var Ce=be(512),He=0;He<128;++He)M()[Ce+4*He>>2]=0;var _e=$.stackBase+$.stackSize,$e=kt.pthreads[$.pthread_ptr]={worker:ne,stackBase:$.stackBase,stackSize:$.stackSize,allocatedOwnStack:$.allocatedOwnStack,threadInfoStruct:$.pthread_ptr},xt=$e.threadInfoStruct>>2;Atomics.store(R(),xt+16,$.detached),Atomics.store(R(),xt+25,Ce),Atomics.store(R(),xt+10,$e.threadInfoStruct),Atomics.store(R(),xt+20,$.stackSize),Atomics.store(R(),xt+19,_e),Atomics.store(R(),xt+26,$.stackSize),Atomics.store(R(),xt+28,_e),Atomics.store(R(),xt+29,$.detached);var sn=lt()+40;Atomics.store(R(),xt+43,sn),ne.pthread=$e;var Cn={cmd:"run",start_routine:$.startRoutine,arg:$.arg,threadInfoStruct:$.pthread_ptr,stackBase:$.stackBase,stackSize:$.stackSize};ne.runPthread=function(){Cn.time=performance.now(),ne.postMessage(Cn,$.transferList)},ne.loaded&&(ne.runPthread(),delete ne.runPthread)}function gi(){if(ue){var $=ct();if($&&!Atomics.load(R(),$+56>>2)&&Atomics.load(R(),$+0>>2)==2)throw"Canceled!"}}function Lr(){te||ae||ut("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function vA($){if(ue)return ba(6,1,$);switch($){case 30:case 75:return 16384;case 85:return 131072;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:return 200809;case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:case 80:case 81:case 79:return-1;case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 39:return 1e3;case 89:return 700;case 71:return 256;case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:return typeof navigator=="object"&&navigator.hardwareConcurrency||1}return M()[at()>>2]=28,-1}ue||kt.initMainThreadBlock();var na,sl=[null,function($,ne){if(ue)return ba(1,1,$,ne)},ms,As,Er,mi,vA],Hi={e:function($,ne,Ce,He){xn("Assertion failed: "+Mt($)+", at: "+[ne?Mt(ne):"unknown filename",Ce,He?Mt(He):"unknown function"])},r:function($,ne){_main($,ne)},x:function($,ne){if($==ne)postMessage({cmd:"processQueuedMainThreadWork"});else if(ue)postMessage({targetThread:$,cmd:"processThreadQueue"});else{var Ce=kt.pthreads[$],He=Ce&&Ce.worker;if(!He)return;He.postMessage({cmd:"processThreadQueue"})}return 1},b:function(){xn()},y:function($,ne,Ce){var He=function(_e,$e){var xt;for(bn.length=0,$e>>=2;xt=j()[_e++];){var sn=xt<105;sn&&1&$e&&$e++,bn.push(sn?B()[$e++>>1]:M()[$e]),++$e}return bn}(ne,Ce);return nn[$].apply(null,He)},j:function($,ne){},d:Ba,c:Dt,f:Gn,p:function($,ne,Ce){j().copyWithin($,ne,ne+Ce)},A:function(){return te?k(74).cpus().length:navigator.hardwareConcurrency},u:function($,ne,Ce){Je.length=ne;for(var He=Ce>>3,_e=0;_e<ne;_e++)Je[_e]=B()[He+_e];return($<0?nn[-$-1]:sl[$]).apply(null,Je)},q:function($){var ne=j().length;if($<=ne)return!1;var Ce,He=2147483648;if($>He)return!1;for(var _e=1;_e<=4;_e*=2){var $e=ne*(1+.2/_e);if($e=Math.min($e,$+100663296),vr(Math.min(He,((Ce=Math.max($,$e))%65536>0&&(Ce+=65536-Ce%65536),Ce))))return!0}return!1},v:function($,ne,Ce){return Ss($)?Xo($,ne,Ce):ms($,ne,Ce)},i:function($){},s:function($,ne){},w:function($,ne){return Ce=$,He=ne>>2,_e=M()[He+6],$e={alpha:!!M()[He+0],depth:!!M()[He+1],stencil:!!M()[He+2],antialias:!!M()[He+3],premultipliedAlpha:!!M()[He+4],preserveDrawingBuffer:!!M()[He+5],powerPreference:Zr[_e],failIfMajorPerformanceCaveat:!!M()[He+7],majorVersion:M()[He+8],minorVersion:M()[He+9],enableExtensionsByDefault:M()[He+10],explicitSwapControl:M()[He+11],proxyContextToMainThread:M()[He+12],renderViaOffscreenBackBuffer:M()[He+13]},(xt=Ss(Ce))?$e.explicitSwapControl?0:Nn.createContext(xt,$e):0;var Ce,He,_e,$e,xt},l:As,n:Er,g:mi,o:function(){kt.initRuntime()},a:ge||C.wasmMemory,z:function($){var ne=kt.threadExitHandlers.pop();$&&ne()},k:function($,ne){kt.threadExitHandlers.push(function(){J.get($)(ne)})},h:function($,ne,Ce,He){if(typeof SharedArrayBuffer>"u")return Ke("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;if(!$)return Ke("pthread_create called with a null thread pointer!"),28;var _e=[];if(ue&&_e.length===0)return Pn(687865856,$,ne,Ce,He);var $e=0,xt=0,sn=0;ne&&ne!=-1?($e=M()[ne>>2],$e+=81920,xt=M()[ne+8>>2],sn=M()[ne+12>>2]!==0):$e=2097152;var Cn=xt==0;Cn?xt=Gi(16,$e):Wt((xt-=$e)>0);for(var ar=be(228),Jn=0;Jn<57;++Jn)R()[(ar>>2)+Jn]=0;M()[$>>2]=ar,M()[ar+12>>2]=ar;var Ja=ar+152;M()[Ja>>2]=Ja;var xo={stackBase:xt,stackSize:$e,allocatedOwnStack:Cn,detached:sn,startRoutine:Ce,pthread_ptr:ar,arg:He,transferList:_e};return ue?(xo.cmd="spawnThread",postMessage(xo,_e)):st(xo),0},m:function($,ne){return function(Ce,He){if(!Ce)return Ke("pthread_join attempted on a null thread pointer!"),71;if(ue&&ct()==Ce)return Ke("PThread "+Ce+" is attempting to join to itself!"),16;if(!ue&&Pt()==Ce)return Ke("Main thread "+Ce+" is attempting to join to itself!"),16;if(M()[Ce+12>>2]!==Ce)return Ke("pthread_join attempted on thread "+Ce+", which does not point to a valid thread, or does not exist anymore!"),71;if(Atomics.load(R(),Ce+64>>2))return Ke("Attempted to join thread "+Ce+", which was already detached!"),28;for(Lr();;){var _e=Atomics.load(R(),Ce+0>>2);if(_e==1){var $e=Atomics.load(R(),Ce+4>>2);return He&&(M()[He>>2]=$e),Atomics.store(R(),Ce+64>>2,1),ue?postMessage({cmd:"cleanupThread",thread:Ce}):rn(Ce),0}gi(),ue||nt(),Ba(Ce+0,_e,ue?100:1)}}($,ne)},t:vA},ve=(function(){var $={a:Hi};function ne(_e,$e){var xt=_e.exports;if(C.asm=xt,J=C.asm.I,Qe=$e,!ue){var sn=kt.unusedWorkers.length;kt.unusedWorkers.forEach(function(Cn){kt.loadWasmModuleToWorker(Cn,function(){--sn||function(){if(cn--,C.monitorRunDependencies&&C.monitorRunDependencies(cn),cn==0&&jt){var ar=jt;jt=null,ar()}}()})})}}function Ce(_e){ne(_e.instance,_e.module)}function He(_e){return function(){if(!xe&&(Y||ae)){if(typeof fetch=="function"&&!tt(Oe))return fetch(Oe,{credentials:"same-origin"}).then(function($e){if(!$e.ok)throw"failed to load wasm binary file at '"+Oe+"'";return $e.arrayBuffer()}).catch(function(){return Tt(Oe)});if(ye)return new Promise(function($e,xt){ye(Oe,function(sn){$e(new Uint8Array(sn))},xt)})}return Promise.resolve().then(function(){return Tt(Oe)})}().then(function($e){return WebAssembly.instantiate($e,$)}).then(_e,function($e){Ke("failed to asynchronously prepare wasm: "+$e),xn($e)})}if(ue||(Wt(!ue,"addRunDependency cannot be used in a pthread worker"),cn++,C.monitorRunDependencies&&C.monitorRunDependencies(cn)),C.instantiateWasm)try{return C.instantiateWasm($,ne)}catch(_e){return Ke("Module.instantiateWasm callback failed with error: "+_e),!1}(xe||typeof WebAssembly.instantiateStreaming!="function"||pt(Oe)||tt(Oe)||typeof fetch!="function"?He(Ce):fetch(Oe,{credentials:"same-origin"}).then(function(_e){return WebAssembly.instantiateStreaming(_e,$).then(Ce,function($e){return Ke("wasm streaming compile failed: "+$e),Ke("falling back to ArrayBuffer instantiation"),He(Ce)})})).catch(H)}(),C.___wasm_call_ctors=function(){return(ve=C.___wasm_call_ctors=C.asm.B).apply(null,arguments)}),be=(C._init=function(){return(C._init=C.asm.C).apply(null,arguments)},C._init_with_threads_count=function(){return(C._init_with_threads_count=C.asm.D).apply(null,arguments)},C._get_threads_count=function(){return(C._get_threads_count=C.asm.E).apply(null,arguments)},C._register_tensor=function(){return(C._register_tensor=C.asm.F).apply(null,arguments)},C._dispose_data=function(){return(C._dispose_data=C.asm.G).apply(null,arguments)},C._dispose=function(){return(C._dispose=C.asm.H).apply(null,arguments)},C._Abs=function(){return(C._Abs=C.asm.J).apply(null,arguments)},C._Add=function(){return(C._Add=C.asm.K).apply(null,arguments)},C._AddN=function(){return(C._AddN=C.asm.L).apply(null,arguments)},C._All=function(){return(C._All=C.asm.M).apply(null,arguments)},C._Any=function(){return(C._Any=C.asm.N).apply(null,arguments)},C._ArgMax=function(){return(C._ArgMax=C.asm.O).apply(null,arguments)},C._AvgPool=function(){return(C._AvgPool=C.asm.P).apply(null,arguments)},C._BatchMatMul=function(){return(C._BatchMatMul=C.asm.Q).apply(null,arguments)},C._Ceil=function(){return(C._Ceil=C.asm.R).apply(null,arguments)},C._ClipByValue=function(){return(C._ClipByValue=C.asm.S).apply(null,arguments)},C._Conv2D=function(){return(C._Conv2D=C.asm.T).apply(null,arguments)},C._Conv2DBackpropInput=function(){return(C._Conv2DBackpropInput=C.asm.U).apply(null,arguments)},C._Cos=function(){return(C._Cos=C.asm.V).apply(null,arguments)},C._Cosh=function(){return(C._Cosh=C.asm.W).apply(null,arguments)},C._CropAndResize=function(){return(C._CropAndResize=C.asm.X).apply(null,arguments)},C._Cumsum=function(){return(C._Cumsum=C.asm.Y).apply(null,arguments)},C._DepthToSpace=function(){return(C._DepthToSpace=C.asm.Z).apply(null,arguments)},C._DepthwiseConv2dNative=function(){return(C._DepthwiseConv2dNative=C.asm._).apply(null,arguments)},C._Elu=function(){return(C._Elu=C.asm.$).apply(null,arguments)},C._Equal=function(){return(C._Equal=C.asm.aa).apply(null,arguments)},C._Exp=function(){return(C._Exp=C.asm.ba).apply(null,arguments)},C._FlipLeftRight=function(){return(C._FlipLeftRight=C.asm.ca).apply(null,arguments)},C._Floor=function(){return(C._Floor=C.asm.da).apply(null,arguments)},C._FloorDiv=function(){return(C._FloorDiv=C.asm.ea).apply(null,arguments)},C._FusedBatchNorm=function(){return(C._FusedBatchNorm=C.asm.fa).apply(null,arguments)},C._FusedConv2D=function(){return(C._FusedConv2D=C.asm.ga).apply(null,arguments)},C._FusedDepthwiseConv2D=function(){return(C._FusedDepthwiseConv2D=C.asm.ha).apply(null,arguments)},C._Gather=function(){return(C._Gather=C.asm.ia).apply(null,arguments)},C._GatherNd=function(){return(C._GatherNd=C.asm.ja).apply(null,arguments)},C._Greater=function(){return(C._Greater=C.asm.ka).apply(null,arguments)},C._GreaterEqual=function(){return(C._GreaterEqual=C.asm.la).apply(null,arguments)},C._LeakyRelu=function(){return(C._LeakyRelu=C.asm.ma).apply(null,arguments)},C._Less=function(){return(C._Less=C.asm.na).apply(null,arguments)},C._LessEqual=function(){return(C._LessEqual=C.asm.oa).apply(null,arguments)},C._Log=function(){return(C._Log=C.asm.pa).apply(null,arguments)},C._LogicalAnd=function(){return(C._LogicalAnd=C.asm.qa).apply(null,arguments)},C._Max=function(){return(C._Max=C.asm.ra).apply(null,arguments)},C._MaxPool=function(){return(C._MaxPool=C.asm.sa).apply(null,arguments)},C._Maximum=function(){return(C._Maximum=C.asm.ta).apply(null,arguments)},C._Mean=function(){return(C._Mean=C.asm.ua).apply(null,arguments)},C._Min=function(){return(C._Min=C.asm.va).apply(null,arguments)},C._Minimum=function(){return(C._Minimum=C.asm.wa).apply(null,arguments)},C._MirrorPad=function(){return(C._MirrorPad=C.asm.xa).apply(null,arguments)},C._Multiply=function(){return(C._Multiply=C.asm.ya).apply(null,arguments)},C._Neg=function(){return(C._Neg=C.asm.za).apply(null,arguments)},C._NonMaxSuppressionV3=function(){return(C._NonMaxSuppressionV3=C.asm.Aa).apply(null,arguments)},C._NonMaxSuppressionV4=function(){return(C._NonMaxSuppressionV4=C.asm.Ba).apply(null,arguments)},C._NonMaxSuppressionV5=function(){return(C._NonMaxSuppressionV5=C.asm.Ca).apply(null,arguments)},C._NotEqual=function(){return(C._NotEqual=C.asm.Da).apply(null,arguments)},C._OneHot=function(){return(C._OneHot=C.asm.Ea).apply(null,arguments)},C._PadV2=function(){return(C._PadV2=C.asm.Fa).apply(null,arguments)},C._Pow=function(){return(C._Pow=C.asm.Ga).apply(null,arguments)},C._Prelu=function(){return(C._Prelu=C.asm.Ha).apply(null,arguments)},C._Prod=function(){return(C._Prod=C.asm.Ia).apply(null,arguments)},C._RealDiv=function(){return(C._RealDiv=C.asm.Ja).apply(null,arguments)},C._Relu=function(){return(C._Relu=C.asm.Ka).apply(null,arguments)},C._Relu6=function(){return(C._Relu6=C.asm.La).apply(null,arguments)},C._ResizeBilinear=function(){return(C._ResizeBilinear=C.asm.Ma).apply(null,arguments)},C._Reverse=function(){return(C._Reverse=C.asm.Na).apply(null,arguments)},C._RotateWithOffset=function(){return(C._RotateWithOffset=C.asm.Oa).apply(null,arguments)},C._Round=function(){return(C._Round=C.asm.Pa).apply(null,arguments)},C._Rsqrt=function(){return(C._Rsqrt=C.asm.Qa).apply(null,arguments)},C._ScatterNd=function(){return(C._ScatterNd=C.asm.Ra).apply(null,arguments)},C._SelectV2=function(){return(C._SelectV2=C.asm.Sa).apply(null,arguments)},C._Sigmoid=function(){return(C._Sigmoid=C.asm.Ta).apply(null,arguments)},C._Sin=function(){return(C._Sin=C.asm.Ua).apply(null,arguments)},C._Softmax=function(){return(C._Softmax=C.asm.Va).apply(null,arguments)},C._Sqrt=function(){return(C._Sqrt=C.asm.Wa).apply(null,arguments)},C._Square=function(){return(C._Square=C.asm.Xa).apply(null,arguments)},C._SquaredDifference=function(){return(C._SquaredDifference=C.asm.Ya).apply(null,arguments)},C._Step=function(){return(C._Step=C.asm.Za).apply(null,arguments)},C._StridedSlice=function(){return(C._StridedSlice=C.asm._a).apply(null,arguments)},C._Sub=function(){return(C._Sub=C.asm.$a).apply(null,arguments)},C._Sum=function(){return(C._Sum=C.asm.ab).apply(null,arguments)},C._Tan=function(){return(C._Tan=C.asm.bb).apply(null,arguments)},C._Tanh=function(){return(C._Tanh=C.asm.cb).apply(null,arguments)},C._Tile=function(){return(C._Tile=C.asm.db).apply(null,arguments)},C._TopK=function(){return(C._TopK=C.asm.eb).apply(null,arguments)},C._Transform=function(){return(C._Transform=C.asm.fb).apply(null,arguments)},C._Transpose=function(){return(C._Transpose=C.asm.gb).apply(null,arguments)},C.__FusedMatMul=function(){return(C.__FusedMatMul=C.asm.hb).apply(null,arguments)},C._malloc=function(){return(be=C._malloc=C.asm.ib).apply(null,arguments)}),Le=C._free=function(){return(Le=C._free=C.asm.jb).apply(null,arguments)},at=C.___errno_location=function(){return(at=C.___errno_location=C.asm.kb).apply(null,arguments)},lt=C._emscripten_get_global_libc=function(){return(lt=C._emscripten_get_global_libc=C.asm.lb).apply(null,arguments)},ct=C._pthread_self=function(){return(ct=C._pthread_self=C.asm.mb).apply(null,arguments)},St=C.___pthread_tsd_run_dtors=function(){return(St=C.___pthread_tsd_run_dtors=C.asm.nb).apply(null,arguments)},nt=C._emscripten_main_thread_process_queued_calls=function(){return(nt=C._emscripten_main_thread_process_queued_calls=C.asm.ob).apply(null,arguments)},Ot=(C._emscripten_current_thread_process_queued_calls=function(){return(C._emscripten_current_thread_process_queued_calls=C.asm.pb).apply(null,arguments)},C._emscripten_register_main_browser_thread_id=function(){return(Ot=C._emscripten_register_main_browser_thread_id=C.asm.qb).apply(null,arguments)}),Pt=C._emscripten_main_browser_thread_id=function(){return(Pt=C._emscripten_main_browser_thread_id=C.asm.rb).apply(null,arguments)},Bt=C.__emscripten_do_dispatch_to_thread=function(){return(Bt=C.__emscripten_do_dispatch_to_thread=C.asm.sb).apply(null,arguments)},Pn=C._emscripten_sync_run_in_main_thread_4=function(){return(Pn=C._emscripten_sync_run_in_main_thread_4=C.asm.tb).apply(null,arguments)},Zn=C._emscripten_run_in_main_runtime_thread_js=function(){return(Zn=C._emscripten_run_in_main_runtime_thread_js=C.asm.ub).apply(null,arguments)},Rr=C.__emscripten_call_on_thread=function(){return(Rr=C.__emscripten_call_on_thread=C.asm.vb).apply(null,arguments)},$r=(C._emscripten_tls_init=function(){return(C._emscripten_tls_init=C.asm.wb).apply(null,arguments)},C.__emscripten_thread_init=function(){return($r=C.__emscripten_thread_init=C.asm.xb).apply(null,arguments)}),gs=C.stackSave=function(){return(gs=C.stackSave=C.asm.yb).apply(null,arguments)},sr=C.stackRestore=function(){return(sr=C.stackRestore=C.asm.zb).apply(null,arguments)},vn=C.stackAlloc=function(){return(vn=C.stackAlloc=C.asm.Ab).apply(null,arguments)},va=C._emscripten_stack_set_limits=function(){return(va=C._emscripten_stack_set_limits=C.asm.Bb).apply(null,arguments)},Gi=C._memalign=function(){return(Gi=C._memalign=C.asm.Cb).apply(null,arguments)},ra=C.__emscripten_allow_main_runtime_queued_calls=10512,Wr=C.__emscripten_main_thread_futex=12148;function xa($){this.name="ExitStatus",this.message="Program terminated with exit("+$+")",this.status=$}function Fa($){if(!(cn>0)){if(ue)return P(C),Et(),void postMessage({cmd:"loaded"});(function(){if(!ue){if(C.preRun)for(typeof C.preRun=="function"&&(C.preRun=[C.preRun]);C.preRun.length;)Ce=C.preRun.shift(),rr.unshift(Ce);var Ce;mt(rr)}})(),cn>0||(C.setStatus?(C.setStatus("Running..."),setTimeout(function(){setTimeout(function(){C.setStatus("")},1),ne()},1)):ne())}function ne(){na||(na=!0,C.calledRun=!0,Ht||(Et(),ue||mt(Ye),P(C),C.onRuntimeInitialized&&C.onRuntimeInitialized(),function(){if(!ue){if(C.postRun)for(typeof C.postRun=="function"&&(C.postRun=[C.postRun]);C.postRun.length;)Ce=C.postRun.shift(),ht.unshift(Ce);var Ce;mt(ht)}}()))}}if(C.cwrap=function($,ne,Ce,He){var _e=(Ce=Ce||[]).every(function($e){return $e==="number"});return ne!=="string"&&_e&&!He?on($):function(){return function($e,xt,sn,Cn){var ar={string:function(sa){var wA=0;if(sa!=null&&sa!==0){var wo=1+(sa.length<<2);Tn(sa,wA=vn(wo),wo)}return wA},array:function(sa){var wA=vn(sa.length);return function(wo,al){G().set(wo,al)}(sa,wA),wA}},Jn=on($e),Ja=[],xo=0;if(Cn)for(var Zo=0;Zo<Cn.length;Zo++){var xA=ar[sn[Zo]];xA?(xo===0&&(xo=gs()),Ja[Zo]=xA(Cn[Zo])):Ja[Zo]=Cn[Zo]}var Vi=Jn.apply(null,Ja);return Vi=function(sa){return xt==="string"?Mt(sa):xt==="boolean"?!!sa:sa}(Vi),xo!==0&&sr(xo),Vi}($,ne,Ce,arguments)}},C.PThread=kt,C.PThread=kt,C.wasmMemory=ge,C.ExitStatus=xa,jt=function $(){na||Fa(),na||(jt=$)},C.run=Fa,C.preInit)for(typeof C.preInit=="function"&&(C.preInit=[C.preInit]);C.preInit.length>0;)C.preInit.pop()();return ue&&(At=!1,kt.initWorker()),Fa(),z.ready});g.exports=E},805:(g,x,k)=>{var N,E=(N=(N=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(z){var G,j,M=(z=z||{})!==void 0?z:{};M.ready=new Promise(function(tt,Oe){G=tt,j=Oe});var R,B={};for(R in M)M.hasOwnProperty(R)&&(B[R]=M[R]);var P,H,C,O;P=typeof window=="object",H=typeof importScripts=="function",C=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",O=!P&&!C&&!H;var F,Y,ae,te,oe,fe="";C?(fe=H?k(281).dirname(fe)+"/":"//",F=function(tt,Oe){return te||(te=k(893)),oe||(oe=k(281)),tt=oe.normalize(tt),te.readFileSync(tt,Oe?null:"utf8")},ae=function(tt){var Oe=F(tt,!0);return Oe.buffer||(Oe=new Uint8Array(Oe)),ke(Oe.buffer),Oe},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(tt){if(!(tt instanceof yn))throw tt}),process.on("unhandledRejection",Ht),M.inspect=function(){return"[Emscripten Module object]"}):O?(typeof read<"u"&&(F=function(tt){return read(tt)}),ae=function(tt){var Oe;return typeof readbuffer=="function"?new Uint8Array(readbuffer(tt)):(ke(typeof(Oe=read(tt,"binary"))=="object"),Oe)},typeof scriptArgs<"u"&&scriptArgs,typeof print<"u"&&(typeof console>"u"&&(console={}),console.log=print,console.warn=console.error=typeof printErr<"u"?printErr:print)):(P||H)&&(H?fe=self.location.href:typeof document<"u"&&document.currentScript&&(fe=document.currentScript.src),N&&(fe=N),fe=fe.indexOf("blob:")!==0?fe.substr(0,fe.lastIndexOf("/")+1):"",F=function(tt){var Oe=new XMLHttpRequest;return Oe.open("GET",tt,!1),Oe.send(null),Oe.responseText},H&&(ae=function(tt){var Oe=new XMLHttpRequest;return Oe.open("GET",tt,!1),Oe.responseType="arraybuffer",Oe.send(null),new Uint8Array(Oe.response)}),Y=function(tt,Oe,Tt){var nn=new XMLHttpRequest;nn.open("GET",tt,!0),nn.responseType="arraybuffer",nn.onload=function(){nn.status==200||nn.status==0&&nn.response?Oe(nn.response):Tt()},nn.onerror=Tt,nn.send(null)});var ue,Z,ye=M.print||console.log.bind(console),pe=M.printErr||console.warn.bind(console);for(R in B)B.hasOwnProperty(R)&&(M[R]=B[R]);B=null,M.arguments&&M.arguments,M.thisProgram&&M.thisProgram,M.quit&&M.quit,M.wasmBinary&&(ue=M.wasmBinary),M.noExitRuntime,typeof WebAssembly!="object"&&Ht("no native wasm support detected");var Q=!1;function ke(tt,Oe){tt||Ht("Assertion failed: "+Oe)}function ie(tt){var Oe=M["_"+tt];return ke(Oe,"Cannot call unknown function "+tt+", make sure it is exported"),Oe}var Ie,je,xe,We,Ke=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function ut(tt,Oe,Tt){for(var nn=Oe+Tt,mt=Oe;tt[mt]&&!(mt>=nn);)++mt;if(mt-Oe>16&&tt.subarray&&Ke)return Ke.decode(tt.subarray(Oe,mt));for(var Dt="";Oe<mt;){var rn=tt[Oe++];if(128&rn){var Gn=63&tt[Oe++];if((224&rn)!=192){var kt=63&tt[Oe++];if((rn=(240&rn)==224?(15&rn)<<12|Gn<<6|kt:(7&rn)<<18|Gn<<12|kt<<6|63&tt[Oe++])<65536)Dt+=String.fromCharCode(rn);else{var Ba=rn-65536;Dt+=String.fromCharCode(55296|Ba>>10,56320|1023&Ba)}}else Dt+=String.fromCharCode((31&rn)<<6|Gn)}else Dt+=String.fromCharCode(rn)}return Dt}function ge(tt,Oe){return tt?ut(xe,tt,Oe):""}function Qe(tt){Ie=tt,M.HEAP8=je=new Int8Array(tt),M.HEAP16=new Int16Array(tt),M.HEAP32=We=new Int32Array(tt),M.HEAPU8=xe=new Uint8Array(tt),M.HEAPU16=new Uint16Array(tt),M.HEAPU32=new Uint32Array(tt),M.HEAPF32=new Float32Array(tt),M.HEAPF64=new Float64Array(tt)}M.INITIAL_MEMORY;var At,dt=[],It=[],Ft=[],pn=[];It.push({func:function(){ht()}});var Yt=0,wt=null;function Ht(tt){M.onAbort&&M.onAbort(tt),pe(tt+=""),Q=!0,tt="abort("+tt+"). Build with -s ASSERTIONS=1 for more info.";var Oe=new WebAssembly.RuntimeError(tt);throw j(Oe),Oe}function Wt(tt,Oe){return String.prototype.startsWith?tt.startsWith(Oe):tt.indexOf(Oe)===0}function on(tt){return Wt(tt,"data:application/octet-stream;base64,")}function Rt(tt){return Wt(tt,"file://")}M.preloadedImages={},M.preloadedAudios={};var Mt,Tn="tfjs-backend-wasm.wasm";function Sn(tt){try{if(tt==Tn&&ue)return new Uint8Array(ue);if(ae)return ae(tt);throw"both async and sync fetching of the wasm failed"}catch(Oe){Ht(Oe)}}function J(tt){for(;tt.length>0;){var Oe=tt.shift();if(typeof Oe!="function"){var Tt=Oe.func;typeof Tt=="number"?Oe.arg===void 0?At.get(Tt)():At.get(Tt)(Oe.arg):Tt(Oe.arg===void 0?null:Oe.arg)}else Oe(M)}}function gn(tt){try{return Z.grow(tt-Ie.byteLength+65535>>>16),Qe(Z.buffer),1}catch{}}on(Tn)||(Mt=Tn,Tn=M.locateFile?M.locateFile(Mt,fe):fe+Mt);var rr,qt={mappings:{},buffers:[null,[],[]],printChar:function(tt,Oe){var Tt=qt.buffers[tt];Oe===0||Oe===10?((tt===1?ye:pe)(ut(Tt,0)),Tt.length=0):Tt.push(Oe)},varargs:void 0,get:function(){return qt.varargs+=4,We[qt.varargs-4>>2]},getStr:function(tt){return ge(tt)},get64:function(tt,Oe){return tt}},Ye={a:function(){Ht()},d:function(tt,Oe,Tt){xe.copyWithin(tt,Oe,Oe+Tt)},e:function(tt){var Oe,Tt=xe.length,nn=2147483648;if(tt>nn)return!1;for(var mt=1;mt<=4;mt*=2){var Dt=Tt*(1+.2/mt);if(Dt=Math.min(Dt,tt+100663296),gn(Math.min(nn,((Oe=Math.max(tt,Dt))%65536>0&&(Oe+=65536-Oe%65536),Oe))))return!0}return!1},f:function(tt){return 0},c:function(tt,Oe,Tt,nn,mt){},b:function(tt,Oe,Tt,nn){for(var mt=0,Dt=0;Dt<Tt;Dt++){for(var rn=We[Oe+8*Dt>>2],Gn=We[Oe+(8*Dt+4)>>2],kt=0;kt<Gn;kt++)qt.printChar(tt,xe[rn+kt]);mt+=Gn}return We[nn>>2]=mt,0},h:function(){return 6},g:function(){return 28},i:function(tt){switch(tt){case 30:case 75:return 16384;case 85:return 131072;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:return 200809;case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:case 80:case 81:case 79:return-1;case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 39:return 1e3;case 89:return 700;case 71:return 256;case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:return typeof navigator=="object"&&navigator.hardwareConcurrency||1}return We[Et()>>2]=28,-1}},ht=(function(){var tt={a:Ye};function Oe(mt,Dt){var rn=mt.exports;M.asm=rn,Qe((Z=M.asm.j).buffer),At=M.asm.r,function(){if(Yt--,M.monitorRunDependencies&&M.monitorRunDependencies(Yt),Yt==0&&wt){var Gn=wt;wt=null,Gn()}}()}function Tt(mt){Oe(mt.instance)}function nn(mt){return function(){if(!ue&&(P||H)){if(typeof fetch=="function"&&!Rt(Tn))return fetch(Tn,{credentials:"same-origin"}).then(function(Dt){if(!Dt.ok)throw"failed to load wasm binary file at '"+Tn+"'";return Dt.arrayBuffer()}).catch(function(){return Sn(Tn)});if(Y)return new Promise(function(Dt,rn){Y(Tn,function(Gn){Dt(new Uint8Array(Gn))},rn)})}return Promise.resolve().then(function(){return Sn(Tn)})}().then(function(Dt){return WebAssembly.instantiate(Dt,tt)}).then(mt,function(Dt){pe("failed to asynchronously prepare wasm: "+Dt),Ht(Dt)})}if(Yt++,M.monitorRunDependencies&&M.monitorRunDependencies(Yt),M.instantiateWasm)try{return M.instantiateWasm(tt,Oe)}catch(mt){return pe("Module.instantiateWasm callback failed with error: "+mt),!1}(ue||typeof WebAssembly.instantiateStreaming!="function"||on(Tn)||Rt(Tn)||typeof fetch!="function"?nn(Tt):fetch(Tn,{credentials:"same-origin"}).then(function(mt){return WebAssembly.instantiateStreaming(mt,tt).then(Tt,function(Dt){return pe("wasm streaming compile failed: "+Dt),pe("falling back to ArrayBuffer instantiation"),nn(Tt)})})).catch(j)}(),M.___wasm_call_ctors=function(){return(ht=M.___wasm_call_ctors=M.asm.k).apply(null,arguments)}),Et=(M._init=function(){return(M._init=M.asm.l).apply(null,arguments)},M._init_with_threads_count=function(){return(M._init_with_threads_count=M.asm.m).apply(null,arguments)},M._get_threads_count=function(){return(M._get_threads_count=M.asm.n).apply(null,arguments)},M._register_tensor=function(){return(M._register_tensor=M.asm.o).apply(null,arguments)},M._dispose_data=function(){return(M._dispose_data=M.asm.p).apply(null,arguments)},M._dispose=function(){return(M._dispose=M.asm.q).apply(null,arguments)},M._Abs=function(){return(M._Abs=M.asm.s).apply(null,arguments)},M._Add=function(){return(M._Add=M.asm.t).apply(null,arguments)},M._AddN=function(){return(M._AddN=M.asm.u).apply(null,arguments)},M._All=function(){return(M._All=M.asm.v).apply(null,arguments)},M._Any=function(){return(M._Any=M.asm.w).apply(null,arguments)},M._ArgMax=function(){return(M._ArgMax=M.asm.x).apply(null,arguments)},M._AvgPool=function(){return(M._AvgPool=M.asm.y).apply(null,arguments)},M._BatchMatMul=function(){return(M._BatchMatMul=M.asm.z).apply(null,arguments)},M._Ceil=function(){return(M._Ceil=M.asm.A).apply(null,arguments)},M._ClipByValue=function(){return(M._ClipByValue=M.asm.B).apply(null,arguments)},M._Conv2D=function(){return(M._Conv2D=M.asm.C).apply(null,arguments)},M._Conv2DBackpropInput=function(){return(M._Conv2DBackpropInput=M.asm.D).apply(null,arguments)},M._Cos=function(){return(M._Cos=M.asm.E).apply(null,arguments)},M._Cosh=function(){return(M._Cosh=M.asm.F).apply(null,arguments)},M._CropAndResize=function(){return(M._CropAndResize=M.asm.G).apply(null,arguments)},M._Cumsum=function(){return(M._Cumsum=M.asm.H).apply(null,arguments)},M._DepthToSpace=function(){return(M._DepthToSpace=M.asm.I).apply(null,arguments)},M._DepthwiseConv2dNative=function(){return(M._DepthwiseConv2dNative=M.asm.J).apply(null,arguments)},M._Elu=function(){return(M._Elu=M.asm.K).apply(null,arguments)},M._Equal=function(){return(M._Equal=M.asm.L).apply(null,arguments)},M._Exp=function(){return(M._Exp=M.asm.M).apply(null,arguments)},M._FlipLeftRight=function(){return(M._FlipLeftRight=M.asm.N).apply(null,arguments)},M._Floor=function(){return(M._Floor=M.asm.O).apply(null,arguments)},M._FloorDiv=function(){return(M._FloorDiv=M.asm.P).apply(null,arguments)},M._FusedBatchNorm=function(){return(M._FusedBatchNorm=M.asm.Q).apply(null,arguments)},M._FusedConv2D=function(){return(M._FusedConv2D=M.asm.R).apply(null,arguments)},M._FusedDepthwiseConv2D=function(){return(M._FusedDepthwiseConv2D=M.asm.S).apply(null,arguments)},M._Gather=function(){return(M._Gather=M.asm.T).apply(null,arguments)},M._GatherNd=function(){return(M._GatherNd=M.asm.U).apply(null,arguments)},M._Greater=function(){return(M._Greater=M.asm.V).apply(null,arguments)},M._GreaterEqual=function(){return(M._GreaterEqual=M.asm.W).apply(null,arguments)},M._LeakyRelu=function(){return(M._LeakyRelu=M.asm.X).apply(null,arguments)},M._Less=function(){return(M._Less=M.asm.Y).apply(null,arguments)},M._LessEqual=function(){return(M._LessEqual=M.asm.Z).apply(null,arguments)},M._Log=function(){return(M._Log=M.asm._).apply(null,arguments)},M._LogicalAnd=function(){return(M._LogicalAnd=M.asm.$).apply(null,arguments)},M._Max=function(){return(M._Max=M.asm.aa).apply(null,arguments)},M._MaxPool=function(){return(M._MaxPool=M.asm.ba).apply(null,arguments)},M._Maximum=function(){return(M._Maximum=M.asm.ca).apply(null,arguments)},M._Mean=function(){return(M._Mean=M.asm.da).apply(null,arguments)},M._Min=function(){return(M._Min=M.asm.ea).apply(null,arguments)},M._Minimum=function(){return(M._Minimum=M.asm.fa).apply(null,arguments)},M._MirrorPad=function(){return(M._MirrorPad=M.asm.ga).apply(null,arguments)},M._Multiply=function(){return(M._Multiply=M.asm.ha).apply(null,arguments)},M._Neg=function(){return(M._Neg=M.asm.ia).apply(null,arguments)},M._NonMaxSuppressionV3=function(){return(M._NonMaxSuppressionV3=M.asm.ja).apply(null,arguments)},M._NonMaxSuppressionV4=function(){return(M._NonMaxSuppressionV4=M.asm.ka).apply(null,arguments)},M._NonMaxSuppressionV5=function(){return(M._NonMaxSuppressionV5=M.asm.la).apply(null,arguments)},M._NotEqual=function(){return(M._NotEqual=M.asm.ma).apply(null,arguments)},M._OneHot=function(){return(M._OneHot=M.asm.na).apply(null,arguments)},M._PadV2=function(){return(M._PadV2=M.asm.oa).apply(null,arguments)},M._Pow=function(){return(M._Pow=M.asm.pa).apply(null,arguments)},M._Prelu=function(){return(M._Prelu=M.asm.qa).apply(null,arguments)},M._Prod=function(){return(M._Prod=M.asm.ra).apply(null,arguments)},M._RealDiv=function(){return(M._RealDiv=M.asm.sa).apply(null,arguments)},M._Relu=function(){return(M._Relu=M.asm.ta).apply(null,arguments)},M._Relu6=function(){return(M._Relu6=M.asm.ua).apply(null,arguments)},M._ResizeBilinear=function(){return(M._ResizeBilinear=M.asm.va).apply(null,arguments)},M._Reverse=function(){return(M._Reverse=M.asm.wa).apply(null,arguments)},M._RotateWithOffset=function(){return(M._RotateWithOffset=M.asm.xa).apply(null,arguments)},M._Round=function(){return(M._Round=M.asm.ya).apply(null,arguments)},M._Rsqrt=function(){return(M._Rsqrt=M.asm.za).apply(null,arguments)},M._ScatterNd=function(){return(M._ScatterNd=M.asm.Aa).apply(null,arguments)},M._SelectV2=function(){return(M._SelectV2=M.asm.Ba).apply(null,arguments)},M._Sigmoid=function(){return(M._Sigmoid=M.asm.Ca).apply(null,arguments)},M._Sin=function(){return(M._Sin=M.asm.Da).apply(null,arguments)},M._Softmax=function(){return(M._Softmax=M.asm.Ea).apply(null,arguments)},M._Sqrt=function(){return(M._Sqrt=M.asm.Fa).apply(null,arguments)},M._Square=function(){return(M._Square=M.asm.Ga).apply(null,arguments)},M._SquaredDifference=function(){return(M._SquaredDifference=M.asm.Ha).apply(null,arguments)},M._Step=function(){return(M._Step=M.asm.Ia).apply(null,arguments)},M._StridedSlice=function(){return(M._StridedSlice=M.asm.Ja).apply(null,arguments)},M._Sub=function(){return(M._Sub=M.asm.Ka).apply(null,arguments)},M._Sum=function(){return(M._Sum=M.asm.La).apply(null,arguments)},M._Tan=function(){return(M._Tan=M.asm.Ma).apply(null,arguments)},M._Tanh=function(){return(M._Tanh=M.asm.Na).apply(null,arguments)},M._Tile=function(){return(M._Tile=M.asm.Oa).apply(null,arguments)},M._TopK=function(){return(M._TopK=M.asm.Pa).apply(null,arguments)},M._Transform=function(){return(M._Transform=M.asm.Qa).apply(null,arguments)},M._Transpose=function(){return(M._Transpose=M.asm.Ra).apply(null,arguments)},M.__FusedMatMul=function(){return(M.__FusedMatMul=M.asm.Sa).apply(null,arguments)},M._malloc=function(){return(M._malloc=M.asm.Ta).apply(null,arguments)},M._free=function(){return(M._free=M.asm.Ua).apply(null,arguments)},M.___errno_location=function(){return(Et=M.___errno_location=M.asm.Va).apply(null,arguments)}),cn=M.stackSave=function(){return(cn=M.stackSave=M.asm.Wa).apply(null,arguments)},jt=M.stackRestore=function(){return(jt=M.stackRestore=M.asm.Xa).apply(null,arguments)},xn=M.stackAlloc=function(){return(xn=M.stackAlloc=M.asm.Ya).apply(null,arguments)};function yn(tt){this.name="ExitStatus",this.message="Program terminated with exit("+tt+")",this.status=tt}function pt(tt){function Oe(){rr||(rr=!0,M.calledRun=!0,Q||(J(It),J(Ft),G(M),M.onRuntimeInitialized&&M.onRuntimeInitialized(),function(){if(M.postRun)for(typeof M.postRun=="function"&&(M.postRun=[M.postRun]);M.postRun.length;)Tt=M.postRun.shift(),pn.unshift(Tt);var Tt;J(pn)}()))}Yt>0||(function(){if(M.preRun)for(typeof M.preRun=="function"&&(M.preRun=[M.preRun]);M.preRun.length;)Tt=M.preRun.shift(),dt.unshift(Tt);var Tt;J(dt)}(),Yt>0||(M.setStatus?(M.setStatus("Running..."),setTimeout(function(){setTimeout(function(){M.setStatus("")},1),Oe()},1)):Oe()))}if(M.cwrap=function(tt,Oe,Tt,nn){var mt=(Tt=Tt||[]).every(function(Dt){return Dt==="number"});return Oe!=="string"&&mt&&!nn?ie(tt):function(){return function(Dt,rn,Gn,kt){var Ba={string:function(Ss){var Xo=0;if(Ss!=null&&Ss!==0){var ms=1+(Ss.length<<2);(function(is,Nn,Zr){(function(vo,As,Er,mi){if(!(mi>0))return 0;for(var st=Er+mi-1,gi=0;gi<vo.length;++gi){var Lr=vo.charCodeAt(gi);if(Lr>=55296&&Lr<=57343&&(Lr=65536+((1023&Lr)<<10)|1023&vo.charCodeAt(++gi)),Lr<=127){if(Er>=st)break;As[Er++]=Lr}else if(Lr<=2047){if(Er+1>=st)break;As[Er++]=192|Lr>>6,As[Er++]=128|63&Lr}else if(Lr<=65535){if(Er+2>=st)break;As[Er++]=224|Lr>>12,As[Er++]=128|Lr>>6&63,As[Er++]=128|63&Lr}else{if(Er+3>=st)break;As[Er++]=240|Lr>>18,As[Er++]=128|Lr>>12&63,As[Er++]=128|Lr>>6&63,As[Er++]=128|63&Lr}}As[Er]=0})(is,xe,Nn,Zr)})(Ss,Xo=xn(ms),ms)}return Xo},array:function(Ss){var Xo=xn(Ss.length);return function(ms,is){je.set(ms,is)}(Ss,Xo),Xo}},ba=ie(Dt),Je=[],bn=0;if(kt)for(var vr=0;vr<kt.length;vr++){var kn=Ba[Gn[vr]];kn?(bn===0&&(bn=cn()),Je[vr]=kn(kt[vr])):Je[vr]=kt[vr]}var Mr=ba.apply(null,Je);return Mr=function(Ss){return rn==="string"?ge(Ss):rn==="boolean"?!!Ss:Ss}(Mr),bn!==0&&jt(bn),Mr}(tt,Oe,Tt,arguments)}},wt=function tt(){rr||pt(),rr||(wt=tt)},M.run=pt,M.preInit)for(typeof M.preInit=="function"&&(M.preInit=[M.preInit]);M.preInit.length>0;)M.preInit.pop()();return pt(),z.ready});g.exports=E},264:(g,x,k)=>{var N=k(297),E=k(72),z=k(950),G=k(436),j=k(242),M=k(668),R=k(456);R.alea=N,R.xor128=E,R.xorwow=z,R.xorshift7=G,R.xor4096=j,R.tychei=M,g.exports=R},297:function(g,x,k){var N;(function(E,z){function G(R){var B,P=this,H=(B=4022871197,function(C){C=C.toString();for(var O=0;O<C.length;O++){var F=.02519603282416938*(B+=C.charCodeAt(O));F-=B=F>>>0,B=(F*=B)>>>0,B+=4294967296*(F-=B)}return 23283064365386963e-26*(B>>>0)});P.next=function(){var C=2091639*P.s0+23283064365386963e-26*P.c;return P.s0=P.s1,P.s1=P.s2,P.s2=C-(P.c=0|C)},P.c=1,P.s0=H(" "),P.s1=H(" "),P.s2=H(" "),P.s0-=H(R),P.s0<0&&(P.s0+=1),P.s1-=H(R),P.s1<0&&(P.s1+=1),P.s2-=H(R),P.s2<0&&(P.s2+=1),H=null}function j(R,B){return B.c=R.c,B.s0=R.s0,B.s1=R.s1,B.s2=R.s2,B}function M(R,B){var P=new G(R),H=B&&B.state,C=P.next;return C.int32=function(){return 4294967296*P.next()|0},C.double=function(){return C()+11102230246251565e-32*(2097152*C()|0)},C.quick=C,H&&(typeof H=="object"&&j(H,P),C.state=function(){return j(P,{})}),C}z&&z.exports?z.exports=M:k.amdD&&k.amdO?(N=(function(){return M}).call(x,k,x,z))===void 0||(z.exports=N):this.alea=M})(0,g=k.nmd(g),k.amdD)},668:function(g,x,k){var N;(function(E,z){function G(R){var B=this,P="";B.next=function(){var C=B.b,O=B.c,F=B.d,Y=B.a;return C=C<<25^C>>>7^O,O=O-F|0,F=F<<24^F>>>8^Y,Y=Y-C|0,B.b=C=C<<20^C>>>12^O,B.c=O=O-F|0,B.d=F<<16^O>>>16^Y,B.a=Y-C|0},B.a=0,B.b=0,B.c=-1640531527,B.d=1367130551,R===Math.floor(R)?(B.a=R/4294967296|0,B.b=0|R):P+=R;for(var H=0;H<P.length+20;H++)B.b^=0|P.charCodeAt(H),B.next()}function j(R,B){return B.a=R.a,B.b=R.b,B.c=R.c,B.d=R.d,B}function M(R,B){var P=new G(R),H=B&&B.state,C=function(){return(P.next()>>>0)/4294967296};return C.double=function(){do var O=((P.next()>>>11)+(P.next()>>>0)/4294967296)/2097152;while(O===0);return O},C.int32=P.next,C.quick=C,H&&(typeof H=="object"&&j(H,P),C.state=function(){return j(P,{})}),C}z&&z.exports?z.exports=M:k.amdD&&k.amdO?(N=(function(){return M}).call(x,k,x,z))===void 0||(z.exports=N):this.tychei=M})(0,g=k.nmd(g),k.amdD)},72:function(g,x,k){var N;(function(E,z){function G(R){var B=this,P="";B.x=0,B.y=0,B.z=0,B.w=0,B.next=function(){var C=B.x^B.x<<11;return B.x=B.y,B.y=B.z,B.z=B.w,B.w^=B.w>>>19^C^C>>>8},R===(0|R)?B.x=R:P+=R;for(var H=0;H<P.length+64;H++)B.x^=0|P.charCodeAt(H),B.next()}function j(R,B){return B.x=R.x,B.y=R.y,B.z=R.z,B.w=R.w,B}function M(R,B){var P=new G(R),H=B&&B.state,C=function(){return(P.next()>>>0)/4294967296};return C.double=function(){do var O=((P.next()>>>11)+(P.next()>>>0)/4294967296)/2097152;while(O===0);return O},C.int32=P.next,C.quick=C,H&&(typeof H=="object"&&j(H,P),C.state=function(){return j(P,{})}),C}z&&z.exports?z.exports=M:k.amdD&&k.amdO?(N=(function(){return M}).call(x,k,x,z))===void 0||(z.exports=N):this.xor128=M})(0,g=k.nmd(g),k.amdD)},242:function(g,x,k){var N;(function(E,z){function G(R){var B=this;B.next=function(){var P,H,C=B.w,O=B.X,F=B.i;return B.w=C=C+1640531527|0,H=O[F+34&127],P=O[F=F+1&127],H^=H<<13,P^=P<<17,H^=H>>>15,P^=P>>>12,H=O[F]=H^P,B.i=F,H+(C^C>>>16)|0},function(P,H){var C,O,F,Y,ae,te=[],oe=128;for(H===(0|H)?(O=H,H=null):(H+="\0",O=0,oe=Math.max(oe,H.length)),F=0,Y=-32;Y<oe;++Y)H&&(O^=H.charCodeAt((Y+32)%H.length)),Y===0&&(ae=O),O^=O<<10,O^=O>>>15,O^=O<<4,O^=O>>>13,Y>=0&&(ae=ae+1640531527|0,F=(C=te[127&Y]^=O+ae)==0?F+1:0);for(F>=128&&(te[127&(H&&H.length||0)]=-1),F=127,Y=512;Y>0;--Y)O=te[F+34&127],C=te[F=F+1&127],O^=O<<13,C^=C<<17,O^=O>>>15,C^=C>>>12,te[F]=O^C;P.w=ae,P.X=te,P.i=F}(B,R)}function j(R,B){return B.i=R.i,B.w=R.w,B.X=R.X.slice(),B}function M(R,B){R==null&&(R=+new Date);var P=new G(R),H=B&&B.state,C=function(){return(P.next()>>>0)/4294967296};return C.double=function(){do var O=((P.next()>>>11)+(P.next()>>>0)/4294967296)/2097152;while(O===0);return O},C.int32=P.next,C.quick=C,H&&(H.X&&j(H,P),C.state=function(){return j(P,{})}),C}z&&z.exports?z.exports=M:k.amdD&&k.amdO?(N=(function(){return M}).call(x,k,x,z))===void 0||(z.exports=N):this.xor4096=M})(0,g=k.nmd(g),k.amdD)},436:function(g,x,k){var N;(function(E,z){function G(R){var B=this;B.next=function(){var P,H,C=B.x,O=B.i;return P=C[O],H=(P^=P>>>7)^P<<24,H^=(P=C[O+1&7])^P>>>10,H^=(P=C[O+3&7])^P>>>3,H^=(P=C[O+4&7])^P<<7,P=C[O+7&7],H^=(P^=P<<13)^P<<9,C[O]=H,B.i=O+1&7,H},function(P,H){var C,O=[];if(H===(0|H))O[0]=H;else for(H=""+H,C=0;C<H.length;++C)O[7&C]=O[7&C]<<15^H.charCodeAt(C)+O[C+1&7]<<13;for(;O.length<8;)O.push(0);for(C=0;C<8&&O[C]===0;++C);for(C==8?O[7]=-1:O[C],P.x=O,P.i=0,C=256;C>0;--C)P.next()}(B,R)}function j(R,B){return B.x=R.x.slice(),B.i=R.i,B}function M(R,B){R==null&&(R=+new Date);var P=new G(R),H=B&&B.state,C=function(){return(P.next()>>>0)/4294967296};return C.double=function(){do var O=((P.next()>>>11)+(P.next()>>>0)/4294967296)/2097152;while(O===0);return O},C.int32=P.next,C.quick=C,H&&(H.x&&j(H,P),C.state=function(){return j(P,{})}),C}z&&z.exports?z.exports=M:k.amdD&&k.amdO?(N=(function(){return M}).call(x,k,x,z))===void 0||(z.exports=N):this.xorshift7=M})(0,g=k.nmd(g),k.amdD)},950:function(g,x,k){var N;(function(E,z){function G(R){var B=this,P="";B.next=function(){var C=B.x^B.x>>>2;return B.x=B.y,B.y=B.z,B.z=B.w,B.w=B.v,(B.d=B.d+362437|0)+(B.v=B.v^B.v<<4^C^C<<1)|0},B.x=0,B.y=0,B.z=0,B.w=0,B.v=0,R===(0|R)?B.x=R:P+=R;for(var H=0;H<P.length+64;H++)B.x^=0|P.charCodeAt(H),H==P.length&&(B.d=B.x<<10^B.x>>>4),B.next()}function j(R,B){return B.x=R.x,B.y=R.y,B.z=R.z,B.w=R.w,B.v=R.v,B.d=R.d,B}function M(R,B){var P=new G(R),H=B&&B.state,C=function(){return(P.next()>>>0)/4294967296};return C.double=function(){do var O=((P.next()>>>11)+(P.next()>>>0)/4294967296)/2097152;while(O===0);return O},C.int32=P.next,C.quick=C,H&&(typeof H=="object"&&j(H,P),C.state=function(){return j(P,{})}),C}z&&z.exports?z.exports=M:k.amdD&&k.amdO?(N=(function(){return M}).call(x,k,x,z))===void 0||(z.exports=N):this.xorwow=M})(0,g=k.nmd(g),k.amdD)},456:(g,x,k)=>{var N;(function(E,z){var G,j=this,M=256,R="random",B=z.pow(M,6),P=z.pow(2,52),H=2*P,C=255;function O(fe,ue,Z){var ye=[],pe=te(ae((ue=ue==1?{entropy:!0}:ue||{}).entropy?[fe,oe(E)]:fe??function(){try{var ie;return G&&(ie=G.randomBytes)?ie=ie(M):(ie=new Uint8Array(M),(j.crypto||j.msCrypto).getRandomValues(ie)),oe(ie)}catch{var Ie=j.navigator,je=Ie&&Ie.plugins;return[+new Date,j,je,j.screen,oe(E)]}}(),3),ye),Q=new F(ye),ke=function(){for(var ie=Q.g(6),Ie=B,je=0;ie<P;)ie=(ie+je)*M,Ie*=M,je=Q.g(1);for(;ie>=H;)ie/=2,Ie/=2,je>>>=1;return(ie+je)/Ie};return ke.int32=function(){return 0|Q.g(4)},ke.quick=function(){return Q.g(4)/4294967296},ke.double=ke,te(oe(Q.S),E),(ue.pass||Z||function(ie,Ie,je,xe){return xe&&(xe.S&&Y(xe,Q),ie.state=function(){return Y(Q,{})}),je?(z[R]=ie,Ie):ie})(ke,pe,"global"in ue?ue.global:this==z,ue.state)}function F(fe){var ue,Z=fe.length,ye=this,pe=0,Q=ye.i=ye.j=0,ke=ye.S=[];for(Z||(fe=[Z++]);pe<M;)ke[pe]=pe++;for(pe=0;pe<M;pe++)ke[pe]=ke[Q=C&Q+fe[pe%Z]+(ue=ke[pe])],ke[Q]=ue;(ye.g=function(ie){for(var Ie,je=0,xe=ye.i,We=ye.j,Ke=ye.S;ie--;)Ie=Ke[xe=C&xe+1],je=je*M+Ke[C&(Ke[xe]=Ke[We=C&We+Ie])+(Ke[We]=Ie)];return ye.i=xe,ye.j=We,je})(M)}function Y(fe,ue){return ue.i=fe.i,ue.j=fe.j,ue.S=fe.S.slice(),ue}function ae(fe,ue){var Z,ye=[],pe=typeof fe;if(ue&&pe=="object")for(Z in fe)try{ye.push(ae(fe[Z],ue-1))}catch{}return ye.length?ye:pe=="string"?fe:fe+"\0"}function te(fe,ue){for(var Z,ye=fe+"",pe=0;pe<ye.length;)ue[C&pe]=C&(Z^=19*ue[C&pe])+ye.charCodeAt(pe++);return oe(ue)}function oe(fe){return String.fromCharCode.apply(0,fe)}if(z["seed"+R]=O,te(z.random(),E),g.exports){g.exports=O;try{G=k(857)}catch{}}else(N=(function(){return O}).call(x,k,x,g))===void 0||(g.exports=N)})([],Math)},892:(g,x,k)=>{var N=k(501),E=k(84),z=k(450),G=k(296),j=k(774),M=k(760),R=k(988);R.alea=N,R.xor128=E,R.xorwow=z,R.xorshift7=G,R.xor4096=j,R.tychei=M,g.exports=R},501:function(g,x,k){var N;(function(E,z){function G(R){var B,P=this,H=(B=4022871197,function(C){C=C.toString();for(var O=0;O<C.length;O++){var F=.02519603282416938*(B+=C.charCodeAt(O));F-=B=F>>>0,B=(F*=B)>>>0,B+=4294967296*(F-=B)}return 23283064365386963e-26*(B>>>0)});P.next=function(){var C=2091639*P.s0+23283064365386963e-26*P.c;return P.s0=P.s1,P.s1=P.s2,P.s2=C-(P.c=0|C)},P.c=1,P.s0=H(" "),P.s1=H(" "),P.s2=H(" "),P.s0-=H(R),P.s0<0&&(P.s0+=1),P.s1-=H(R),P.s1<0&&(P.s1+=1),P.s2-=H(R),P.s2<0&&(P.s2+=1),H=null}function j(R,B){return B.c=R.c,B.s0=R.s0,B.s1=R.s1,B.s2=R.s2,B}function M(R,B){var P=new G(R),H=B&&B.state,C=P.next;return C.int32=function(){return 4294967296*P.next()|0},C.double=function(){return C()+11102230246251565e-32*(2097152*C()|0)},C.quick=C,H&&(typeof H=="object"&&j(H,P),C.state=function(){return j(P,{})}),C}z&&z.exports?z.exports=M:k.amdD&&k.amdO?(N=(function(){return M}).call(x,k,x,z))===void 0||(z.exports=N):this.alea=M})(0,g=k.nmd(g),k.amdD)},760:function(g,x,k){var N;(function(E,z){function G(R){var B=this,P="";B.next=function(){var C=B.b,O=B.c,F=B.d,Y=B.a;return C=C<<25^C>>>7^O,O=O-F|0,F=F<<24^F>>>8^Y,Y=Y-C|0,B.b=C=C<<20^C>>>12^O,B.c=O=O-F|0,B.d=F<<16^O>>>16^Y,B.a=Y-C|0},B.a=0,B.b=0,B.c=-1640531527,B.d=1367130551,R===Math.floor(R)?(B.a=R/4294967296|0,B.b=0|R):P+=R;for(var H=0;H<P.length+20;H++)B.b^=0|P.charCodeAt(H),B.next()}function j(R,B){return B.a=R.a,B.b=R.b,B.c=R.c,B.d=R.d,B}function M(R,B){var P=new G(R),H=B&&B.state,C=function(){return(P.next()>>>0)/4294967296};return C.double=function(){do var O=((P.next()>>>11)+(P.next()>>>0)/4294967296)/2097152;while(O===0);return O},C.int32=P.next,C.quick=C,H&&(typeof H=="object"&&j(H,P),C.state=function(){return j(P,{})}),C}z&&z.exports?z.exports=M:k.amdD&&k.amdO?(N=(function(){return M}).call(x,k,x,z))===void 0||(z.exports=N):this.tychei=M})(0,g=k.nmd(g),k.amdD)},84:function(g,x,k){var N;(function(E,z){function G(R){var B=this,P="";B.x=0,B.y=0,B.z=0,B.w=0,B.next=function(){var C=B.x^B.x<<11;return B.x=B.y,B.y=B.z,B.z=B.w,B.w^=B.w>>>19^C^C>>>8},R===(0|R)?B.x=R:P+=R;for(var H=0;H<P.length+64;H++)B.x^=0|P.charCodeAt(H),B.next()}function j(R,B){return B.x=R.x,B.y=R.y,B.z=R.z,B.w=R.w,B}function M(R,B){var P=new G(R),H=B&&B.state,C=function(){return(P.next()>>>0)/4294967296};return C.double=function(){do var O=((P.next()>>>11)+(P.next()>>>0)/4294967296)/2097152;while(O===0);return O},C.int32=P.next,C.quick=C,H&&(typeof H=="object"&&j(H,P),C.state=function(){return j(P,{})}),C}z&&z.exports?z.exports=M:k.amdD&&k.amdO?(N=(function(){return M}).call(x,k,x,z))===void 0||(z.exports=N):this.xor128=M})(0,g=k.nmd(g),k.amdD)},774:function(g,x,k){var N;(function(E,z){function G(R){var B=this;B.next=function(){var P,H,C=B.w,O=B.X,F=B.i;return B.w=C=C+1640531527|0,H=O[F+34&127],P=O[F=F+1&127],H^=H<<13,P^=P<<17,H^=H>>>15,P^=P>>>12,H=O[F]=H^P,B.i=F,H+(C^C>>>16)|0},function(P,H){var C,O,F,Y,ae,te=[],oe=128;for(H===(0|H)?(O=H,H=null):(H+="\0",O=0,oe=Math.max(oe,H.length)),F=0,Y=-32;Y<oe;++Y)H&&(O^=H.charCodeAt((Y+32)%H.length)),Y===0&&(ae=O),O^=O<<10,O^=O>>>15,O^=O<<4,O^=O>>>13,Y>=0&&(ae=ae+1640531527|0,F=(C=te[127&Y]^=O+ae)==0?F+1:0);for(F>=128&&(te[127&(H&&H.length||0)]=-1),F=127,Y=512;Y>0;--Y)O=te[F+34&127],C=te[F=F+1&127],O^=O<<13,C^=C<<17,O^=O>>>15,C^=C>>>12,te[F]=O^C;P.w=ae,P.X=te,P.i=F}(B,R)}function j(R,B){return B.i=R.i,B.w=R.w,B.X=R.X.slice(),B}function M(R,B){R==null&&(R=+new Date);var P=new G(R),H=B&&B.state,C=function(){return(P.next()>>>0)/4294967296};return C.double=function(){do var O=((P.next()>>>11)+(P.next()>>>0)/4294967296)/2097152;while(O===0);return O},C.int32=P.next,C.quick=C,H&&(H.X&&j(H,P),C.state=function(){return j(P,{})}),C}z&&z.exports?z.exports=M:k.amdD&&k.amdO?(N=(function(){return M}).call(x,k,x,z))===void 0||(z.exports=N):this.xor4096=M})(0,g=k.nmd(g),k.amdD)},296:function(g,x,k){var N;(function(E,z){function G(R){var B=this;B.next=function(){var P,H,C=B.x,O=B.i;return P=C[O],H=(P^=P>>>7)^P<<24,H^=(P=C[O+1&7])^P>>>10,H^=(P=C[O+3&7])^P>>>3,H^=(P=C[O+4&7])^P<<7,P=C[O+7&7],H^=(P^=P<<13)^P<<9,C[O]=H,B.i=O+1&7,H},function(P,H){var C,O=[];if(H===(0|H))O[0]=H;else for(H=""+H,C=0;C<H.length;++C)O[7&C]=O[7&C]<<15^H.charCodeAt(C)+O[C+1&7]<<13;for(;O.length<8;)O.push(0);for(C=0;C<8&&O[C]===0;++C);for(C==8?O[7]=-1:O[C],P.x=O,P.i=0,C=256;C>0;--C)P.next()}(B,R)}function j(R,B){return B.x=R.x.slice(),B.i=R.i,B}function M(R,B){R==null&&(R=+new Date);var P=new G(R),H=B&&B.state,C=function(){return(P.next()>>>0)/4294967296};return C.double=function(){do var O=((P.next()>>>11)+(P.next()>>>0)/4294967296)/2097152;while(O===0);return O},C.int32=P.next,C.quick=C,H&&(H.x&&j(H,P),C.state=function(){return j(P,{})}),C}z&&z.exports?z.exports=M:k.amdD&&k.amdO?(N=(function(){return M}).call(x,k,x,z))===void 0||(z.exports=N):this.xorshift7=M})(0,g=k.nmd(g),k.amdD)},450:function(g,x,k){var N;(function(E,z){function G(R){var B=this,P="";B.next=function(){var C=B.x^B.x>>>2;return B.x=B.y,B.y=B.z,B.z=B.w,B.w=B.v,(B.d=B.d+362437|0)+(B.v=B.v^B.v<<4^C^C<<1)|0},B.x=0,B.y=0,B.z=0,B.w=0,B.v=0,R===(0|R)?B.x=R:P+=R;for(var H=0;H<P.length+64;H++)B.x^=0|P.charCodeAt(H),H==P.length&&(B.d=B.x<<10^B.x>>>4),B.next()}function j(R,B){return B.x=R.x,B.y=R.y,B.z=R.z,B.w=R.w,B.v=R.v,B.d=R.d,B}function M(R,B){var P=new G(R),H=B&&B.state,C=function(){return(P.next()>>>0)/4294967296};return C.double=function(){do var O=((P.next()>>>11)+(P.next()>>>0)/4294967296)/2097152;while(O===0);return O},C.int32=P.next,C.quick=C,H&&(typeof H=="object"&&j(H,P),C.state=function(){return j(P,{})}),C}z&&z.exports?z.exports=M:k.amdD&&k.amdO?(N=(function(){return M}).call(x,k,x,z))===void 0||(z.exports=N):this.xorwow=M})(0,g=k.nmd(g),k.amdD)},988:(g,x,k)=>{var N;(function(E,z){var G,j=this,M=256,R="random",B=z.pow(M,6),P=z.pow(2,52),H=2*P,C=255;function O(fe,ue,Z){var ye=[],pe=te(ae((ue=ue==1?{entropy:!0}:ue||{}).entropy?[fe,oe(E)]:fe??function(){try{var ie;return G&&(ie=G.randomBytes)?ie=ie(M):(ie=new Uint8Array(M),(j.crypto||j.msCrypto).getRandomValues(ie)),oe(ie)}catch{var Ie=j.navigator,je=Ie&&Ie.plugins;return[+new Date,j,je,j.screen,oe(E)]}}(),3),ye),Q=new F(ye),ke=function(){for(var ie=Q.g(6),Ie=B,je=0;ie<P;)ie=(ie+je)*M,Ie*=M,je=Q.g(1);for(;ie>=H;)ie/=2,Ie/=2,je>>>=1;return(ie+je)/Ie};return ke.int32=function(){return 0|Q.g(4)},ke.quick=function(){return Q.g(4)/4294967296},ke.double=ke,te(oe(Q.S),E),(ue.pass||Z||function(ie,Ie,je,xe){return xe&&(xe.S&&Y(xe,Q),ie.state=function(){return Y(Q,{})}),je?(z[R]=ie,Ie):ie})(ke,pe,"global"in ue?ue.global:this==z,ue.state)}function F(fe){var ue,Z=fe.length,ye=this,pe=0,Q=ye.i=ye.j=0,ke=ye.S=[];for(Z||(fe=[Z++]);pe<M;)ke[pe]=pe++;for(pe=0;pe<M;pe++)ke[pe]=ke[Q=C&Q+fe[pe%Z]+(ue=ke[pe])],ke[Q]=ue;(ye.g=function(ie){for(var Ie,je=0,xe=ye.i,We=ye.j,Ke=ye.S;ie--;)Ie=Ke[xe=C&xe+1],je=je*M+Ke[C&(Ke[xe]=Ke[We=C&We+Ie])+(Ke[We]=Ie)];return ye.i=xe,ye.j=We,je})(M)}function Y(fe,ue){return ue.i=fe.i,ue.j=fe.j,ue.S=fe.S.slice(),ue}function ae(fe,ue){var Z,ye=[],pe=typeof fe;if(ue&&pe=="object")for(Z in fe)try{ye.push(ae(fe[Z],ue-1))}catch{}return ye.length?ye:pe=="string"?fe:fe+"\0"}function te(fe,ue){for(var Z,ye=fe+"",pe=0;pe<ye.length;)ue[C&pe]=C&(Z^=19*ue[C&pe])+ye.charCodeAt(pe++);return oe(ue)}function oe(fe){return String.fromCharCode.apply(0,fe)}if(z["seed"+R]=O,te(z.random(),E),g.exports){g.exports=O;try{G=k(53)}catch{}}else(N=(function(){return O}).call(x,k,x,g))===void 0||(g.exports=N)})([],Math)},570:g=>{g.exports=k;var x=null;try{x=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function k(Q,ke,ie){this.low=0|Q,this.high=0|ke,this.unsigned=!!ie}function N(Q){return(Q&&Q.__isLong__)===!0}k.prototype.__isLong__,Object.defineProperty(k.prototype,"__isLong__",{value:!0}),k.isLong=N;var E={},z={};function G(Q,ke){var ie,Ie,je;return ke?(je=0<=(Q>>>=0)&&Q<256)&&(Ie=z[Q])?Ie:(ie=M(Q,(0|Q)<0?-1:0,!0),je&&(z[Q]=ie),ie):(je=-128<=(Q|=0)&&Q<128)&&(Ie=E[Q])?Ie:(ie=M(Q,Q<0?-1:0,!1),je&&(E[Q]=ie),ie)}function j(Q,ke){if(isNaN(Q))return ke?ae:Y;if(ke){if(Q<0)return ae;if(Q>=C)return Z}else{if(Q<=-O)return ye;if(Q+1>=O)return ue}return Q<0?j(-Q,ke).neg():M(Q%H|0,Q/H|0,ke)}function M(Q,ke,ie){return new k(Q,ke,ie)}k.fromInt=G,k.fromNumber=j,k.fromBits=M;var R=Math.pow;function B(Q,ke,ie){if(Q.length===0)throw Error("empty string");if(Q==="NaN"||Q==="Infinity"||Q==="+Infinity"||Q==="-Infinity")return Y;if(typeof ke=="number"?(ie=ke,ke=!1):ke=!!ke,(ie=ie||10)<2||36<ie)throw RangeError("radix");var Ie;if((Ie=Q.indexOf("-"))>0)throw Error("interior hyphen");if(Ie===0)return B(Q.substring(1),ke,ie).neg();for(var je=j(R(ie,8)),xe=Y,We=0;We<Q.length;We+=8){var Ke=Math.min(8,Q.length-We),ut=parseInt(Q.substring(We,We+Ke),ie);if(Ke<8){var ge=j(R(ie,Ke));xe=xe.mul(ge).add(j(ut))}else xe=(xe=xe.mul(je)).add(j(ut))}return xe.unsigned=ke,xe}function P(Q,ke){return typeof Q=="number"?j(Q,ke):typeof Q=="string"?B(Q,ke):M(Q.low,Q.high,typeof ke=="boolean"?ke:Q.unsigned)}k.fromString=B,k.fromValue=P;var H=4294967296,C=H*H,O=C/2,F=G(1<<24),Y=G(0);k.ZERO=Y;var ae=G(0,!0);k.UZERO=ae;var te=G(1);k.ONE=te;var oe=G(1,!0);k.UONE=oe;var fe=G(-1);k.NEG_ONE=fe;var ue=M(-1,2147483647,!1);k.MAX_VALUE=ue;var Z=M(-1,-1,!0);k.MAX_UNSIGNED_VALUE=Z;var ye=M(0,-2147483648,!1);k.MIN_VALUE=ye;var pe=k.prototype;pe.toInt=function(){return this.unsigned?this.low>>>0:this.low},pe.toNumber=function(){return this.unsigned?(this.high>>>0)*H+(this.low>>>0):this.high*H+(this.low>>>0)},pe.toString=function(Q){if((Q=Q||10)<2||36<Q)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(ye)){var ke=j(Q),ie=this.div(ke),Ie=ie.mul(ke).sub(this);return ie.toString(Q)+Ie.toInt().toString(Q)}return"-"+this.neg().toString(Q)}for(var je=j(R(Q,6),this.unsigned),xe=this,We="";;){var Ke=xe.div(je),ut=(xe.sub(Ke.mul(je)).toInt()>>>0).toString(Q);if((xe=Ke).isZero())return ut+We;for(;ut.length<6;)ut="0"+ut;We=""+ut+We}},pe.getHighBits=function(){return this.high},pe.getHighBitsUnsigned=function(){return this.high>>>0},pe.getLowBits=function(){return this.low},pe.getLowBitsUnsigned=function(){return this.low>>>0},pe.getNumBitsAbs=function(){if(this.isNegative())return this.eq(ye)?64:this.neg().getNumBitsAbs();for(var Q=this.high!=0?this.high:this.low,ke=31;ke>0&&!(Q&1<<ke);ke--);return this.high!=0?ke+33:ke+1},pe.isZero=function(){return this.high===0&&this.low===0},pe.eqz=pe.isZero,pe.isNegative=function(){return!this.unsigned&&this.high<0},pe.isPositive=function(){return this.unsigned||this.high>=0},pe.isOdd=function(){return!(1&~this.low)},pe.isEven=function(){return!(1&this.low)},pe.equals=function(Q){return N(Q)||(Q=P(Q)),(this.unsigned===Q.unsigned||this.high>>>31!=1||Q.high>>>31!=1)&&this.high===Q.high&&this.low===Q.low},pe.eq=pe.equals,pe.notEquals=function(Q){return!this.eq(Q)},pe.neq=pe.notEquals,pe.ne=pe.notEquals,pe.lessThan=function(Q){return this.comp(Q)<0},pe.lt=pe.lessThan,pe.lessThanOrEqual=function(Q){return this.comp(Q)<=0},pe.lte=pe.lessThanOrEqual,pe.le=pe.lessThanOrEqual,pe.greaterThan=function(Q){return this.comp(Q)>0},pe.gt=pe.greaterThan,pe.greaterThanOrEqual=function(Q){return this.comp(Q)>=0},pe.gte=pe.greaterThanOrEqual,pe.ge=pe.greaterThanOrEqual,pe.compare=function(Q){if(N(Q)||(Q=P(Q)),this.eq(Q))return 0;var ke=this.isNegative(),ie=Q.isNegative();return ke&&!ie?-1:!ke&&ie?1:this.unsigned?Q.high>>>0>this.high>>>0||Q.high===this.high&&Q.low>>>0>this.low>>>0?-1:1:this.sub(Q).isNegative()?-1:1},pe.comp=pe.compare,pe.negate=function(){return!this.unsigned&&this.eq(ye)?ye:this.not().add(te)},pe.neg=pe.negate,pe.add=function(Q){N(Q)||(Q=P(Q));var ke=this.high>>>16,ie=65535&this.high,Ie=this.low>>>16,je=65535&this.low,xe=Q.high>>>16,We=65535&Q.high,Ke=Q.low>>>16,ut=0,ge=0,Qe=0,At=0;return Qe+=(At+=je+(65535&Q.low))>>>16,ge+=(Qe+=Ie+Ke)>>>16,ut+=(ge+=ie+We)>>>16,ut+=ke+xe,M((Qe&=65535)<<16|(At&=65535),(ut&=65535)<<16|(ge&=65535),this.unsigned)},pe.subtract=function(Q){return N(Q)||(Q=P(Q)),this.add(Q.neg())},pe.sub=pe.subtract,pe.multiply=function(Q){if(this.isZero())return Y;if(N(Q)||(Q=P(Q)),x)return M(x.mul(this.low,this.high,Q.low,Q.high),x.get_high(),this.unsigned);if(Q.isZero())return Y;if(this.eq(ye))return Q.isOdd()?ye:Y;if(Q.eq(ye))return this.isOdd()?ye:Y;if(this.isNegative())return Q.isNegative()?this.neg().mul(Q.neg()):this.neg().mul(Q).neg();if(Q.isNegative())return this.mul(Q.neg()).neg();if(this.lt(F)&&Q.lt(F))return j(this.toNumber()*Q.toNumber(),this.unsigned);var ke=this.high>>>16,ie=65535&this.high,Ie=this.low>>>16,je=65535&this.low,xe=Q.high>>>16,We=65535&Q.high,Ke=Q.low>>>16,ut=65535&Q.low,ge=0,Qe=0,At=0,dt=0;return At+=(dt+=je*ut)>>>16,Qe+=(At+=Ie*ut)>>>16,At&=65535,Qe+=(At+=je*Ke)>>>16,ge+=(Qe+=ie*ut)>>>16,Qe&=65535,ge+=(Qe+=Ie*Ke)>>>16,Qe&=65535,ge+=(Qe+=je*We)>>>16,ge+=ke*ut+ie*Ke+Ie*We+je*xe,M((At&=65535)<<16|(dt&=65535),(ge&=65535)<<16|(Qe&=65535),this.unsigned)},pe.mul=pe.multiply,pe.divide=function(Q){if(N(Q)||(Q=P(Q)),Q.isZero())throw Error("division by zero");var ke,ie,Ie;if(x)return this.unsigned||this.high!==-2147483648||Q.low!==-1||Q.high!==-1?M((this.unsigned?x.div_u:x.div_s)(this.low,this.high,Q.low,Q.high),x.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?ae:Y;if(this.unsigned){if(Q.unsigned||(Q=Q.toUnsigned()),Q.gt(this))return ae;if(Q.gt(this.shru(1)))return oe;Ie=ae}else{if(this.eq(ye))return Q.eq(te)||Q.eq(fe)?ye:Q.eq(ye)?te:(ke=this.shr(1).div(Q).shl(1)).eq(Y)?Q.isNegative()?te:fe:(ie=this.sub(Q.mul(ke)),Ie=ke.add(ie.div(Q)));if(Q.eq(ye))return this.unsigned?ae:Y;if(this.isNegative())return Q.isNegative()?this.neg().div(Q.neg()):this.neg().div(Q).neg();if(Q.isNegative())return this.div(Q.neg()).neg();Ie=Y}for(ie=this;ie.gte(Q);){ke=Math.max(1,Math.floor(ie.toNumber()/Q.toNumber()));for(var je=Math.ceil(Math.log(ke)/Math.LN2),xe=je<=48?1:R(2,je-48),We=j(ke),Ke=We.mul(Q);Ke.isNegative()||Ke.gt(ie);)Ke=(We=j(ke-=xe,this.unsigned)).mul(Q);We.isZero()&&(We=te),Ie=Ie.add(We),ie=ie.sub(Ke)}return Ie},pe.div=pe.divide,pe.modulo=function(Q){return N(Q)||(Q=P(Q)),x?M((this.unsigned?x.rem_u:x.rem_s)(this.low,this.high,Q.low,Q.high),x.get_high(),this.unsigned):this.sub(this.div(Q).mul(Q))},pe.mod=pe.modulo,pe.rem=pe.modulo,pe.not=function(){return M(~this.low,~this.high,this.unsigned)},pe.and=function(Q){return N(Q)||(Q=P(Q)),M(this.low&Q.low,this.high&Q.high,this.unsigned)},pe.or=function(Q){return N(Q)||(Q=P(Q)),M(this.low|Q.low,this.high|Q.high,this.unsigned)},pe.xor=function(Q){return N(Q)||(Q=P(Q)),M(this.low^Q.low,this.high^Q.high,this.unsigned)},pe.shiftLeft=function(Q){return N(Q)&&(Q=Q.toInt()),(Q&=63)==0?this:Q<32?M(this.low<<Q,this.high<<Q|this.low>>>32-Q,this.unsigned):M(0,this.low<<Q-32,this.unsigned)},pe.shl=pe.shiftLeft,pe.shiftRight=function(Q){return N(Q)&&(Q=Q.toInt()),(Q&=63)==0?this:Q<32?M(this.low>>>Q|this.high<<32-Q,this.high>>Q,this.unsigned):M(this.high>>Q-32,this.high>=0?0:-1,this.unsigned)},pe.shr=pe.shiftRight,pe.shiftRightUnsigned=function(Q){if(N(Q)&&(Q=Q.toInt()),(Q&=63)==0)return this;var ke=this.high;return Q<32?M(this.low>>>Q|ke<<32-Q,ke>>>Q,this.unsigned):M(Q===32?ke:ke>>>Q-32,0,this.unsigned)},pe.shru=pe.shiftRightUnsigned,pe.shr_u=pe.shiftRightUnsigned,pe.toSigned=function(){return this.unsigned?M(this.low,this.high,!1):this},pe.toUnsigned=function(){return this.unsigned?this:M(this.low,this.high,!0)},pe.toBytes=function(Q){return Q?this.toBytesLE():this.toBytesBE()},pe.toBytesLE=function(){var Q=this.high,ke=this.low;return[255&ke,ke>>>8&255,ke>>>16&255,ke>>>24,255&Q,Q>>>8&255,Q>>>16&255,Q>>>24]},pe.toBytesBE=function(){var Q=this.high,ke=this.low;return[Q>>>24,Q>>>16&255,Q>>>8&255,255&Q,ke>>>24,ke>>>16&255,ke>>>8&255,255&ke]},k.fromBytes=function(Q,ke,ie){return ie?k.fromBytesLE(Q,ke):k.fromBytesBE(Q,ke)},k.fromBytesLE=function(Q,ke){return new k(Q[0]|Q[1]<<8|Q[2]<<16|Q[3]<<24,Q[4]|Q[5]<<8|Q[6]<<16|Q[7]<<24,ke)},k.fromBytesBE=function(Q,ke){return new k(Q[4]<<24|Q[5]<<16|Q[6]<<8|Q[7],Q[0]<<24|Q[1]<<16|Q[2]<<8|Q[3],ke)}},159:(g,x,k)=>{(N=k(540))&&typeof N=="object"&&"default"in N&&N.default;var N,E=k(576),z=new E,G=z.getBrowser(),j=(z.getCPU(),z.getDevice()),M=z.getEngine(),R=z.getOS(),B=z.getUA(),P="mobile",H="tablet",C="Chrome",O="Firefox",F="Opera",Y="Yandex",ae="Safari",te="Internet Explorer",oe="Edge",fe="Chromium",ue="IE",Z="Mobile Safari",ye="MIUI Browser",pe="Samsung Browser",Q="iOS",ke="Android",ie="Windows Phone",Ie="Windows",je="Mac OS",xe=function(Je){return Je||(arguments.length>1&&arguments[1]!==void 0?arguments[1]:"none")},We=function(){return!(typeof window>"u"||!window.navigator&&!navigator)&&(window.navigator||navigator)},Ke=function(Je){var bn=We();return bn&&bn.platform&&(bn.platform.indexOf(Je)!==-1||bn.platform==="MacIntel"&&bn.maxTouchPoints>1&&!window.MSStream)},ut=function(Je){return Je.type===P},ge=function(Je){return Je.type===H},Qe=function(Je){var bn=Je.type;return bn===P||bn===H},At=function(Je){return Je.type==="smarttv"},dt=function(Je){return Je.type===void 0},It=function(Je){return Je.type==="wearable"},Ft=function(Je){return Je.type==="console"},pn=function(Je){return Je.type==="embedded"},Yt=function(Je){var bn=Je.vendor;return xe(bn)},wt=function(Je){var bn=Je.model;return xe(bn)},Ht=function(Je){var bn=Je.type;return xe(bn,"browser")},Wt=function(Je){return Je.name===ke},on=function(Je){return Je.name===Ie},Rt=function(Je){return Je.name===je},Mt=function(Je){return Je.name===ie},Tn=function(Je){return Je.name===Q},Sn=function(Je){var bn=Je.version;return xe(bn)},J=function(Je){var bn=Je.name;return xe(bn)},gn=function(Je){return Je.name===C},rr=function(Je){return Je.name===O},qt=function(Je){return Je.name===fe},Ye=function(Je){return Je.name===oe},ht=function(Je){return Je.name===Y},Et=function(Je){var bn=Je.name;return bn===ae||bn===Z},cn=function(Je){return Je.name===Z},jt=function(Je){return Je.name===F},xn=function(Je){var bn=Je.name;return bn===te||bn===ue},yn=function(Je){return Je.name===ye},pt=function(Je){return Je.name===pe},tt=function(Je){var bn=Je.version;return xe(bn)},Oe=function(Je){var bn=Je.major;return xe(bn)},Tt=function(Je){var bn=Je.name;return xe(bn)},nn=function(Je){var bn=Je.name;return xe(bn)},mt=function(Je){var bn=Je.version;return xe(bn)},Dt=function(){var Je=We(),bn=Je&&Je.userAgent&&Je.userAgent.toLowerCase();return typeof bn=="string"&&/electron/.test(bn)},rn=function(Je){return typeof Je=="string"&&Je.indexOf("Edg/")!==-1},Gn=function(){return Ke("iPad")},kt=function(){return Ke("iPhone")},Ba=function(){return Ke("iPod")};At(j),Ft(j),It(j),pn(j),cn(G)||Gn(),qt(G);var ba=Qe(j)||Gn();ut(j),ge(j)||Gn(),dt(j),dt(j),Wt(R),Mt(R),Tn(R)||Gn(),gn(G),rr(G),Et(G),jt(G),xn(G),Sn(R),J(R),tt(G),Oe(G),Tt(G),Yt(j),wt(j),nn(M),mt(M),Ye(G)||rn(B),ht(G),Ht(j),Gn(),kt(),Ba(),Dt(),rn(B),Ye(G)&&rn(B),on(R),Rt(R),yn(G),pt(G),x.Fr=ba},869:(g,x)=>{var k=Symbol.for("react.transitional.element"),N=Symbol.for("react.portal"),E=Symbol.for("react.fragment"),z=Symbol.for("react.strict_mode"),G=Symbol.for("react.profiler"),j=Symbol.for("react.consumer"),M=Symbol.for("react.context"),R=Symbol.for("react.forward_ref"),B=Symbol.for("react.suspense"),P=Symbol.for("react.memo"),H=Symbol.for("react.lazy"),C=Symbol.iterator,O={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},F=Object.assign,Y={};function ae(ge,Qe,At){this.props=ge,this.context=Qe,this.refs=Y,this.updater=At||O}function te(){}function oe(ge,Qe,At){this.props=ge,this.context=Qe,this.refs=Y,this.updater=At||O}ae.prototype.isReactComponent={},ae.prototype.setState=function(ge,Qe){if(typeof ge!="object"&&typeof ge!="function"&&ge!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,ge,Qe,"setState")},ae.prototype.forceUpdate=function(ge){this.updater.enqueueForceUpdate(this,ge,"forceUpdate")},te.prototype=ae.prototype;var fe=oe.prototype=new te;fe.constructor=oe,F(fe,ae.prototype),fe.isPureReactComponent=!0;var ue=Array.isArray,Z={H:null,A:null,T:null,S:null,V:null},ye=Object.prototype.hasOwnProperty;function pe(ge,Qe,At,dt,It,Ft){return At=Ft.ref,{$$typeof:k,type:ge,key:Qe,ref:At!==void 0?At:null,props:Ft}}function Q(ge){return typeof ge=="object"&&ge!==null&&ge.$$typeof===k}var ke=/\/+/g;function ie(ge,Qe){return typeof ge=="object"&&ge!==null&&ge.key!=null?(At=""+ge.key,dt={"=":"=0",":":"=2"},"$"+At.replace(/[=:]/g,function(It){return dt[It]})):Qe.toString(36);var At,dt}function Ie(){}function je(ge,Qe,At,dt,It){var Ft=typeof ge;Ft!=="undefined"&&Ft!=="boolean"||(ge=null);var pn,Yt,wt=!1;if(ge===null)wt=!0;else switch(Ft){case"bigint":case"string":case"number":wt=!0;break;case"object":switch(ge.$$typeof){case k:case N:wt=!0;break;case H:return je((wt=ge._init)(ge._payload),Qe,At,dt,It)}}if(wt)return It=It(ge),wt=dt===""?"."+ie(ge,0):dt,ue(It)?(At="",wt!=null&&(At=wt.replace(ke,"$&/")+"/"),je(It,Qe,At,"",function(Rt){return Rt})):It!=null&&(Q(It)&&(pn=It,Yt=At+(It.key==null||ge&&ge.key===It.key?"":(""+It.key).replace(ke,"$&/")+"/")+wt,It=pe(pn.type,Yt,void 0,0,0,pn.props)),Qe.push(It)),1;wt=0;var Ht,Wt=dt===""?".":dt+":";if(ue(ge))for(var on=0;on<ge.length;on++)wt+=je(dt=ge[on],Qe,At,Ft=Wt+ie(dt,on),It);else if(typeof(on=(Ht=ge)===null||typeof Ht!="object"?null:typeof(Ht=C&&Ht[C]||Ht["@@iterator"])=="function"?Ht:null)=="function")for(ge=on.call(ge),on=0;!(dt=ge.next()).done;)wt+=je(dt=dt.value,Qe,At,Ft=Wt+ie(dt,on++),It);else if(Ft==="object"){if(typeof ge.then=="function")return je(function(Rt){switch(Rt.status){case"fulfilled":return Rt.value;case"rejected":throw Rt.reason;default:switch(typeof Rt.status=="string"?Rt.then(Ie,Ie):(Rt.status="pending",Rt.then(function(Mt){Rt.status==="pending"&&(Rt.status="fulfilled",Rt.value=Mt)},function(Mt){Rt.status==="pending"&&(Rt.status="rejected",Rt.reason=Mt)})),Rt.status){case"fulfilled":return Rt.value;case"rejected":throw Rt.reason}}throw Rt}(ge),Qe,At,dt,It);throw Qe=String(ge),Error("Objects are not valid as a React child (found: "+(Qe==="[object Object]"?"object with keys {"+Object.keys(ge).join(", ")+"}":Qe)+"). If you meant to render a collection of children, use an array instead.")}return wt}function xe(ge,Qe,At){if(ge==null)return ge;var dt=[],It=0;return je(ge,dt,"","",function(Ft){return Qe.call(At,Ft,It++)}),dt}function We(ge){if(ge._status===-1){var Qe=ge._result;(Qe=Qe()).then(function(At){ge._status!==0&&ge._status!==-1||(ge._status=1,ge._result=At)},function(At){ge._status!==0&&ge._status!==-1||(ge._status=2,ge._result=At)}),ge._status===-1&&(ge._status=0,ge._result=Qe)}if(ge._status===1)return ge._result.default;throw ge._result}var Ke=typeof reportError=="function"?reportError:function(ge){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var Qe=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof ge=="object"&&ge!==null&&typeof ge.message=="string"?String(ge.message):String(ge),error:ge});if(!window.dispatchEvent(Qe))return}else if(typeof process=="object"&&typeof process.emit=="function")return void process.emit("uncaughtException",ge);console.error(ge)};function ut(){}x.Children={map:xe,forEach:function(ge,Qe,At){xe(ge,function(){Qe.apply(this,arguments)},At)},count:function(ge){var Qe=0;return xe(ge,function(){Qe++}),Qe},toArray:function(ge){return xe(ge,function(Qe){return Qe})||[]},only:function(ge){if(!Q(ge))throw Error("React.Children.only expected to receive a single React element child.");return ge}},x.Component=ae,x.Fragment=E,x.Profiler=G,x.PureComponent=oe,x.StrictMode=z,x.Suspense=B,x.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=Z,x.__COMPILER_RUNTIME={__proto__:null,c:function(ge){return Z.H.useMemoCache(ge)}},x.cache=function(ge){return function(){return ge.apply(null,arguments)}},x.cloneElement=function(ge,Qe,At){if(ge==null)throw Error("The argument must be a React element, but you passed "+ge+".");var dt=F({},ge.props),It=ge.key;if(Qe!=null)for(Ft in Qe.ref,Qe.key!==void 0&&(It=""+Qe.key),Qe)!ye.call(Qe,Ft)||Ft==="key"||Ft==="__self"||Ft==="__source"||Ft==="ref"&&Qe.ref===void 0||(dt[Ft]=Qe[Ft]);var Ft=arguments.length-2;if(Ft===1)dt.children=At;else if(1<Ft){for(var pn=Array(Ft),Yt=0;Yt<Ft;Yt++)pn[Yt]=arguments[Yt+2];dt.children=pn}return pe(ge.type,It,void 0,0,0,dt)},x.createContext=function(ge){return(ge={$$typeof:M,_currentValue:ge,_currentValue2:ge,_threadCount:0,Provider:null,Consumer:null}).Provider=ge,ge.Consumer={$$typeof:j,_context:ge},ge},x.createElement=function(ge,Qe,At){var dt,It={},Ft=null;if(Qe!=null)for(dt in Qe.key!==void 0&&(Ft=""+Qe.key),Qe)ye.call(Qe,dt)&&dt!=="key"&&dt!=="__self"&&dt!=="__source"&&(It[dt]=Qe[dt]);var pn=arguments.length-2;if(pn===1)It.children=At;else if(1<pn){for(var Yt=Array(pn),wt=0;wt<pn;wt++)Yt[wt]=arguments[wt+2];It.children=Yt}if(ge&&ge.defaultProps)for(dt in pn=ge.defaultProps)It[dt]===void 0&&(It[dt]=pn[dt]);return pe(ge,Ft,void 0,0,0,It)},x.createRef=function(){return{current:null}},x.forwardRef=function(ge){return{$$typeof:R,render:ge}},x.isValidElement=Q,x.lazy=function(ge){return{$$typeof:H,_payload:{_status:-1,_result:ge},_init:We}},x.memo=function(ge,Qe){return{$$typeof:P,type:ge,compare:Qe===void 0?null:Qe}},x.startTransition=function(ge){var Qe=Z.T,At={};Z.T=At;try{var dt=ge(),It=Z.S;It!==null&&It(At,dt),typeof dt=="object"&&dt!==null&&typeof dt.then=="function"&&dt.then(ut,Ke)}catch(Ft){Ke(Ft)}finally{Z.T=Qe}},x.unstable_useCacheRefresh=function(){return Z.H.useCacheRefresh()},x.use=function(ge){return Z.H.use(ge)},x.useActionState=function(ge,Qe,At){return Z.H.useActionState(ge,Qe,At)},x.useCallback=function(ge,Qe){return Z.H.useCallback(ge,Qe)},x.useContext=function(ge){return Z.H.useContext(ge)},x.useDebugValue=function(){},x.useDeferredValue=function(ge,Qe){return Z.H.useDeferredValue(ge,Qe)},x.useEffect=function(ge,Qe,At){var dt=Z.H;if(typeof At=="function")throw Error("useEffect CRUD overload is not enabled in this build of React.");return dt.useEffect(ge,Qe)},x.useId=function(){return Z.H.useId()},x.useImperativeHandle=function(ge,Qe,At){return Z.H.useImperativeHandle(ge,Qe,At)},x.useInsertionEffect=function(ge,Qe){return Z.H.useInsertionEffect(ge,Qe)},x.useLayoutEffect=function(ge,Qe){return Z.H.useLayoutEffect(ge,Qe)},x.useMemo=function(ge,Qe){return Z.H.useMemo(ge,Qe)},x.useOptimistic=function(ge,Qe){return Z.H.useOptimistic(ge,Qe)},x.useReducer=function(ge,Qe,At){return Z.H.useReducer(ge,Qe,At)},x.useRef=function(ge){return Z.H.useRef(ge)},x.useState=function(ge){return Z.H.useState(ge)},x.useSyncExternalStore=function(ge,Qe,At){return Z.H.useSyncExternalStore(ge,Qe,At)},x.useTransition=function(){return Z.H.useTransition()},x.version="19.1.0"},540:(g,x,k)=>{g.exports=k(869)},576:function(g,x,k){var N;(function(E,z){var G="function",j="undefined",M="object",R="string",B="major",P="model",H="name",C="type",O="vendor",F="version",Y="architecture",ae="console",te="mobile",oe="tablet",fe="smarttv",ue="wearable",Z="embedded",ye="Amazon",pe="Apple",Q="ASUS",ke="BlackBerry",ie="Browser",Ie="Chrome",je="Firefox",xe="Google",We="Huawei",Ke="LG",ut="Microsoft",ge="Motorola",Qe="Opera",At="Samsung",dt="Sharp",It="Sony",Ft="Xiaomi",pn="Zebra",Yt="Facebook",wt="Chromium OS",Ht="Mac OS",Wt=" Browser",on=function(Et){for(var cn={},jt=0;jt<Et.length;jt++)cn[Et[jt].toUpperCase()]=Et[jt];return cn},Rt=function(Et,cn){return typeof Et===R&&Mt(cn).indexOf(Mt(Et))!==-1},Mt=function(Et){return Et.toLowerCase()},Tn=function(Et,cn){if(typeof Et===R)return Et=Et.replace(/^\s\s*/,""),typeof cn===j?Et:Et.substring(0,500)},Sn=function(Et,cn){for(var jt,xn,yn,pt,tt,Oe,Tt=0;Tt<cn.length&&!tt;){var nn=cn[Tt],mt=cn[Tt+1];for(jt=xn=0;jt<nn.length&&!tt&&nn[jt];)if(tt=nn[jt++].exec(Et))for(yn=0;yn<mt.length;yn++)Oe=tt[++xn],typeof(pt=mt[yn])===M&&pt.length>0?pt.length===2?typeof pt[1]==G?this[pt[0]]=pt[1].call(this,Oe):this[pt[0]]=pt[1]:pt.length===3?typeof pt[1]!==G||pt[1].exec&&pt[1].test?this[pt[0]]=Oe?Oe.replace(pt[1],pt[2]):z:this[pt[0]]=Oe?pt[1].call(this,Oe,pt[2]):z:pt.length===4&&(this[pt[0]]=Oe?pt[3].call(this,Oe.replace(pt[1],pt[2])):z):this[pt]=Oe||z;Tt+=2}},J=function(Et,cn){for(var jt in cn)if(typeof cn[jt]===M&&cn[jt].length>0){for(var xn=0;xn<cn[jt].length;xn++)if(Rt(cn[jt][xn],Et))return jt==="?"?z:jt}else if(Rt(cn[jt],Et))return jt==="?"?z:jt;return cn.hasOwnProperty("*")?cn["*"]:Et},gn={ME:"4.90","NT 3.11":"NT3.51","NT 4.0":"NT4.0",2e3:"NT 5.0",XP:["NT 5.1","NT 5.2"],Vista:"NT 6.0",7:"NT 6.1",8:"NT 6.2",8.1:"NT 6.3",10:["NT 6.4","NT 10.0"],RT:"ARM"},rr={browser:[[/\b(?:crmo|crios)\/([\w\.]+)/i],[F,[H,"Chrome"]],[/edg(?:e|ios|a)?\/([\w\.]+)/i],[F,[H,"Edge"]],[/(opera mini)\/([-\w\.]+)/i,/(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,/(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i],[H,F],[/opios[\/ ]+([\w\.]+)/i],[F,[H,Qe+" Mini"]],[/\bop(?:rg)?x\/([\w\.]+)/i],[F,[H,Qe+" GX"]],[/\bopr\/([\w\.]+)/i],[F,[H,Qe]],[/\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i],[F,[H,"Baidu"]],[/\b(?:mxbrowser|mxios|myie2)\/?([-\w\.]*)\b/i],[F,[H,"Maxthon"]],[/(kindle)\/([\w\.]+)/i,/(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\/ ]?([\w\.]*)/i,/(avant|iemobile|slim(?:browser|boat|jet))[\/ ]?([\d\.]*)/i,/(?:ms|\()(ie) ([\w\.]+)/i,/(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio|(?=comodo_)?dragon)\/([-\w\.]+)/i,/(heytap|ovi|115)browser\/([\d\.]+)/i,/(weibo)__([\d\.]+)/i],[H,F],[/quark(?:pc)?\/([-\w\.]+)/i],[F,[H,"Quark"]],[/\bddg\/([\w\.]+)/i],[F,[H,"DuckDuckGo"]],[/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i],[F,[H,"UC"+ie]],[/microm.+\bqbcore\/([\w\.]+)/i,/\bqbcore\/([\w\.]+).+microm/i,/micromessenger\/([\w\.]+)/i],[F,[H,"WeChat"]],[/konqueror\/([\w\.]+)/i],[F,[H,"Konqueror"]],[/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i],[F,[H,"IE"]],[/ya(?:search)?browser\/([\w\.]+)/i],[F,[H,"Yandex"]],[/slbrowser\/([\w\.]+)/i],[F,[H,"Smart Lenovo "+ie]],[/(avast|avg)\/([\w\.]+)/i],[[H,/(.+)/,"$1 Secure "+ie],F],[/\bfocus\/([\w\.]+)/i],[F,[H,je+" Focus"]],[/\bopt\/([\w\.]+)/i],[F,[H,Qe+" Touch"]],[/coc_coc\w+\/([\w\.]+)/i],[F,[H,"Coc Coc"]],[/dolfin\/([\w\.]+)/i],[F,[H,"Dolphin"]],[/coast\/([\w\.]+)/i],[F,[H,Qe+" Coast"]],[/miuibrowser\/([\w\.]+)/i],[F,[H,"MIUI"+Wt]],[/fxios\/([\w\.-]+)/i],[F,[H,je]],[/\bqihoobrowser\/?([\w\.]*)/i],[F,[H,"360"]],[/\b(qq)\/([\w\.]+)/i],[[H,/(.+)/,"$1Browser"],F],[/(oculus|sailfish|huawei|vivo|pico)browser\/([\w\.]+)/i],[[H,/(.+)/,"$1"+Wt],F],[/samsungbrowser\/([\w\.]+)/i],[F,[H,At+" Internet"]],[/metasr[\/ ]?([\d\.]+)/i],[F,[H,"Sogou Explorer"]],[/(sogou)mo\w+\/([\d\.]+)/i],[[H,"Sogou Mobile"],F],[/(electron)\/([\w\.]+) safari/i,/(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,/m?(qqbrowser|2345(?=browser|chrome|explorer))\w*[\/ ]?v?([\w\.]+)/i],[H,F],[/(lbbrowser|rekonq)/i,/\[(linkedin)app\]/i],[H],[/ome\/([\w\.]+) \w* ?(iron) saf/i,/ome\/([\w\.]+).+qihu (360)[es]e/i],[F,H],[/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i],[[H,Yt],F],[/(Klarna)\/([\w\.]+)/i,/(kakao(?:talk|story))[\/ ]([\w\.]+)/i,/(naver)\(.*?(\d+\.[\w\.]+).*\)/i,/safari (line)\/([\w\.]+)/i,/\b(line)\/([\w\.]+)\/iab/i,/(alipay)client\/([\w\.]+)/i,/(twitter)(?:and| f.+e\/([\w\.]+))/i,/(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i],[H,F],[/\bgsa\/([\w\.]+) .*safari\//i],[F,[H,"GSA"]],[/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i],[F,[H,"TikTok"]],[/headlesschrome(?:\/([\w\.]+)| )/i],[F,[H,Ie+" Headless"]],[/ wv\).+(chrome)\/([\w\.]+)/i],[[H,Ie+" WebView"],F],[/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i],[F,[H,"Android "+ie]],[/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i],[H,F],[/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i],[F,[H,"Mobile Safari"]],[/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i],[F,H],[/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i],[H,[F,J,{"1.0":"/8",1.2:"/1",1.3:"/3","2.0":"/412","2.0.2":"/416","2.0.3":"/417","2.0.4":"/419","?":"/"}]],[/(webkit|khtml)\/([\w\.]+)/i],[H,F],[/(navigator|netscape\d?)\/([-\w\.]+)/i],[[H,"Netscape"],F],[/(wolvic|librewolf)\/([\w\.]+)/i],[H,F],[/mobile vr; rv:([\w\.]+)\).+firefox/i],[F,[H,je+" Reality"]],[/ekiohf.+(flow)\/([\w\.]+)/i,/(swiftfox)/i,/(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\/ ]?([\w\.\+]+)/i,/(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,/(firefox)\/([\w\.]+)/i,/(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,/(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,/(links) \(([\w\.]+)/i],[H,[F,/_/g,"."]],[/(cobalt)\/([\w\.]+)/i],[H,[F,/master.|lts./,""]]],cpu:[[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i],[[Y,"amd64"]],[/(ia32(?=;))/i],[[Y,Mt]],[/((?:i[346]|x)86)[;\)]/i],[[Y,"ia32"]],[/\b(aarch64|arm(v?8e?l?|_?64))\b/i],[[Y,"arm64"]],[/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i],[[Y,"armhf"]],[/windows (ce|mobile); ppc;/i],[[Y,"arm"]],[/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i],[[Y,/ower/,"",Mt]],[/(sun4\w)[;\)]/i],[[Y,"sparc"]],[/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i],[[Y,Mt]]],device:[[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i],[P,[O,At],[C,oe]],[/\b((?:s[cgp]h|gt|sm)-(?![lr])\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,/samsung[- ]((?!sm-[lr])[-\w]+)/i,/sec-(sgh\w+)/i],[P,[O,At],[C,te]],[/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i],[P,[O,pe],[C,te]],[/\((ipad);[-\w\),; ]+apple/i,/applecoremedia\/[\w\.]+ \((ipad)/i,/\b(ipad)\d\d?,\d\d?[;\]].+ios/i],[P,[O,pe],[C,oe]],[/(macintosh);/i],[P,[O,pe]],[/\b(sh-?[altvz]?\d\d[a-ekm]?)/i],[P,[O,dt],[C,te]],[/(?:honor)([-\w ]+)[;\)]/i],[P,[O,"Honor"],[C,te]],[/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i],[P,[O,We],[C,oe]],[/(?:huawei)([-\w ]+)[;\)]/i,/\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i],[P,[O,We],[C,te]],[/\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i,/\b; (\w+) build\/hm\1/i,/\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,/\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,/oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i,/\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite|pro)?)(?: bui|\))/i],[[P,/_/g," "],[O,Ft],[C,te]],[/oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i,/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i],[[P,/_/g," "],[O,Ft],[C,oe]],[/; (\w+) bui.+ oppo/i,/\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i],[P,[O,"OPPO"],[C,te]],[/\b(opd2\d{3}a?) bui/i],[P,[O,"OPPO"],[C,oe]],[/vivo (\w+)(?: bui|\))/i,/\b(v[12]\d{3}\w?[at])(?: bui|;)/i],[P,[O,"Vivo"],[C,te]],[/\b(rmx[1-3]\d{3})(?: bui|;|\))/i],[P,[O,"Realme"],[C,te]],[/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,/\bmot(?:orola)?[- ](\w*)/i,/((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i],[P,[O,ge],[C,te]],[/\b(mz60\d|xoom[2 ]{0,2}) build\//i],[P,[O,ge],[C,oe]],[/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i],[P,[O,Ke],[C,oe]],[/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,/\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,/\blg-?([\d\w]+) bui/i],[P,[O,Ke],[C,te]],[/(ideatab[-\w ]+)/i,/lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i],[P,[O,"Lenovo"],[C,oe]],[/(?:maemo|nokia).*(n900|lumia \d+)/i,/nokia[-_ ]?([-\w\.]*)/i],[[P,/_/g," "],[O,"Nokia"],[C,te]],[/(pixel c)\b/i],[P,[O,xe],[C,oe]],[/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i],[P,[O,xe],[C,te]],[/droid.+; (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i],[P,[O,It],[C,te]],[/sony tablet [ps]/i,/\b(?:sony)?sgp\w+(?: bui|\))/i],[[P,"Xperia Tablet"],[O,It],[C,oe]],[/ (kb2005|in20[12]5|be20[12][59])\b/i,/(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i],[P,[O,"OnePlus"],[C,te]],[/(alexa)webm/i,/(kf[a-z]{2}wi|aeo(?!bc)\w\w)( bui|\))/i,/(kf[a-z]+)( bui|\)).+silk\//i],[P,[O,ye],[C,oe]],[/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i],[[P,/(.+)/g,"Fire Phone $1"],[O,ye],[C,te]],[/(playbook);[-\w\),; ]+(rim)/i],[P,O,[C,oe]],[/\b((?:bb[a-f]|st[hv])100-\d)/i,/\(bb10; (\w+)/i],[P,[O,ke],[C,te]],[/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i],[P,[O,Q],[C,oe]],[/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i],[P,[O,Q],[C,te]],[/(nexus 9)/i],[P,[O,"HTC"],[C,oe]],[/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,/(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,/(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i],[O,[P,/_/g," "],[C,te]],[/droid [\w\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])\w*(\)| bui)/i],[P,[O,"TCL"],[C,oe]],[/(itel) ((\w+))/i],[[O,Mt],P,[C,J,{tablet:["p10001l","w7001"],"*":"mobile"}]],[/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i],[P,[O,"Acer"],[C,oe]],[/droid.+; (m[1-5] note) bui/i,/\bmz-([-\w]{2,})/i],[P,[O,"Meizu"],[C,te]],[/; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i],[P,[O,"Ulefone"],[C,te]],[/; (energy ?\w+)(?: bui|\))/i,/; energizer ([\w ]+)(?: bui|\))/i],[P,[O,"Energizer"],[C,te]],[/; cat (b35);/i,/; (b15q?|s22 flip|s48c|s62 pro)(?: bui|\))/i],[P,[O,"Cat"],[C,te]],[/((?:new )?andromax[\w- ]+)(?: bui|\))/i],[P,[O,"Smartfren"],[C,te]],[/droid.+; (a(?:015|06[35]|142p?))/i],[P,[O,"Nothing"],[C,te]],[/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno|micromax|advan)[-_ ]?([-\w]*)/i,/; (imo) ((?!tab)[\w ]+?)(?: bui|\))/i,/(hp) ([\w ]+\w)/i,/(asus)-?(\w+)/i,/(microsoft); (lumia[\w ]+)/i,/(lenovo)[-_ ]?([-\w]+)/i,/(jolla)/i,/(oppo) ?([\w ]+) bui/i],[O,P,[C,te]],[/(imo) (tab \w+)/i,/(kobo)\s(ereader|touch)/i,/(archos) (gamepad2?)/i,/(hp).+(touchpad(?!.+tablet)|tablet)/i,/(kindle)\/([\w\.]+)/i,/(nook)[\w ]+build\/(\w+)/i,/(dell) (strea[kpr\d ]*[\dko])/i,/(le[- ]+pan)[- ]+(\w{1,9}) bui/i,/(trinity)[- ]*(t\d{3}) bui/i,/(gigaset)[- ]+(q\w{1,9}) bui/i,/(vodafone) ([\w ]+)(?:\)| bui)/i],[O,P,[C,oe]],[/(surface duo)/i],[P,[O,ut],[C,oe]],[/droid [\d\.]+; (fp\du?)(?: b|\))/i],[P,[O,"Fairphone"],[C,te]],[/(u304aa)/i],[P,[O,"AT&T"],[C,te]],[/\bsie-(\w*)/i],[P,[O,"Siemens"],[C,te]],[/\b(rct\w+) b/i],[P,[O,"RCA"],[C,oe]],[/\b(venue[\d ]{2,7}) b/i],[P,[O,"Dell"],[C,oe]],[/\b(q(?:mv|ta)\w+) b/i],[P,[O,"Verizon"],[C,oe]],[/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i],[P,[O,"Barnes & Noble"],[C,oe]],[/\b(tm\d{3}\w+) b/i],[P,[O,"NuVision"],[C,oe]],[/\b(k88) b/i],[P,[O,"ZTE"],[C,oe]],[/\b(nx\d{3}j) b/i],[P,[O,"ZTE"],[C,te]],[/\b(gen\d{3}) b.+49h/i],[P,[O,"Swiss"],[C,te]],[/\b(zur\d{3}) b/i],[P,[O,"Swiss"],[C,oe]],[/\b((zeki)?tb.*\b) b/i],[P,[O,"Zeki"],[C,oe]],[/\b([yr]\d{2}) b/i,/\b(dragon[- ]+touch |dt)(\w{5}) b/i],[[O,"Dragon Touch"],P,[C,oe]],[/\b(ns-?\w{0,9}) b/i],[P,[O,"Insignia"],[C,oe]],[/\b((nxa|next)-?\w{0,9}) b/i],[P,[O,"NextBook"],[C,oe]],[/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i],[[O,"Voice"],P,[C,te]],[/\b(lvtel\-)?(v1[12]) b/i],[[O,"LvTel"],P,[C,te]],[/\b(ph-1) /i],[P,[O,"Essential"],[C,te]],[/\b(v(100md|700na|7011|917g).*\b) b/i],[P,[O,"Envizen"],[C,oe]],[/\b(trio[-\w\. ]+) b/i],[P,[O,"MachSpeed"],[C,oe]],[/\btu_(1491) b/i],[P,[O,"Rotor"],[C,oe]],[/(shield[\w ]+) b/i],[P,[O,"Nvidia"],[C,oe]],[/(sprint) (\w+)/i],[O,P,[C,te]],[/(kin\.[onetw]{3})/i],[[P,/\./g," "],[O,ut],[C,te]],[/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i],[P,[O,pn],[C,oe]],[/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i],[P,[O,pn],[C,te]],[/smart-tv.+(samsung)/i],[O,[C,fe]],[/hbbtv.+maple;(\d+)/i],[[P,/^/,"SmartTV"],[O,At],[C,fe]],[/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i],[[O,Ke],[C,fe]],[/(apple) ?tv/i],[O,[P,pe+" TV"],[C,fe]],[/crkey/i],[[P,Ie+"cast"],[O,xe],[C,fe]],[/droid.+aft(\w+)( bui|\))/i],[P,[O,ye],[C,fe]],[/\(dtv[\);].+(aquos)/i,/(aquos-tv[\w ]+)\)/i],[P,[O,dt],[C,fe]],[/(bravia[\w ]+)( bui|\))/i],[P,[O,It],[C,fe]],[/(mitv-\w{5}) bui/i],[P,[O,Ft],[C,fe]],[/Hbbtv.*(technisat) (.*);/i],[O,P,[C,fe]],[/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,/hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i],[[O,Tn],[P,Tn],[C,fe]],[/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i],[[C,fe]],[/(ouya)/i,/(nintendo) ([wids3utch]+)/i],[O,P,[C,ae]],[/droid.+; (shield) bui/i],[P,[O,"Nvidia"],[C,ae]],[/(playstation [345portablevi]+)/i],[P,[O,It],[C,ae]],[/\b(xbox(?: one)?(?!; xbox))[\); ]/i],[P,[O,ut],[C,ae]],[/\b(sm-[lr]\d\d[05][fnuw]?s?)\b/i],[P,[O,At],[C,ue]],[/((pebble))app/i],[O,P,[C,ue]],[/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i],[P,[O,pe],[C,ue]],[/droid.+; (glass) \d/i],[P,[O,xe],[C,ue]],[/droid.+; (wt63?0{2,3})\)/i],[P,[O,pn],[C,ue]],[/droid.+; (glass) \d/i],[P,[O,xe],[C,ue]],[/(pico) (4|neo3(?: link|pro)?)/i],[O,P,[C,ue]],[/; (quest( \d| pro)?)/i],[P,[O,Yt],[C,ue]],[/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i],[O,[C,Z]],[/(aeobc)\b/i],[P,[O,ye],[C,Z]],[/droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i],[P,[C,te]],[/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i],[P,[C,oe]],[/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i],[[C,oe]],[/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i],[[C,te]],[/(android[-\w\. ]{0,9});.+buil/i],[P,[O,"Generic"]]],engine:[[/windows.+ edge\/([\w\.]+)/i],[F,[H,"EdgeHTML"]],[/(arkweb)\/([\w\.]+)/i],[H,F],[/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i],[F,[H,"Blink"]],[/(presto)\/([\w\.]+)/i,/(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna|servo)\/([\w\.]+)/i,/ekioh(flow)\/([\w\.]+)/i,/(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,/(icab)[\/ ]([23]\.[\d\.]+)/i,/\b(libweb)/i],[H,F],[/rv\:([\w\.]{1,9})\b.+(gecko)/i],[F,H]],os:[[/microsoft (windows) (vista|xp)/i],[H,F],[/(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i],[H,[F,J,gn]],[/windows nt 6\.2; (arm)/i,/windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i,/(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i],[[F,J,gn],[H,"Windows"]],[/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,/(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i,/cfnetwork\/.+darwin/i],[[F,/_/g,"."],[H,"iOS"]],[/(mac os x) ?([\w\. ]*)/i,/(macintosh|mac_powerpc\b)(?!.+haiku)/i],[[H,Ht],[F,/_/g,"."]],[/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i],[F,H],[/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish|openharmony)[-\/ ]?([\w\.]*)/i,/(blackberry)\w*\/([\w\.]*)/i,/(tizen|kaios)[\/ ]([\w\.]+)/i,/\((series40);/i],[H,F],[/\(bb(10);/i],[F,[H,ke]],[/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i],[F,[H,"Symbian"]],[/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i],[F,[H,je+" OS"]],[/web0s;.+rt(tv)/i,/\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i],[F,[H,"webOS"]],[/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i],[F,[H,"watchOS"]],[/crkey\/([\d\.]+)/i],[F,[H,Ie+"cast"]],[/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i],[[H,wt],F],[/panasonic;(viera)/i,/(netrange)mmh/i,/(nettv)\/(\d+\.[\w\.]+)/i,/(nintendo|playstation) ([wids345portablevuch]+)/i,/(xbox); +xbox ([^\);]+)/i,/\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,/(mint)[\/\(\) ]?(\w*)/i,/(mageia|vectorlinux)[; ]/i,/([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,/(hurd|linux) ?([\w\.]*)/i,/(gnu) ?([\w\.]*)/i,/\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,/(haiku) (\w+)/i],[H,F],[/(sunos) ?([\w\.\d]*)/i],[[H,"Solaris"],F],[/((?:open)?solaris)[-\/ ]?([\w\.]*)/i,/(aix) ((\d)(?=\.|\)| )[\w\.])*/i,/\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i,/(unix) ?([\w\.]*)/i],[H,F]]},qt=function(Et,cn){if(typeof Et===M&&(cn=Et,Et=z),!(this instanceof qt))return new qt(Et,cn).getResult();var jt=typeof E!==j&&E.navigator?E.navigator:z,xn=Et||(jt&&jt.userAgent?jt.userAgent:""),yn=jt&&jt.userAgentData?jt.userAgentData:z,pt=cn?function(Oe,Tt){var nn={};for(var mt in Oe)Tt[mt]&&Tt[mt].length%2==0?nn[mt]=Tt[mt].concat(Oe[mt]):nn[mt]=Oe[mt];return nn}(rr,cn):rr,tt=jt&&jt.userAgent==xn;return this.getBrowser=function(){var Oe,Tt={};return Tt[H]=z,Tt[F]=z,Sn.call(Tt,xn,pt.browser),Tt[B]=typeof(Oe=Tt[F])===R?Oe.replace(/[^\d\.]/g,"").split(".")[0]:z,tt&&jt&&jt.brave&&typeof jt.brave.isBrave==G&&(Tt[H]="Brave"),Tt},this.getCPU=function(){var Oe={};return Oe[Y]=z,Sn.call(Oe,xn,pt.cpu),Oe},this.getDevice=function(){var Oe={};return Oe[O]=z,Oe[P]=z,Oe[C]=z,Sn.call(Oe,xn,pt.device),tt&&!Oe[C]&&yn&&yn.mobile&&(Oe[C]=te),tt&&Oe[P]=="Macintosh"&&jt&&typeof jt.standalone!==j&&jt.maxTouchPoints&&jt.maxTouchPoints>2&&(Oe[P]="iPad",Oe[C]=oe),Oe},this.getEngine=function(){var Oe={};return Oe[H]=z,Oe[F]=z,Sn.call(Oe,xn,pt.engine),Oe},this.getOS=function(){var Oe={};return Oe[H]=z,Oe[F]=z,Sn.call(Oe,xn,pt.os),tt&&!Oe[H]&&yn&&yn.platform&&yn.platform!="Unknown"&&(Oe[H]=yn.platform.replace(/chrome os/i,wt).replace(/macos/i,Ht)),Oe},this.getResult=function(){return{ua:this.getUA(),browser:this.getBrowser(),engine:this.getEngine(),os:this.getOS(),device:this.getDevice(),cpu:this.getCPU()}},this.getUA=function(){return xn},this.setUA=function(Oe){return xn=typeof Oe===R&&Oe.length>500?Tn(Oe,500):Oe,this},this.setUA(xn),this};qt.VERSION="1.0.40",qt.BROWSER=on([H,F,B]),qt.CPU=on([Y]),qt.DEVICE=on([P,O,C,ae,te,fe,oe,ue,Z]),qt.ENGINE=qt.OS=on([H,F]),typeof x!==j?(g.exports&&(x=g.exports=qt),x.UAParser=qt):k.amdO?(N=(function(){return qt}).call(x,k,x,g))===z||(g.exports=N):typeof E!==j&&(E.UAParser=qt);var Ye=typeof E!==j&&(E.jQuery||E.Zepto);if(Ye&&!Ye.ua){var ht=new qt;Ye.ua=ht.getResult(),Ye.ua.get=function(){return ht.getUA()},Ye.ua.set=function(Et){ht.setUA(Et);var cn=ht.getResult();for(var jt in cn)Ye.ua[jt]=cn[jt]}}})(typeof window=="object"?window:this)},893:()=>{},74:()=>{},281:()=>{},244:()=>{},556:()=>{},817:()=>{},590:()=>{},857:()=>{},78:()=>{},905:()=>{},637:()=>{},279:()=>{},222:()=>{},53:()=>{}},i={};function p(g){var x=i[g];if(x!==void 0)return x.exports;var k=i[g]={id:g,loaded:!1,exports:{}};return a[g].call(k.exports,k,k.exports,p),k.loaded=!0,k.exports}p.amdD=function(){throw new Error("define cannot be used indirect")},p.amdO={},p.n=g=>{var x=g&&g.__esModule?()=>g.default:()=>g;return p.d(x,{a:x}),x},p.d=(g,x)=>{for(var k in x)p.o(x,k)&&!p.o(g,k)&&Object.defineProperty(g,k,{enumerable:!0,get:x[k]})},p.g=function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}}(),p.o=(g,x)=>Object.prototype.hasOwnProperty.call(g,x),p.r=g=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},p.nmd=g=>(g.paths=[],g.children||(g.children=[]),g);var f={};return(()=>{var vh,Sl,qH,si,Yg,Ug,JH;p.r(f),p.d(f,{captureSelfie:()=>Lbe,cropAndValidateFace:()=>Wbe,stop:()=>X1,version:()=>Rbe,withConfig:()=>jbe});var g={};p.r(g),p.d(g,{assertParamsValid:()=>DI,computeFlatOffset:()=>OI,computeOutShape:()=>s4,getNormalizedAxes:()=>A4,isSliceContinous:()=>zI,maskToAxes:()=>Wv,parseSliceParams:()=>jv,sliceInfo:()=>PI,startForAxis:()=>d4,startIndicesWithElidedDims:()=>l4,stopForAxis:()=>p4,stopIndicesWithElidedDims:()=>u4,stridesForAxis:()=>c4,stridesWithElidedDims:()=>a4});var x={};p.r(x),p.d(x,{collectGatherOpShapeInfo:()=>WS,computeOutShape:()=>U4,segOpComputeOptimalWindowSize:()=>Y4});var k={};p.r(k),p.d(k,{ERF_A1:()=>SS,ERF_A2:()=>NS,ERF_A3:()=>TS,ERF_A4:()=>MS,ERF_A5:()=>ES,ERF_P:()=>IS,PARALLELIZE_THRESHOLD:()=>vS,SELU_SCALE:()=>ux,SELU_SCALEALPHA:()=>lx,applyActivation:()=>rx,assertAndGetBroadcastShape:()=>Bn,assertAxesAreInnerMostDims:()=>ia,assertParamsConsistent:()=>bS,assignToTypedArray:()=>H4,axesAreInnerMostDims:()=>XI,calculateShapes:()=>Hm,checkEinsumDimSizes:()=>BS,combineLocations:()=>v4,complexWithEvenIndex:()=>W4,complexWithOddIndex:()=>j4,computeConv2DInfo:()=>Vs,computeConv3DInfo:()=>Au,computeDefaultPad:()=>LI,computeDilation2DInfo:()=>Sm,computeOptimalWindowSize:()=>Ax,computeOutAndReduceShapes:()=>Xs,computeOutShape:()=>SA,computePool2DInfo:()=>bi,computePool3DInfo:()=>ul,convertConv2DDataFormat:()=>cl,decodeEinsumEquation:()=>OS,eitherStridesOrDilationsAreOne:()=>oa,expandShapeToKeepDim:()=>us,exponent:()=>V4,exponents:()=>G4,fromStringArrayToUint8:()=>Q4,fromUint8ToStringArray:()=>Lc,getAxesPermutation:()=>cs,getBroadcastDims:()=>Sp,getComplexWithIndex:()=>DS,getEinsumComputePath:()=>FS,getEinsumPermutation:()=>PS,getFusedBiasGradient:()=>nx,getFusedDyActivation:()=>tx,getImageCenter:()=>xS,getInnerMostAxes:()=>bs,getPermuted:()=>Wm,getReductionAxes:()=>Ms,getReshaped:()=>Rm,getReshapedPermuted:()=>jm,getSliceBeginCoords:()=>wS,getSliceSize:()=>kS,getUndoAxesPermutation:()=>Np,isIdentityPermutation:()=>LS,log:()=>vo,mergeRealAndImagArrays:()=>fl,prepareAndValidate:()=>CS,prepareSplitSize:()=>RS,segment_util:()=>x,shouldFuse:()=>sx,slice_util:()=>g,splitRealAndImagArrays:()=>R4,tupleValuesAreOne:()=>lu,upcastType:()=>Uo,validateInput:()=>L4,validateUpdateShape:()=>F4,warn:()=>Zr});var N={};p.r(N),p.d(N,{json:()=>Are});var E={};p.r(E),p.d(E,{json:()=>lre});var z={};p.r(z),p.d(z,{json:()=>ure});var G={};p.r(G),p.d(G,{json:()=>cre});var j={};p.r(j),p.d(j,{json:()=>dre});var M={};p.r(M),p.d(M,{json:()=>pre});var R={};p.r(R),p.d(R,{json:()=>hre});var B={};p.r(B),p.d(B,{json:()=>fre});var P={};p.r(P),p.d(P,{json:()=>mre});var H={};p.r(H),p.d(H,{json:()=>gre});var C={};p.r(C),p.d(C,{json:()=>yre});var O={};p.r(O),p.d(O,{json:()=>bre});var F={};p.r(F),p.d(F,{json:()=>vre});var Y={};p.r(Y),p.d(Y,{json:()=>xre});var ae={};p.r(ae),p.d(ae,{json:()=>wre});var te={};p.r(te),p.d(te,{json:()=>kre});var oe={};p.r(oe),p.d(oe,{json:()=>Cre});var fe={};p.r(fe),p.d(fe,{json:()=>Ire});var ue={};p.r(ue),p.d(ue,{json:()=>Sre});var Z={};p.r(Z),p.d(Z,{mx:()=>gL,XI:()=>$3,Nk:()=>kL,YG:()=>CL,hH:()=>IL,z3:()=>TL,sG:()=>EL,uM:()=>zL,vS:()=>BL,qB:()=>FL,GG:()=>LL,lg:()=>WL,rq:()=>RL,cu:()=>HL,WR:()=>jL,GE:()=>GL,px:()=>VL,jC:()=>XL,He:()=>YL,hE:()=>UL,BF:()=>_3,Dk:()=>KL,cl:()=>qL,_B:()=>_L,qy:()=>e6,Zy:()=>t6,zv:()=>tse,dH:()=>bL,HS:()=>wL,yH:()=>s6,l3:()=>a6,z9:()=>aN,x6:()=>Hie,eW:()=>o6,GK:()=>i6,SP:()=>A6,f6:()=>l6,dl:()=>OL,Dw:()=>u6,xT:()=>d6,_X:()=>q3,wz:()=>h6});var ye={};p.r(ye),p.d(ye,{json:()=>Age});var pe={};p.r(pe),p.d(pe,{json:()=>lge});var Q={};p.r(Q),p.d(Q,{json:()=>uge});var ke={};p.r(ke),p.d(ke,{json:()=>cge});var ie={};p.r(ie),p.d(ie,{json:()=>dge});var Ie={};p.r(Ie),p.d(Ie,{json:()=>pge});var je={};p.r(je),p.d(je,{json:()=>hge});var xe={};p.r(xe),p.d(xe,{json:()=>fge});var We={};p.r(We),p.d(We,{json:()=>mge});var Ke={};p.r(Ke),p.d(Ke,{json:()=>gge});var ut={};p.r(ut),p.d(ut,{json:()=>yge});var ge={};p.r(ge),p.d(ge,{json:()=>bge});var Qe={};p.r(Qe),p.d(Qe,{json:()=>vge});var At={};p.r(At),p.d(At,{json:()=>xge});var dt={};p.r(dt),p.d(dt,{json:()=>wge});var It={};p.r(It),p.d(It,{json:()=>kge});var Ft={};p.r(Ft),p.d(Ft,{json:()=>Cge});var pn={};p.r(pn),p.d(pn,{json:()=>Ige});var Yt={};p.r(Yt),p.d(Yt,{json:()=>Sge});class wt{}qs(wt,"VERSION","4.1.0"),qs(wt,"STATIC_ASSETS_BASE_URL","https://makeup.sdk.orbo.ai/"),qs(wt,"ASSETS_BASE_URL","./smart-capture/");class Ht{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Wt{refCount(e){return on("refCount")}incRef(e){return on("incRef")}timerAvailable(){return!0}time(e){return on("time")}read(e){return on("read")}readSync(e){return on("readSync")}numDataIds(){return on("numDataIds")}disposeData(e,t){return on("disposeData")}write(e,t,r){return on("write")}move(e,t,r,s,o){return on("move")}memory(){return on("memory")}floatPrecision(){return on("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return on("dispose")}}function on(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Rt(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,Sn(n,e,t)}function Mt(n,e,t){return Math.max(n,Math.min(e,t))}function Tn(n){return n%2==0?n:n+1}function Sn(n,e,t){const r=n[e];n[e]=n[t],n[t]=r}function J(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function gn(n,e,t=""){J(ht(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function rr(n){J(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function qt(n,e=[],t=!1){if(e==null&&(e=[]),Array.isArray(n)||mt(n)&&!t)for(let r=0;r<n.length;++r)qt(n[r],e,t);else e.push(n);return e}function Ye(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function ht(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function Et(n){return n%1==0}function cn(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function jt(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function xn(n,e=r=>0,t){return new Promise((r,s)=>{let o=0;const A=()=>{if(n())return void r();o++;const u=e(o);setTimeout(A,u)};A()})}function yn(n,e){let t=1,r=-1;for(let o=0;o<n.length;++o)if(n[o]>=0)t*=n[o];else if(n[o]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${o}`);r=o}else if(n[o]<0)throw Error(`Shapes can not be < 0. Found ${n[o]} at dim ${o}`);if(r===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!=0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const s=n.slice();return s[r]=e/t,s}function pt(n,e){const t=e.length;return J((n=n==null?e.map((r,s)=>s):[].concat(n)).every(r=>r>=-t&&r<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),J(n.every(r=>Et(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?t+r:r)}function tt(n,e){const t=[],r=[],s=e!=null&&Array.isArray(e)&&e.length===0,o=e==null||s?null:pt(e,n).sort();let A=0;for(let u=0;u<n.length;++u){if(o!=null){if(o[A]===u&&n[u]!==1)throw new Error(`Can't squeeze axis ${u} since its dim '${n[u]}' is not 1`);(o[A]==null||o[A]>u)&&n[u]===1&&(t.push(n[u]),r.push(u)),o[A]<=u&&A++}n[u]!==1&&(t.push(n[u]),r.push(u))}return{newShape:t,keptDims:r}}function Oe(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else{if(n!=="bool")throw new Error(`Unknown data type ${n}`);t=new Uint8Array(e)}return t}function Tt(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else{if(n!=="string")throw new Error(`Unknown data type ${n}`);t=new Array(e)}return t}function nn(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function mt(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array}function Dt(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function rn(n){return typeof n=="string"||n instanceof String}function Gn(n){return typeof n=="number"}function kt(n){return Array.isArray(n)?kt(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array?"int32":Gn(n)?"float32":rn(n)?"string":typeof n=="boolean"?"bool":"float32"}function Ba(n){return!!(n&&n.constructor&&n.call&&n.apply)}function ba(n,e){for(let t=e;t<n;++t)if(n%t==0)return t;return n}function Je(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let r=e-3;r>=0;--r)t[r]=t[r+1]*n[r+1];return t}function bn(n,e,t,r=!1){const s=new Array;if(e.length===1){const o=e[0]*(r?2:1);for(let A=0;A<o;A++)s[A]=t[n+A]}else{const o=e[0],A=e.slice(1),u=A.reduce((h,l)=>h*l)*(r?2:1);for(let h=0;h<o;h++)s[h]=bn(n+h*u,A,t,r)}return s}function vr(n,e,t=!1){if(n.length===0)return e[0];const r=n.reduce((s,o)=>s*o)*(t?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return bn(0,n,e,t)}function kn(n,e){const t=Mr(n,e);for(let r=0;r<t.length;r++)t[r]=1;return t}function Mr(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function Ss(n,e){const t=n.reduce((r,s)=>r*s,1);if(e==null||e==="float32")return vr(n,new Float32Array(t));if(e==="int32")return vr(n,new Int32Array(t));if(e==="bool")return vr(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function Xo(n){n.forEach(e=>{J(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function ms(n,e,t){if(e===0)return 0;if(e===1)return n[0];let r=n[n.length-1];for(let s=0;s<n.length-1;++s)r+=t[s]*n[s];return r}function is(n,e,t){if(e===0)return[];if(e===1)return[n];const r=new Array(e);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(n/t[s]),n-=r[s]*t[s];return r[r.length-1]=n,r}function Nn(n){return n&&n.then&&typeof n.then=="function"}function Zr(...n){st().getBool("IS_TEST")||st().getBool("PROD")||console.warn(...n)}function vo(...n){st().getBool("IS_TEST")||st().getBool("PROD")||console.log(...n)}const As="tfjsflags";class Er{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=mi,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&Zr(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`),this.platformName=e,this.platform=t}registerFlag(e,t,r){if(this.flagRegistry[e]={evaluationFn:t,setHook:r},this.urlFlags[e]!=null){const s=this.urlFlags[e];Zr(`Setting feature override from URL ${e}: ${s}.`),this.set(e,s)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Nn(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(this.global===void 0||this.global.location===void 0||this.global.location.search===void 0)return;const e=this.getQueryParams(this.global.location.search);As in e&&e[As].split(",").forEach(t=>{const[r,s]=t.split(":");this.urlFlags[r]=function(o,A){if((A=A.toLowerCase())==="true"||A==="false")return A==="true";if(""+ +A===A)return+A;throw new Error(`Could not parse value flag value ${A} for flag ${o}.`)}(r,s)})}}function mi(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...r)=>(function(s,o,A){s[decodeURIComponent(o)]=decodeURIComponent(A||"")}(e,r[0],r[1]),r.join("="))),e}function st(){return Lr}let gi,Lr=null;function vA(){if(gi==null){let n;if(typeof window<"u")n=window;else if(p.g!==void 0)n=p.g;else if(typeof process<"u")n=process;else{if(typeof self>"u")throw new Error("Could not find a global object");n=self}gi=n}return gi}function na(n,e){const t=function(){const r=vA();return r._tfGlobals==null&&(r._tfGlobals=new Map),r._tfGlobals}();if(t.has(n))return t.get(n);{const r=e();return t.set(n,r),t.get(n)}}const sl="Abs",Hi="Acos",ve="Acosh",be="Add",Le="AddN",at="All",lt="Any",ct="ArgMax",St="ArgMin",nt="Asin",Ot="Asinh",Pt="Atan",Bt="Atanh",Pn="Atan2",Zn="AvgPool",Rr="AvgPoolGrad",$r="AvgPool3D",gs="AvgPool3DGrad",sr="BatchMatMul",vn="BatchToSpaceND",va="Bincount",Gi="BroadcastArgs",ra="Cast",Wr="Ceil",xa="ClipByValue",Fa="Complex",$="ComplexAbs",ne="Concat",Ce="Conv2D",He="Conv2DBackpropFilter",_e="Conv2DBackpropInput",$e="Conv3D",xt="Conv3DBackpropFilterV2",sn="Conv3DBackpropInputV2",Cn="Cos",ar="Cosh",Jn="Cumsum",Ja="CropAndResize",xo="DenseBincount",Zo="DepthToSpace",xA="DepthwiseConv2dNative",Vi="DepthwiseConv2dNativeBackpropFilter",sa="DepthwiseConv2dNativeBackpropInput",wA="Diag",wo="Dilation2D",al="Dilation2DBackpropInput",xc="Dilation2DBackpropFilter",ol="RealDiv",_l="Einsum",Yo="Elu",zC="EluGrad",Hf="Erf",H0="Equal",Gf="Exp",G0="ExpandDims",Vf="Expm1",OC="FFT",PC="Fill",BC="FlipLeftRight",Xf="Floor",Zf="FloorDiv",V0="FusedBatchNorm",X0="GatherV2",FC="GatherNd",Z0="Greater",Yf="GreaterEqual",Uf="Identity",LC="IFFT",RC="Imag",Qf="IsFinite",Kf="IsInf",qf="IsNan",Y0="LeakyRelu",U0="Less",Q0="LessEqual",WC="LinSpace",Jf="Log",$f="Log1p",K0="LogicalAnd",q0="LogicalNot",J0="LogicalOr",$0="LRN",jC="LRNGrad",_0="Max",_f="Maximum",ev="MaxPool",HC="MaxPoolGrad",tv="MaxPool3D",GC="MaxPool3DGrad",VC="MaxPoolWithArgmax",nv="Mean",rv="Min",em="Minimum",sv="MirrorPad",tm="Mod",XC="Multinomial",nm="Multiply",av="Neg",ov="NotEqual",ZC="NonMaxSuppressionV3",YC="NonMaxSuppressionV4",UC="NonMaxSuppressionV5",iv="OnesLike",Av="OneHot",lv="Pack",uv="PadV2",rm="Pow",cv="Prelu",QC="Prod",KC="Range",qC="Real",sm="Reciprocal",am="Relu",dv="Reshape",pv="ResizeNearestNeighbor",JC="ResizeNearestNeighborGrad",hv="ResizeBilinear",$C="ResizeBilinearGrad",om="Relu6",fv="Reverse",im="Round",Am="Rsqrt",_C="ScatterNd",mv="Select",lm="Selu",gv="Slice",um="Sin",cm="Sinh",dm="Sign",pm="Sigmoid",hm="Softplus",fm="Sqrt",yv="Sum",bv="SpaceToBatchND",vv="SplitV",xv="Softmax",eI="SparseFillEmptyRows",tI="SparseReshape",nI="SparseSegmentMean",rI="SparseSegmentSum",sI="SparseToDense",mm="SquaredDifference",aI="Square",oI="StridedSlice",iI="StringNGrams",AI="StringSplit",lI="StringToHashBucketFast",gm="Sub",ym="Tan",bm="Tanh",vm="Tile",uI="TopK",cI="Transform",wv="Transpose",dI="Unique",kv="Unpack",Cv="UnsortedSegmentSum",Iv="ZerosLike",xm="Step",pI="FromPixels",hI="RotateWithOffset",Sv="_FusedMatMul",Nv="FusedConv2D",Tv="FusedDepthwiseConv2D",Mv=na("kernelRegistry",()=>new Map),fI=na("gradRegistry",()=>new Map);function mI(n,e){const t=k7(n,e);return Mv.get(t)}function v7(n){return fI.get(n)}function x7(n){const e=Mv.entries(),t=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[o,A]=s,[u]=o.split("_");u===n&&t.push(A)}return t}function w7(n){const{kernelName:e,backendName:t}=n,r=k7(e,t);Mv.has(r)&&Zr(`The kernel '${e}' for backend '${t}' is already registered`),Mv.set(r,n)}function V_(n){const{kernelName:e}=n;fI.has(e)&&st().getBool("DEBUG")&&Zr(`Overriding the gradient for '${e}'`),fI.set(e,n)}function k7(n,e){return`${e}_${n}`}var gI=p(570),C7=p.n(gI);const wc=C7()||gI;function Ev(n){return wc.fromString(n,!0,16)}const I7=Ev("c3a5c85c97cb3127"),kc=Ev("b492b66fbe98f273"),La=Ev("9ae16a3b2f90404f");function yI(n){return n.xor(n.shru(47))}function S7(n,e,t){const r=n.slice(e,e+t);return wc.fromBytes(Array.from(r),!0,!0)}function Sr(n,e){return S7(n,e,8)}function N7(n,e){return S7(n,e,4)}function Hs(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function eu(n,e,t=Ev("9ddfea08eb382d69")){let r=n.xor(e).mul(t);r=r.xor(r.shru(47));let s=e.xor(r).mul(t);return s=s.xor(s.shru(47)),s=s.mul(t),s}function Dv(n,e,t,r){return function(s,o,A,u,h,l){h=h.add(s),l=Hs(l.add(h).add(u),21);const c=h;return h=(h=h.add(o)).add(A),l=l.add(Hs(h,44)),[h.add(u),l.add(c)]}(Sr(n,e),Sr(n,e+8),Sr(n,e+16),Sr(n,e+24),t,r)}function X_(n,e=n.length){const t=wc.fromNumber(81,!0);if(e<=32)return e<=16?function(m,y=m.length){if(y>=8){const b=La.add(2*y),v=Sr(m,0).add(La),w=Sr(m,y-8);return eu(Hs(w,37).mul(b).add(v),Hs(v,25).add(w).mul(b),b)}if(y>=4){const b=La.add(2*y);return eu(N7(m,0).shl(3).add(y),N7(m,y-4),b)}if(y>0){const b=m[0]+(m[y>>1]<<8),v=y+(m[y-1]<<2);return yI(La.mul(b).xor(I7.mul(v))).mul(La)}return La}(n,e):function(m,y=m.length){const b=La.add(2*y),v=Sr(m,0).mul(kc),w=Sr(m,8),I=Sr(m,y-8).mul(b),S=Sr(m,y-16).mul(La);return eu(Hs(v.add(w),43).add(Hs(I,30)).add(S),v.add(Hs(w.add(La),18)).add(I),b)}(n,e);if(e<=64)return function(m,y=m.length){const b=La.add(2*y),v=Sr(m,0).mul(La),w=Sr(m,8),I=Sr(m,y-8).mul(b),S=Sr(m,y-16).mul(La),T=Hs(v.add(w),43).add(Hs(I,30)).add(S),D=eu(T,v.add(Hs(w.add(La),18)).add(I),b),L=Sr(m,16).mul(b),W=Sr(m,24),K=T.add(Sr(m,y-32)).mul(b),U=D.add(Sr(m,y-24)).mul(b);return eu(Hs(L.add(W),43).add(Hs(K,30)).add(U),L.add(Hs(W.add(v),18)).add(K),b)}(n,e);let r=t,s=t.mul(kc).add(113),o=yI(s.mul(La).add(113)).mul(La),A=[wc.UZERO,wc.UZERO],u=[wc.UZERO,wc.UZERO];r=r.mul(La).add(Sr(n,0));let h=0;const l=64*(e-1>>6),c=l+(e-1&63)-63;do r=Hs(r.add(s).add(A[0]).add(Sr(n,h+8)),37).mul(kc),s=Hs(s.add(A[1]).add(Sr(n,h+48)),42).mul(kc),r=r.xor(u[1]),s=s.add(A[0]).add(Sr(n,h+40)),o=Hs(o.add(u[0]),33).mul(kc),A=Dv(n,h,A[1].mul(kc),r.add(u[0])),u=Dv(n,h+32,o.add(u[1]),s.add(Sr(n,h+16))),[o,r]=[r,o],h+=64;while(h!==l);const d=kc.add(o.and(255).shl(1));return h=c,u[0]=u[0].add(e-1&63),A[0]=A[0].add(u[0]),u[0]=u[0].add(A[0]),r=Hs(r.add(s).add(A[0]).add(Sr(n,h+8)),37).mul(d),s=Hs(s.add(A[1]).add(Sr(n,h+48)),42).mul(d),r=r.xor(u[1].mul(9)),s=s.add(A[0].mul(9).add(Sr(n,h+40))),o=Hs(o.add(u[0]),33).mul(d),A=Dv(n,h,A[1].mul(d),r.add(u[0])),u=Dv(n,h+32,o.add(u[1]),s.add(Sr(n,h+16))),[o,r]=[r,o],eu(eu(A[0],u[0],d).add(yI(s).mul(I7)).add(o),eu(A[1],u[1],d).add(r),d)}function tu(n,e){return e==="string"?nu(n):Cc([n],e)}function Cc(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=qt(n)),st().getBool("DEBUG")&&function(t,r){for(let s=0;s<t.length;s++){const o=t[s];if(isNaN(o)||!isFinite(o))throw Error(`A tensor of type ${r} being uploaded contains ${o}.`)}}(n,e),function(t,r){return t instanceof Float32Array&&r==="float32"||t instanceof Int32Array&&r==="int32"||t instanceof Uint8Array&&r==="bool"}(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let r=0;r<t.length;++r)Math.round(n[r])!==0&&(t[r]=1);return t}throw new Error(`Unknown data type ${e}`)}function $a(){return st().platform.now()}function nu(n,e="utf-8"){return e=e||"utf-8",st().platform.encode(n,e)}function yp(n,e="utf-8"){return e=e||"utf-8",st().platform.decode(n,e)}class Z_{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new U_)}profileKernel(e,t,r){let s;const o=()=>{s=r()};let A;const u=$a();if(this.backendTimer.timerAvailable())A=this.backendTimer.time(o);else{o();for(const h of s)h.dataSync();A=Promise.resolve({kernelMs:$a()-u})}if(st().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let h=0;h<s.length;h++){const l=s[h];l.data().then(c=>{Y_(c,l.dtype,e)})}return{kernelName:e,outputs:s,inputs:t,timeMs:A.then(h=>h.kernelMs),extraInfo:A.then(h=>h.getExtraProfileInfo!=null?h.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:r,timeMs:s,inputs:o,extraInfo:A}=e;r.forEach(u=>{Promise.all([u.data(),s,A]).then(h=>{this.logger.logKernelProfile(t,u,h[0],h[1],o,h[2])})})}}function Y_(n,e,t){if(e!=="float32")return!1;for(let r=0;r<n.length;r++){const s=n[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${t}'`),!0}return!1}class U_{logKernelProfile(e,t,r,s,o,A){const u=typeof s=="number"?jt(`${s}ms`,9):s.error,h=jt(e,25),l=t.rank,c=t.size,d=jt(t.shape.toString(),14);let m="";for(const y in o){const b=o[y];if(b!=null){const v=b.shape||t.shape,w=v.length;m+=`${y}: ${w}D ${w>0?v:""} `}}console.log(`%c${h}	%c${u}	%c${l}D ${d}	%c${c}	%c${m}	%c${A}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function Q_(n,e,t,r){const s=Je(e),o=function(l,c,d,m){const y=Ye(c),b=m[m.length-1],v=new Array(b).fill(0),w=c.length,I=d==="complex64"?km(l):l;if(w>1)for(let S=0;S<y/b;S++){const T=S*b;for(let D=0;D<b;D++)v[D]=Math.max(v[D],wm(I[T+D],0,d).length)}return v}(n,e,t,s),A=e.length,u=zv(n,e,t,s,o),h=["Tensor"];return r&&(h.push(`  dtype: ${t}`),h.push(`  rank: ${A}`),h.push(`  shape: [${e}]`),h.push("  values:")),h.push(u.map(l=>"    "+l).join(`
`)),h.join(`
`)}function wm(n,e,t){let r;return r=Array.isArray(n)?`${parseFloat(n[0].toFixed(7))} + ${parseFloat(n[1].toFixed(7))}j`:rn(n)?`'${n}'`:t==="bool"?T7(n):parseFloat(n.toFixed(7)).toString(),jt(r,e)}function T7(n){return n===0?"false":"true"}function zv(n,e,t,r,s,o=!0){const A=t==="complex64"?2:1,u=e[0],h=e.length;if(h===0)return t==="complex64"?[wm(km(n)[0],0,t)]:t==="bool"?[T7(n[0])]:[n[0].toString()];if(h===1){if(u>20){const v=3*A;let w=Array.from(n.slice(0,v)),I=Array.from(n.slice((u-3)*A,u*A));return t==="complex64"&&(w=km(w),I=km(I)),["["+w.map((S,T)=>wm(S,s[T],t)).join(", ")+", ..., "+I.map((S,T)=>wm(S,s[u-3+T],t)).join(", ")+"]"]}return["["+(t==="complex64"?km(n):Array.from(n)).map((v,w)=>wm(v,s[w],t)).join(", ")+"]"]}const l=e.slice(1),c=r.slice(1),d=r[0]*A,m=[];if(u>20){for(let v=0;v<3;v++){const w=v*d,I=w+d;m.push(...zv(n.slice(w,I),l,t,c,s,!1))}m.push("...");for(let v=u-3;v<u;v++){const w=v*d,I=w+d;m.push(...zv(n.slice(w,I),l,t,c,s,v===u-1))}}else for(let v=0;v<u;v++){const w=v*d,I=w+d;m.push(...zv(n.slice(w,I),l,t,c,s,v===u-1))}const y=h===2?",":"";m[0]="["+m[0]+y;for(let v=1;v<m.length-1;v++)m[v]=" "+m[v]+y;let b=`,
`;for(let v=2;v<h;v++)b+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(o?"":b),m}function km(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}class Gs{constructor(e,t,r){if(this.dtype=t,this.shape=e.slice(),this.size=Ye(e),r!=null){const s=r.length;J(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Tt(t,this.size),this.strides=Je(e)}set(e,...t){t.length===0&&(t=[0]),J(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const r=this.locToIndex(t);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const s of e){if(s<0||s>=this.shape[t]){const o=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(o)}t++}let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=this.strides[s]*e[s];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let r=0;r<e.length-1;++r)t+=this.strides[r]*e[r];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let r=0;r<t.length-1;++r)t[r]=Math.floor(e/this.strides[r]),e-=t[r]*this.strides[r];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return kA().makeTensor(this.values,this.shape,this.dtype)}}let kA=null,bp=null;class ls{constructor(e,t,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Ye(e),this.strides=Je(e),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return bp.buffer(this.shape,this.dtype,e)}bufferSync(){return bp.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return vr(this.shape,e,this.dtype==="complex64")}arraySync(){return vr(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=kA().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(r=>yp(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataSync(){this.throwIfDisposed();const e=kA().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>yp(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await kA().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(kA().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return bp.print(this,e)}clone(){return this.throwIfDisposed(),bp.clone(this)}toString(e=!1){return Q_(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),bp.cast(this,e)}variable(e=!0,t,r){return this.throwIfDisposed(),kA().makeVariable(this,e,t,r)}}function rt(){return na("Tensor",()=>ls)}Object.defineProperty(ls,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null}),rt();class Ov extends ls{constructor(e,t,r,s){super(e.shape,e.dtype,e.dataId,s),this.trainable=t,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!ht(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);kA().disposeTensor(this),this.dataId=e.dataId,kA().incRef(this,null)}dispose(){kA().disposeVariable(this),this.isDisposedInternal=!0}}var M7,Ic,bI,Pv,vI,Bv,xI,Fv,wI,Lv;Object.defineProperty(Ov,Symbol.hasInstance,{value:n=>n instanceof ls&&n.assign!=null&&n.assign instanceof Function}),(Ic=M7||(M7={})).R0="R0",Ic.R1="R1",Ic.R2="R2",Ic.R3="R3",Ic.R4="R4",Ic.R5="R5",Ic.R6="R6",(Pv=bI||(bI={})).float32="float32",Pv.int32="int32",Pv.bool="int32",Pv.complex64="complex64",(Bv=vI||(vI={})).float32="float32",Bv.int32="int32",Bv.bool="bool",Bv.complex64="complex64",(Fv=xI||(xI={})).float32="float32",Fv.int32="float32",Fv.bool="float32",Fv.complex64="complex64",(Lv=wI||(wI={})).float32="complex64",Lv.int32="complex64",Lv.bool="complex64",Lv.complex64="complex64";const K_={float32:xI,int32:bI,bool:vI,complex64:wI};function Uo(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return K_[n][e]}function kI(n){return Uo(n,"int32")}function _r(n,e){if(n.dtype===e.dtype)return[n,e];const t=Uo(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function E7(n){const e=[];return D7(n,e,new Set),e}function D7(n,e,t){if(n==null)return;if(n instanceof ls)return void e.push(n);if(r=n,!Array.isArray(r)&&typeof r!="object")return;var r;const s=n;for(const o in s){const A=s[o];t.has(A)||(t.add(A),D7(A,e,t))}}function CI(n){return n.kernelName!=null}class z7{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class vp{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new z7}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t];if(await this.initializeBackend(r).success)return void await this.setBackend(r)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,r=1){return e in this.registryFactory?(Zr(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:r}=this.initializeBackend(e);if(!(r?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Z_(this.backendInstance),!0}setupRegisteredKernels(){x7(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){x7(e).forEach(t=>{t.disposeFunc!=null&&t.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=t.factory();if(!r||r instanceof Wt||typeof r.then!="function")return this.registry[e]=r,{success:!0,asyncInit:!1};{const s=++this.pendingBackendInitId,o=r.then(A=>!(s<this.pendingBackendInitId||(this.registry[e]=A,this.pendingBackendInit=null,0))).catch(A=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,Zr(`Initialization of backend ${e} failed`),Zr(A.stack||A.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}}catch(r){return Zr(`Initialization of backend ${e} failed`),Zr(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t],{success:s,asyncInit:o}=this.initializeBackend(r);if(o||s)return{name:r,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const r=this.state.tensorInfo.get(t),s=r.backend,o=this.readSync(t),A=s.refCount(t);s.disposeData(t,!0),r.backend=e,e.move(t,o,r.shape,r.dtype,A),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let r,s=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,r){e();try{const s=r();return t(),s}catch(s){throw t(),s}}nextTensorId(){return vp.nextTensorId++}nextVariableId(){return vp.nextVariableId++}clone(e){const t=Ne.runKernel(Uf,{x:e}),r={x:e};return this.addTapeNode(this.state.activeScope.name,r,[t],s=>({x:()=>{const o={x:s};return Ne.runKernel(ra,o,{dtype:"float32"})}}),[],{}),t}runKernel(e,t,r){if(this.backendName==null&&this.backend,mI(e,this.backendName)==null)throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,r){const s=this.backend.numDataIds();let o=0;r.forEach(h=>{o+=h.dtype==="complex64"?3:1});const A=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],u=s-t-o-A;if(u>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${u} data ids) after running '${e}'`)}runKernelFunc(e){let t,r=[];const s=this.isTapeOn(),o=this.state.numBytes,A=this.state.numTensors;let u,h;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),this.backendName==null&&this.backend;const l=CI(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(CI(e)){const{kernelName:b,inputs:v,attrs:w}=e;this.backendName==null&&this.backend;const I=mI(b,this.backendName);J(I!=null,()=>`Cannot find registered kernel '${b}' for backend '${this.backendName}'`),u=()=>{const S=this.backend.numDataIds();h=I.kernelFunc({inputs:v,attrs:w,backend:this.backend});const T=Array.isArray(h)?h:[h];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(b,S,T);const D=T.map(L=>{if(L.rank!=null)return L;const{dataId:W,shape:K,dtype:U}=L;return this.makeTensorFromDataId(W,K,U)});if(s){const L=this.getTensorsForGradient(b,v,D);r=this.saveTensorsForBackwardMode(L)}return D}}else{const{forwardFunc:b}=e,v=w=>{s&&(r=w.map(I=>this.keep(this.clone(I))))};u=()=>{const w=this.backend.numDataIds();h=this.tidy(()=>b(this.backend,v));const I=Array.isArray(h)?h:[h];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,w,I),I}}const{inputs:c,attrs:d}=e,m=CI(e)?null:e.backwardsFunc;let y;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(y=this.profiler.profileKernel(l,c,()=>u()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(y),t=y.outputs):t=u()}),s&&this.addTapeNode(l,c,t,m,r,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-A,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(b=>c[b]!=null?c[b].shape:null),outputShapes:t.map(b=>b.shape),kernelTimeMs:y.timeMs,extraInfo:y.extraInfo}),Array.isArray(h)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(t=>this.keep(this.clone(t)))}getTensorsForGradient(e,t,r){const s=v7(e);if(s!=null){const o=s.inputsToSave||[],A=s.outputsToSave||[];let u;s.saveAllInputs?(J(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),u=Object.keys(t).map(l=>t[l])):u=o.map(l=>t[l]);const h=r.filter((l,c)=>A[c]);return u.concat(h)}return[]}makeTensor(e,t,r,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let o=e;r==="string"&&rn(e[0])&&(o=e.map(h=>nu(h)));const A=s.write(o,t,r),u=new ls(t,r,A,this.nextTensorId());if(this.trackTensor(u,s),r==="string"){const h=this.state.tensorInfo.get(A),l=function(c){if(c==null)return 0;let d=0;return c.forEach(m=>d+=m.length),d}(o);this.state.numBytes+=l-h.bytes,h.bytes=l}return u}makeTensorFromDataId(e,t,r,s){const o=new ls(t,r=r||"float32",e,this.nextTensorId());return this.trackTensor(o,s),o}makeVariable(e,t=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));const o=new Ov(e,t,r,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null)throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*Dt(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof Ov||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*Dt(e.dtype);this.state.numBytes-=r}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,r,s,o,A){const u={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:r,saved:o},h=v7(e);h!=null&&(s=h.gradFunc),s!=null&&(u.gradient=l=>(l=l.map((c,d)=>{if(c==null){const m=r[d],y=Mr(m.size,m.dtype);return this.makeTensor(y,m.shape,m.dtype)}return c}),s(l.length>1?l:l[0],o,A))),this.state.activeTape.push(u)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=E7(e),r=new Set(t.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const A=this.state.activeScope.track[o];A.kept||r.has(A.id)||A.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(o=>{o.kept||o.scopeId!==s.id||this.track(o)})}gradients(e,t,r,s=!1){if(J(t.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));J(o instanceof ls,()=>"The result y returned by f() must be a tensor.");const A=function(u,h,l){const c={},d={};for(let v=0;v<h.length;v++)c[h[v].id]=!0;for(let v=0;v<u.length;v++){const w=u[v],I=w.inputs;for(const S in I){const T=I[S];let D=!1;for(let L=0;L<h.length;L++)if(c[T.id]){w.outputs.forEach(W=>c[W.id]=!0),D=!0,d[w.id]=!0;break}if(D)break}}const m={};m[l.id]=!0;const y={};for(let v=u.length-1;v>=0;v--){const w=u[v],I=w.inputs;for(let S=0;S<w.outputs.length;S++)if(m[w.outputs[S].id]){for(const T in I)m[I[T].id]=!0,y[w.id]=!0;break}}const b=[];for(let v=0;v<u.length;v++){const w=u[v];if(d[w.id]&&y[w.id]){const I={};for(const T in w.inputs){const D=w.inputs[T];c[D.id]&&(I[T]=D)}const S=Object.assign({},w);S.inputs=I,S.outputs=w.outputs,b.push(S)}}return b}(this.state.activeTape,t,o);if(!s&&A.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const u={};u[o.id]=r??function(l){const c=kn(Ye(l),"float32");return Ne.makeTensor(c,l,"float32")}(o.shape),function(l,c,d,m){for(let y=c.length-1;y>=0;y--){const b=c[y],v=[];if(b.outputs.forEach(I=>{const S=l[I.id];S!=null?v.push(S):v.push(null)}),b.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${b.kernelName}.`);const w=b.gradient(v);for(const I in b.inputs){if(!(I in w))throw new Error(`Cannot backprop through input ${I}. Available gradients found: ${Object.keys(w)}.`);const S=d(()=>w[I]());if(S.dtype!=="float32")throw new Error(`Error in gradient for op ${b.kernelName}. The gradient of input ${I} must have 'float32' dtype, but has '${S.dtype}'`);const T=b.inputs[I];if(!ht(S.shape,T.shape))throw new Error(`Error in gradient for op ${b.kernelName}. The gradient of input '${I}' has shape '${S.shape}', which does not match the shape of the input '${T.shape}'`);if(l[T.id]==null)l[T.id]=S;else{const D=l[T.id];l[T.id]=m(D,S),D.dispose()}}}}(u,A,l=>this.tidy(l),q_);const h=t.map(l=>u[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(const c of l.saved)c.dispose()}),this.state.activeTape=null),{value:o,grads:h}})}customGrad(e){return J(Ba(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{let r;J(t.every(o=>o instanceof ls),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const s={};return t.forEach((o,A)=>{s[A]=o}),this.runKernelFunc({forwardFunc:(o,A)=>(r=e(...t,A),J(r.value instanceof ls,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),J(Ba(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),backwardsFunc:(o,A)=>{const u=r.gradFunc(o,A),h=Array.isArray(u)?u:[u];J(h.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),J(h.every(c=>c instanceof ls),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const l={};return h.forEach((c,d)=>{l[d]=()=>c}),l},inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}async time(e){const t=$a(),r=await this.backend.time(e);return r.wallMs=$a()-t,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new z7;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function O7(){const n=vA();if(n._tfengine==null){const t=new Er(n);n._tfengine=new vp(t)}var e;return e=n._tfengine.ENV,Lr=e,kA=()=>n._tfengine,n._tfengine}vp.nextTensorId=0,vp.nextVariableId=0;const Ne=O7();function q_(n,e){const t={a:n,b:e};return Ne.runKernel(be,t)}function P7(n){if(n||typeof navigator<"u"&&navigator!=null){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function B7(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const Xi=st();function Cm(n,e){let t=n;if(mt(n))return e==="string"?[]:[n.length];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(t)||mt(t)&&e!=="string";)r.push(t.length),t=t[0];return Array.isArray(n)&&st().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&F7(n,r,[]),r}function F7(n,e,t){if(t=t||[],!Array.isArray(n)&&!mt(n))return void J(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);J(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),J(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const r=e.slice(1);for(let s=0;s<n.length;++s)F7(n[s],r,t.concat(s))}function L7(n,e,t,r){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${r}' must be ${n} tensor, but got ${e} tensor`)}}function le(n,e,t,r="numeric"){if(n instanceof ls)return L7(r,n.dtype,e,t),n;let s=kt(n);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),L7(r,s,e,t),n==null||!mt(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const u=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${u}'`)}const o=Cm(n,s);mt(n)||Array.isArray(n)||(n=[n]);const A=s!=="string"?Cc(n,s):qt(n,[],!0);return Ne.makeTensor(A,o,s)}function R7(n,e,t,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((s,o)=>le(s,`${e}[${o}]`,t,r))}function De(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const r=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t+="__op";const s=(...o)=>{Ne.startScope(t);try{const A=r(...o);return Nn(A)&&console.error("Cannot return a Promise inside of tidy."),Ne.endScope(A),A}catch(A){throw Ne.endScope(null),A}};return Object.defineProperty(s,"name",{value:t,configurable:!0}),s}Xi.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),Xi.registerFlag("IS_BROWSER",()=>B7()),Xi.registerFlag("IS_NODE",()=>typeof process<"u"&&process.versions!==void 0&&process.versions.node!==void 0),Xi.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),Xi.registerFlag("PROD",()=>!1),Xi.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Xi.getBool("DEBUG")),Xi.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),Xi.registerFlag("IS_TEST",()=>!1),Xi.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),Xi.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);const Sc=De({complex_:function(n,e){const t=le(n,"real","complex"),r=le(e,"imag","complex");gn(t.shape,r.shape,`real and imag shapes, ${t.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:t,imag:r};return Ne.runKernel(Fa,s)}});function Im(n,e,t,r){if(r==null&&(r=kt(n)),r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!mt(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Xo(e);const s=Ye(e),o=Ye(t);J(s===o,()=>`Based on the provided shape, [${e}], the tensor should have ${s} values but has ${o}`);for(let A=0;A<t.length;++A){const u=t[A],h=A!==t.length-1||u!==Ye(e.slice(A));J(t[A]===e[A]||!h,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return mt(n)||Array.isArray(n)||(n=[n]),e=e||t,n=r!=="string"?Cc(n,r):qt(n,[],!0),Ne.makeTensor(n,e,r)}function ru(n,e,t){return Im(n,e,Cm(n,t),t)}const W7={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};async function j7(n,e){const t=[],r=[],s=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<s.length;++o){const A=s[o],u=Array.isArray(n)?n[o].tensor:n[A];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${A}': ${u.dtype}`);const h={name:A,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){const l=new Promise(async c=>{const d=await u.bytes(),m=d.reduce((v,w)=>v+w.length,0)+4*d.length,y=new Uint8Array(m);let b=0;for(let v=0;v<d.length;v++){const w=d[v],I=new Uint8Array(new Uint32Array([w.length]).buffer);y.set(I,b),b+=4,y.set(w,b),b+=w.length}c(y)});r.push(l)}else r.push(u.data());e!=null&&(h.group=e),t.push(h)}return{data:J_(await Promise.all(r)),specs:t}}function J_(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(o=>{if(e+=o.byteLength,t.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const r=new Uint8Array(e);let s=0;return t.forEach(o=>{r.set(new Uint8Array(o.buffer),s),s+=o.byteLength}),r.buffer}const II=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function H7(n){return II?Buffer.byteLength(n):new Blob([n]).size}function G7(n){if(n.length===1)return n[0];let e=0;n.forEach(s=>{e+=s.byteLength});const t=new Uint8Array(e);let r=0;return n.forEach(s=>{t.set(new Uint8Array(s),r),r+=s.byteLength}),t.buffer}function V7(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function Rv(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:H7(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:H7(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:n.weightData.byteLength}}function $_(){const n=function(){const r=o=>{let A=o<<13,u=0;for(;!(8388608&A);)u-=8388608,A<<=1;return A&=-8388609,u+=947912704,A|u},s=new Uint32Array(2048);s[0]=0;for(let o=1;o<1024;o++)s[o]=r(o);for(let o=1024;o<2048;o++)s[o]=939524096+(o-1024<<13);return s}(),e=function(){const r=new Uint32Array(64);r[0]=0,r[31]=1199570944,r[32]=2147483648,r[63]=3347054592;for(let s=1;s<31;s++)r[s]=s<<23;for(let s=33;s<63;s++)r[s]=2147483648+(s-32<<23);return r}(),t=function(){const r=new Uint32Array(64);for(let s=0;s<64;s++)r[s]=1024;return r[0]=r[32]=0,r}();return r=>{const s=new ArrayBuffer(4*r.length),o=new Uint32Array(s);for(let A=0;A<r.length;A++){const u=r[A],h=n[t[u>>10]+(1023&u)]+e[u>>10];o[A]=h}return new Float32Array(s)}}class Ns{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Ns.instance==null&&(Ns.instance=new Ns),Ns.instance}static registerSaveRouter(e){Ns.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Ns.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Ns.getHandlers(e,"save")}static getLoadHandlers(e,t){return Ns.getHandlers(e,"load",t)}static getHandlers(e,t,r){const s=[];return(t==="load"?Ns.getInstance().loadRouters:Ns.getInstance().saveRouters).forEach(o=>{const A=o(e,r);A!==null&&s.push(A)}),s}}const X7=n=>Ns.getSaveHandlers(n),SI="tensorflowjs",Nc="models_store",su="model_info_store";function Z7(){if(!st().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function NI(n){const e=n.result;e.createObjectStore(Nc,{keyPath:"modelPath"}),e.createObjectStore(su,{keyPath:"modelPath"})}class Tc{constructor(e){if(this.indexedDB=Z7(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((r,s)=>{const o=this.indexedDB.open(SI,1);o.onupgradeneeded=()=>NI(o),o.onsuccess=()=>{const A=o.result;if(t==null){const u=A.transaction(Nc,"readonly"),h=u.objectStore(Nc).get(this.modelPath);h.onsuccess=()=>{if(h.result==null)return A.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(h.result.modelArtifacts)},h.onerror=l=>(A.close(),s(h.error)),u.oncomplete=()=>A.close()}else{const u=Rv(t),h=A.transaction(su,"readwrite");let l=h.objectStore(su);const c=l.put({modelPath:this.modelPath,modelArtifactsInfo:u});let d;c.onsuccess=()=>{d=A.transaction(Nc,"readwrite");const m=d.objectStore(Nc).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:u});m.onsuccess=()=>r({modelArtifactsInfo:u}),m.onerror=y=>{l=h.objectStore(su);const b=l.delete(this.modelPath);b.onsuccess=()=>(A.close(),s(m.error)),b.onerror=v=>(A.close(),s(m.error))}},c.onerror=m=>(A.close(),s(c.error)),h.oncomplete=()=>{d==null?A.close():d.oncomplete=()=>A.close()}}},o.onerror=A=>s(o.error)})}}Tc.URL_SCHEME="indexeddb://";const Y7=n=>{return st().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Tc.URL_SCHEME)?(e=n.slice(Tc.URL_SCHEME.length),new Tc(e)):null;var e};Ns.registerSaveRouter(Y7),Ns.registerLoadRouter(Y7);class __{constructor(){this.indexedDB=Z7()}async listModels(){return new Promise((e,t)=>{const r=this.indexedDB.open(SI,1);r.onupgradeneeded=()=>NI(r),r.onsuccess=()=>{const s=r.result,o=s.transaction(su,"readonly"),A=o.objectStore(su).getAll();A.onsuccess=()=>{const u={};for(const h of A.result)u[h.modelPath]=h.modelArtifactsInfo;e(u)},A.onerror=u=>(s.close(),t(A.error)),o.oncomplete=()=>s.close()},r.onerror=s=>t(r.error)})}async removeModel(e){var t;return e=(t=e).startsWith(Tc.URL_SCHEME)?t.slice(Tc.URL_SCHEME.length):t,new Promise((r,s)=>{const o=this.indexedDB.open(SI,1);o.onupgradeneeded=()=>NI(o),o.onsuccess=()=>{const A=o.result,u=A.transaction(su,"readwrite"),h=u.objectStore(su),l=h.get(e);let c;l.onsuccess=()=>{if(l.result==null)return A.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const d=h.delete(e),m=()=>{c=A.transaction(Nc,"readwrite");const y=c.objectStore(Nc).delete(e);y.onsuccess=()=>r(l.result.modelArtifactsInfo),y.onerror=b=>s(l.error)};d.onsuccess=m,d.onerror=y=>(m(),A.close(),s(l.error))}},l.onerror=d=>(A.close(),s(l.error)),u.oncomplete=()=>{c==null?A.close():c.oncomplete=()=>A.close()}},o.onerror=A=>s(o.error)})}}const il="/",xp="tensorflowjs_models",U7="info",eee="model_topology",tee="weight_specs",nee="weight_data",ree="model_metadata";function Q7(n){return{info:[xp,n,U7].join(il),topology:[xp,n,eee].join(il),weightSpecs:[xp,n,tee].join(il),weightData:[xp,n,nee].join(il),modelMetadata:[xp,n,ree].join(il)}}function K7(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function see(n){const e=n.split(il);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(il)}class Mc{constructor(e){if(!st().getBool("IS_BROWSER")||typeof window>"u"||window.localStorage===void 0)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Q7(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=Rv(e);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,function(A){if(II)return Buffer.from(A).toString("base64");const u=new Uint8Array(A);let h="";for(let l=0,c=u.length;l<c;l++)h+=String.fromCharCode(u[l]);return btoa(h)}(e.weightData));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:s}}catch{throw K7(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=r;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=s;const o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){const u=JSON.parse(o);t.format=u.format,t.generatedBy=u.generatedBy,t.convertedBy=u.convertedBy,u.signature!=null&&(t.signature=u.signature),u.userDefinedMetadata!=null&&(t.userDefinedMetadata=u.userDefinedMetadata),u.modelInitializer!=null&&(t.modelInitializer=u.modelInitializer),u.trainingConfig!=null&&(t.trainingConfig=u.trainingConfig)}const A=this.LS.getItem(this.keys.weightData);if(A==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(u){if(II){const c=Buffer.from(u,"base64");return c.buffer.slice(c.byteOffset,c.byteOffset+c.byteLength)}const h=atob(u),l=new Uint8Array(h.length);for(let c=0;c<h.length;++c)l.set([h.charCodeAt(c)],c);return l.buffer}(A),t}}Mc.URL_SCHEME="localstorage://";const q7=n=>{return st().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Mc.URL_SCHEME)?(e=n.slice(Mc.URL_SCHEME.length),new Mc(e)):null;var e};Ns.registerSaveRouter(q7),Ns.registerLoadRouter(q7);class aee{constructor(){J(st().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),J(typeof window>"u"||window.localStorage!==void 0,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=xp+il,r=il+U7;for(let s=0;s<this.LS.length;++s){const o=this.LS.key(s);o.startsWith(t)&&o.endsWith(r)&&(e[see(o)]=JSON.parse(this.LS.getItem(o)))}return e}async removeModel(e){var t;const r=Q7(e=(t=e).startsWith(Mc.URL_SCHEME)?t.slice(Mc.URL_SCHEME.length):t);if(this.LS.getItem(r.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(r.info));return K7(r),s}}class au{constructor(){this.managers={}}static getInstance(){return au.instance==null&&(au.instance=new au),au.instance}static registerManager(e,t){J(e!=null,()=>"scheme must not be undefined or null."),e.endsWith("://")&&(e=e.slice(0,e.indexOf("://"))),J(e.length>0,()=>"scheme must not be an empty string.");const r=au.getInstance();J(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=t}static getManager(e){const t=this.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}}class oee{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}}if(st().get("IS_BROWSER")){st().setPlatform("browser",new oee);try{au.registerManager(Mc.URL_SCHEME,new aee)}catch{}try{au.registerManager(Tc.URL_SCHEME,new __)}catch{}}let TI;function Wn(n,e="float32",t){return e=e||"float32",Xo(n),new Gs(n,e,t)}st().get("IS_NODE")&&st().setPlatform("node",new class{constructor(){this.util=p(905),this.textEncoder=new this.util.TextEncoder}fetch(n,e){return st().global.fetch!=null?st().global.fetch(n,e):(TI==null&&(TI=p(78)),TI(n,e))}now(){const n=process.hrtime();return 1e3*n[0]+n[1]/1e6}encode(n,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(n)}decode(n,e){return n.length===0?"":new this.util.TextDecoder(e).decode(n)}});const zt=De({cast_:function(n,e){const t=le(n,"x","cast");if(!function(o){return o==="bool"||o==="complex64"||o==="float32"||o==="int32"||o==="string"}(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:t},s={dtype:e};return Ne.runKernel(ra,r,s)}}),ou=De({clone_:function(n){const e={x:le(n,"x","clone","string_or_numeric")};return Ne.runKernel(Uf,e)}});function J7(n){return new Promise(e=>setTimeout(e)).then(n)}O7(),bp={buffer:Wn,cast:zt,clone:ou,print:function(n,e=!1){console.log(n.toString(e))}};class Ec{constructor(e){if(!st().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Ec.URL_SCHEME)&&(e=e.slice(Ec.URL_SCHEME.length)),e!=null&&e.length!==0||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=V7(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),s=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=s,await J7(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const A=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;A.download=this.weightDataFileName,A.href=t,await J7(()=>A.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Rv(e)}}}}function $7(n,e,t,r){(function(o){J(o!=null&&Array.isArray(o)&&o.length>0,()=>"promises must be a none empty array")})(n),function(o,A){J(o>=0&&o<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${o}`),J(A>=0&&A<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${A}`),J(A>=o,()=>`startFraction must be no more than endFraction, but got startFraction ${o} and endFraction ${A}`)}(t=t??0,r=r??1);let s=0;return Promise.all(n.map(o=>(o.then(A=>{const u=t+ ++s/n.length*(r-t);return e(u),A}),o)))}async function iee(n,e){e==null&&(e={});const t=e.fetchFunc==null?st().platform.fetch:e.fetchFunc,r=n.map(o=>t(o,e.requestInit,{isBinary:!0})),s=(e.onProgress==null?await Promise.all(r):await $7(r,e.onProgress,0,.5)).map(o=>o.arrayBuffer());return e.onProgress==null?await Promise.all(s):await $7(s,e.onProgress,.5,1)}Ec.URL_SCHEME="downloads://",Ns.registerSaveRouter(n=>st().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Ec.URL_SCHEME)?function(e="model"){return new Ec(e)}(n.slice(Ec.URL_SCHEME.length)):null);class MI{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(J(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=st().platform.fetch,J(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&J(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const r=V7(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);t.body.append("model.json",new Blob([JSON.stringify(r)],{type:"application/json"}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const s=await this.fetch(this.path,t);if(s.ok)return{modelArtifactsInfo:Rv(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let A=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?A+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":A+=" Please make sure the server is serving valid JSON for this request.",new Error(A)}const r=t.modelTopology,s=t.weightsManifest;if(r==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return async function(o,A){const u={modelTopology:o.modelTopology,format:o.format,generatedBy:o.generatedBy,convertedBy:o.convertedBy};if(o.trainingConfig!=null&&(u.trainingConfig=o.trainingConfig),o.weightsManifest!=null){const[h,l]=await A(o.weightsManifest);u.weightSpecs=h,u.weightData=l}return o.signature!=null&&(u.signature=o.signature),o.userDefinedMetadata!=null&&(u.userDefinedMetadata=o.userDefinedMetadata),o.modelInitializer!=null&&(u.modelInitializer=o.modelInitializer),u}(t,o=>this.loadWeights(o))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[r,s]=function(l){const c=l.lastIndexOf("/"),d=l.lastIndexOf("?");return[l.substring(0,c)+"/",d>c?l.substring(d):""]}(t),o=this.weightPathPrefix||r,A=[];for(const l of e)A.push(...l.weights);const u=[],h=[];for(const l of e)for(const c of l.paths)this.weightUrlConverter!=null?h.push(this.weightUrlConverter(c)):u.push(o+c+s);return this.weightUrlConverter&&u.push(...await Promise.all(h)),[A,G7(await iee(u,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function _7(n){return n.match(MI.URL_SCHEME_REGEX)!=null}MI.URL_SCHEME_REGEX=/^https?:\/\//;const e4=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(t=Array.isArray(n)?n.every(r=>_7(r)):_7(n),t)return t4(n,e)}return null};function t4(n,e){return new MI(n,e)}function n4(n,e){return t4(n,e)}Ns.registerSaveRouter(e4),Ns.registerLoadRouter(e4);class EI{constructor(e){this.modelArtifacts=e}async load(){return this.modelArtifacts}}let wp;const r4=De({fromPixels_:function(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,r=!1,s=!1,o=!1,A=!1,u=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)o=!0;else if(n.getContext!=null)A=!0;else{if(!(typeof ImageBitmap<"u"&&n instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);u=!0}if(s&&s&&n.readyState<2)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");if(mI(pI,Ne.backendName)!=null){const m={pixels:n},y={numChannels:e};return Ne.runKernel(pI,m,y)}const[h,l]=s?[n.videoWidth,n.videoHeight]:[n.width,n.height];let c,d;if(A?c=n.getContext("2d").getImageData(0,0,h,l).data:r||t?c=n.data:(o||s||u)&&(wp==null&&(wp=document.createElement("canvas").getContext("2d")),wp.canvas.width=h,wp.canvas.height=l,wp.drawImage(n,0,0,h,l),c=wp.getImageData(0,0,h,l).data),e===4)d=new Int32Array(c);else{const m=h*l;d=new Int32Array(m*e);for(let y=0;y<m;y++)for(let b=0;b<e;++b)d[y*e+b]=c[4*y+b]}return function(m,y,b){if(rr(m),y!=null&&y.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const v=Cm(m,b);if(v.length!==3&&v.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(v.length===1&&y==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Im(m,y,v,b)}(d,[l,h,e],"int32")}});function DI(n,e,t){const r=n.shape.length;J(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),J(r===t.length,()=>`Error in slice${r}D: Length of size ${t} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)J(e[s]+t[s]<=n.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${e[s]+t[s]}) would overflow input.shape[${s}] (${n.shape[s]})`)}function Wv(n){const e=[];let t=0;for(;n>0;)1&n&&e.push(t),n/=2,t++;return e}function s4(n,e,t){const r=[];for(let s=0;s<n.length;s++)r[s]=Math.ceil((e[s]-n[s])/t[s]);return r}function a4(n,e,t,r){const s=[...n];for(let o=s.length;o<r.length;o++)s.push(1);for(let o=0;o<t;o++)o===0?s[e]=1:(s.splice(e,0,1),s.pop());return s}function o4(n,e,t){return t<=n?t:t-(e-1)}function i4(n,e){const t=[];for(let r=0;r<n;r++)t.push(e+r);return t}function A4(n,e,t,r,s,o,A,u,h){const l=n.length;let c=new Array(l),d=new Array(l),m=new Array(l);if(e.length&&t>0){const y=e[0],b=t+1;c=l4(A,y,b,r,n),d=u4(u,y,b,s,n),m=a4(o,y,b,n)}else for(let y=0;y<l;y++)c[y]=d4(A,r,o,n,y,h),d[y]=p4(u,s,o,n,y,h),m[y]=c4(o,y,h);return{begin:c,end:d,strides:m}}function l4(n,e,t,r,s){const o=[...s],A=i4(t,e);for(let u=0;u<o.length;u++)if(A.indexOf(u)>-1)o[u]=0;else{const h=o4(e,t,u);let l=r[h];n&1<<h&&(l=0),o[u]=l}return o}function u4(n,e,t,r,s){const o=[...s],A=i4(t,e);for(let u=0;u<o.length;u++)if(A.indexOf(u)>-1)o[u]=Number.MAX_SAFE_INTEGER;else{const h=o4(e,t,u);let l=r[h];n&1<<h&&(l=Number.MAX_SAFE_INTEGER),o[u]=l}for(let u=0;u<o.length;u++){const h=s[u];o[u]<0&&(o[u]+=h),o[u]=Mt(0,o[u],s[u])}return o}function c4(n,e,t){let r=n[e];return(t&1<<e||r==null)&&(r=1),r}function d4(n,e,t,r,s,o){let A=e[s];const u=t[s]||1;(n&1<<s||o&1<<s||A==null)&&(A=u>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const h=r[s];return A<0&&(A+=h),A=Mt(0,A,h-1),A}function p4(n,e,t,r,s,o){let A=e[s];const u=t[s]||1;(n&1<<s||o&1<<s||A==null)&&(A=u>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const h=r[s];return A<0&&(A+=h),A=u>0?Mt(0,A,h):Mt(-1,A,h-1),A}function zI(n,e,t){let r=t.length;for(let s=0;s<t.length;s++)if(t[s]>1){r=s;break}for(let s=r+1;s<t.length;s++)if(e[s]>0||t[s]!==n[s])return!1;return!0}function OI(n,e){let t=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)t+=n[r]*e[r];return t}function jv(n,e,t){let r;const s=n.shape.length;let o;return r=typeof e=="number"?[e,...new Array(s-1).fill(0)]:e.length<s?e.concat(new Array(s-e.length).fill(0)):e.slice(),r.forEach(A=>{J(A!==-1,()=>"slice() does not support negative begin indexing.")}),o=t==null?new Array(s).fill(-1):typeof t=="number"?[t,...new Array(s-1).fill(-1)]:t.length<s?t.concat(new Array(s-t.length).fill(-1)):t,o=o.map((A,u)=>A>=0?A:(J(A===-1,()=>`Negative size values should be exactly -1 but got ${A} for the slice() size at index ${u}.`),n.shape[u]-r[u])),[r,o]}function PI(n,e,t,r,s,o,A,u,h){let l=e.slice(),c=t.slice(),d=r;r==null&&(d=new Array(l.length));const m=Wv(A);if(m.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(A!==0&&u!==0)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(A!==0&&h!==0)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const y=n.length-l.length,b=Wv(u),v=n.slice();b.forEach(W=>{l[W]=0,c[W]=1,v.splice(W,0,1)});const{begin:w,end:I,strides:S}=A4(v,m,y,l,c,d,s,o,A);l=w,c=I,d=S;const T=Wv(h);T.forEach(W=>{c[W]=l[W]+1,d[W]=1});const D=s4(l,c,d),L=D.filter((W,K)=>T.indexOf(K)===-1);return{nonStrided:d.every(W=>W===1),$begin:l,$end:c,$strides:d,size:D,newShape:v,outShape:L}}class kp{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class yi{constructor(){this.classNameMap={}}static getMap(){return yi.instance==null&&(yi.instance=new yi),yi.instance}static register(e){yi.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function gt(n){J(n.className!=null,()=>"Class being registered does not have the static className property defined."),J(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),J(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),yi.register(n)}function Al(){return Ne}function BI(){return Ne.memory()}function Ve(n,e){return Ne.tidy(n,e)}function Rn(n){E7(n).forEach(e=>e.dispose())}function aa(n){return Ne.keep(n)}function h4(n,e,t=1){return Ne.registerBackend(n,e,t)}function ll(n){return Ne.customGrad(n)}function un(n,e){if((mt(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&mt(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Im(n,[],[],e)}class iu extends kp{minimize(e,t=!1,r){const{value:s,grads:o}=this.computeGradients(e,r);if(r!=null){const A=r.map(u=>({name:u.name,tensor:o[u.name]}));this.applyGradients(A)}else this.applyGradients(o);return Rn(o),t?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(r,s){J(Ba(r),()=>"The f passed in variableGrads(f) must be a function"),J(s==null||Array.isArray(s)&&s.every(d=>d instanceof Ov),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const o=s!=null;if(!o){s=[];for(const d in Ne.registeredVariables)s.push(Ne.registeredVariables[d])}const A=o?s.filter(d=>!d.trainable):null,u=s.length;J((s=s.filter(d=>d.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${u} variables is trainable.`);const{value:h,grads:l}=Ne.gradients(r,s,null,!0);J(l.some(d=>d!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),J(h.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${h.rank} tensor`);const c={};return s.forEach((d,m)=>{l[m]!=null&&(c[d.name]=l[m])}),A!=null&&A.forEach(d=>c[d.name]=null),{value:h,grads:c}}(e,t)}dispose(){this.iterations_!=null&&Rn(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:un(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(iu,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});const Ts=De({abs_:function(n){const e=le(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return Ne.runKernel($,t)}{const t={x:e};return Ne.runKernel(sl,t)}}}),vt=De({add_:function(n,e){let t=le(n,"a","add"),r=le(e,"b","add");[t,r]=_r(t,r);const s={a:t,b:r};return Ne.runKernel(be,s)}}),FI=De({all_:function(n,e=null,t=!1){const r={x:le(n,"x","all","bool")},s={axis:e,keepDims:t};return Ne.runKernel(at,r,s)}}),Hv=De({any_:function(n,e=null,t=!1){const r={x:le(n,"x","any","bool")},s={axis:e,keepDims:t};return Ne.runKernel(lt,r,s)}}),Cp=De({argMax_:function(n,e=0){const t={x:le(n,"x","argMax")},r={axis:e};return Ne.runKernel(ct,t,r)}});function Sm(n,e,t,r,s="NHWC",o){return Vs(n,[...e,n[3]],t,o,r,null,null,cl(s))}function bi(n,e,t,r,s,o,A="channelsLast"){const[u,h]=Gv(e);let l;if(A==="channelsLast")l=[u,h,n[3],n[3]];else{if(A!=="channelsFirst")throw new Error(`Unknown dataFormat ${A}`);l=[u,h,n[1],n[1]]}return Vs(n,l,t,r,s,o,!1,A)}function ul(n,e,t,r,s,o,A="NDHWC"){const[u,h,l]=RI(e);let c,d;if(A==="NDHWC")d="channelsLast",c=[u,h,l,n[4],n[4]];else{if(A!=="NCDHW")throw new Error(`Unknown dataFormat ${A}`);d="channelsFirst",c=[u,h,l,n[1],n[1]]}return Au(n,c,t,r,s,!1,d,o)}function Vs(n,e,t,r,s,o,A=!1,u="channelsLast"){let[h,l,c,d]=[-1,-1,-1,-1];if(u==="channelsLast")[h,l,c,d]=n;else{if(u!=="channelsFirst")throw new Error(`Unknown dataFormat ${u}`);[h,d,l,c]=n}const[m,y,,b]=e,[v,w]=Gv(t),[I,S]=Gv(r),T=Ip(m,I),D=Ip(y,S),{padInfo:L,outHeight:W,outWidth:K}=function(ee,re,ce,we,Ee,Pe,he,de,Ae){let Se,Te,Ze;if(typeof ee=="number"){Se={top:ee,bottom:ee,left:ee,right:ee,type:ee===0?"VALID":"NUMBER"};const et=function(qe,Re,Ue,ot,yt){ot==null&&(ot=LI(qe,Re,Ue));const Vt=qe[1];return[Dc((qe[0]-Re+2*ot)/Ue+1,yt),Dc((Vt-Re+2*ot)/Ue+1,yt)]}([re,ce],Pe,we,ee,de);Te=et[0],Ze=et[1]}else if(ee==="same"){Te=Math.ceil(re/we),Ze=Math.ceil(ce/Ee);const et=Math.max(0,(Te-1)*we+Pe-re),qe=Math.max(0,(Ze-1)*Ee+he-ce),Re=Math.floor(et/2),Ue=et-Re,ot=Math.floor(qe/2);Se={top:Re,bottom:Ue,left:ot,right:qe-ot,type:"SAME"}}else if(ee==="valid")Se={top:0,bottom:0,left:0,right:0,type:"VALID"},Te=Math.ceil((re-Pe+1)/we),Ze=Math.ceil((ce-he+1)/Ee);else{if(typeof ee!="object")throw Error(`Unknown padding parameter: ${ee}`);{const et=Ae==="channelsLast"?ee[1][0]:ee[2][0],qe=Ae==="channelsLast"?ee[1][1]:ee[2][1],Re=Ae==="channelsLast"?ee[2][0]:ee[3][0],Ue=Ae==="channelsLast"?ee[2][1]:ee[3][1];Se={top:et,bottom:qe,left:Re,right:Ue,type:et===0&&qe===0&&Re===0&&Ue===0?"VALID":"EXPLICIT"},Te=Dc((re-Pe+et+qe)/we+1,de),Ze=Dc((ce-he+Re+Ue)/Ee+1,de)}}return{padInfo:Se,outHeight:Te,outWidth:Ze}}(s,l,c,v,w,T,D,o,u),U=A?b*d:b;let _;return u==="channelsFirst"?_=[h,U,W,K]:u==="channelsLast"&&(_=[h,W,K,U]),{batchSize:h,dataFormat:u,inHeight:l,inWidth:c,inChannels:d,outHeight:W,outWidth:K,outChannels:U,padInfo:L,strideHeight:v,strideWidth:w,filterHeight:m,filterWidth:y,effectiveFilterHeight:T,effectiveFilterWidth:D,dilationHeight:I,dilationWidth:S,inShape:n,outShape:_,filterShape:e}}function Au(n,e,t,r,s,o=!1,A="channelsLast",u){let[h,l,c,d,m]=[-1,-1,-1,-1,-1];if(A==="channelsLast")[h,l,c,d,m]=n;else{if(A!=="channelsFirst")throw new Error(`Unknown dataFormat ${A}`);[h,m,l,c,d]=n}const[y,b,v,,w]=e,[I,S,T]=RI(t),[D,L,W]=RI(r),K=Ip(y,D),U=Ip(b,L),_=Ip(v,W),{padInfo:ee,outDepth:re,outHeight:ce,outWidth:we}=function(he,de,Ae,Se,Te,Ze,et,qe,Re,Ue,ot){let yt,Vt,ln,en;if(typeof he=="number"){yt={top:he,bottom:he,left:he,right:he,front:he,back:he,type:he===0?"VALID":"NUMBER"};const Xt=function(hn,wn,Fn,In,zn,Kn){zn==null&&(zn=LI(hn,wn,In));const Ls=hn[1],Na=hn[2];return[Dc((hn[0]-wn+2*zn)/In+1,Kn),Dc((Ls-wn+2*zn)/In+1,Kn),Dc((Na-wn+2*zn)/In+1,Kn),1]}([de,Ae,Se,1],qe,0,Te,he,ot);Vt=Xt[0],ln=Xt[1],en=Xt[2]}else if(he==="same"){Vt=Math.ceil(de/Te),ln=Math.ceil(Ae/Ze),en=Math.ceil(Se/et);const Xt=(Vt-1)*Te+qe-de,hn=(ln-1)*Ze+Re-Ae,wn=(en-1)*et+Ue-Se,Fn=Math.floor(Xt/2),In=Xt-Fn,zn=Math.floor(hn/2),Kn=hn-zn,Ls=Math.floor(wn/2);yt={top:zn,bottom:Kn,left:Ls,right:wn-Ls,front:Fn,back:In,type:"SAME"}}else{if(he!=="valid")throw Error(`Unknown padding parameter: ${he}`);yt={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},Vt=Math.ceil((de-qe+1)/Te),ln=Math.ceil((Ae-Re+1)/Ze),en=Math.ceil((Se-Ue+1)/et)}return{padInfo:yt,outDepth:Vt,outHeight:ln,outWidth:en}}(s,l,c,d,I,S,T,K,U,_,u),Ee=o?w*m:w;let Pe;return A==="channelsFirst"?Pe=[h,Ee,re,ce,we]:A==="channelsLast"&&(Pe=[h,re,ce,we,Ee]),{batchSize:h,dataFormat:A,inDepth:l,inHeight:c,inWidth:d,inChannels:m,outDepth:re,outHeight:ce,outWidth:we,outChannels:Ee,padInfo:ee,strideDepth:I,strideHeight:S,strideWidth:T,filterDepth:y,filterHeight:b,filterWidth:v,effectiveFilterDepth:K,effectiveFilterHeight:U,effectiveFilterWidth:_,dilationDepth:D,dilationHeight:L,dilationWidth:W,inShape:n,outShape:Pe,filterShape:e}}function LI(n,e,t,r=1){const s=Ip(e,r);return Math.floor((n[0]*(t-1)-t+s)/2)}function Gv(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function RI(n){return typeof n=="number"?[n,n,n]:n}function Ip(n,e){return e<=1?n:n+(n-1)*(e-1)}function Dc(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function lu(n){const[e,t,r]=Gv(n);return e===1&&t===1&&r===1}function oa(n,e){return lu(n)||lu(e)}function cl(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}const Fe=De({reshape_:function(n,e){const t={x:le(n,"x","reshape","string_or_numeric")},r={shape:e};return Ne.runKernel(dv,t,r)}}),Vv=De({avgPool_:function(n,e,t,r,s){const o=le(n,"x","avgPool","float32");J(oa(t,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '1'`);let A=o,u=!1;o.rank===3&&(u=!0,A=Fe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),J(A.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${A.rank}.`),s!=null&&J(Et(r),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const h={x:A},l={filterSize:e,strides:t,pad:r,dimRoundingMode:s};let c=Ne.runKernel(Zn,h,l);return c=zt(c,o.dtype),u?Fe(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),f4=De({avgPool3d_:function(n,e,t,r,s,o="NDHWC"){const A=le(n,"x","avgPool3d","float32");let u=A,h=!1;A.rank===4&&(h=!0,u=Fe(A,[1,A.shape[0],A.shape[1],A.shape[2],A.shape[3]])),J(u.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${u.rank}.`),J(o==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),s!=null&&J(Et(r),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const l={x:u},c={filterSize:e,strides:t,pad:r,dimRoundingMode:s,dataFormat:o};let d=Ne.runKernel($r,l,c);return d=zt(d,u.dtype),h?Fe(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),Nm=De({batchNorm_:function(n,e,t,r,s,o){o==null&&(o=.001);const A=le(n,"x","batchNorm"),u=le(e,"mean","batchNorm"),h=le(t,"variance","batchNorm");let l,c;s!=null&&(l=le(s,"scale","batchNorm")),r!=null&&(c=le(r,"offset","batchNorm")),J(u.rank===h.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),J(c==null||u.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),J(l==null||u.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const d={x:function(b){let v;return v=b.rank===0||b.rank===1?Fe(b,[1,1,1,b.size]):b.rank===2?Fe(b,[1,1,b.shape[0],b.shape[1]]):b.rank===3?Fe(b,[1,b.shape[0],b.shape[1],b.shape[2]]):b,v}(A),scale:l,offset:c,mean:u,variance:h},m={varianceEpsilon:o},y=Ne.runKernel(V0,d,m);return Fe(y,A.shape)}}),Aee=De({batchNorm2d_:function(n,e,t,r,s,o){const A=le(n,"x","batchNorm"),u=le(e,"mean","batchNorm"),h=le(t,"variance","batchNorm");let l,c;return s!=null&&(l=le(s,"scale","batchNorm")),r!=null&&(c=le(r,"offset","batchNorm")),J(A.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${A.rank}.`),J(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${u.rank}.`),J(h.rank===2||h.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${h.rank}.`),l!=null&&J(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&J(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Nm(A,u,h,c,l,o)}}),lee=De({batchNorm3d_:function(n,e,t,r,s,o){const A=le(n,"x","batchNorm"),u=le(e,"mean","batchNorm"),h=le(t,"variance","batchNorm");let l,c;return s!=null&&(l=le(s,"scale","batchNorm")),r!=null&&(c=le(r,"offset","batchNorm")),J(A.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${A.rank}.`),J(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${u.rank}.`),J(h.rank===3||h.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${h.rank}.`),l!=null&&J(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&J(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Nm(A,u,h,c,l,o)}}),uee=De({batchNorm4d_:function(n,e,t,r,s,o){const A=le(n,"x","batchNorm"),u=le(e,"mean","batchNorm"),h=le(t,"variance","batchNorm");let l,c;return s!=null&&(l=le(s,"scale","batchNorm")),r!=null&&(c=le(r,"offset","batchNorm")),J(A.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${A.rank}.`),J(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${u.rank}.`),J(h.rank===4||h.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${h.rank}.`),l!=null&&J(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&J(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Nm(A,u,h,c,l,o)}}),ko=De({clipByValue_:function(n,e,t){const r=le(n,"x","clipByValue");J(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`);const s={x:r},o={clipValueMin:e,clipValueMax:t};return Ne.runKernel(xa,s,o)}}),ys=De({concat_:function(n,e=0){J(n.length>=1,()=>"Pass at least one tensor to concat");const t=R7(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(o=>{if(o.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${o.dtype}. `)}),t.length===1)return ou(t[0]);const r=t,s={axis:e};return Ne.runKernel(ne,r,s)}}),cee=De({concat1d_:function(n){return ys(n,0)}}),dee=De({concat2d_:function(n,e){return ys(n,e)}}),pee=De({concat3d_:function(n,e){return ys(n,e)}}),hee=De({concat4d_:function(n,e){return ys(n,e)}}),uu=De({conv2d_:function(n,e,t,r,s="NHWC",o=[1,1],A){const u=le(n,"x","conv2d"),h=le(e,"filter","conv2d");let l=u,c=!1;u.rank===3&&(c=!0,l=Fe(u,[1,u.shape[0],u.shape[1],u.shape[2]])),J(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),J(h.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${h.rank}.`),A!=null&&J(Et(r),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${A} but got pad ${r}.`);const d=s==="NHWC"?l.shape[3]:l.shape[1];J(d===h.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${h.shape[2]}.`),J(oa(t,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);const m={x:l,filter:h},y={strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:A},b=Ne.runKernel(Ce,m,y);return c?Fe(b,[b.shape[1],b.shape[2],b.shape[3]]):b}}),WI=De({conv1d_:function(n,e,t,r,s="NWC",o=1,A){const u=le(n,"x","conv1d"),h=le(e,"filter","conv1d");let l=u,c=!1;u.rank===2&&(c=!0,l=Fe(u,[1,u.shape[0],u.shape[1]])),J(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),J(h.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${h.rank}.`),A!=null&&J(Et(r),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${A} but got pad ${r}.`),J(l.shape[2]===h.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${h.shape[1]}.`),J(oa(t,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${o}'`),J(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const d=Fe(h,[1,h.shape[0],h.shape[1],h.shape[2]]),m=Fe(l,[l.shape[0],1,l.shape[1],l.shape[2]]),y=uu(m,d,[1,t],r,"NHWC",[1,o],A);return Fe(y,c?[y.shape[2],y.shape[3]]:[y.shape[0],y.shape[2],y.shape[3]])}}),jI=De({conv2DBackpropInput_:function(n,e,t,r,s,o="NHWC",A){J(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let u=n,h=e,l=!1;e.rank===3&&(l=!0,h=Fe(e,[1,e.shape[0],e.shape[1],e.shape[2]]),u=[1,n[0],n[1],n[2]]),J(u.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${u.length}.`),J(h.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${h.rank}`),J(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const c=o==="NHWC"?u[3]:u[1],d=o==="NHWC"?h.shape[3]:h.shape[1];J(c===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${t.shape[2]}.`),J(d===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${t.shape[3]}.`),A!=null&&J(Et(s),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${A} but got pad ${s}.`);const m={dy:h,filter:t},y={strides:r,pad:s,dataFormat:o,dimRoundingMode:A,inputShape:u},b=Ne.runKernel(_e,m,y);return l?Fe(b,[b.shape[1],b.shape[2],b.shape[3]]):b}}),HI=De({conv2dTranspose_:function(n,e,t,r,s,o){const A=le(n,"x","conv2dTranspose"),u=le(e,"filter","conv2dTranspose");return jI(t,A,u,r,s,"NHWC",o)}}),m4=De({conv3d_:function(n,e,t,r,s="NDHWC",o=[1,1,1]){const A=le(n,"x","conv3d"),u=le(e,"filter","conv3d");let h=A,l=!1;A.rank===4&&(l=!0,h=Fe(A,[1,A.shape[0],A.shape[1],A.shape[2],A.shape[3]])),J(h.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${h.rank}.`),J(u.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${u.rank}.`),J(h.shape[4]===u.shape[3],()=>`Error in conv3d: depth of input (${h.shape[4]}) must match input depth for filter ${u.shape[3]}.`),J(oa(t,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),J(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);const c={x:h,filter:u},d={strides:t,pad:r,dataFormat:s,dilations:o},m=Ne.runKernel($e,c,d);return l?Fe(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),g4=De({conv3DBackpropInput_:function(n,e,t,r,s){J(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let o=n,A=e,u=!1;e.rank===4&&(u=!0,A=Fe(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),o=[1,n[0],n[1],n[2],n[3]]);const h=o[4],l=A.shape[4];J(o.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),J(A.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${A.rank}`),J(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),J(h===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${h}) must match input depth for filter ${t.shape[3]}.`),J(l===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${t.shape[4]}.`);const c={dy:A,filter:t},d={pad:s,strides:r,inputShape:o},m=Ne.runKernel(sn,c,d);return u?Fe(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),fee=De({conv3dTranspose_:function(n,e,t,r,s){const o=le(n,"x","conv3dTranspose"),A=le(e,"filter","conv3dTranspose");return g4(t,o,A,r,s)}}),Tm=De({depthwiseConv2d_:function(n,e,t,r,s="NHWC",o=[1,1],A){const u=le(n,"x","depthwiseConv2d"),h=le(e,"filter","depthwiseConv2d");let l=u,c=!1;u.rank===3&&(c=!0,l=Fe(u,[1,u.shape[0],u.shape[1],u.shape[2]])),J(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),J(h.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`),J(l.shape[3]===h.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),A!=null&&J(Et(r),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${A} but got pad ${r}.`);const d={x:l,filter:h},m={strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:A},y=Ne.runKernel(xA,d,m);return c?Fe(y,[y.shape[1],y.shape[2],y.shape[3]]):y}}),GI=De({floorDiv_:function(n,e){let t=le(n,"a","floorDiv"),r=le(e,"b","floorDiv");[t,r]=_r(t,r);const s={a:t,b:r};return Ne.runKernel(Zf,s)}}),an=De({div_:function(n,e){let t=le(n,"a","div"),r=le(e,"b","div");if([t,r]=_r(t,r),t.dtype==="int32"&&r.dtype==="int32")return GI(t,r);const s={a:t,b:r};return Ne.runKernel(ol,s,{})}}),Mm=De({elu_:function(n){const e={x:le(n,"x","elu")};return Ne.runKernel(Yo,e)}});function Sp(n,e){const t=n.length,r=[];for(let s=0;s<t;s++){const o=t-1-s,A=n[o]||1;(e[e.length-1-s]||1)>1&&A===1&&r.unshift(o)}return r}function Ms(n,e){const t=[];for(let r=0;r<e.length;r++){const s=n[n.length-r-1],o=e.length-r-1,A=e[o];(s==null||s===1&&A>1)&&t.unshift(o)}return t}function Bn(n,e){const t=[],r=Math.max(n.length,e.length);for(let s=0;s<r;s++){let o=n[n.length-s-1];o==null&&(o=1);let A=e[e.length-s-1];if(A==null&&(A=1),o===1)t.unshift(A);else if(A===1)t.unshift(o);else{if(o!==A)throw Error(`Operands could not be broadcast together with shapes ${n} and ${e}.`);t.unshift(o)}}return t}const Zi=De({equal_:function(n,e){let t=le(n,"a","equal","string_or_numeric"),r=le(e,"b","equal","string_or_numeric");[t,r]=_r(t,r),Bn(t.shape,r.shape);const s={a:t,b:r};return Ne.runKernel(H0,s)}}),Qo=De({exp_:function(n){const e={x:le(n,"x","exp")};return Ne.runKernel(Gf,e)}}),Ko=De({expandDims_:function(n,e=0){const t=le(n,"x","expandDims","string_or_numeric");J(e<=t.rank,()=>"Axis must be <= rank of the tensor");const r={input:t},s={dim:e};return Ne.runKernel(G0,r,s)}}),vi=De({tile_:function(n,e){const t=le(n,"x","tile","string_or_numeric");J(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const r={x:t},s={reps:e};return Ne.runKernel(vm,r,s)}}),y4=De({eye_:function(n,e,t,r="float32"){e==null&&(e=n);const s=Wn([n,e],r),o=n<=e?n:e;for(let u=0;u<o;++u)s.set(1,u,u);const A=Fe(s.toTensor(),[n,e]);if(t==null)return A;if(t.length===1)return vi(Ko(A,0),[t[0],1,1]);if(t.length===2)return vi(Ko(Ko(A,0),0),[t[0],t[1],1,1]);if(t.length===3)return vi(Ko(Ko(Ko(A,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}});function Em(n,e,t){const r={shape:n,value:e,dtype:t};return Ne.runKernel(PC,{},r)}const Dm=De({floor_:function(n){const e={x:le(n,"x","floor")};return Ne.runKernel(Xf,e)}}),zm=De({gather_:function(n,e,t=0,r=0){const s={x:le(n,"x","gather"),indices:le(e,"indices","gather","int32")},o={axis:t,batchDims:r};return Ne.runKernel(X0,s,o)}}),qo=De({greater_:function(n,e){let t=le(n,"a","greater","string_or_numeric"),r=le(e,"b","greater","string_or_numeric");[t,r]=_r(t,r),Bn(t.shape,r.shape);const s={a:t,b:r};return Ne.runKernel(Z0,s)}}),zc=De({greaterEqual_:function(n,e){let t=le(n,"a","greaterEqual","string_or_numeric"),r=le(e,"b","greaterEqual","string_or_numeric");[t,r]=_r(t,r),Bn(t.shape,r.shape);const s={a:t,b:r};return Ne.runKernel(Yf,s)}}),Xv=De({leakyRelu_:function(n,e=.2){const t={x:le(n,"x","leakyRelu")},r={alpha:e};return Ne.runKernel(Y0,t,r)}}),Jo=De({log_:function(n){const e={x:le(n,"x","log")};return Ne.runKernel(Jf,e)}}),Zv=De({log1p_:function(n){const e={x:le(n,"x","log1p")};return Ne.runKernel($f,e)}}),Yi=De({max_:function(n,e=null,t=!1){const r={x:le(n,"x","max")},s={reductionIndices:e,keepDims:t};return Ne.runKernel(_0,r,s)}}),Me=De({mul_:function(n,e){let t=le(n,"a","mul"),r=le(e,"b","mul");[t,r]=_r(t,r);const s={a:t,b:r};return Ne.runKernel(nm,s)}}),Ut=De({sub_:function(n,e){let t=le(n,"a","sub"),r=le(e,"b","sub");[t,r]=_r(t,r);const s={a:t,b:r};return Ne.runKernel(gm,s)}}),Qt=De({sum_:function(n,e=null,t=!1){let r=le(n,"x","sum");r.dtype==="bool"&&(r=zt(r,"int32"));const s={x:r},o={axis:e,keepDims:t};return Ne.runKernel(yv,s,o)}}),VI=De({logSoftmax_:function(n,e=-1){const t=le(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return ll((r,s)=>{const o=Yi(r,e,!0),A=Ut(r,o),u=Ut(zt(A,"float32"),Jo(Qt(Qo(A),e,!0)));return s([u]),{value:u,gradFunc:(h,l)=>{const[c]=l,d=Qo(c);return Ut(h,Me(Qt(h,e,!0),d))}}})(t)}}),CA=De({logicalAnd_:function(n,e){const t=le(n,"a","logicalAnd","bool"),r=le(e,"b","logicalAnd","bool");Bn(t.shape,r.shape);const s={a:t,b:r};return Ne.runKernel(K0,s)}}),nr=De({matMul_:function(n,e,t=!1,r=!1){let s=le(n,"a","matMul"),o=le(e,"b","matMul");[s,o]=_r(s,o);const A={a:s,b:o},u={transposeA:t,transposeB:r};return Ne.runKernel(sr,A,u)}}),Yv=De({maxPool_:function(n,e,t,r,s){const o=le(n,"x","maxPool");let A=o,u=!1;o.rank===3&&(u=!0,A=Fe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),J(A.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${A.rank}.`),J(oa(t,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '1'`),s!=null&&J(Et(r),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const h={x:A},l={filterSize:e,strides:t,pad:r,dimRoundingMode:s},c=Ne.runKernel(ev,h,l);return u?Fe(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),b4=De({maxPool3d_:function(n,e=[1,1,1],t,r,s,o="NDHWC"){const A=le(n,"x","maxPool3d");let u=A,h=!1;A.rank===4&&(h=!0,u=Fe(A,[1,A.shape[0],A.shape[1],A.shape[2],A.shape[3]])),J(u.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${u.rank}.`),J(o==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),s!=null&&J(Et(r),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const l={x:u},c={filterSize:e,strides:t,pad:r,dimRoundingMode:s,dataFormat:o},d=Ne.runKernel(tv,l,c);return h?Fe(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),dl=De({maximum_:function(n,e){let t=le(n,"a","maximum"),r=le(e,"b","maximum");[t,r]=_r(t,r),t.dtype==="bool"&&(t=zt(t,"int32"),r=zt(r,"int32")),Bn(t.shape,r.shape);const s={a:t,b:r};return Ne.runKernel(_f,s)}}),es=De({mean_:function(n,e=null,t=!1){const r={x:le(n,"x","mean")},s={axis:e,keepDims:t};return Ne.runKernel(nv,r,s)}}),Om=De({minimum_:function(n,e){let t=le(n,"a","minimum"),r=le(e,"b","minimum");[t,r]=_r(t,r),t.dtype==="bool"&&(t=zt(t,"int32"),r=zt(r,"int32")),Bn(t.shape,r.shape);const s={a:t,b:r};return Ne.runKernel(em,s)}});function XI(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function v4(n,e,t){const r=n.length+e.length,s=[];let o=0,A=0;for(let u=0;u<r;u++)t.indexOf(u)===-1?s.push(n[o++]):s.push(e[A++]);return s}function Xs(n,e){const t=[],r=n.length;for(let s=0;s<r;s++)e.indexOf(s)===-1&&t.push(n[s]);return[t,e.map(s=>n[s])]}function us(n,e){return v4(n,e.map(t=>1),e)}function ia(n,e,t){J(XI(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function cs(n,e){if(XI(n,e))return null;const t=[];for(let r=0;r<e;++r)n.indexOf(r)===-1&&t.push(r);return n.forEach(r=>t.push(r)),t}function Np(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function bs(n,e){const t=[];for(let r=e-n;r<e;++r)t.push(r);return t}const xr=De({square_:function(n){const e=le(n,"x","square");return Ne.runKernel("Square",{x:e},{})}}),ZI=De({moments_:function(n,e=null,t=!1){const r=pt(e,(n=le(n,"x","moments")).shape),s=es(n,r,t);let o=s.shape;t||(o=us(s.shape,r));const A=xr(Ut(zt(n,"float32"),Fe(s,o)));return{mean:s,variance:es(A,r,t)}}}),Yr=De({neg_:function(n){const e={x:le(n,"x","neg")};return Ne.runKernel(av,e)}}),Tp=De({notEqual_:function(n,e){let t=le(n,"a","notEqual","string_or_numeric"),r=le(e,"b","notEqual","string_or_numeric");[t,r]=_r(t,r),Bn(t.shape,r.shape);const s={a:t,b:r};return Ne.runKernel(ov,s)}}),YI=De({oneHot_:function(n,e,t=1,r=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const s={indices:le(n,"indices","oneHot","int32")},o={depth:e,onValue:t,offValue:r};return Ne.runKernel(Av,s,o)}});function Es(n,e="float32"){if(e==="complex64"){const r=Es(n,"float32"),s=Es(n,"float32");return Sc(r,s)}const t=Mr(Ye(n),e);return Ne.makeTensor(t,n,e)}function pl(n,e="float32"){if(e==="complex64"){const r=pl(n,"float32"),s=Es(n,"float32");return Sc(r,s)}const t=kn(Ye(n),e);return Ne.makeTensor(t,n,e)}const $o=De({onesLike_:function(n){const e={x:le(n,"x","onesLike")};return Ne.runKernel(iv,e)}}),Uv=De({pad_:function(n,e,t=0){const r=le(n,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:e,constantValue:t},o={x:r};return Ne.runKernel(uv,o,s)}}),Qv=De({prelu_:function(n,e){const t={x:le(n,"x","prelu"),alpha:le(e,"alpha","prelu")};return Ne.runKernel(cv,t)}});var UI=p(892);class x4{constructor(e,t,r,s,o){this.mean=e,this.stdDev=t,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const A=o||Math.random();this.random=UI.alea(A.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let e,t,r=!1;for(;!r;){let s,o,A;do s=2*this.random()-1,o=2*this.random()-1,A=s*s+o*o;while(A>=1||A===0);const u=Math.sqrt(-2*Math.log(A)/A);e=this.mean+this.stdDev*s*u,t=this.mean+this.stdDev*o*u,this.truncated&&!this.isValidTruncated(e)||(r=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class mee{constructor(e=0,t=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=UI.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const gee=De({randomNormal_:function(n,e=0,t=1,r,s){if(r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const o=new x4(e,t,r,!1,s),A=Wn(n,r);for(let u=0;u<A.values.length;u++)A.values[u]=o.nextValue();return A.toTensor()}}),Pm=De({randomUniform_:function(n,e=0,t=1,r="float32",s){const o=Wn(n,r),A=new mee(e,t,null,s);for(let u=0;u<o.values.length;u++)o.values[u]=A.nextValue();return o.toTensor()}}),IA=De({relu_:function(n){const e={x:le(n,"x","relu")};return Ne.runKernel(am,e)}}),hl=De({reverse_:function(n,e){const t={x:le(n,"x","reverse")},r={dims:e};return Ne.runKernel(fv,t,r)}}),QI=De({selu_:function(n){const e={x:le(n,"x","selu")};return Ne.runKernel(lm,e)}}),w4=De({separableConv2d_:function(n,e,t,r,s,o=[1,1],A="NHWC"){const u=le(n,"x","separableConv2d"),h=le(e,"depthwiseFilter","separableConv2d"),l=le(t,"pointwiseFilter","separableConv2d");let c=u,d=!1;if(u.rank===3&&(d=!0,c=Fe(u,[1,u.shape[0],u.shape[1],u.shape[2]])),A==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");J(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),J(h.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${h.rank}.`),J(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${h.rank}.`),J(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),J(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);const m=h.shape[2],y=h.shape[3];J(l.shape[2]===m*y,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*y}, but got ${l.shape[2]}.`);const b=Tm(c,h,r,s,A,o),v=uu(b,l,1,"valid",A);return d?Fe(v,[v.shape[1],v.shape[2],v.shape[3]]):v}}),Oc=De({sigmoid_:function(n){const e={x:le(n,"x","sigmoid")};return Ne.runKernel(pm,e)}}),or=De({slice_:function(n,e,t){const r=le(n,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const s={x:r},o={begin:e,size:t};return Ne.runKernel(gv,s,o)}}),KI=De({slice1d_:function(n,e,t){const r=le(n,"x","slice1d");return J(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),or(r,[e],[t])}}),k4=De({slice2d_:function(n,e,t){const r=le(n,"x","slice2d");return J(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),or(r,e,t)}}),qI=De({slice3d_:function(n,e,t){const r=le(n,"x","slice3d");return J(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),or(r,e,t)}}),Kv=De({slice4d_:function(n,e,t){const r=le(n,"x","slice4d");return J(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),or(r,e,t)}}),qv=De({softmax_:function(n,e=-1){const t=le(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const r={logits:t},s={dim:e};return Ne.runKernel(xv,r,s)}}),Mp=De({softplus_:function(n){const e={x:le(n,"x","softplus")};return Ne.runKernel(hm,e)}}),_a=De({split_:function(n,e,t=0){const r={x:le(n,"x","split")},s={numOrSizeSplits:e,axis:t};return Ne.runKernel(vv,r,s)}}),wa=De({sqrt_:function(n){const e={x:le(n,"x","sqrt")};return Ne.runKernel(fm,e)}}),cu=De({squeeze_:function(n,e){const t=le(n,"x","squeeze");return Fe(t,tt(t.shape,e).newShape)}}),xi=De({stack_:function(n,e=0){const t=R7(n,"tensors","stack","string_or_numeric");J(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&J(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const r=t,s={axis:e};return Ne.runKernel(lv,r,s)}}),Jv=De({tanh_:function(n){const e={x:le(n,"x","tanh")};return Ne.runKernel(bm,e)}});function Ra(n,e){rr(n);const t=Cm(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Im(n,null,t,e)}function $v(n,e,t){if(rr(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=Cm(n,t);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Im(n,e,r,t)}const JI=De({truncatedNormal_:function(n,e=0,t=1,r,s){if(r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const o=new x4(e,t,r,!0,s),A=Wn(n,r);for(let u=0;u<A.values.length;u++)A.values[u]=o.nextValue();return A.toTensor()}}),Ui=De({unstack_:function(n,e=0){const t=le(n,"x","unstack","string_or_numeric");J(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const r={value:t},s={axis:e};return Ne.runKernel(kv,r,s)}}),Bm=De({broadcastTo_:function(n,e){let t=le(n,"broadcastTo","x");const r=t.shape;if(e.some(h=>!(h>0)||h%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const h=t.shape.slice();for(;h.length<e.length;)h.unshift(1);t=Fe(t,h)}const s=t.shape,o=Array.from(e);for(let h=e.length-1;h>=0;h--)if(s[h]===e[h])o[h]=1;else if(t.shape[h]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(o.map((h,l)=>h>1?l:-1).filter(h=>h>=0).length===0)return ou(t);const A={x:t},u={reps:o};return Ne.runKernel(vm,A,u)}}),eo=De({where_:function(n,e,t){const r=le(e,"a","where"),s=le(t,"b","where"),o=le(n,"condition","where","bool"),A=Bn(Bn(o.shape,r.shape),s.shape),u={condition:Bm(o,A),t:Bm(r,A),e:Bm(s,A)};return Ne.runKernel(mv,u)}}),Vn=De({zerosLike_:function(n){const e={x:le(n,"x","zerosLike")};return Ne.runKernel(Iv,e)}}),Yn=De({transpose_:function(n,e){const t=le(n,"x","transpose");if(e==null&&(e=t.shape.map((o,A)=>A).reverse()),J(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of perm ${e}.`),e.forEach(o=>{J(o>=0&&o<t.rank,()=>"All entries in 'perm' must be between 0 and "+(t.rank-1)+` but got ${e}`)}),t.rank<=1)return t.clone();const r={x:t},s={perm:e};return Ne.runKernel(wv,r,s)}}),yee=De({dropout_:function(n,e,t,r){const s=le(n,"x","dropout");if(J(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),J(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof ls?s.clone():s;const o=function(h,l){if(l==null)return h.shape.slice();if(ht(h.shape,l))return l;if(h.shape.length===l.length){const c=[];for(let d=0;d<h.shape.length;d++)l[d]==null&&h.shape[d]!=null?c.push(h.shape[d]):c.push(l[d]);return c}return l}(s,t),A=1-e,u=an(Dm(vt(Pm(o,0,1,"float32",r),A)),A);return Me(s,u)}}),$I=De({imag_:function(n){const e={input:le(n,"input","imag")};return Ne.runKernel(RC,e)}}),_v=De({real_:function(n){const e={input:le(n,"input","real")};return Ne.runKernel(qC,e)}}),_I=De({fft_:function(n){J(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return Ne.runKernel(OC,e)}}),eS=De({rfft_:function(n,e){J(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const r=n.size/t;let s;if(e!=null&&e<t){const b=n.shape.map(w=>0),v=n.shape.map(w=>w);v[n.shape.length-1]=e,s=or(n,b,v),t=e}else if(e!=null&&e>t){const b=n.shape.map(v=>v);b[n.shape.length-1]=e-t,s=ys([n,Es(b)],n.shape.length-1),t=e}else s=n;const o=Vn(s),A=Fe(Sc(s,o),[r,t]),u=_I(A),h=Math.floor(t/2)+1,l=_v(u),c=$I(u),d=_a(l,[h,t-h],l.shape.length-1),m=_a(c,[h,t-h],c.shape.length-1),y=s.shape.slice();return y[s.shape.length-1]=h,Fe(Sc(d[0],m[0]),y)}}),ex=De({ifft_:function(n){J(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return Ne.runKernel(LC,e)}}),C4=De({irfft_:function(n){const e=n.shape[n.shape.length-1],t=n.size/e;let r;if(e<=2){const s=Fe(n,[t,e]);r=ex(s)}else{const s=[t,2*(e-1)],o=Fe(_v(n),[t,e]),A=Fe($I(n),[t,e]),u=hl(or(o,[0,1],[t,e-2]),1),h=Me(hl(or(A,[0,1],[t,e-2]),1),un(-1)),l=ys([o,u],1),c=ys([A,h],1),d=Fe(Sc(l,c),[s[0],s[1]]);r=ex(d)}if(r=_v(r),n.rank===3&&n.shape[0]!==0){const s=r,o=n.shape[0];r=Fe(r,[o,r.shape[0]/o,r.shape[1]]),s.dispose()}return r}}),tS=De({conv2DBackpropFilter_:function(n,e,t,r,s,o="NHWC",A){let u=n;n.rank===3&&(u=Fe(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let h=e;h.rank===3&&(h=Fe(e,[1,e.shape[0],e.shape[1],e.shape[2]])),J(u.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${u.shape}.`),J(h.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${h.shape}.`),J(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const l=o==="NHWC"?u.shape[3]:u.shape[1],c=o==="NHWC"?h.shape[3]:h.shape[1];J(l===t[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${t[2]}.`),J(c===t[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${t[3]}).`),A!=null&&J(Et(s),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${A} but got pad ${s}.`);const d={x:u,dy:h},m={strides:r,pad:s,dataFormat:o,dimRoundingMode:A,filterShape:t};return Ne.runKernel(He,d,m)}}),nS=De({relu6_:function(n){const e={x:le(n,"x","relu6")};return Ne.runKernel(om,e)}}),Fm=De({step_:function(n,e=0){const t={x:le(n,"x","step")},r={alpha:e};return Ne.runKernel(xm,t,r)}});function tx(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return Me(n,Fm(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function nx(n,e){let t=e;const r=Ms(n.shape,e.shape);return r.length>0&&(t=Qt(t,r)),Fe(t,n.shape)}function rx(n,e,t,r){if(e==="linear")return n;if(e==="relu")return IA(n);if(e==="elu")return Mm(n);if(e==="relu6")return nS(n);if(e==="prelu")return Qv(n,t);if(e==="leakyrelu")return Xv(n,r);if(e==="sigmoid")return Oc(n);throw new Error(`Unknown fused activation ${e}.`)}const sx=(n,e)=>!(n>0)||e==="linear",I4=De({fusedConv2d_:function({x:n,filter:e,strides:t,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:A,bias:u,activation:h="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(h=h||"linear",sx(Ne.state.gradientDepth,h)===!1){let L=uu(n,e,t,r,s,o,A);return u!=null&&(L=vt(L,u)),rx(L,h,l,c)}const d=le(n,"x","conv2d"),m=le(e,"filter","conv2d");let y=d,b=!1;d.rank===3&&(b=!0,y=Fe(d,[1,d.shape[0],d.shape[1],d.shape[2]])),J(y.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${y.rank}.`),J(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),A!=null&&J(Et(r),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${A} but got pad ${r}.`),J(y.shape[3]===m.shape[2],()=>`Error in conv2d: depth of input (${y.shape[3]}) must match input depth for filter ${m.shape[2]}.`),J(oa(t,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),J(s==="NHWC",()=>`Error in conv2d: got dataFormat of ${s} but only NHWC is currently supported.`);const v=Vs(y.shape,m.shape,t,o,r,A);let w,I;u!=null&&(w=le(u,"bias","fused conv2d"),[w]=_r(w,d),Bn(v.outShape,w.shape)),l!=null&&(I=le(l,"prelu weights","fused conv2d"));const S=(L,W)=>{const[K,U,_,ee]=W,re=tx(L,_,h);J(lu(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const ce=[jI(U.shape,re,K,t,r),tS(U,re,K.shape,t,r)];if(ee!=null){const we=nx(ee,re);ce.push(we)}return ce},T={x:y,filter:m,bias:w,preluActivationWeights:I},D={strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:A,activation:h,leakyreluAlpha:c};return u==null?ll((W,K,U)=>{let _=Ne.runKernel(Nv,T,D);return U([K,W,_]),b&&(_=Fe(_,[_.shape[1],_.shape[2],_.shape[3]])),{value:_,gradFunc:S}})(y,m):ll((W,K,U,_)=>{let ee=Ne.runKernel(Nv,T,D);return _([K,W,ee,U]),b&&(ee=Fe(ee,[ee.shape[1],ee.shape[2],ee.shape[3]])),{value:ee,gradFunc:S}})(y,m,w)}}),S4=De({depthwiseConv2dNativeBackpropFilter_:function(n,e,t,r,s,o=[1,1],A){let u=n;n.rank===3&&(u=Fe(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let h=e;h.rank===3&&(h=Fe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={x:u,dy:h},c={strides:r,pad:s,dimRoundingMode:A,dilations:o,filterShape:t};return Ne.runKernel(Vi,l,c)}}),N4=De({depthwiseConv2dNativeBackpropInput_:function(n,e,t,r,s,o=[1,1],A){let u=e,h=!1;e.rank===3&&(h=!0,u=Fe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={dy:u,filter:t},c={strides:r,pad:s,dimRoundingMode:A,dilations:o,inputShape:n},d=Ne.runKernel(sa,l,c);return h?Fe(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),bee=De({fusedDepthwiseConv2d_:function({x:n,filter:e,strides:t,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:A,bias:u,activation:h="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(sx(Ne.state.gradientDepth,h)===!1){let L=Tm(n,e,t,r,s,o,A);return u!=null&&(L=vt(L,u)),rx(L,h,l,c)}const d=le(n,"x","depthwiseConv2d"),m=le(e,"filter","depthwiseConv2d");let y=d,b=!1;d.rank===3&&(b=!0,y=Fe(d,[1,d.shape[0],d.shape[1],d.shape[2]])),J(y.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${y.rank}.`),J(m.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${m.rank}.`),J(y.shape[3]===m.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${y.shape[3]}) must match the inChannels dimension in filter ${m.shape[2]}.`),o==null&&(o=[1,1]),J(oa(t,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),A!=null&&J(Et(r),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${A} but got pad ${r}.`);const v=Vs(y.shape,m.shape,t,o,r,A,!0);let w,I;u!=null&&(w=le(u,"bias","fused conv2d"),[w]=_r(w,d),Bn(v.outShape,w.shape)),l!=null&&(I=le(l,"prelu weights","fused depthwiseConv2d"));const S=(L,W)=>{J(lu(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[K,U,_,ee]=W,re=tx(L,_,h),ce=N4(U.shape,re,K,t,r,o,A),we=S4(U,re,K.shape,t,r,o,A);return ee!=null?[ce,we,nx(w,re)]:[ce,we]},T={x:y,filter:m,bias:w,preluActivationWeights:I},D={strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:A,activation:h,leakyreluAlpha:c};return u==null?ll((W,K,U)=>{let _=Ne.runKernel(Tv,T,D);return U([K,W,_]),b&&(_=Fe(_,[_.shape[1],_.shape[2],_.shape[3]])),{value:_,gradFunc:S}})(y,m):ll((W,K,U,_)=>{let ee=Ne.runKernel(Tv,T,D);return _([K,W,ee,U]),b&&(ee=Fe(ee,[ee.shape[1],ee.shape[2],ee.shape[3]])),{value:ee,gradFunc:S}})(y,m,w)}}),rS=De({fusedMatMul_:function({a:n,b:e,transposeA:t=!1,transposeB:r=!1,bias:s,activation:o="linear",preluActivationWeights:A,leakyreluAlpha:u}){if(sx(Ne.state.gradientDepth,o)===!1){let ee=nr(n,e,t,r);return s!=null&&(ee=vt(ee,s)),rx(ee,o,A,u)}let h=le(n,"a","fused matMul"),l=le(e,"b","fused matMul");[h,l]=_r(h,l);const c=t?h.shape[h.rank-2]:h.shape[h.rank-1],d=r?l.shape[l.rank-1]:l.shape[l.rank-2],m=t?h.shape[h.rank-1]:h.shape[h.rank-2],y=r?l.shape[l.rank-2]:l.shape[l.rank-1],b=h.shape.slice(0,-2),v=l.shape.slice(0,-2),w=Ye(b),I=Ye(v);J(h.rank>=2&&l.rank>=2&&h.rank===l.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${h.rank} and ${l.rank}.`),J(ht(b,v),()=>`Error in fused matMul: outer dimensions (${b}) and (${v}) of Tensors with shapes ${h.shape} and ${l.shape} must match.`),J(c===d,()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${h.shape} and ${l.shape} and transposeA=${t} and transposeB=${r} must match.`);const S=h.shape.slice(0,-2).concat([m,y]),T=Fe(h,t?[w,c,m]:[w,m,c]),D=Fe(l,r?[I,y,d]:[I,d,y]);let L,W;s!=null&&(L=le(s,"bias","fused matMul"),[L]=_r(L,h),Bn(S,L.shape)),A!=null&&(W=le(A,"prelu weights","fused matMul"));const K=(ee,re)=>{const[ce,we,Ee,Pe]=re,he=tx(Fe(ee,Ee.shape),Ee,o);let de,Ae;return t||r?!t&&r?(de=nr(he,we,!1,!1),Ae=nr(he,ce,!0,!1)):t&&!r?(de=nr(we,he,!1,!0),Ae=nr(ce,he,!1,!1)):(de=nr(we,he,!0,!0),Ae=nr(he,ce,!0,!0)):(de=nr(he,we,!1,!0),Ae=nr(ce,he,!0,!1)),s!=null?[de,Ae,nx(Pe,he)]:[de,Ae]},U={a:T,b:D,bias:L,preluActivationWeights:W},_={transposeA:t,transposeB:r,activation:o,leakyreluAlpha:u};return s==null?ll((re,ce,we)=>{const Ee=Ne.runKernel(Sv,U,_);return we([re,ce,Ee]),{value:Fe(Ee,S),gradFunc:K}})(T,D):ll((re,ce,we,Ee)=>{const Pe=Ne.runKernel(Sv,U,_);return Ee([re,ce,Pe,we]),{value:Fe(Pe,S),gradFunc:K}})(T,D,L)}});function T4(n,e,t){const r=1-n%2,s=new Float32Array(n);for(let o=0;o<n;++o){const A=2*Math.PI*o/(n+r-1);s[o]=e-t*Math.cos(A)}return Ra(s,"float32")}De({hammingWindow_:function(n){return T4(n,.54,.46)}});const vee=De({hannWindow_:function(n){return T4(n,.5,.5)}}),xee=De({frame_:function(n,e,t,r=!1,s=0){let o=0;const A=[];for(;o+e<=n.size;)A.push(or(n,o,e)),o+=t;if(r)for(;o<n.size;){const u=o+e-n.size,h=ys([or(n,o,e-u),Em([u],s)]);A.push(h),o+=t}return A.length===0?$v([],[0,e]):Fe(ys(A),[A.length,e])}});De({stft_:function(n,e,t,r,s=vee){var o;r==null&&(o=e,r=Math.floor(Math.pow(2,Math.ceil(Math.log(o)/Math.log(2)))));const A=xee(n,e,t),u=Me(A,s(e));return eS(u,r)}});const wee=De({cropAndResize_:function(n,e,t,r,s="bilinear",o=0){const A=le(n,"image","cropAndResize"),u=le(e,"boxes","cropAndResize","float32"),h=le(t,"boxInd","cropAndResize","int32"),l=u.shape[0];J(A.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${A.rank}.`),J(u.rank===2&&u.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${u.shape}.`),J(h.rank===1&&h.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${u.shape}.`),J(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),J(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),J(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const c={image:A,boxes:u,boxInd:h},d={method:s,extrapolationValue:o,cropSize:r};return Ne.runKernel(Ja,c,d)}}),kee=De({flipLeftRight_:function(n){const e=le(n,"image","flipLeftRight","float32");J(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return Ne.runKernel(BC,t,{})}}),Cee=De({grayscaleToRGB_:function(n){const e=le(n,"image","grayscaleToRGB"),t=e.rank-1,r=e.shape[t];J(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),J(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(e.rank);return s.fill(1,0,t),s[t]=3,vi(e,s)}}),Iee=De({rotateWithOffset_:function(n,e,t=0,r=.5){const s=le(n,"image","rotateWithOffset","float32");J(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const o={image:s},A={radians:e,fillValue:t,center:r};return Ne.runKernel(hI,o,A)}});function Ep(n,e,t,r,s,o){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),o==null&&(o=0);const A=n.shape[0];return t=Math.min(t,A),J(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),J(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),J(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),J(e.rank===1,()=>"scores must be a 1D tensor"),J(e.shape[0]===A,()=>`scores has incompatible shape with boxes. Expected ${A}, but was ${e.shape[0]}`),J(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:t,iouThreshold:r,scoreThreshold:s,softNmsSigma:o}}const See=De({nonMaxSuppression_:function(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY){const o=le(n,"boxes","nonMaxSuppression"),A=le(e,"scores","nonMaxSuppression"),u=Ep(o,A,t,r,s),h={maxOutputSize:t=u.maxOutputSize,iouThreshold:r=u.iouThreshold,scoreThreshold:s=u.scoreThreshold};return Ne.runKernel(ZC,{boxes:o,scores:A},h)}});function Nee(n,e,t){const r=function(o,A,u){return function(h,l,c){let d=0,m=h.length,y=0,b=!1;for(;d<m;){y=d+(m-d>>>1);const v=c(l,h[y]);v>0?d=y+1:(m=y,b=!v)}return b?d:-d-1}(o,A,u||Tee)}(n,e,t),s=r<0?-(r+1):r;n.splice(s,0,e)}function Tee(n,e){return n>e?1:n<e?-1:0}function sS(n,e,t,r,s){return iS(n,e,t,r,s,0)}function aS(n,e,t,r,s,o){return iS(n,e,t,r,s,0,!1,o,!0)}function oS(n,e,t,r,s,o){return iS(n,e,t,r,s,o,!0)}function iS(n,e,t,r,s,o,A=!1,u=!1,h=!1){const l=[];for(let w=0;w<e.length;w++)e[w]>s&&l.push({score:e[w],boxIndex:w,suppressBeginIndex:0});l.sort(M4);const c=o>0?-.5/o:0,d=[],m=[];for(;d.length<t&&l.length>0;){const w=l.pop(),{score:I,boxIndex:S,suppressBeginIndex:T}=w;if(I<s)break;let D=!1;for(let L=d.length-1;L>=T;--L){const W=Mee(n,S,d[L]);if(W>=r){D=!0;break}if(w.score=w.score*Eee(r,c,W),w.score<=s)break}w.suppressBeginIndex=d.length,D||(w.score===I?(d.push(S),m.push(w.score)):w.score>s&&Nee(l,w,M4))}const y=d.length,b=t-y;u&&b>0&&(d.push(...new Array(b).fill(0)),m.push(...new Array(b).fill(0)));const v={selectedIndices:d};return A&&(v.selectedScores=m),h&&(v.validOutputs=y),v}function Mee(n,e,t){const r=n.subarray(4*e,4*e+4),s=n.subarray(4*t,4*t+4),o=Math.min(r[0],r[2]),A=Math.min(r[1],r[3]),u=Math.max(r[0],r[2]),h=Math.max(r[1],r[3]),l=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),m=Math.max(s[1],s[3]),y=(u-o)*(h-A),b=(d-l)*(m-c);if(y<=0||b<=0)return 0;const v=Math.max(o,l),w=Math.max(A,c),I=Math.min(u,d),S=Math.min(h,m),T=Math.max(I-v,0)*Math.max(S-w,0);return T/(y+b-T)}function Eee(n,e,t){const r=Math.exp(e*t*t);return t<=n?r:0}function M4(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}const Dee=De({nonMaxSuppressionWithScore_:function(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const A=le(n,"boxes","nonMaxSuppression"),u=le(e,"scores","nonMaxSuppression"),h=Ep(A,u,t,r,s,o),l={boxes:A,scores:u},c={maxOutputSize:t=h.maxOutputSize,iouThreshold:r=h.iouThreshold,scoreThreshold:s=h.scoreThreshold,softNmsSigma:o=h.softNmsSigma},d=Ne.runKernel(UC,l,c);return{selectedIndices:d[0],selectedScores:d[1]}}}),zee=De({nonMaxSuppressionPadded_:function(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const A=le(n,"boxes","nonMaxSuppression"),u=le(e,"scores","nonMaxSuppression"),h=Ep(A,u,t,r,s,null),l={boxes:A,scores:u},c={maxOutputSize:h.maxOutputSize,iouThreshold:h.iouThreshold,scoreThreshold:h.scoreThreshold,padToMaxOutputSize:o},d=Ne.runKernel(YC,l,c);return{selectedIndices:d[0],validOutputs:d[1]}}}),E4=De({resizeBilinear_:function(n,e,t=!1,r=!1){const s=le(n,"images","resizeBilinear");J(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),J(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),J(r===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=s,A=!1;s.rank===3&&(A=!0,o=Fe(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const u={images:o},h={alignCorners:t,halfPixelCenters:r,size:e},l=Ne.runKernel(hv,u,h);return A?Fe(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),D4=De({resizeNearestNeighbor_:function(n,e,t=!1,r=!1){const s=le(n,"images","resizeNearestNeighbor");J(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),J(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),J(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),J(r===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=s,A=!1;s.rank===3&&(A=!0,o=Fe(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const u={images:o},h={alignCorners:t,halfPixelCenters:r,size:e},l=Ne.runKernel(pv,u,h);return A?Fe(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),z4=De({bincount_:function(n,e,t){const r=le(n,"x","bincount"),s=le(e,"weights","bincount");J(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),J(t>=0,()=>`size must be non-negative, but got ${t}.`),J(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const o={x:r,weights:s},A={size:t};return Ne.runKernel(va,o,A)}}),Pc=De({lessEqual_:function(n,e){let t=le(n,"a","lessEqual","string_or_numeric"),r=le(e,"b","lessEqual","string_or_numeric");[t,r]=_r(t,r),Bn(t.shape,r.shape);const s={a:t,b:r};return Ne.runKernel(Q0,s)}}),AS=De({round_:function(n){const e={x:le(n,"x","round")};return Ne.runKernel(im,e)}});function Lm(n,e,t=1,r="float32"){if(t===0)throw new Error("Cannot have a step of zero");const s={start:n,stop:e,step:t,dtype:r};return Ne.runKernel(KC,{},s)}const Oee=De({threshold_:function(n,e="binary",t=!1,r=.5){const s=le(n,"image","threshold"),o=s.shape[0]*s.shape[1];let A,u,h,l,c=Me(Ra([r]),255);if(J(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),J(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),J(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),J(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),s.shape[2]===3){[A,u,h]=_a(s,[1,1,1],-1);const m=Me(A,.2989),y=Me(u,.587),b=Me(h,.114);l=vt(vt(m,y),b)}else l=n;e==="otsu"&&(c=function(m,y){let b,v,w,I,S,T,D=Ra([-1]),L=Ra([0]),W=Ra([0]);for(let K=0;K<m.size-1;K++){b=or(m,0,K+1),v=or(m,K+1),S=an(Qt(b),y),T=an(Qt(v),y);const U=Qt(Me(b,Lm(0,b.size)));w=an(U,Qt(b));const _=Em(v.shape,b.size),ee=vt(Lm(0,v.size),_),re=Me(v,ee);I=an(Qt(re),Qt(v));const ce=Ut(w,I),we=Ut(w,I),Ee=Me(S,T);W=Me(Me(Ee,ce),we);const Pe=qo(W,L);L=eo(Pe,W,L),D=eo(Pe,Ra([K]),D)}return D}(z4(zt(AS(l),"int32"),ru([]),256),o));const d=t?Pc(l,c):qo(l,c);return zt(Me(d,255),"int32")}}),Pee=De({transform_:function(n,e,t="nearest",r="constant",s=0,o){const A=le(n,"image","transform","float32"),u=le(e,"transforms","transform","float32");J(A.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${A.rank}.`),J(u.rank===2&&(u.shape[0]===A.shape[0]||u.shape[0]===1)&&u.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),J(o==null||o.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`);const h={image:A,transforms:u},l={interpolation:t,fillMode:r,fillValue:s,outputShape:o};return Ne.runKernel(cI,h,l)}}),Bee=De({bandPart_:function(n,e,t){J(e%1==0,()=>`bandPart(): numLower must be an integer, got ${e}.`),J(t%1==0,()=>`bandPart(): numUpper must be an integer, got ${t}.`);const r=le(n,"a","bandPart");J(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[o,A]=r.shape.slice(-2);if(!(e<=o))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${o}).`);if(!(t<=A))throw new Error(`bandPart(): numUpper (${t}) must not be greater than the number of columns (${A}).`);e<0&&(e=o),t<0&&(t=A);const u=Fe(Lm(0,o,1,"int32"),[-1,1]),h=Lm(0,A,1,"int32"),l=Ut(u,h),c=CA(Pc(l,un(+e,"int32")),zc(l,un(-t,"int32"))),d=Es([o,A],r.dtype);return Fe(xi(Ui(Fe(r,[-1,o,A])).map(m=>eo(c,m,d))),s)}}),ax=De({min_:function(n,e=null,t=!1){const r={x:le(n,"x","min")},s={axis:e,keepDims:t};return Ne.runKernel(rv,r,s)}}),Bc=De({pow_:function(n,e){let t=le(n,"base","pow"),r=le(e,"exp","pow");[t,r]=_r(t,r);const s={a:t,b:r};return Ne.runKernel(rm,s)}});function O4(n,e,t=null){if(n.rank===0)return Ts(n);if(n.rank!==1&&t===null)return O4(Fe(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return Qt(Ts(n),t);if(e===1/0)return Yi(Ts(n),t);if(e===-1/0)return ax(Ts(n),t);if(e==="euclidean"||e===2)return wa(Qt(Bc(Ts(n),un(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return Yi(Qt(Ts(n),t[0]),t[1]-1);if(e===1/0)return Yi(Qt(Ts(n),t[1]),t[0]);if(e===-1/0)return ax(Qt(Ts(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return wa(Qt(xr(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const lS=De({norm_:function(n,e="euclidean",t=null,r=!1){const s=O4(n=le(n,"x","norm"),e,t);let o=s.shape;if(r){const A=pt(t,n.shape);o=us(s.shape,A)}return Fe(s,o)}}),Fee=De({gramSchmidt_:function(n){let e;if(Array.isArray(n)){e=!1,J(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=n[0].shape[0];for(let o=1;o<n.length;++o)J(n[o].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[o].shape[0]} vs. ${s})`)}else e=!0,n=_a(n,n.shape[0],0).map(s=>cu(s,[0]));J(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],r=n;for(let s=0;s<n.length;++s)t.push(Ne.tidy(()=>{let o=r[s];if(s>0)for(let A=0;A<s;++A){const u=Me(Qt(Me(t[A],o)),t[A]);o=Ut(o,u)}return an(o,lS(o,"euclidean"))}));return e?xi(t,0):t}});function P4(n,e=!1){return Ne.tidy(()=>{J(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],r=n.shape[1];let s=y4(t),o=ou(n);const A=$v([[1]],[1,1]);let u=ou(A);const h=t>=r?r:t;for(let l=0;l<h;++l){const c=o,d=u,m=s;[u,o,s]=Ne.tidy(()=>{const y=or(o,[l,l],[t-l,1]),b=lS(y),v=or(o,[l,l],[1,1]),w=eo(qo(v,0),$v([[-1]]),$v([[1]])),I=Ut(v,Me(w,b)),S=an(y,I);u=S.shape[0]===1?ou(A):ys([A,or(S,[1,0],[S.shape[0]-1,S.shape[1]])],0);const T=Yr(an(nr(w,I),b)),D=or(o,[l,0],[t-l,r]),L=Me(T,u),W=Yn(u);if(l===0)o=Ut(D,nr(L,nr(W,D)));else{const _=Ut(D,nr(L,nr(W,D)));o=ys([or(o,[0,0],[l,r]),_],0)}const K=Yn(L),U=or(s,[0,l],[t,s.shape[1]-l]);if(l===0)s=Ut(U,nr(nr(U,u),K));else{const _=Ut(U,nr(nr(U,u),K));s=ys([or(s,[0,0],[t,l]),_],1)}return[u,o,s]}),Rn([c,d,m])}return!e&&t>r&&(s=or(s,[0,0],[t,r]),o=or(o,[0,0],[r,r])),[s,o]})}const Lee=De({qr_:function(n,e=!1){if(J(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return P4(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((A,u)=>A*u),r=Ui(Fe(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),s=[],o=[];return r.forEach(A=>{const[u,h]=P4(A,e);s.push(u),o.push(h)}),[Fe(xi(s,0),n.shape),Fe(xi(o,0),n.shape)]}}});var to,du;(du=to||(to={}))[du.NONE=0]="NONE",du[du.MEAN=1]="MEAN",du[du.SUM=2]="SUM",du[du.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS";const pu=De({computeWeightedLoss_:function(n,e,t=to.SUM_BY_NONZERO_WEIGHTS){const r=le(n,"losses","computeWeightedLoss");let s=null;e!=null&&(s=le(e,"weights","computeWeightedLoss"));const o=s==null?r:Me(r,s);if(t===to.NONE)return o;if(t===to.SUM)return Qt(o);if(t===to.MEAN){if(s==null)return es(o);{const A=r.size/s.size,u=an(Qt(o),Qt(s));return A>1?an(u,un(A)):u}}if(t===to.SUM_BY_NONZERO_WEIGHTS){if(s==null)return an(Qt(o),un(r.size));{const A=Me(s,pl(r.shape)),u=zt(Qt(Tp(A,un(0))),"float32");return an(Qt(o),u)}}throw Error(`Unknown reduction: ${t}`)}});De({absoluteDifference_:function(n,e,t,r=to.SUM_BY_NONZERO_WEIGHTS){const s=le(n,"labels","absoluteDifference"),o=le(e,"predictions","absoluteDifference");let A=null;t!=null&&(A=le(t,"weights","absoluteDifference")),gn(s.shape,o.shape,"Error in absoluteDifference: ");const u=Ts(Ut(s,o));return pu(u,A,r)}}),De({cosineDistance_:function(n,e,t,r,s=to.SUM_BY_NONZERO_WEIGHTS){const o=le(n,"labels","cosineDistance"),A=le(e,"predictions","cosineDistance");let u=null;r!=null&&(u=le(r,"weights","cosineDistance")),gn(o.shape,A.shape,"Error in cosineDistance: ");const h=un(1),l=Ut(h,Qt(Me(o,A),t,!0));return pu(l,u,s)}}),De({hingeLoss_:function(n,e,t,r=to.SUM_BY_NONZERO_WEIGHTS){let s=le(n,"labels","hingeLoss");const o=le(e,"predictions","hingeLoss");let A=null;t!=null&&(A=le(t,"weights","hingeLoss")),gn(s.shape,o.shape,"Error in hingeLoss: ");const u=un(1);s=Ut(Me(un(2),s),u);const h=IA(Ut(u,Me(s,o)));return pu(h,A,r)}}),De({huberLoss_:function(n,e,t,r=1,s=to.SUM_BY_NONZERO_WEIGHTS){const o=le(n,"labels","huberLoss"),A=le(e,"predictions","huberLoss");let u=null;t!=null&&(u=le(t,"weights","huberLoss")),gn(o.shape,A.shape,"Error in huberLoss: ");const h=un(r),l=Ts(Ut(A,o)),c=Om(l,h),d=Ut(l,c),m=vt(Me(un(.5),xr(c)),Me(h,d));return pu(m,u,s)}}),De({logLoss_:function(n,e,t,r=1e-7,s=to.SUM_BY_NONZERO_WEIGHTS){const o=le(n,"labels","logLoss"),A=le(e,"predictions","logLoss");let u=null;t!=null&&(u=le(t,"weights","logLoss")),gn(o.shape,A.shape,"Error in logLoss: ");const h=un(1),l=un(r),c=Yr(Me(o,Jo(vt(A,l)))),d=Me(Ut(h,o),Jo(vt(Ut(h,A),l))),m=Ut(c,d);return pu(m,u,s)}});const uS=De({squaredDifference_:function(n,e){let t=le(n,"a","squaredDifference"),r=le(e,"b","squaredDifference");[t,r]=_r(t,r),Bn(t.shape,r.shape);const s={a:t,b:r};return Ne.runKernel(mm,s,{})}});De({meanSquaredError_:function(n,e,t,r=to.SUM_BY_NONZERO_WEIGHTS){const s=le(n,"labels","meanSquaredError"),o=le(e,"predictions","meanSquaredError");let A=null;t!=null&&(A=le(t,"weights","meanSquaredError")),gn(s.shape,o.shape,"Error in meanSquaredError: ");const u=uS(s,o);return pu(u,A,r)}}),De({sigmoidCrossEntropy_:function(n,e,t,r=0,s=to.SUM_BY_NONZERO_WEIGHTS){let o=le(n,"multiClassLabels","sigmoidCrossEntropy");const A=le(e,"logits","sigmoidCrossEntropy");let u=null;if(t!=null&&(u=le(t,"weights","sigmoidCrossEntropy")),gn(o.shape,A.shape,"Error in sigmoidCrossEntropy: "),r>0){const l=un(r),c=un(1),d=un(.5);o=vt(Me(o,Ut(c,l)),Me(d,l))}const h=function(l,c){const d=le(l,"labels","sigmoidCrossEntropyWithLogits"),m=le(c,"logits","sigmoidCrossEntropyWithLogits");gn(d.shape,m.shape,"Error in sigmoidCrossEntropyWithLogits: ");const y=IA(m),b=Me(m,d),v=Zv(Qo(Yr(Ts(m))));return vt(Ut(y,b),v)}(o,A);return pu(h,u,s)}});const B4=De({logSumExp_:function(n,e=null,t=!1){const r=le(n,"x","logSumExp"),s=pt(e,r.shape),o=Yi(r,s,!0),A=Ut(r,o),u=Qo(A),h=Qt(u,s),l=Jo(h),c=vt(Fe(o,l.shape),l);if(t){const d=us(c.shape,s);return Fe(c,d)}return c}});De({softmaxCrossEntropy_:function(n,e,t,r=0,s=to.SUM_BY_NONZERO_WEIGHTS){let o=le(n,"onehotLabels","softmaxCrossEntropy");const A=le(e,"logits","softmaxCrossEntropy");let u=null;if(t!=null&&(u=le(t,"weights","softmaxCrossEntropy")),gn(o.shape,A.shape,"Error in softmaxCrossEntropy: "),r>0){const l=un(r),c=un(1),d=un(o.shape[1]);o=vt(Me(o,Ut(c,l)),an(l,d))}const h=function(l,c,d=-1){if(d===-1&&(d=c.rank-1),d!==c.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${c.rank} and dim was ${d}`);return ll((y,b,v)=>{const w=B4(b,[d],!0),I=Ut(zt(b,"float32"),w);v([y,I]);const S=Yr(Me(I,y));return{value:Qt(S,[d]),gradFunc:(T,D)=>{const[L,W]=D,K=us(T.shape,[d]);return[Me(Fe(T,K),Ut(zt(L,"float32"),Qo(W))),Me(Fe(T,K),Ut(Qo(W),zt(L,"float32")))]}}})(l,c)}(o,A);return pu(h,u,s)}});const Ree=De({sparseFillEmptyRows_:function(n,e,t,r){const s=le(n,"indices","sparseFillEmptyRows"),o=le(e,"values","sparseFillEmptyRows"),A=le(t,"denseShape","sparseFillEmptyRows"),u=le(r,"defaultValue","sparseFillEmptyRows",o.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(o.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(A.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${A.shape}`);if(u.rank!==0)throw new Error(`Default value should be a scalar but received shape ${u.shape}`);const h={indices:s,values:o,denseShape:A,defaultValue:u},l=Ne.runKernel(eI,h);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}}),Wee=De({sparseReshape_:function(n,e,t){const r=le(n,"inputIndices","sparseReshape"),s=le(e,"inputShape","sparseReshape"),o=le(t,"newShape","sparseReshape");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(o.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const A={inputIndices:r,inputShape:s,newShape:o},u=Ne.runKernel(tI,A);return{outputIndices:u[0],outputShape:u[1]}}}),jee=De({sparseSegmentMean_:function(n,e,t){const r=le(n,"data","sparseSegmentMean"),s=le(e,"indices","sparseSegmentMean"),o=le(t,"segmentIds","sparseSegmentMean");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${o.shape}`);const A={data:r,indices:s,segmentIds:o};return Ne.runKernel(nI,A)}}),Hee=De({sparseSegmentSum_:function(n,e,t){const r=le(n,"data","sparseSegmentSum"),s=le(e,"indices","sparseSegmentSum"),o=le(t,"segmentIds","sparseSegmentSum");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${o.shape}`);const A={data:r,indices:s,segmentIds:o};return Ne.runKernel(rI,A)}}),Gee=De({stringNGrams_:function(n,e,t,r,s,o,A,u){const h=le(n,"data","stringNGrams","string");if(h.dtype!=="string")throw new Error("Data must be of datatype string");if(h.shape.length!==1)throw new Error(`Data must be a vector, saw: ${h.shape}`);const l=le(e,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const c={separator:t,nGramWidths:r,leftPad:s,rightPad:o,padWidth:A,preserveShortSequences:u},d={data:h,dataSplits:l},m=Ne.runKernel(iI,d,c);return{nGrams:m[0],nGramsSplits:m[1]}}}),Vee=De({stringSplit_:function(n,e,t=!0){const r=le(n,"input","stringSplit","string"),s=le(e,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const o={skipEmpty:t},A={input:r,delimiter:s},u=Ne.runKernel(AI,A,o);return{indices:u[0],values:u[1],shape:u[2]}}}),Xee=De({stringToHashBucketFast_:function(n,e){const t=le(n,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const s={input:t};return Ne.runKernel(lI,s,r)}}),Qi={flipLeftRight:kee,grayscaleToRGB:Cee,resizeNearestNeighbor:D4,resizeBilinear:E4,rotateWithOffset:Iee,cropAndResize:wee,nonMaxSuppression:See,nonMaxSuppressionAsync:async function(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY){const o=le(n,"boxes","nonMaxSuppressionAsync"),A=le(e,"scores","nonMaxSuppressionAsync"),u=Ep(o,A,t,r,s);t=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold;const h=await Promise.all([o.data(),A.data()]),l=h[0],c=h[1],{selectedIndices:d}=sS(l,c,t,r,s);return o!==n&&o.dispose(),A!==e&&A.dispose(),Ra(d,"int32")},nonMaxSuppressionWithScore:Dee,nonMaxSuppressionWithScoreAsync:async function(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const A=le(n,"boxes","nonMaxSuppressionAsync"),u=le(e,"scores","nonMaxSuppressionAsync"),h=Ep(A,u,t,r,s,o);t=h.maxOutputSize,r=h.iouThreshold,s=h.scoreThreshold,o=h.softNmsSigma;const l=await Promise.all([A.data(),u.data()]),c=l[0],d=l[1],{selectedIndices:m,selectedScores:y}=oS(c,d,t,r,s,o);return A!==n&&A.dispose(),u!==e&&u.dispose(),{selectedIndices:Ra(m,"int32"),selectedScores:Ra(y)}},nonMaxSuppressionPadded:zee,nonMaxSuppressionPaddedAsync:async function(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const A=le(n,"boxes","nonMaxSuppressionAsync"),u=le(e,"scores","nonMaxSuppressionAsync"),h=Ep(A,u,t,r,s,null),l=h.maxOutputSize,c=h.iouThreshold,d=h.scoreThreshold,[m,y]=await Promise.all([A.data(),u.data()]),{selectedIndices:b,validOutputs:v}=aS(m,y,l,c,d,o);return A!==n&&A.dispose(),u!==e&&u.dispose(),{selectedIndices:Ra(b,"int32"),validOutputs:un(v,"int32")}},threshold:Oee,transform:Pee},Zee={bandPart:Bee,gramSchmidt:Fee,qr:Lee},ox={sparseFillEmptyRows:Ree,sparseReshape:Wee,sparseSegmentMean:jee,sparseSegmentSum:Hee},cS={stringNGrams:Gee,stringSplit:Vee,stringToHashBucketFast:Xee};class dS extends iu{constructor(e,t,r=null){super(),this.learningRate=e,this.rho=t,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=Ne.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,r)=>{const s=Ne.registeredVariables[t],o=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${t}/accum_grad`,variable:Ve(()=>Vn(s).variable(o))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${t}/accum_var`,variable:Ve(()=>Vn(s).variable(o))});const A=Array.isArray(e)?e[r].tensor:e[t];if(A==null)return;const u=this.accumulatedGrads[r].variable,h=this.accumulatedUpdates[r].variable;Ve(()=>{const l=vt(Me(u,this.rho),Me(xr(A),1-this.rho)),c=Me(an(wa(vt(h,this.epsilon)),wa(vt(u,this.epsilon))),A),d=vt(Me(h,this.rho),Me(xr(c),1-this.rho));u.assign(l),h.assign(d);const m=vt(Me(c,-this.learningRate),s);s.assign(m)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Rn(this.accumulatedGrads.map(e=>e.variable)),Rn(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,r=!1;this.accumulatedGrads=e.slice(0,t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedUpdates=e.slice(t,2*t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}dS.className="Adadelta",gt(dS);class pS extends iu{constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,r)=>{const s=Ne.registeredVariables[t];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${t}/accumulator`,variable:Ve(()=>Em(s.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(e)?e[r].tensor:e[t];if(o==null)return;const A=this.accumulatedGrads[r].variable;Ve(()=>{const u=vt(A,xr(o));A.assign(u);const h=vt(Me(an(o,wa(vt(u,Ne.backend.epsilon()))),-this.learningRate),s);s.assign(h)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Rn(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),this.accumulatedGrads=e.map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}pS.className="Adagrad",gt(pS);class hS extends iu{constructor(e,t,r,s=null){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Ve(()=>{this.accBeta1=un(t).variable(),this.accBeta2=un(r).variable()}),s==null&&(this.epsilon=Ne.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);Ve(()=>{const r=Ut(1,this.accBeta1),s=Ut(1,this.accBeta2);t.forEach((o,A)=>{const u=Ne.registeredVariables[o],h=!1;this.accumulatedFirstMoment[A]==null&&(this.accumulatedFirstMoment[A]={originalName:`${o}/m`,variable:Ve(()=>Vn(u).variable(h))}),this.accumulatedSecondMoment[A]==null&&(this.accumulatedSecondMoment[A]={originalName:`${o}/v`,variable:Ve(()=>Vn(u).variable(h))});const l=Array.isArray(e)?e[A].tensor:e[o];if(l==null)return;const c=this.accumulatedFirstMoment[A].variable,d=this.accumulatedSecondMoment[A].variable,m=vt(Me(c,this.beta1),Me(l,1-this.beta1)),y=vt(Me(d,this.beta2),Me(xr(l),1-this.beta2)),b=an(m,r),v=an(y,s);c.assign(m),d.assign(y);const w=vt(Me(an(b,vt(wa(v),this.epsilon)),-this.learningRate),u);u.assign(w)}),this.accBeta1.assign(Me(this.accBeta1,this.beta1)),this.accBeta2.assign(Me(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Rn(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Rn(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),Ve(()=>{this.accBeta1.assign(Bc(this.beta1,this.iterations_+1)),this.accBeta2.assign(Bc(this.beta2,this.iterations_+1))});const t=e.length/2,r=!1;this.accumulatedFirstMoment=e.slice(0,t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedSecondMoment=e.slice(t,2*t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}hS.className="Adam",gt(hS);class fS extends iu{constructor(e,t,r,s=null,o=0){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=s,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Ve(()=>{this.iteration=un(0).variable(),this.accBeta1=un(t).variable()}),s==null&&(this.epsilon=Ne.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);Ve(()=>{const r=Ut(1,this.accBeta1),s=an(-this.learningRate,vt(Me(this.iteration,this.decay),1));t.forEach((o,A)=>{const u=Ne.registeredVariables[o],h=!1;this.accumulatedFirstMoment[A]==null&&(this.accumulatedFirstMoment[A]={originalName:`${o}/m`,variable:Vn(u).variable(h)}),this.accumulatedWeightedInfNorm[A]==null&&(this.accumulatedWeightedInfNorm[A]={originalName:`${o}/v`,variable:Vn(u).variable(h)});const l=Array.isArray(e)?e[A].tensor:e[o];if(l==null)return;const c=this.accumulatedFirstMoment[A].variable,d=this.accumulatedWeightedInfNorm[A].variable,m=vt(Me(c,this.beta1),Me(l,1-this.beta1)),y=Me(d,this.beta2),b=Ts(l),v=dl(y,b);c.assign(m),d.assign(v);const w=vt(Me(an(s,r),an(m,vt(v,this.epsilon))),u);u.assign(w)}),this.iteration.assign(vt(this.iteration,1)),this.accBeta1.assign(Me(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Rn(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Rn(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}fS.className="Adamax",gt(fS);class ix extends iu{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,r)=>{const s=Array.isArray(e)?e[r].tensor:e[t];if(s==null)return;const o=Ne.registeredVariables[t];Ve(()=>{const A=vt(Me(this.c,s),o);o.assign(A)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=aa(un(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if((e=await this.extractIterations(e)).length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}ix.className="SGD",gt(ix);class mS extends ix{constructor(e,t,r=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=r,this.accumulations=[],this.m=un(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,r)=>{const s=Ne.registeredVariables[t];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${t}/momentum`,variable:Ve(()=>Vn(s).variable(!1))});const o=this.accumulations[r].variable,A=Array.isArray(e)?e[r].tensor:e[t];A!=null&&Ve(()=>{let u;const h=vt(Me(this.m,o),A);u=this.useNesterov?vt(Me(this.c,vt(A,Me(h,this.m))),s):vt(Me(this.c,h),s),o.assign(h),s.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Rn(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),this.accumulations=e.map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}mS.className="Momentum",gt(mS);class gS extends iu{constructor(e,t=.9,r=0,s=null,o=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,s==null&&(this.epsilon=Ne.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,r)=>{const s=Ne.registeredVariables[t],o=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${t}/rms`,variable:Ve(()=>Vn(s).variable(o))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${t}/momentum`,variable:Ve(()=>Vn(s).variable(o))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${t}/mg`,variable:Ve(()=>Vn(s).variable(o))});const A=Array.isArray(e)?e[r].tensor:e[t];if(A==null)return;const u=this.accumulatedMeanSquares[r].variable,h=this.accumulatedMoments[r].variable;Ve(()=>{const l=vt(Me(u,this.decay),Me(xr(A),1-this.decay));if(this.centered){const c=this.accumulatedMeanGrads[r].variable,d=vt(Me(c,this.decay),Me(A,1-this.decay)),m=an(Me(A,this.learningRate),wa(Ut(l,vt(xr(d),this.epsilon)))),y=vt(Me(h,this.momentum),m);u.assign(l),c.assign(d),h.assign(y);const b=Ut(s,y);s.assign(b)}else{const c=vt(Me(u,this.decay),Me(xr(A),1-this.decay)),d=vt(Me(h,this.momentum),an(Me(A,this.learningRate),wa(vt(c,this.epsilon))));u.assign(c),h.assign(d);const m=Ut(s,d);s.assign(m)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Rn(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Rn(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Rn(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,r=!1;this.accumulatedMeanSquares=e.slice(0,t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedMoments=e.slice(t,2*t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}gS.className="RMSProp",gt(gS);class Fc{static sgd(e){return new ix(e)}static momentum(e,t,r=!1){return new mS(e,t,r)}static rmsprop(e,t=.9,r=0,s=null,o=!1){return new gS(e,t,r,s,o)}static adam(e=.001,t=.9,r=.999,s=null){return new hS(e,t,r,s)}static adadelta(e=.001,t=.95,r=null){return new dS(e,t,r)}static adamax(e=.002,t=.9,r=.999,s=null,o=0){return new fS(e,t,r,s,o)}static adagrad(e,t=.1){return new pS(e,t)}}const Dp={sgd:Fc.sgd,momentum:Fc.momentum,adadelta:Fc.adadelta,adagrad:Fc.adagrad,rmsprop:Fc.rmsprop,adamax:Fc.adamax,adam:Fc.adam},Yee=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function yS(){return new Promise(n=>Yee(()=>n()))}function bS(n,e){const t=n[0].length;n.forEach((s,o)=>{J(s.length===t,()=>`Error in concat${t}D: rank of tensors[${o}] must be the same as the rank of the rest (${t})`)}),J(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const r=n[0];n.forEach((s,o)=>{for(let A=0;A<t;A++)J(A===e||s[A]===r[A],()=>`Error in concat${t}D: Shape of tensors[${o}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${o}.`)})}function SA(n,e){const t=n[0].slice();for(let r=1;r<n.length;r++)t[e]+=n[r][e];return t}const vS=30;function Ax(n){return n<=vS?n:ba(n,Math.floor(Math.sqrt(n)))}function xS(n,e,t){return[t*(typeof n=="number"?n:n[0]),e*(typeof n=="number"?n:n[1])]}function Rm(n,e,t,r=!0){let s=[];if(r)s=s.concat(e.slice(0)),s.push(n[0]/t),s=s.concat(n.slice(1));else{s=s.concat(n[0]);const o=e.length;for(let A=0;A<o;++A)s=s.concat([n[A+1]/e[A],e[A]]);s=s.concat(n.slice(o+1))}return s}function Wm(n,e,t=!0){const r=[];if(t){r.push(e);for(let s=e+1;s<n;++s)s<=2*e?(r.push(s),r.push(s-(e+1))):r.push(s)}else{const s=[],o=[];for(let A=1;A<n;++A)A>=2*e+1||A%2==1?o.push(A):s.push(A);r.push(...s),r.push(0),r.push(...o)}return r}function jm(n,e,t,r=!0){const s=[];r?s.push(n[0]/t):s.push(n[0]*t);for(let o=1;o<n.length;++o)o<=e.length?r?s.push(e[o-1]*n[o]):s.push(n[o]/e[o-1]):s.push(n[o]);return s}function wS(n,e){const t=[0];for(let r=0;r<e;++r)t.push(n[r][0]);return t}function kS(n,e,t){const r=n.slice(0,1);for(let s=0;s<t;++s)r.push(n[s+1]-e[s][0]-e[s][1]);return r}function CS(n,e){const t=n.shape.length,r=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${t}`);if(Ye(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const s=e.shape,o=s[s.length-1];let A=1;for(let d=0;d<s.length-1;++d)A*=s[d];const u=n.shape,h=s.slice();h.pop();let l=1;for(let d=o;d<t;++d)l*=u[d],h.push(u[d]);const c=[...Je(n.shape).map(d=>d/l),1].slice(0,o);return[h,A,l,c]}function F4(n,e,t){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${s}.`;if(t.rank<s)throw new Error(o+` update.rank < ${s}. `);if(n.length<r+(t.rank-s))throw new Error(o+` Output shape length < ${r+(t.rank-s)}`);if(t.rank!==s+n.length-r)throw new Error(o+" update.rank != "+(s+n.length-r));for(let A=0;A<s;++A)if(t.shape[A]!==e.shape[A])throw new Error(o+` updates.shape[${A}] (${t.shape[A]}) != indices.shape[${A}] (${e.shape[A]}).`);for(let A=0;A<t.rank-s;++A)if(t.shape[A+s]!==n[A+r])throw new Error(o+` updates.shape[${A+s}] (${t.shape[A+s]}) != shape[${A+s}] (${n[A+s]})`)}function L4(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}F4(t,e,n)}function Hm(n,e,t){const r=e.shape.length,s=r>1?e.shape[r-1]:1,o=t.length;let A=1;for(let h=s;h<o;++h)A*=t[h];const u=s<1?1:s;return{sliceRank:s,numUpdates:Ye(e.shape)/u,sliceSize:A,strides:[...Je(t.slice(0,s)),1],outputSize:Ye(t)}}const lx=1.7580993408473768,ux=1.0507009873554805,IS=.3275911,SS=.254829592,NS=-.284496736,TS=1.421413741,MS=-1.453152027,ES=1.061405429;function fl(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(2*n.length);for(let r=0;r<t.length;r+=2)t[r]=n[r/2],t[r+1]=e[r/2];return t}function R4(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let r=0;r<n.length;r+=2)e[r/2]=n[r],t[r/2]=n[r+1];return{real:e,imag:t}}function W4(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),r=new Float32Array(e);for(let s=0;s<n.length;s+=4)t[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:t,imag:r}}function j4(n){const e=Math.floor(n.length/4),t=new Float32Array(e),r=new Float32Array(e);for(let s=2;s<n.length;s+=4)t[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:t,imag:r}}function DS(n,e){return{real:n[2*e],imag:n[2*e+1]}}function H4(n,e,t,r){n[2*r]=e,n[2*r+1]=t}function G4(n,e){const t=new Float32Array(n/2),r=new Float32Array(n/2);for(let s=0;s<Math.ceil(n/2);s++){const o=(e?2:-2)*Math.PI*(s/n);t[s]=Math.cos(o),r[s]=Math.sin(o)}return{real:t,imag:r}}function V4(n,e,t){const r=(t?2:-2)*Math.PI*(n/e);return{real:Math.cos(r),imag:Math.sin(r)}}const zS="->",Uee=/->/g,X4=",",Z4="...";function OS(n,e){const t=((n=n.replace(/\s/g,"")).length-n.replace(Uee,"").length)/zS.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${zS}").`);const[r,s]=n.split(zS);J(r.indexOf(Z4)===-1,()=>`The ellipsis notation ("${Z4}") is not supported yet.`);const o=r.split(X4),A=o.length;if(e!==A)throw new Error(`Expected ${A} input tensors, received ${e}`);if(A>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const u=[];for(let d=0;d<s.length;++d){const m=s[d];if(!o.some(y=>y.indexOf(m)!==-1))throw new Error(`Output subscripts contain the label ${m} not present in the input subscripts.`);u.indexOf(m)===-1&&u.push(m)}for(let d=0;d<r.length;++d){const m=r[d];u.indexOf(m)===-1&&m!==X4&&u.push(m)}const h=new Array(o.length);for(let d=0;d<A;++d){if(new Set(o[d].split("")).size!==o[d].length)throw new Error(`Found duplicate axes in input component ${o[d]}. Support for duplicate axes in input is not implemented yet.`);h[d]=[];for(let m=0;m<o[d].length;++m)h[d].push(u.indexOf(o[d][m]))}const l=u.length,c=[];for(let d=s.length;d<l;++d)c.push(d);return{allDims:u,summedDims:c,idDims:h}}function PS(n,e){let t=new Array(n);t.fill(-1);for(let s=0;s<e.length;++s)t[e[s]]=s;const r=[];for(let s=0;s<n;++s)t[s]===-1&&r.push(s);return t=t.filter(s=>s!==-1),{permutationIndices:t,expandDims:r}}function BS(n,e,t){const r=new Array(n);for(let s=0;s<t.length;++s){const o=t[s].shape;for(let A=0;A<e[s].length;++A)r[e[s][A]]===void 0?r[e[s][A]]=o[A]:J(r[e[s][A]]===o[A],()=>`Expected dimension ${r[e[s][A]]} at axis ${A} of input shaped ${JSON.stringify(o)}, but got dimension ${o[A]}`)}}function FS(n,e){const t=n,r=[];let s=0;n.length===0&&t.push(-1),s=n.length+1;for(let A=0;A<s;++A)r.push([]);const o=[];for(let A=0;A<t.length;++A){const u=Qee(e,t[A]);for(const h of u)o.indexOf(h)===-1&&(r[A].push(h),o.push(h))}return{path:t,steps:r}}function LS(n){return n.every((e,t)=>e===t)}function Qee(n,e){const t=[];for(let r=0;r<n.length;++r)n[r].length!==0&&n[r].indexOf(e)===-1&&e!==-1||t.push(r);return t}function RS(n,e,t=0){let r=[];if(typeof e=="number")J(n.shape[t]%e==0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(n.shape[t]/e);else{J(e.reduce((o,A)=>(A===-1&&(o+=1),o),0)<=1,()=>"There should be only one negative value in split array.");const s=e.indexOf(-1);if(s!==-1){const o=e.reduce((A,u)=>u>0?A+u:A);e[s]=n.shape[t]-o}J(n.shape[t]===e.reduce((o,A)=>o+A),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}function Y4(n,e){let t,r=!1;for(n<=vS?(t=n,r=!0):t=ba(n,Math.floor(Math.sqrt(n)));!r;)t>e||t===n?r=!0:t=ba(n,t+1);return t}function U4(n,e,t){const r=[],s=n.length;for(let o=0;o<s;o++)o!==e?r.push(n[o]):r.push(t);return r}function WS(n,e,t,r){const s=e.shape.length,o=n.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>o)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${o}).`);if(t<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${t}).`);for(let d=0;d<r;++d)if(n.shape[d]!==e.shape[d])throw new Error(`x.shape[${d}]: ${n.shape[d]} should be equal to indices.shape[${d}]: ${e.shape[d]}.`);const A=n.shape[t],u=[];let h=1,l=1,c=1;for(let d=0;d<r;++d)u.push(n.shape[d]),h*=n.shape[d];for(let d=r;d<t;d++)u.push(n.shape[d]),l*=n.shape[d];for(let d=r;d<s;d++)u.push(e.shape[d]);for(let d=t+1;d<o;d++)u.push(n.shape[d]),c*=n.shape[d];return{batchSize:h,sliceSize:c,outerSize:l,dimSize:A,outputShape:u}}function Lc(n){try{return n.map(e=>yp(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function Q4(n){return n.map(e=>nu(e))}function jS(n,e){const t=[];for(let o=0;o<e.length;o++)e[o]&&t.push(o);const r=Wn(n,"int32"),s=Wn([t.length,n.length],"int32");for(let o=0;o<t.length;o++){const A=r.indexToLoc(t[o]),u=o*n.length;s.values.set(A,u)}return s.toTensor()}const K4={kernelName:sl,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Me(n,Fm(zt(t,"float32"),-1))}}},Kee={kernelName:Hi,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=xr(zt(t,"float32")),s=wa(Ut(un(1),r));return Yr(an(n,s))}}}},qee={kernelName:ve,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=wa(Ut(xr(zt(t,"float32")),1));return an(n,r)}}}},Jee={kernelName:be,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=Bn(t.shape,r.shape);return{a:()=>{let o=n;const A=Ms(t.shape,s);return A.length>0&&(o=Qt(o,A)),Fe(o,t.shape)},b:()=>{let o=n;const A=Ms(r.shape,s);return A.length>0&&(o=Qt(o,A)),Fe(o,r.shape)}}}},$ee={kernelName:Le,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((r,s)=>{t[s]=()=>n.clone()}),t}},_ee={kernelName:ct,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Vn(t)}}},ete={kernelName:St,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Vn(t)}}},tte={kernelName:nt,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>an(n,wa(Ut(un(1),xr(zt(t,"float32")))))}}},nte={kernelName:Ot,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=wa(vt(un(1),xr(zt(t,"float32"))));return an(n,r)}}}},rte={kernelName:Pn,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=Bn(t.shape,r.shape);return{a:()=>{const o=vt(xr(t),xr(r));let A=Me(n,an(r,o));const u=Ms(t.shape,s);return u.length>0&&(A=Qt(A,u)),Fe(A,t.shape)},b:()=>{const o=vt(xr(t),xr(r));let A=Yr(Me(n,an(t,o)));const u=Ms(r.shape,s);return u.length>0&&(A=Qt(A,u)),Fe(A,r.shape)}}}},ste={kernelName:Pt,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>an(n,vt(xr(zt(t,"float32")),1))}}},ate={kernelName:Bt,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>an(n,Ut(un(1),xr(zt(t,"float32"))))}}},ote=De({avgPool3dGrad_:function(n,e,t,r,s,o){const A=le(n,"dy","avgPool3dGrad"),u=le(e,"input","avgPool3dGrad");let h=A,l=u,c=!1;u.rank===4&&(c=!0,h=Fe(A,[1,A.shape[0],A.shape[1],A.shape[2],A.shape[3]]),l=Fe(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),J(h.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${h.rank}.`),J(l.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`),o!=null&&J(Et(s),()=>`Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`);const d={dy:h,input:l},m={filterSize:t,strides:r,pad:s,dimRoundingMode:o},y=Ne.runKernel(gs,d,m);return c?Fe(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}}),ite={kernelName:$r,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{filterSize:s,strides:o,pad:A,dimRoundingMode:u}=t;return{x:()=>ote(n,r,s,o,A,u)}}},Ate=De({avgPoolGrad_:function(n,e,t,r,s){const o=le(n,"dy","avgPoolGrad"),A=le(e,"input","avgPoolGrad");J(A.rank===o.rank,()=>`Rank of input (${A.rank}) does not match rank of dy (${o.rank})`);let u=A,h=o,l=!1;A.rank===3&&(l=!0,u=Fe(A,[1,A.shape[0],A.shape[1],A.shape[2]]),h=Fe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),J(h.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${h.rank}.`),J(u.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${u.rank}.`);const c={dy:h,input:u},d={filterSize:t,strides:r,pad:s},m=Ne.runKernel(Rr,c,d);return l?Fe(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),lte={kernelName:Zn,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{filterSize:s,strides:o,pad:A}=t;return{x:()=>Ate(n,r,s,o,A)}}},ute={kernelName:sr,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[r,s]=e,{transposeA:o,transposeB:A}=t;return o||A?!o&&A?{a:()=>nr(n,s,!1,!1),b:()=>nr(n,r,!0,!1)}:o&&!A?{a:()=>nr(s,n,!1,!0),b:()=>nr(r,n,!1,!1)}:{a:()=>nr(s,n,!0,!0),b:()=>nr(n,r,!0,!0)}:{a:()=>nr(n,s,!1,!0),b:()=>nr(r,n,!0,!1)}}},cx=De({spaceToBatchND_:function(n,e,t){const r=le(n,"x","spaceToBatchND");J(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),J(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),J(r.shape.reduce((A,u,h)=>h>0&&h<=e.length?A&&(u+t[h-1][0]+t[h-1][1])%e[h-1]==0:A,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const s={x:r},o={blockShape:e,paddings:t};return Ne.runKernel(bv,s,o)}}),cte={kernelName:vn,gradFunc:(n,e,t)=>{const{blockShape:r,crops:s}=t;return{x:()=>cx(n,r,s)}}},dte={kernelName:"BroadcastTo",gradFunc:(n,e,t)=>{const r=t,s=r.inputShape,o=r.shape,A=Array.from(o);for(let h=s.length-1;h>=0;h--)if(s[h]===o[h])A[h]=1;else if(s[h]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${o}].`);const u=[];for(let h=0;h<A.length;h++)A[h]>1&&u.push(h);return{x:()=>Qt(n,u,!0)}}},pte={kernelName:ra,gradFunc:n=>({x:()=>n.clone()})},hte={kernelName:Wr,gradFunc:n=>({x:()=>Vn(n)})},fte={kernelName:xa,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{clipValueMin:s,clipValueMax:o}=t;return{x:()=>eo(CA(zc(r,s),Pc(r,o)),n,Vn(n))}}},mte={kernelName:$,inputsToSave:["x"],gradFunc:K4.gradFunc},gte={kernelName:ne,saveAllInputs:!0,gradFunc:(n,e,t)=>{const r=e.map(u=>u.shape),{axis:s}=t,o=pt(s,e[0].shape)[0],A=r.map(u=>u[o]);return _a(n,A,o).map(u=>()=>u)}},yte={kernelName:Ce,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[r,s]=e,{dilations:o,strides:A,pad:u,dataFormat:h}=t;return J(lu(o),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`),{x:()=>jI(r.shape,n,s,A,u,h),filter:()=>tS(r,n,s.shape,A,u,h)}}},bte={kernelName:_e,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[r,s]=e,{strides:o,pad:A,dataFormat:u,dimRoundingMode:h}=t;return{dy:()=>uu(n,s,o,A,u,1,h),filter:()=>tS(n,r,s.shape,o,A,u,h)}}},vte=De({conv3DBackpropFilter_:function(n,e,t,r,s){let o=n;n.rank===4&&(o=Fe(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let A=e;A.rank===4&&(A=Fe(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),J(o.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${o.shape}.`),J(A.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${A.shape}.`),J(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),J(o.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${o.shape[4]}) must match input depth in filter (${t[3]}.`),J(A.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${A.shape[4]}) must match output depth for filter (${t[4]}).`);const u={x:o,dy:A},h={strides:r,pad:s,filterShape:t};return Ne.runKernel(xt,u,h)}}),xte={kernelName:$e,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:r,strides:s,pad:o}=t;J(lu(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[A,u]=e;return{x:()=>g4(A.shape,n,u,s,o),filter:()=>vte(A,n,u.shape,s,o)}}},HS=De({sin_:function(n){const e={x:le(n,"x","sin")};return Ne.runKernel(um,e)}}),wte={kernelName:Cn,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Me(Yr(HS(zt(t,"float32"))),n)}}},GS=De({sinh_:function(n){const e={x:le(n,"x","sinh")};return Ne.runKernel(cm,e)}}),kte={kernelName:ar,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Me(GS(zt(t,"float32")),n)}}},VS=De({cumsum_:function(n,e=0,t=!1,r=!1){const s={x:le(n,"x","cumsum")},o={axis:e,exclusive:t,reverse:r};return Ne.runKernel(Jn,s,o)}}),Cte={kernelName:Jn,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{axis:s,exclusive:o,reverse:A}=t;return{x:()=>{const u=cs([s],r.rank);let h=VS(n,s,o,!A);return u!=null&&(h=Yn(h,u)),h}}}},Ite={kernelName:xA,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:r,strides:s,pad:o,dimRoundingMode:A}=t,u=r??[1,1];J(lu(u),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${u}'`);const[h,l]=e;return J(h.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${h.rank}.`),J(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`),J(h.shape[3]===l.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${h.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),J(oa(s,u),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${u}'.`),A!=null&&J(Et(o),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${A} but got pad ${o}.`),{x:()=>N4(h.shape,n,l,s,o,u,A),filter:()=>S4(h,n,l.shape,s,o,u,A)}}},Ste={kernelName:wo,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[r,s]=e,o={x:r,filter:s,dy:n},A={x:r,filter:s,dy:n};return{x:()=>Ne.runKernel(al,o,t),filter:()=>Ne.runKernel(xc,A,t)}}},Nte={kernelName:Yo,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,r={dy:n,y:t};return{x:()=>Ne.runKernel(zC,r)}}},Tte={kernelName:Hf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,r=Me(Qo(Yr(xr(t))),2/Math.sqrt(Math.PI));return{x:()=>Me(n,r)}}},Mte={kernelName:Gf,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Me(n,t)}}},Ete={kernelName:G0,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>Fe(n,t.shape)}}},Dte={kernelName:Vf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Me(n,Qo(t))}}},zte={kernelName:Xf,gradFunc:n=>({x:()=>Vn(n)})},Ote={kernelName:Zf,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=Bn(t.shape,r.shape);return{a:()=>{const o=an(n,zt(r,"float32")),A=Ms(t.shape,s);return A.length>0?Fe(Qt(o,A),t.shape):o},b:()=>{let o=Me(n,zt(t,"float32"));const A=Ms(r.shape,s);A.length>0&&(o=Fe(Qt(o,A),r.shape));const u=xr(r);return Yr(an(o,zt(u,"float32")))}}}},XS=De({rsqrt_:function(n){const e={x:le(n,"x","rsqrt")};return Ne.runKernel(Am,e)}}),Pte={kernelName:V0,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:r}=t,[s,o,A,u]=e,h=u??un(1),l=Ms(o.shape,s.shape),c=[];if(o.rank===1){for(let v=0;v<s.shape.length-1;++v)c.push(s.shape[v]);c.push(1)}const d=Ut(s,o),m=Me(n,h),y=XS(vt(A,un(r))),b=Me(Me(Me(y,y),y),un(-.5));return{x:()=>o.rank===1?Fe(Me(Me(n,vi(Fe(y,[1,1,1,o.shape[0]]),c)),h),s.shape):Fe(Me(Me(n,y),h),s.shape),mean:()=>{let v=Me(Me(y,un(-1)),m);return o.rank===1&&(v=Qt(v,l)),Fe(v,o.shape)},variance:()=>{let v=Me(Me(b,d),m);return o.rank===1&&(v=Qt(v,l)),Fe(v,o.shape)},scale:()=>{const v=Me(d,y);let w=Me(n,v);return o.rank===1&&(w=Qt(w,l)),Fe(w,o.shape)},offset:()=>{let v=n;return o.rank===1&&(v=Qt(v,l)),Fe(v,o.shape)}}}},q4=De({unsortedSegmentSum_:function(n,e,t){const r=le(n,"x","unsortedSegmentSum"),s=le(e,"segmentIds","unsortedSegmentSum","int32");J(Et(t),()=>"numSegments must be of dtype int");const o={x:r,segmentIds:s},A={numSegments:t};return Ne.runKernel(Cv,o,A)}}),Bte={kernelName:X0,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[r,s]=e,{axis:o}=t,A=pt(o,r.shape)[0];return{x:()=>{const u=r.shape,h=s.size,l=u.slice(0,A),c=l.length,d=u.slice(o,u.length).slice(1),m=d.length,y=J4(0,c),b=J4(c+1,c+1+m),v=$4([l,[h],d]),w=Fe(n,v),I=Fe(s,[h]),S=$4([[c],y,b]),T=Yn(w,S);let D=q4(T,I,r.shape[A]);const L=Np(S);return D=Yn(D,L),D},indices:()=>s}}};function J4(n,e){const t=[];for(let r=n;r<e;++r)t.push(r);return t}function $4(n){const e=[];for(let t=0;t<n.length;++t)for(let r=0;r<n[t].length;++r)e.push(n[t][r]);return e}const Fte={kernelName:Yf,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e;return{a:()=>Vn(t),b:()=>Vn(r)}}},Lte={kernelName:Uf,gradFunc:n=>({x:()=>zt(n,"float32")})},Rte={kernelName:Qf,gradFunc:n=>({x:()=>Vn(n)})},Wte={kernelName:Kf,gradFunc:n=>({x:()=>Vn(n)})},jte={kernelName:qf,gradFunc:n=>({x:()=>Vn(n)})},Hte={kernelName:Y0,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{alpha:s}=t,o=qo(r,0);return{x:()=>eo(o,n,Me(n,s))}}},Gte={kernelName:$f,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>an(n,vt(t,1))}}},Vte={kernelName:Jf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>an(n,zt(t,"float32"))}}},Xte={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r]=e,{axis:s}=t;return{logits:()=>{const o=Qo(r);return Ut(n,Me(Qt(n,s,!0),o))}}}},Zte=De({localResponseNormalizationBackprop_:function(n,e,t,r=5,s=1,o=1,A=.5){const u={x:n,y:e,dy:t},h={depthRadius:r,bias:s,alpha:o,beta:A};return Ne.runKernel(jC,u,h)}}),Yte={kernelName:$0,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r,s]=e,{depthRadius:o,bias:A,alpha:u,beta:h}=t;return{x:()=>Zte(r,s,n,o,A,u,h)}}};function _4(n,e,t,r){return e.rank<t.rank&&(e=Fe(e,us(e.shape,r))),n.rank<t.rank&&(n=Fe(n,us(n.shape,r))),{x:()=>Me(n,zt(Zi(t,e),n.dtype))}}const eF={kernelName:_0,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const r=t,{reductionIndices:s}=r,o=e[0],A=_4(n,e[1],o,pt(s,o.shape));return{x:()=>A.x()}}},ZS=De({less_:function(n,e){let t=le(n,"a","less","string_or_numeric"),r=le(e,"b","less","string_or_numeric");[t,r]=_r(t,r),Bn(t.shape,r.shape);const s={a:t,b:r};return Ne.runKernel(U0,s)}}),Ute={kernelName:_f,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e;return{a:()=>Me(n,zt(zc(t,r),"float32")),b:()=>Me(n,zt(ZS(t,r),"float32"))}}},Qte=De({maxPool3dGrad_:function(n,e,t,r,s,o,A){const u=le(n,"dy","maxPool3dGrad"),h=le(e,"input","maxPool3dGrad"),l=le(t,"output","maxPool3dGrad");let c=u,d=h,m=l,y=!1;h.rank===4&&(y=!0,c=Fe(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),d=Fe(h,[1,h.shape[0],h.shape[1],h.shape[2],h.shape[3]]),m=Fe(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),J(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),J(d.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),J(m.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${m.rank}.`),A!=null&&J(Et(o),()=>`Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ${A} but got pad ${o}.`);const b={dy:c,input:d,output:m},v={filterSize:r,strides:s,pad:o,dimRoundingMode:A},w=Ne.runKernel(GC,b,v);return y?Fe(w,[w.shape[1],w.shape[2],w.shape[3],w.shape[4]]):w}}),Kte={kernelName:tv,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r,s]=e,{filterSize:o,strides:A,pad:u,dimRoundingMode:h}=t;return{x:()=>Qte(n,r,s,o,A,u,h)}}},qte=De({maxPoolGrad_:function(n,e,t,r,s,o,A){const u=le(n,"dy","maxPoolGrad"),h=le(e,"input","maxPoolGrad"),l=le(t,"output","maxPoolGrad");J(h.rank===u.rank,()=>`Rank of input (${h.rank}) does not match rank of dy (${u.rank})`),J(u.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),J(h.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${h.rank}.`),A!=null&&J(Et(o),()=>`Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ${A} but got pad ${o}.`);const c={dy:u,input:h,output:l},d={filterSize:r,strides:s,pad:o,dimRoundingMode:A};return Ne.runKernel(HC,c,d)}}),Jte={kernelName:ev,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r,s]=e,{filterSize:o,strides:A,pad:u}=t;return{x:()=>qte(n,r,s,o,A,u)}}},$te={kernelName:nv,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{axis:s}=t,o=pt(s,r.shape),A=Ye(Xs(r.shape,o)[1]);return{x:()=>{const u=r.shape.slice();o.forEach(l=>{u[l]=1});const h=Fe(n,u);return an(Me(h,pl(r.shape,"float32")),A)}}}},_te={kernelName:rv,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const r=t,{axis:s}=r,[o,A]=e,u=_4(n,A,o,pt(s,o.shape));return{x:()=>u.x()}}},ene={kernelName:em,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e;return{a:()=>Me(n,zt(Pc(t,r),"float32")),b:()=>Me(n,zt(qo(t,r),"float32"))}}},tne={kernelName:sv,inputsToSave:["x"],gradFunc:(n,e,t)=>{const r=e[0],{paddings:s}=t,o=s.map(A=>A[0]);return{x:()=>or(n,o,r.shape)}}},nne={kernelName:tm,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=Bn(t.shape,r.shape);return{a:()=>{const o=Ms(t.shape,s);return o.length>0?Fe(Qt(n,o),t.shape):n},b:()=>{const o=Me(n,Yr(Dm(an(t,r)))),A=Ms(r.shape,s);return A.length>0?Fe(Qt(o,A),r.shape):o}}}},rne={kernelName:nm,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=Bn(t.shape,r.shape);return{a:()=>{const o=Me(n,zt(r,"float32")),A=Ms(t.shape,s);return A.length>0?Fe(Qt(o,A),t.shape):o},b:()=>{const o=Me(n,zt(t,"float32")),A=Ms(r.shape,s);return A.length>0?Fe(Qt(o,A),r.shape):o}}}},sne={kernelName:av,gradFunc:n=>({x:()=>Yr(n)})},ane={kernelName:Av,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>Es(t.shape,"float32")}}},one={kernelName:iv,gradFunc:n=>({x:()=>Vn(n)})},ine={kernelName:lv,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:r}=t;return Ui(n,r).map(s=>()=>s)}},tF={kernelName:uv,inputsToSave:["x"],gradFunc:(n,e,t)=>{const r=e[0],{paddings:s}=t,o=s.map(A=>A[0]);return{x:()=>or(n,o,r.shape)}}},Ane={kernelName:rm,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,r,s]=e,o=t,A=r,u=Bn(o.shape,A.shape);return{a:()=>{const h=zt(A,"float32");let l=Me(n,Me(h,Bc(o,Ut(h,un(1)))));const c=Ms(o.shape,u);return c.length>0&&(l=Qt(l,c)),Fe(l,o.shape)},b:()=>{const h=qo(o,0),l=eo(h,Jo(o),Vn(o));let c=Me(n,Me(s,l));const d=Ms(A.shape,u);return d.length>0&&(c=Qt(c,d)),Fe(c,A.shape)}}}},lne={kernelName:cv,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,r]=e,s=qo(t,0);return{x:()=>eo(s,n,Me(n,r)),alpha:()=>{let o=eo(s,Vn(n),Me(n,t));const A=Ms(r.shape,n.shape);return A.length>0&&(o=Qt(o,A)),Fe(o,r.shape)}}}},une={kernelName:ol,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=Bn(t.shape,r.shape);return{a:()=>{const o=an(n,zt(r,"float32")),A=Ms(t.shape,s);return A.length>0?Fe(Qt(o,A),t.shape):o},b:()=>{let o=Me(n,zt(t,"float32"));const A=Ms(r.shape,s);A.length>0&&(o=Fe(Qt(o,A),r.shape));const u=xr(r);return Yr(an(o,zt(u,"float32")))}}}},cne={kernelName:sm,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>an(n,Yr(xr(t)))}}},dne={kernelName:om,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,r=Me(Pc(t,6),Fm(t));return{x:()=>Me(n,zt(r,"float32"))}}},pne={kernelName:am,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Me(n,zt(Fm(t),"float32"))}}},hne={kernelName:dv,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Fe(n,t.shape)}}},fne={kernelName:hv,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[r]=e,s={dy:n,images:r};return{images:()=>Ne.runKernel($C,s,t)}}},mne={kernelName:pv,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[r]=e,s={dy:n,images:r};return{images:()=>Ne.runKernel(JC,s,t)}}},gne={kernelName:fv,gradFunc:(n,e,t)=>{const{dims:r}=t,s=pt(r,n.shape);return{x:()=>hl(n,s)}}},yne={kernelName:im,gradFunc:n=>({x:()=>Vn(n)})},bne={kernelName:Am,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Yr(an(n,Me(Bc(t,1.5),2)))}}},dx=De({logicalNot_:function(n){const e={x:le(n,"x","logicalNot","bool")};return Ne.runKernel(q0,e)}}),vne={kernelName:mv,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>zt(Vn(t),"float32"),t:()=>Me(n,zt(t,n.dtype)),e:()=>Me(n,zt(dx(t),n.dtype))}}},xne={kernelName:lm,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=qo(t,un(0)),s=un(lx),o=un(ux),A=Me(n,o),u=Me(Me(n,s),Qo(zt(t,"float32")));return eo(r,A,u)}}}},wne={kernelName:pm,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Me(n,Me(t,Ut(un(1),t)))}}},kne={kernelName:dm,gradFunc:n=>({x:()=>Vn(n)})},px=De({cos_:function(n){const e={x:le(n,"x","cos")};return Ne.runKernel(Cn,e)}}),Cne={kernelName:um,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Me(px(zt(t,"float32")),n)}}},YS=De({cosh_:function(n){const e={x:le(n,"x","cosh")};return Ne.runKernel(ar,e)}}),Ine={kernelName:cm,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Me(YS(zt(t,"float32")),n)}}},Sne={kernelName:gv,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{begin:s,size:o}=t,A=r.shape,[u,h]=jv(r,s,o),l=[];for(let c=0;c<n.rank;c++)l.push([u[c],A[c]-u[c]-h[c]]);return{x:()=>Uv(n,l)}}},Nne={kernelName:xv,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r]=e,{dim:s}=t,o=Me(n,r);return{logits:()=>Ut(o,Me(Qt(o,[s],!0),r))}}},Tne={kernelName:hm,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Me(n,Oc(t))}}},hx=De({batchToSpaceND_:function(n,e,t){const r=le(n,"x","batchToSpaceND"),s=e.reduce((u,h)=>u*h);J(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),J(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),J(r.shape[0]%s==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${s}`);const o={x:r},A={blockShape:e,crops:t};return Ne.runKernel(vn,o,A)}}),nF={kernelName:bv,gradFunc:(n,e,t)=>{const{blockShape:r,paddings:s}=t;return{x:()=>hx(n,r,s)}}},rF={kernelName:vv,gradFunc:(n,e,t)=>{const{axis:r}=t;return{x:()=>ys(n,r)}}},Mne=[K4,Kee,qee,Jee,$ee,_ee,ete,tte,nte,rte,ste,ate,ite,lte,ute,cte,dte,pte,hte,fte,mte,gte,bte,yte,xte,wte,kte,Cte,Ite,Ste,une,Nte,Tte,Mte,Ete,Dte,Ote,zte,Pte,Bte,Fte,Lte,Rte,Wte,jte,Hte,Gte,Vte,Xte,Yte,eF,eF,Ute,Kte,Jte,$te,_te,ene,tne,nne,rne,sne,ane,one,ine,tF,tF,Ane,lne,cne,dne,pne,hne,fne,mne,gne,yne,bne,vne,xne,wne,kne,Cne,Ine,Sne,Nne,Tne,nF,nF,rF,rF,{kernelName:fm,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>an(n,Me(wa(zt(t,"float32")),2))}}},{kernelName:mm,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=un(2);return{a:()=>Me(n,Me(s,Ut(t,r))),b:()=>Me(n,Me(s,Ut(r,t)))}}},{kernelName:aI,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Me(n,Me(zt(t,"float32"),2))}}},{kernelName:xm,gradFunc:n=>({x:()=>Vn(n)})},{kernelName:gm,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=Bn(t.shape,r.shape);return{a:()=>{let o=n;const A=Ms(t.shape,s);return A.length>0&&(o=Qt(o,A)),Fe(o,t.shape)},b:()=>{let o=n;const A=Ms(r.shape,s);return A.length>0&&(o=Qt(o,A)),Fe(Yr(o),r.shape)}}}},{kernelName:yv,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,s=r.shape.slice(),{axis:o}=t;pt(o,r.shape).forEach(h=>{s[h]=1});const A=Fe(n,s),u=Me(A,pl(r.shape,"float32"));return{x:()=>u}}},{kernelName:ym,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>an(n,xr(px(t)))}}},{kernelName:bm,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Me(Ut(un(1),xr(t)),n)}}},{kernelName:vm,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{reps:s}=t;return{x:()=>{let o=Vn(r);if(r.rank===1)for(let A=0;A<s[0];++A)o=vt(o,or(n,[A*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let A=0;A<s[0];++A)for(let u=0;u<s[1];++u)o=vt(o,or(n,[A*r.shape[0],u*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let A=0;A<s[0];++A)for(let u=0;u<s[1];++u)for(let h=0;h<s[2];++h)o=vt(o,or(n,[A*r.shape[0],u*r.shape[1],h*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(r.rank!==4)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let A=0;A<s[0];++A)for(let u=0;u<s[1];++u)for(let h=0;h<s[2];++h)for(let l=0;l<s[3];++l)o=vt(o,or(n,[A*r.shape[0],u*r.shape[1],h*r.shape[2],l*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return o}}}},{kernelName:wv,gradFunc:(n,e,t)=>{const r=t,{perm:s}=r,o=Np(s);return{x:()=>Yn(n,o)}}},{kernelName:kv,gradFunc:(n,e,t)=>{const r=t,{axis:s}=r;return{value:()=>xi(n,s)}}},{kernelName:Cv,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>function(r,s){const o=dl(s,Vn(s)),A=zm(r,o);let u=zc(s,un(0,"int32"));const h=A.rank-u.rank;for(let c=0;c<h;++c)u=Ko(u,c+1);u=CA(u,pl(A.shape,"bool"));const l=Vn(A);return eo(u,A,l)}(n,t)}}},{kernelName:Iv,gradFunc:n=>({x:()=>Vn(n)})}];for(const n of Mne)V_(n);rt().prototype.abs=function(){return this.throwIfDisposed(),Ts(this)};const sF=De({acos_:function(n){const e={x:le(n,"x","acos")};return Ne.runKernel(Hi,e)}});rt().prototype.acos=function(){return this.throwIfDisposed(),sF(this)};const aF=De({acosh_:function(n){const e={x:le(n,"x","acosh")};return Ne.runKernel(ve,e)}});rt().prototype.acosh=function(){return this.throwIfDisposed(),aF(this)},rt().prototype.add=function(n){return this.throwIfDisposed(),vt(this,n)},rt().prototype.all=function(n,e){return this.throwIfDisposed(),FI(this,n,e)},rt().prototype.any=function(n,e){return this.throwIfDisposed(),Hv(this,n,e)},rt().prototype.argMax=function(n){return this.throwIfDisposed(),Cp(this,n)};const oF=De({argMin_:function(n,e=0){const t={x:le(n,"x","argMin")},r={axis:e};return Ne.runKernel(St,t,r)}});rt().prototype.argMin=function(n){return this.throwIfDisposed(),oF(this,n)},rt().prototype.asScalar=function(){return this.throwIfDisposed(),J(this.size===1,()=>"The array must have only 1 element."),Fe(this,[])},rt().prototype.asType=function(n){return this.throwIfDisposed(),zt(this,n)},rt().prototype.as1D=function(){return this.throwIfDisposed(),Fe(this,[this.size])},rt().prototype.as2D=function(n,e){return this.throwIfDisposed(),Fe(this,[n,e])},rt().prototype.as3D=function(n,e,t){return this.throwIfDisposed(),Fe(this,[n,e,t])},rt().prototype.as4D=function(n,e,t,r){return this.throwIfDisposed(),Fe(this,[n,e,t,r])},rt().prototype.as5D=function(n,e,t,r,s){return this.throwIfDisposed(),Fe(this,[n,e,t,r,s])};const iF=De({asin_:function(n){const e={x:le(n,"x","asin")};return Ne.runKernel(nt,e)}});rt().prototype.asin=function(){return this.throwIfDisposed(),iF(this)};const AF=De({asinh_:function(n){const e={x:le(n,"x","asinh")};return Ne.runKernel(Ot,e)}});rt().prototype.asinh=function(){return this.throwIfDisposed(),AF(this)};const lF=De({atan_:function(n){const e={x:le(n,"x","atan")};return Ne.runKernel(Pt,e)}});rt().prototype.atan=function(){return this.throwIfDisposed(),lF(this)};const uF=De({atan2_:function(n,e){let t=le(n,"a","atan2"),r=le(e,"b","atan2");[t,r]=_r(t,r);const s={a:t,b:r};return Ne.runKernel(Pn,s)}});rt().prototype.atan2=function(n){return this.throwIfDisposed(),uF(this,n)};const cF=De({atanh_:function(n){const e={x:le(n,"x","atanh")};return Ne.runKernel(Bt,e)}});rt().prototype.atanh=function(){return this.throwIfDisposed(),cF(this)},rt().prototype.avgPool=function(n,e,t,r){return this.throwIfDisposed(),Vv(this,n,e,t,r)},rt().prototype.batchToSpaceND=function(n,e){return this.throwIfDisposed(),hx(this,n,e)},rt().prototype.batchNorm=function(n,e,t,r,s){return this.throwIfDisposed(),Nm(this,n,e,t,r,s)},rt().prototype.broadcastTo=function(n){return this.throwIfDisposed(),Bm(this,n)},rt().prototype.cast=function(n){return this.throwIfDisposed(),zt(this,n)};const dF=De({ceil_:function(n){const e={x:le(n,"x","ceil")};return Ne.runKernel(Wr,e)}});rt().prototype.ceil=function(){return this.throwIfDisposed(),dF(this)},rt().prototype.clipByValue=function(n,e){return this.throwIfDisposed(),ko(this,n,e)},rt().prototype.concat=function(n,e){return this.throwIfDisposed(),n instanceof ls&&(n=[n]),ys([this,...n],e)},rt().prototype.conv1d=function(n,e,t,r,s,o){return this.throwIfDisposed(),WI(this,n,e,t,r,s,o)},rt().prototype.conv2dTranspose=function(n,e,t,r,s){return this.throwIfDisposed(),HI(this,n,e,t,r,s)},rt().prototype.conv2d=function(n,e,t,r,s,o){return this.throwIfDisposed(),uu(this,n,e,t,r,s,o)},rt().prototype.cos=function(){return this.throwIfDisposed(),px(this)},rt().prototype.cosh=function(){return this.throwIfDisposed(),YS(this)},rt().prototype.cumsum=function(n,e,t){return this.throwIfDisposed(),VS(this,n,e,t)};const pF=De({depthToSpace_:function(n,e,t="NHWC"){const r=le(n,"x","depthToSpace"),s=t==="NHWC"?r.shape[1]:r.shape[2],o=t==="NHWC"?r.shape[2]:r.shape[3],A=t==="NHWC"?r.shape[3]:r.shape[1];J(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e}  for depthToSpace with input shape
    ${r.shape}`),J(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e} for depthToSpace with input shape
        ${r.shape}`),J(A%(e*e)==0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${A} for depthToSpace with input shape ${r.shape}`);const u={x:r},h={blockSize:e,dataFormat:t};return Ne.runKernel(Zo,u,h)}});rt().prototype.depthToSpace=function(n,e){return this.throwIfDisposed(),pF(this,n,e)},rt().prototype.depthwiseConv2d=function(n,e,t,r,s,o){return this.throwIfDisposed(),Tm(this,n,e,t,r,s,o)};const hF=De({dilation2d_:function(n,e,t,r,s=[1,1],o="NHWC"){const A=le(n,"x","dilation2d"),u=le(e,"filter","dilation2d");J(A.rank===3||A.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${A.rank}.`),J(u.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${u.rank}.`),J(o==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let h=A,l=!1;A.rank===3&&(h=Fe(A,[1,A.shape[0],A.shape[1],A.shape[2]]),l=!0);const c={x:h,filter:u},d={strides:t,pad:r,dilations:s},m=Ne.runKernel(wo,c,d);return l?Fe(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});rt().prototype.dilation2d=function(n,e,t,r,s){return this.throwIfDisposed(),hF(this,n,e,t,r,s)};const fF=De({divNoNan_:function(n,e){let t=le(n,"a","div"),r=le(e,"b","div");[t,r]=_r(t,r);const s=an(t,r),o=Vn(s),A=Zi(r,o);return eo(A,o,s)}});rt().prototype.divNoNan=function(n){return this.throwIfDisposed(),fF(this,n)},rt().prototype.div=function(n){return this.throwIfDisposed(),an(this,n)};const Ene=De({dot_:function(n,e){const t=le(n,"t1","dot"),r=le(e,"t2","dot");J(!(t.rank!==1&&t.rank!==2||r.rank!==1&&r.rank!==2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${r.rank}.`);const s=t.rank===1?t.size:t.shape[1],o=r.rank===1?r.size:r.shape[0];if(J(s===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${o}.`),t.rank===1&&r.rank===1){const A=Fe(t,[1,-1]),u=Fe(r,[-1,1]),h=nr(A,u);return Fe(h,[])}if(t.rank===1&&r.rank===2){const A=Fe(t,[1,-1]),u=Fe(r,[r.shape[0],r.shape[1]]),h=nr(A,u);return Fe(h,[h.size])}if(t.rank===2&&r.rank===1){const A=Fe(r,[-1,1]),u=nr(t,A);return Fe(u,[u.size])}{const A=Fe(r,[r.shape[0],r.shape[1]]);return nr(t,A)}}});rt().prototype.dot=function(n){return this.throwIfDisposed(),Ene(this,n)},rt().prototype.elu=function(){return this.throwIfDisposed(),Mm(this)},rt().prototype.equal=function(n){return this.throwIfDisposed(),Zi(this,n)};const mF=De({erf_:function(n){let e=le(n,"x","erf");J(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=zt(e,"float32"));const t={x:e};return Ne.runKernel(Hf,t)}});rt().prototype.erf=function(){return this.throwIfDisposed(),mF(this)},rt().prototype.exp=function(){return this.throwIfDisposed(),Qo(this)},rt().prototype.expandDims=function(n){return this.throwIfDisposed(),Ko(this,n)};const gF=De({expm1_:function(n){const e={x:le(n,"x","expm1")};return Ne.runKernel(Vf,e)}});rt().prototype.expm1=function(){return this.throwIfDisposed(),gF(this)},rt().prototype.fft=function(){return this.throwIfDisposed(),_I(this)},rt().prototype.flatten=function(){return this.throwIfDisposed(),Fe(this,[this.size])},rt().prototype.floor=function(){return this.throwIfDisposed(),Dm(this)},rt().prototype.floorDiv=function(n){return this.throwIfDisposed(),GI(this,n)},rt().prototype.gather=function(n,e){return this.throwIfDisposed(),zm(this,n,e)},rt().prototype.greaterEqual=function(n){return this.throwIfDisposed(),zc(this,n)},rt().prototype.greater=function(n){return this.throwIfDisposed(),qo(this,n)},rt().prototype.ifft=function(){return this.throwIfDisposed(),ex(this)},rt().prototype.irfft=function(){return this.throwIfDisposed(),C4(this)};const Dne=De({isFinite_:function(n){const e={x:le(n,"x","isFinite")};return Ne.runKernel(Qf,e)}});rt().prototype.isFinite=function(){return this.throwIfDisposed(),Dne(this)};const zne=De({isInf_:function(n){const e={x:le(n,"x","isInf")};return Ne.runKernel(Kf,e)}});rt().prototype.isInf=function(){return this.throwIfDisposed(),zne(this)};const yF=De({isNaN_:function(n){const e={x:le(n,"x","isNaN")};return Ne.runKernel(qf,e)}});rt().prototype.isNaN=function(){return this.throwIfDisposed(),yF(this)},rt().prototype.leakyRelu=function(n){return this.throwIfDisposed(),Xv(this,n)},rt().prototype.lessEqual=function(n){return this.throwIfDisposed(),Pc(this,n)},rt().prototype.less=function(n){return this.throwIfDisposed(),ZS(this,n)};const bF=De({localResponseNormalization_:function(n,e=5,t=1,r=1,s=.5){const o=le(n,"x","localResponseNormalization");J(o.rank===4||o.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${o.rank}.`),J(Et(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let A=o,u=!1;o.rank===3&&(u=!0,A=Fe(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const h={x:A},l={depthRadius:e,bias:t,alpha:r,beta:s},c=Ne.runKernel($0,h,l);return u?Fe(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});rt().prototype.localResponseNormalization=function(n,e,t,r){return this.throwIfDisposed(),bF(this,n,e,t,r)};const One=De({logSigmoid_:function(n){const e=le(n,"x","logSigmoid");return ll(t=>({value:Yr(Mp(Yr(t))),gradFunc:r=>Me(r,Oc(Yr(t)))}))(e)}});rt().prototype.logSigmoid=function(){return this.throwIfDisposed(),One(this)},rt().prototype.logSoftmax=function(n){return this.throwIfDisposed(),VI(this,n)},rt().prototype.logSumExp=function(n,e){return this.throwIfDisposed(),B4(this,n,e)},rt().prototype.log=function(){return this.throwIfDisposed(),Jo(this)},rt().prototype.log1p=function(){return this.throwIfDisposed(),Zv(this)},rt().prototype.logicalAnd=function(n){return this.throwIfDisposed(),CA(this,n)},rt().prototype.logicalNot=function(){return this.throwIfDisposed(),dx(this)};const US=De({logicalOr_:function(n,e){const t=le(n,"a","logicalOr","bool"),r=le(e,"b","logicalOr","bool");Bn(t.shape,r.shape);const s={a:t,b:r};return Ne.runKernel(J0,s)}});rt().prototype.logicalOr=function(n){return this.throwIfDisposed(),US(this,n)};const Pne=De({logicalXor_:function(n,e){const t=le(n,"a","logicalXor","bool"),r=le(e,"b","logicalXor","bool");return Bn(t.shape,r.shape),CA(US(n,e),dx(CA(n,e)))}});rt().prototype.logicalXor=function(n){return this.throwIfDisposed(),Pne(this,n)},rt().prototype.matMul=function(n,e,t){return this.throwIfDisposed(),nr(this,n,e,t)},rt().prototype.maxPool=function(n,e,t,r){return this.throwIfDisposed(),Yv(this,n,e,t,r)},rt().prototype.max=function(n,e){return this.throwIfDisposed(),Yi(this,n,e)},rt().prototype.maximum=function(n){return this.throwIfDisposed(),dl(this,n)},rt().prototype.mean=function(n,e){return this.throwIfDisposed(),es(this,n,e)},rt().prototype.min=function(n,e){return this.throwIfDisposed(),ax(this,n,e)},rt().prototype.minimum=function(n){return this.throwIfDisposed(),Om(this,n)};const vF=De({mirrorPad_:function(n,e,t){J(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const r=le(n,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");J(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);const s=t==="reflect"?1:0;for(let u=0;u<r.rank;u++)J(e[u].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),J(e[u][0]>=0&&e[u][0]<=r.shape[u]-s&&e[u][1]>=0&&e[u][1]<=r.shape[u]-s,()=>`Padding in dimension ${u} cannot be greater than or equal to ${r.shape[u]-s} or less than 0 for input of shape ${r.shape}`);const o={paddings:e,mode:t},A={x:r};return Ne.runKernel(sv,A,o)}});rt().prototype.mirrorPad=function(n,e){return this.throwIfDisposed(),vF(this,n,e)};const xF=De({mod_:function(n,e){let t=le(n,"a","mod"),r=le(e,"b","mod");[t,r]=_r(t,r);const s={a:t,b:r};return Ne.runKernel(tm,s)}});rt().prototype.mod=function(n){return this.throwIfDisposed(),xF(this,n)},rt().prototype.mul=function(n){return this.throwIfDisposed(),Me(this,n)},rt().prototype.neg=function(){return this.throwIfDisposed(),Yr(this)},rt().prototype.norm=function(n,e,t){return this.throwIfDisposed(),lS(this,n,e,t)},rt().prototype.notEqual=function(n){return this.throwIfDisposed(),Tp(this,n)},rt().prototype.oneHot=function(n,e=1,t=0){return this.throwIfDisposed(),YI(this,n,e,t)},rt().prototype.onesLike=function(){return this.throwIfDisposed(),$o(this)},rt().prototype.pad=function(n,e){return this.throwIfDisposed(),Uv(this,n,e)};const Bne=De({pool_:function(n,e,t,r,s,o){s==null&&(s=[1,1]),o==null&&(o=1),r===0&&(r="valid");const A=le(n,"x","maxPool");let u=A,h=!1;A.rank===3&&(h=!0,u=Fe(A,[1,A.shape[0],A.shape[1],A.shape[2]])),J(oa(o,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${s}'`);const l=bi(u.shape,e,o,s,r),c=[l.dilationHeight,l.dilationWidth];let d;d=r==="same"?function(T,D){const L=T.map((U,_)=>U+(U-1)*(D[_]-1)).map(U=>U-1),W=L.map(U=>Math.floor(U/2)),K=L.map((U,_)=>U-W[_]);return L.map((U,_)=>[W[_],K[_]])}([l.filterHeight,l.filterWidth],c):[[0,0],[0,0]];const m=c[0]===1&&c[1]===1,[y,b]=function(T,D,L){const W=L.map(re=>re[0]),K=L.map(re=>re[1]),U=T.concat(W,K),_=D.map((re,ce)=>(re-U[ce]%re)%re),ee=K.map((re,ce)=>re+_[ce]);return[D.map((re,ce)=>[W[ce],ee[ce]]),D.map((re,ce)=>[0,_[ce]])]}([l.inHeight,l.inWidth],c,d),v=m?r:"valid",w=m?u:cx(u,c,y),I=(t==="avg"?()=>Vv(w,e,o,v):()=>Yv(w,e,o,v))(),S=m?I:hx(I,c,b);return h?Fe(S,[S.shape[1],S.shape[2],S.shape[3]]):S}});rt().prototype.pool=function(n,e,t,r,s){return this.throwIfDisposed(),Bne(this,n,e,t,r,s)},rt().prototype.pow=function(n){return this.throwIfDisposed(),Bc(this,n)},rt().prototype.prelu=function(n){return this.throwIfDisposed(),Qv(this,n)};const QS=De({prod_:function(n,e=null,t=!1){let r=le(n,"x","prod");r.dtype==="bool"&&(r=zt(r,"int32"));const s={x:r},o={axis:e,keepDims:t};return Ne.runKernel(QC,s,o)}});rt().prototype.prod=function(n,e){return this.throwIfDisposed(),QS(this,n,e)};const wF=De({reciprocal_:function(n){const e={x:le(n,"x","reciprocal")};return Ne.runKernel(sm,e)}});rt().prototype.reciprocal=function(){return this.throwIfDisposed(),wF(this)},rt().prototype.relu=function(){return this.throwIfDisposed(),IA(this)},rt().prototype.relu6=function(){return this.throwIfDisposed(),nS(this)},rt().prototype.reshapeAs=function(n){return this.throwIfDisposed(),Fe(this,n.shape)},rt().prototype.reshape=function(n){return this.throwIfDisposed(),Fe(this,n)},rt().prototype.resizeBilinear=function(n,e,t){return this.throwIfDisposed(),E4(this,n,e,t)},rt().prototype.resizeNearestNeighbor=function(n,e,t){return this.throwIfDisposed(),D4(this,n,e,t)},rt().prototype.reverse=function(n){return this.throwIfDisposed(),hl(this,n)},rt().prototype.rfft=function(){return this.throwIfDisposed(),eS(this)},rt().prototype.round=function(){return this.throwIfDisposed(),AS(this)},rt().prototype.rsqrt=function(){return this.throwIfDisposed(),XS(this)},rt().prototype.selu=function(){return this.throwIfDisposed(),QI(this)},rt().prototype.separableConv2d=function(n,e,t,r,s,o){return this.throwIfDisposed(),w4(this,n,e,t,r,s,o)},rt().prototype.sigmoid=function(){return this.throwIfDisposed(),Oc(this)};const kF=De({sign_:function(n){const e={x:le(n,"x","sign")};return Ne.runKernel(dm,e)}});rt().prototype.sign=function(){return this.throwIfDisposed(),kF(this)},rt().prototype.sin=function(){return this.throwIfDisposed(),HS(this)},rt().prototype.sinh=function(){return this.throwIfDisposed(),GS(this)},rt().prototype.slice=function(n,e){return this.throwIfDisposed(),or(this,n,e)},rt().prototype.softmax=function(n){return this.throwIfDisposed(),qv(this,n)},rt().prototype.softplus=function(){return this.throwIfDisposed(),Mp(this)},rt().prototype.spaceToBatchND=function(n,e){return this.throwIfDisposed(),cx(this,n,e)},rt().prototype.split=function(n,e){return this.throwIfDisposed(),_a(this,n,e)},rt().prototype.sqrt=function(){return this.throwIfDisposed(),wa(this)},rt().prototype.square=function(){return this.throwIfDisposed(),xr(this)},rt().prototype.squaredDifference=function(n){return this.throwIfDisposed(),uS(this,n)},rt().prototype.squeeze=function(n){return this.throwIfDisposed(),cu(this,n)},rt().prototype.stack=function(n,e){this.throwIfDisposed();const t=n instanceof ls?[this,n]:[this,...n];return xi(t,e)},rt().prototype.step=function(n){return this.throwIfDisposed(),Fm(this,n)};const CF=De({stridedSlice_:function(n,e,t,r,s=0,o=0,A=0,u=0,h=0){const l={x:le(n,"x","stridedSlice","string_or_numeric")},c={begin:e,end:t,strides:r,beginMask:s,endMask:o,ellipsisMask:A,newAxisMask:u,shrinkAxisMask:h};return Ne.runKernel(oI,l,c)}});rt().prototype.stridedSlice=function(n,e,t,r,s,o,A,u){return this.throwIfDisposed(),CF(this,n,e,t,r,s,o,A,u)},rt().prototype.sub=function(n){return this.throwIfDisposed(),Ut(this,n)},rt().prototype.sum=function(n,e){return this.throwIfDisposed(),Qt(this,n,e)};const IF=De({tan_:function(n){const e={x:le(n,"x","tan")};return Ne.runKernel(ym,e)}});rt().prototype.tan=function(){return this.throwIfDisposed(),IF(this)},rt().prototype.tanh=function(){return this.throwIfDisposed(),Jv(this)},rt().prototype.tile=function(n){return this.throwIfDisposed(),vi(this,n)},rt().prototype.toBool=function(){return this.throwIfDisposed(),zt(this,"bool")},rt().prototype.toFloat=function(){return this.throwIfDisposed(),zt(this,"float32")},rt().prototype.toInt=function(){return this.throwIfDisposed(),zt(this,"int32")};const SF=De({topk_:function(n,e=1,t=!0){const r=le(n,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${e}`);const o={x:r},A={k:e,sorted:t},[u,h]=Ne.runKernel(uI,o,A);return{values:u,indices:h}}});rt().prototype.topk=function(n,e){return this.throwIfDisposed(),SF(this,n,e)},rt().prototype.transpose=function(n){return this.throwIfDisposed(),Yn(this,n)};const KS=De({unique_:function(n,e=0){const t=le(n,"x","unique","string_or_numeric");J(t.rank>0,()=>"The input tensor must be at least 1D");const r={x:t},s={axis:e},[o,A]=Ne.runKernel(dI,r,s);return{values:o,indices:A}}});let qS;function Ds(){return qS==null&&(qS=Ne.backend.epsilon()),qS}rt().prototype.unique=function(n){return this.throwIfDisposed(),KS(this,n)},rt().prototype.unsortedSegmentSum=function(n,e){return this.throwIfDisposed(),q4(this,n,e)},rt().prototype.unstack=function(n){return this.throwIfDisposed(),Ui(this,n)},rt().prototype.where=function(n,e){return this.throwIfDisposed(),eo(n,this,e)},rt().prototype.zerosLike=function(){return this.throwIfDisposed(),Vn(this)};class NA extends Error{constructor(e){super(e),Object.setPrototypeOf(this,NA.prototype)}}class wi extends Error{constructor(e){super(e),Object.setPrototypeOf(this,wi.prototype)}}class Be extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Be.prototype)}}class En extends Error{constructor(e){super(e),Object.setPrototypeOf(this,En.prototype)}}class JS extends Error{constructor(e){super(e),Object.setPrototypeOf(this,JS.prototype)}}function Rc(n,e){if(Array.isArray(n)){let t=[];for(let r=0;r<e;r++)t=t.concat(n);return t}{const t=new Array(e);return t.fill(n),t}}function TA(n,e){if(!n)throw new JS(e)}function NF(n,e){let t=0;for(const r of n)r===e&&t++;return t}function no(n){return n.length===1?n[0]:n}function Dr(n){return Array.isArray(n)?n:[n]}function ml(n){const e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function Wc(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let ki={};function $S(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function _S(n){if(n!=null&&typeof n=="object")if(Array.isArray(n))n.forEach(e=>_S(e));else{const e=Object.keys(n);for(const t of e){const r=n[t];r!=null&&typeof r=="object"&&(Array.isArray(r)||r.type!=="ndarray"||typeof r.value!="number"?_S(r):n[t]=r.value)}}}function Gm(n,e={},t={},r="object",s=!1){if(typeof n=="string"){const o=n;let A;if(o in t)A=t[o];else if(o in ki)A=ki[o];else if(A=e[o],A==null)throw new Be(`Unknown ${r}: ${n}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return A}{const o=n;if(o.className==null||o.config==null)throw new Be(`${r}: Improper config format: ${JSON.stringify(o)}.
'className' and 'config' must set.`);const A=o.className;let u,h;if(A in t?[u,h]=t[A]:A in ki?[u,h]=ki.className:A in e&&([u,h]=e[A]),u==null)throw new Be(`Unknown ${r}: ${A}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(h!=null){const l={};for(const m of Object.keys(ki))l[m]=ki[m];for(const m of Object.keys(t))l[m]=t[m];o.config.customObjects=l;const c=Object.assign({},ki);for(const m of Object.keys(t))ki[m]=t[m];_S(o.config);const d=h(u,o.config,t,s);return ki=Object.assign({},c),d}{const l=Object.assign({},ki);for(const d of Object.keys(t))ki[d]=t[d];const c=new u(o.config);return ki=Object.assign({},l),c}}}function fx(n,e){return-1*function(t,r){return t<r?-1:t>r?1:0}(n,e)}function hu(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function Fne(n){if(n==null)throw new Be(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function jc(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new Be(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function e3(n,e,t=0,r=1/0){return TA(t>=0),TA(r>=t),Array.isArray(n)&&n.length>=t&&n.length<=r&&n.every(s=>typeof s===e)}function Zs(n,e){Array.isArray(n)?(J(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,r)=>Zs(t,`element ${r+1} of ${e}`))):J(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${TF(n)}.`)}function TF(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>TF(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function MF(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}function t3(n,e){return Ve(()=>wa(Qt(Me(n,n),e,!0)))}class Vm extends kp{getConfig(){return{}}}class EF extends Vm{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return Ve(()=>{const t=t3(e,this.axis),r=ko(t,0,this.maxValue);return Me(e,an(r,vt(Ds(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}EF.className="MaxNorm",gt(EF);class DF extends Vm{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return Ve(()=>an(e,vt(Ds(),t3(e,this.axis))))}getConfig(){return{axis:this.axis}}}DF.className="UnitNorm",gt(DF);class zF extends Vm{apply(e){return IA(e)}}zF.className="NonNeg",gt(zF);class OF extends Vm{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return Ve(()=>{const t=t3(e,this.axis),r=vt(Me(this.rate,ko(t,this.minValue,this.maxValue)),Me(1-this.rate,t));return Me(e,an(r,vt(Ds(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}OF.className="MinMaxNorm",gt(OF);const PF={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function zs(n){return $S(n)}function BF(n,e={}){return Gm(n,yi.getMap().classNameMap,e,"constraint")}function Os(n){return n==null?null:typeof n=="string"?BF({className:n in PF?PF[n]:n,config:{}}):n instanceof Vm?n:BF(n)}const Lne=["channelsFirst","channelsLast"],Rne=["nearest","bilinear"],Wne=["valid","same","causal"],jne=["max","avg"],Hne=["sum","mul","concat","ave"],zp=new Map;function ds(n){jc(Lne,"DataFormat",n)}function _o(n){jc(Wne,"PaddingMode",n)}function FF(n){jc(jne,"PoolMode",n)}const Xm=[];function Hc(n,e){Xm.push(n);try{const t=e();return Xm.pop(),t}catch(t){throw Xm.pop(),t}}function LF(n){if(!WF(n))throw new Error("Not a valid tensor name: '"+n+"'");return(Xm.length===0?"":Xm.join("/")+"/")+n}function RF(n){if(!WF(n))throw new Error("Not a valid tensor name: '"+n+"'");zp.has(n)||zp.set(n,0);const e=zp.get(n);if(zp.set(n,zp.get(n)+1),e>0){const t=`${n}_${e}`;return zp.set(t,1),t}return n}const Gne=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function WF(n){return!!n.match(Gne)}function fu(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let r=1;for(let s=e;s<t;++s)r*=n[s];return r}function Op(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const r=n[t];r<e&&(e=r)}return e}function mu(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const r=n[t];r>e&&(e=r)}return e}function Ki(n,e){if(e<n)throw new Be(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let r=n;r<e;++r)t.push(r);return t}function mx(n,e){return zt(n,e)}function Zm(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),Fe(n,t)}function Gc(n,e,t){return Ve(()=>{switch(n.rank){case 1:return KI(n,e,t);case 2:return k4(n,[e,0],[t,n.shape[1]]);case 3:return qI(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return Kv(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return or(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return or(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new Be(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function n3(n,e,t){return Ve(()=>{switch(n.rank){case 1:return KI(n,e,t);case 2:return k4(n,[0,e],[n.shape[0],t]);case 3:return qI(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return Kv(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new Be(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function gx(n,e,t,r){return Ve(()=>{switch(n.rank){case 1:return KI(n,e,t);case 2:switch(r){case 1:return Gc(n,e,t);case 2:return n3(n,e,t);default:throw new Be(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Gc(n,e,t);case 2:return qI(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return n3(n,e,t);default:throw new Be(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Gc(n,e,t);case 2:return Kv(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return Kv(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return n3(n,e,t);default:throw new Be(`The axis is not within the rank of the tensor ${r}`)}default:throw new Be(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function r3(n,e=-1){let t;return e<0&&(t=n[0].rank,e=t!==0?t:0),e===n[0].rank&&(e=-1),ys(n,e)}function jF(n,e){switch(n.rank){case 1:return cee([n,e]);case 2:return dee([n,e],0);case 3:return pee([n,e],0);case 4:return hee([n,e],0);default:throw new Be(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function s3(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new Be(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return vi(n,e)}function yx(n,e=0,t=1,r,s){return gee(n,e,t,r,s)}function gl(n,e,t,r){if(n.rank<2||e.rank<2)throw new En(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3&&n.shape.slice(-1)[0]!==e.shape.slice(-2)[0])throw new En(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`);if(n.rank===2&&e.rank===2)return rS({a:n,b:e,transposeA:!1,transposeB:!1,bias:r?a3(n.rank,r,"channelsLast"):null,activation:t});{const s=n.shape.slice(),o=s.pop();n=Fe(n,[-1,o]);const A=e.shape.slice(),u=A.pop(),h=A.pop(),l=[...A,u],c=Array.from({length:e.rank},(m,y)=>y===0?e.rank-2:y<=e.rank-2?y-1:y);e=Fe(Yn(e,c),[h,-1]);const d=[...s,...l];return Fe(rS({a:n,b:e,transposeA:!1,transposeB:!1,bias:r?a3(n.rank,r,"channelsLast"):null,activation:t}),d)}}function HF(n,e,t){return Ve(()=>(e=Array.isArray(e)?Ra(e,"int32"):zt(e,"int32"),zm(n,e,t)))}function Ym(n){return Me(n,n)}function a3(n,e,t){const r=e.shape;if(e.rank!==1&&e.rank!==n)throw new Be(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return r.length===1?Fe(e,[1,r[0],1,1,1]):Fe(e,[1,r[3],r[0],r[1],r[2]]);if(t==="channelsLast")return r.length===1?Fe(e,[1,1,1,1,r[0]]):Fe(e,[1].concat(r))}else if(n===4){if(t==="channelsFirst")return r.length===1?Fe(e,[1,r[0],1,1]):Fe(e,[1,r[2],r[0],r[1]]);if(t==="channelsLast")return r.length===1?Fe(e,[1,1,1,r[0]]):Fe(e,[1].concat(r))}else if(n===3){if(t==="channelsFirst")return r.length===1?Fe(e,[1,r[0],1]):Fe(e,[1,r[1],r[0]]);if(t==="channelsLast")return r.length===1?Fe(e,[1,1,r[0]]):Fe(e,[1].concat(r))}else if(n<3)return e;throw new Be(`Unsupported input rank by biasAdd: ${e.rank}`)}function qi(n,e,t){return Ve(()=>(t==null&&(t="channelsLast"),ds(t),vt(n,a3(n.rank,e,t))))}function GF(n,e,t,r){return Ve(()=>yee(n,e,t,r))}function Um(n,e,t=!1){return t?n():e()}const Vne=["fanIn","fanOut","fanAvg"],Xne=["normal","uniform","truncatedNormal"];class Ci extends kp{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class VF extends Ci{apply(e,t){return Es(e,t)}}VF.className="Zeros",gt(VF);class o3 extends Ci{apply(e,t){return pl(e,t)}}o3.className="Ones",gt(o3);class XF extends Ci{constructor(e){if(super(),typeof e!="object")throw new Be(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new Be(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return Ve(()=>Me(un(this.value),pl(e,t)))}getConfig(){return{value:this.value}}}XF.className="Constant",gt(XF);class ZF extends Ci{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Pm(e,this.minval,this.maxval,t)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}ZF.className="RandomUniform",gt(ZF);class YF extends Ci{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if((t=t||"float32")!=="float32"&&t!=="int32")throw new En(`randomNormal does not support dType ${t}.`);return yx(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}YF.className="RandomNormal",gt(YF);class UF extends Ci{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if((t=t||"float32")!=="float32"&&t!=="int32")throw new En(`truncatedNormal does not support dType ${t}.`);return JI(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}UF.className="TruncatedNormal",gt(UF);class QF extends Ci{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return Ve(()=>{if(e.length!==2||e[0]!==e[1])throw new Be("Identity matrix initializer can only be used for 2D square matrices.");return Me(this.gain,y4(e[0]))})}getConfig(){return{gain:this.gain}}}QF.className="Identity",gt(QF);class Co extends Ci{constructor(e){if(super(),e.scale<0)throw new Be(`scale must be a positive float. Got: ${e.scale}`);var t;this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,t=this.mode,jc(Vne,"FanMode",t),this.distribution=e.distribution==null?"normal":e.distribution,function(r){jc(Xne,"Distribution",r)}(this.distribution),this.seed=e.seed}apply(e,t){const r=function(u,h="channelsLast"){let l,c;if(ds(h),u.length===2)l=u[0],c=u[1];else if([3,4,5].indexOf(u.length)!==-1){if(h==="channelsFirst"){const d=fu(u,2);l=u[1]*d,c=u[0]*d}else if(h==="channelsLast"){const d=fu(u,0,u.length-2);l=u[u.length-2]*d,c=u[u.length-1]*d}}else{const d=fu(u);l=Math.sqrt(d),c=Math.sqrt(d)}return[l,c]}(e),s=r[0],o=r[1];let A=this.scale;if(this.mode==="fanIn"?A/=Math.max(1,s):this.mode==="fanOut"?A/=Math.max(1,o):A/=Math.max(1,(s+o)/2),this.distribution==="normal"){const u=Math.sqrt(A);if((t=t||"float32")!=="float32"&&t!=="int32")throw new En(`${this.getClassName()} does not support dType ${t}.`);return JI(e,0,u,t,this.seed)}{const u=Math.sqrt(3*A);return Pm(e,-u,u,t)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Co.className="VarianceScaling",gt(Co);class i3 extends Co{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Co.className}}i3.className="GlorotUniform",gt(i3);class A3 extends Co{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Co.className}}A3.className="GlorotNormal",gt(A3);class l3 extends Co{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Co.className}}l3.className="HeNormal",gt(l3);class u3 extends Co{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Co.className}}u3.className="HeUniform",gt(u3);class c3 extends Co{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Co.className}}c3.className="LeCunNormal",gt(c3);class d3 extends Co{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Co.className}}d3.className="LeCunNormal",gt(d3);class KF extends Ci{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,this.seed!=null)throw new En("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,t){return Ve(()=>{if(e.length<2)throw new En("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);const r=yx(e[0]>e[1]?[e[1],e[0]]:e,0,1,"float32");let s=Zee.gramSchmidt(r);return e[0]>e[1]&&(s=Yn(s)),Me(this.gain,s)})}getConfig(){return{gain:this.gain,seed:this.seed}}}KF.className="Orthogonal",gt(KF);const qF={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function JF(n,e={}){return Gm(n,yi.getMap().classNameMap,e,"initializer")}function Ur(n){return $S(n)}function jr(n){if(typeof n=="string"){const e=n in qF?qF[n]:n;if(e==="GlorotNormal")return new A3;if(e==="GlorotUniform")return new i3;if(e==="HeNormal")return new l3;if(e==="HeUniform")return new u3;if(e==="LeCunNormal")return new c3;if(e==="LeCunUniform")return new d3;{const t={};return t.className=e,t.config={},JF(t)}}return n instanceof Ci?n:JF(n)}let Zne=0;function $F(){return Zne++}const bx={};function vx(n=""){return n in bx||(bx[n]=0),bx[n]+=1,n+bx[n].toString()}function p3(n){return Array.isArray(n)&&Array.isArray(n[0])}function xx(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function Mn(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new Be(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function pr(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n[0];throw new Be(`Expected exactly 1 Shape; got ${n.length}`)}return n}function wx(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((r,s)=>r*s);return e}const _F="Variable";class Yne{constructor(e,t="float32",r=_F,s=!0,o=null){this.dtype=t??"float32",this.shape=e.shape,this.id=$F(),r=r??_F,this.originalName=LF(r),this.name=RF(this.originalName),this.trainable_=s,this.constraint=o,this.val=function(A,u=!0,h,l){return Ne.makeVariable(A,u,h,l)}(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(t,r){if(t.shape.toString()!==r.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(r.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function h3(n){return n.map(e=>e.read())}function f3(n){n.forEach(e=>{e[0].write(e[1])})}class Ps{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class MA{constructor(e,t,r,s,o,A,u){this.dtype=e,this.shape=t,this.sourceLayer=r,this.inputs=s,this.callArgs=o,this.outputTensorIndex=u,this.id=$F(),A!=null&&(this.originalName=LF(A),this.name=RF(this.originalName)),this.rank=t.length}}let Une=0;class kx{constructor(e,t){this.callArgs=t,this.id=Une++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const r of e.inboundLayers)r!=null&&r.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let Qne=0;class Un extends kp{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Qne++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const r=this.getClassName();t=ml(r)+"_"+vx(r)}if(this.name=t,this.trainable_=e.trainable==null||e.trainable,e.inputShape!=null||e.batchInputShape!=null){let r;if(e.batchInputShape!=null)r=e.batchInputShape;else if(e.inputShape!=null){let o=null;e.batchSize!=null&&(o=e.batchSize),r=[o].concat(e.inputShape)}this.batchInputShape=r;let s=e.dtype;s==null&&(s=e.inputDType),s==null&&(s="float32"),this.dtype=s}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new wi(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new Be(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return no(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return no(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new NA(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new NA(`Layer ${this.name} is not connected, no input to return.`);return no(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new NA(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new NA(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return no(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=Dr(e),this.inputSpec==null||this.inputSpec.length===0)return;const t=Dr(this.inputSpec);if(e.length!==t.length)throw new Be(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let r=0;r<e.length;r++){const s=e[r],o=t[r];if(o==null)continue;const A=s.rank;if(o.ndim!=null&&A!==o.ndim)throw new Be(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${A}`);if(o.maxNDim!=null&&A>o.maxNDim)throw new Be(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${A}`);if(o.minNDim!=null&&A<o.minNDim)throw new Be(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${A}.`);if(o.dtype!=null&&s.dtype!==o.dtype)throw new Be(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${s.dtype}.`);if(o.axes){const u=s.shape;for(const h in o.axes){const l=Number(h),c=o.axes[h],d=l>=0?u[l]:u[u.length+l];if(c!=null&&[c,null].indexOf(d)===-1)throw new Be(`Input ${r} is incompatible with layer ${this.name}: expected axis ${l} of input shape to have value ${c} but got shape ${u}.`)}}if(o.shape!=null)for(let u=0;u<o.shape.length;++u){const h=o.shape[u],l=s.shape[u];if(h!=null&&l!=null&&h!==l)throw new Be(`Input ${r} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${s.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const r=Dr(e);let s=!0;for(const A of r)if(!(A instanceof MA)){s=!1;break}let o=!0;for(const A of r)if(A instanceof MA){o=!1;break}if(s===o)throw new Be("Arguments to apply() must be all SymbolicTensors or all Tensors");return Hc(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const A=[];for(const u of Dr(e))A.push(u.shape);this.build(no(A)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&o&&(this._refCount=1)}if(this.assertInputCompatibility(e),o){let A=this.call(e,t);const u=Dr(A),h=[];for(let l of u)r.indexOf(l)!==-1&&(l=l.clone()),h.push(l);if(A=no(h),this.activityRegularizer!=null)throw new En("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return A}{const A=function(c){c=Dr(c);const d=[];for(const m of c)d.push(m.shape);return no(d)}(e),u=this.computeOutputShape(A);let h;const l="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?A[0]:A),h=u!=null&&u.length>0&&Array.isArray(u[0])?u.map((c,d)=>new MA(l,c,this,Dr(e),t,this.name,d)):new MA(l,u,this,Dr(e),t,this.name),this.addInboundNode(e,h,null,null,A,u,t),this._refCount++,this.activityRegularizer!=null)throw new En("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return h}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((r,s)=>{r!=null&&e[s]!=null&&e[s]!==r&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new NA(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const r=JSON.stringify(t.outputShapes);e.indexOf(r)===-1&&e.push(r)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}throw new NA(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new wi(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return wx(this.weights)}build(e){this.built=!0}getWeights(e=!1){return h3(e?this.trainableWeights:this.weights)}setWeights(e){Ve(()=>{const t=this.weights;if(t.length!==e.length)throw new Be(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const r=[],s=h3(t);for(let o=0;o<s.length;++o){const A=s[o],u=t[o],h=e[o];if(!ht(A.shape,h.shape))throw new Be(`Layer weight shape ${A.shape} not compatible with provided weight shape ${h.shape}`);r.push([u,h])}f3(r)})}addWeight(e,t,r,s,o,A,u){if(this._addedWeightNames.indexOf(e)!==-1)throw new Be(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),r==null&&(r="float32"),this.fastWeightInitDuringBuild&&(s=jr("zeros"));const h=s.apply(t,r),l=new Yne(h,r,e,A,u);return h.dispose(),o!=null&&this.addLoss(()=>o.apply(l.read())),A==null&&(A=!0),A?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Dr(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach(r=>{if(r!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return t}addInboundNode(e,t,r,s,o,A,u=null){const h=Dr(e);t=Dr(t),r=Dr(r),s=Dr(s),o=xx(o),A=xx(A);const l=[],c=[],d=[];for(const m of h)l.push(m.sourceLayer),c.push(m.nodeIndex),d.push(m.tensorIndex);new kx({outboundLayer:this,inboundLayers:l,nodeIndices:c,tensorIndices:d,inputTensors:h,outputTensors:t,inputMasks:r,outputMasks:s,inputShapes:o,outputShapes:A},u);for(let m=0;m<t.length;m++)t[m].sourceLayer=this,t[m].nodeIndex=this.inboundNodes.length-1,t[m].tensorIndex=m}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount==0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function e5(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const r=e.inboundNodes[t];if(r.inboundLayers.length===0)return r.inputTensors;{const s=[];for(let o=0;o<r.inboundLayers.length;o++){const A=e5(r.inputTensors[o],r.inboundLayers[o],r.nodeIndices[o]);for(const u of A)s.indexOf(u)===-1&&s.push(u)}return s}}}class Qm extends Un{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:vx("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new Be("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new Be("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new Be("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const r=e.dtype||"float32";this.batchInputShape=t,this.dtype=r,this.inputSpec=[{shape:t}];const s=new MA(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new kx({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new Be(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}async function Vc(n){if(n==null)return;const e=[],t=[],r=[];for(const s in n){const o=n[s];if(typeof o!="number"){const A=o;e.push(A.data()),t.push(s),r.push(A)}}if(e.length>0){const s=await Promise.all(e);for(let o=0;o<s.length;++o)n[t[o]]=s[o][0];Rn(r)}}function t5(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}var n5,Cx;Qm.className="InputLayer",gt(Qm),(Cx=n5||(n5={}))[Cx.SILENT=0]="SILENT",Cx[Cx.VERBOSE=1]="VERBOSE";class Km{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class Kne{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class qne extends Km{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const r=t.size==null?0:t.size;this.seen+=r;for(const s in t){const o=t[s];if(typeof o=="number")this.totals.hasOwnProperty(s)||(this.totals[s]=0),this.totals[s]=this.totals[s]+o*r;else{let A;s in this.totals?A=this.totals[s]:this.totals[s]=0;const u=Ve(()=>vt(this.totals[s],Me(o,r)));this.totals[s]=u,A!=null&&A.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const r of this.params.metrics)this.totals[r]!=null&&(typeof this.totals[r]=="number"?t[r]=this.totals[r]/this.seen:Ve(()=>{const s=Me(an(1,this.seen),this.totals[r]);t[r]=s,this.totals[r].dispose(),aa(t[r])}))}}class Jne extends Km{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const r in t)this.history[r]==null&&(this.history[r]=[]),this.history[r].push(t[r])}async syncData(){const e=[],t=[],r=[];for(const o in this.history){const A=this.history[o];for(let u=0;u<A.length;++u)if(typeof A[u]!="number"){const h=A[u];e.push(h.data()),t.push(o),r.push(u)}}const s=await Promise.all(e);for(let o=0;o<s.length;++o)this.history[t[o]][r[o]].dispose(),this.history[t[o]][r[o]]=s[o][0]}}class $ne extends Km{constructor(e,t){if(super(),this.currentEpoch=0,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=125),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Gn(this.yieldEvery)&&(this.maybeWait=function(r,s){let o,A=$a();return(...u)=>{const h=$a();return h-A<s||(A=h,o=r(...u)),o}}(this.maybeWait.bind(this),this.yieldEvery)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,r){const s=[];this.yield!=null&&(await Vc(r),s.push(this.yield(e,t,r))),s.push(yS()),await Promise.all(s)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await Vc(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const r=[];this.epochEnd!=null&&(await Vc(t),r.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&r.push(yS()),await Promise.all(r)}async onBatchBegin(e,t){this.batchBegin!=null&&(await Vc(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const r=[];this.batchEnd!=null&&(await Vc(t),r.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?r.push(yS()):Gn(this.yieldEvery)&&r.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(r)}async onTrainBegin(e){this.trainBegin!=null&&(await Vc(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Vc(e),await this.trainEnd(e))}}function r5(n,e){return n==null&&(n={}),n instanceof Km?[n]:Array.isArray(n)&&n[0]instanceof Km?n:Dr(n).map(t=>new $ne(t,e))}class Ii{constructor(){}static registerCallbackConstructor(e,t){J(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),Ii.checkForDuplicate(t),Ii.constructors[e]==null&&(Ii.constructors[e]=[]),Ii.constructors[e].push(t)}static checkForDuplicate(e){for(const t in Ii.constructors)Ii.constructors[+t].forEach(r=>{if(r===e)throw new Be("Duplicate callback constructor.")})}static clear(){Ii.constructors={}}static createCallbacks(e){const t=[];for(const r in Ii.constructors){const s=+r;e>=s&&t.push(...Ii.constructors[s])}return t.map(r=>new r)}}function s5(n,e,t,r,s,o,A,u,h){const l=new Jne,c=[new qne,...Ii.createCallbacks(e)];n!=null&&c.push(...n),c.push(l);const d=new Kne(c);return d.setParams({epochs:t,initialEpoch:r,samples:s,steps:o,batchSize:A,verbose:e,doValidation:u,metrics:h}),{callbackList:d,history:l}}function yl(n,e={},t=!1){return Gm(n,yi.getMap().classNameMap,e,"layer",t)}function Ix(n,e){return Ve(()=>{n.dtype!=="float32"&&(n=zt(n,"float32"));const t=Qt(Ym(n),e,!0),r=Em(t.shape,Ds()),s=wa(dl(t,r));return an(n,s)})}function Sx(n,e){return Ve(()=>es(Ym(Ut(e,n)),-1))}function m3(n,e){return Ve(()=>es(Ts(Ut(e,n)),-1))}function g3(n,e){return Ve(()=>{const t=Ut(n,e),r=ko(Ts(n),Ds(),Number.MAX_VALUE),s=Ts(an(t,r));return Me(100,es(s,-1))})}function qm(n,e,t=!1){return Ve(()=>{if(t)e=qv(e);else{const r=Qt(e,e.shape.length-1,!0);e=an(e,r)}return e=ko(e,Ds(),1-Ds()),Yr(Qt(Me(zt(n,"float32"),Jo(e)),e.shape.length-1))})}function Nx(n,e,t=!1){return Ve(()=>{const r=zt(Dm(function(o){const A=[fu(o.shape)];return Fe(o,A)}(n)),"int32"),s=(e=ko(e,Ds(),1-Ds())).shape;return qm(Fe(YI(r,s[s.length-1]),s),e,t)})}function Tx(n,e){return Ve(()=>{let t;return t=ko(e,Ds(),1-Ds()),t=Jo(an(t,Ut(1,t))),es(function(r,s){if(!ht(r.shape,s.shape))throw new Be(`logits and labels must have the same shape, but got shapes ${JSON.stringify(r.shape)} and ${JSON.stringify(s.shape)}`);return Ve(()=>{const o=IA(s),A=Yr(Ts(s));return vt(Ut(o,Me(s,r)),Zv(Qo(A)))})}(n,t),-1)})}function a5(n,e){return Ve(()=>{const t=Ix(n,-1),r=Ix(e,-1),s=Me(t,r);return Yr(Qt(s,-1))})}Ii.constructors={};const Mx={meanSquaredError:Sx,meanAbsoluteError:m3,meanAbsolutePercentageError:g3,meanSquaredLogarithmicError:function(n,e){return Ve(()=>{const t=ko(e,Ds(),Number.MAX_VALUE),r=Jo(vt(1,t)),s=ko(n,Ds(),Number.MAX_VALUE),o=Jo(vt(1,s));return es(Ym(Ut(r,o)),-1)})},squaredHinge:function(n,e){return Ve(()=>{const t=dl(0,Ut(1,Me(n,e)));return es(Ym(t),-1)})},hinge:function(n,e){return Ve(()=>{const t=dl(0,Ut(1,Me(n,e)));return es(t,-1)})},categoricalHinge:function(n,e){return Ve(()=>{const t=Qt(Me(n,e),-1),r=Yi(Me(Ut(1,n),e),-1);return dl(0,vt(1,Ut(r,t)))})},logcosh:function(n,e){return Ve(()=>{const t=Math.log(2),r=Ut(e,n),s=Ut(vt(r,Mp(Me(-2,r))),t);return es(s,-1)})},categoricalCrossentropy:qm,sparseCategoricalCrossentropy:Nx,binaryCrossentropy:Tx,kullbackLeiblerDivergence:function(n,e){return Ve(()=>{const t=ko(n,Ds(),1),r=ko(e,Ds(),1);return Qt(Me(n,Jo(an(t,r))),-1)})},poisson:function(n,e){return Ve(()=>{const t=Jo(vt(Ds(),e));return es(Ut(e,Me(n,t)),-1)})},cosineProximity:a5};function y3(n){if(typeof n=="string"){if(n in Mx)return Mx[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new Be(e)}return n}function o5(n,e){return Ve(()=>{const t=Me(.5,$o(e)),r=mx(qo(e,t),n.dtype);return es(Zi(n,r),-1)})}function i5(n,e){return Ve(()=>mx(Zi(Cp(n,-1),Cp(e,-1)),"float32"))}function _ne(n,e){return Tx(n,e)}function ere(n,e){return n.rank===e.rank&&(n=cu(n,[n.rank-1])),(e=Cp(e,-1)).dtype!==n.dtype&&(e=zt(e,n.dtype)),zt(Zi(n,e),"float32")}const A5=qm,l5=Nx,Ex={binaryAccuracy:o5,categoricalAccuracy:i5,precision:function(n,e){return Ve(()=>{const t=function(o,A){return Ve(()=>zt(Qt(CA(Zi(o,1),Zi(A,1))),"float32"))}(n,e),r=function(o,A){return Ve(()=>zt(Qt(CA(Zi(o,0),Zi(A,1))),"float32"))}(n,e),s=vt(t,r);return zt(eo(qo(s,0),an(t,s),0),"float32")})},categoricalCrossentropy:A5,sparseCategoricalCrossentropy:l5,mse:Sx,MSE:Sx,mae:m3,MAE:m3,mape:g3,MAPE:g3,cosine:a5};function tre(n){if(typeof n=="string"&&n in Ex)return Ex[n];if(typeof n!="string"&&n!=null)return n;throw new Be(`Unknown metric ${n}`)}function Dx(n){if(TA(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(Mx))if(Mx[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(Ex))if(Ex[t]===n){e=t;break}return e!==void 0?e:n.name}}function u5(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!b3(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const r=JSON.stringify(n);r.length>1048576&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function b3(n){if(n===null)return!0;if(typeof n=="object"){if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!b3(n[t]))return!1;return!0}if(Array.isArray(n)){for(const e of n)if(!b3(e))return!1;return!0}return!1}{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}function zx(n,e,t=console.log){let r="";for(let s=0;s<n.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=n[s],r=r.slice(0,e[s]),r+=" ".repeat(e[s]-r.length);t(r)}function nre(n,e,t){let r;try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}zx([`${n.name} (${n.getClassName()})`,r,n.countParams().toString()],e,t)}function rre(n,e,t,r){let s;try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const o=[];for(const l of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(l)===-1))for(let c=0;c<l.inboundLayers.length;++c){const d=l.inboundLayers[c].name,m=l.nodeIndices[c],y=l.tensorIndices[c];o.push(`${d}[${m}][${y}]`)}const A=n.name,u=n.getClassName(),h=o.length===0?"":o[0];zx([`${A} (${u})`,s,n.countParams().toString(),h],e,r);for(let l=1;l<o.length;++l)zx(["","","",o[l]],e,r)}function c5(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function v3(n,e){if(n===null)return null;if(typeof n=="string")return Wc(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],r=n.length;for(let s=0;s<r;++s){const o=n[s];c5(e,s,o)?t.push(o):t.push(v3(o,e))}return t}{const t={};for(const r of Object.keys(n)){const s=n[r];if(r==="name"&&typeof s=="string")t[r]=s;else{const o=Wc(r);t[o]=v3(s,o)}}return t}}function x3(n,e){if(n==null)return null;if(typeof n=="string")return ml(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],r=n.length;for(let s=0;s<r;++s){const o=n[s];c5(e,s,o)?t.push(o):t.push(x3(o,e))}return t}{const t={};for(const r of Object.keys(n)){const s=n[r];t[ml(r)]=r!=="name"&&r!=="className"||typeof s!="string"?x3(s,r):s}return t}}const d5="3.9.0";class gu{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof gu)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,r){if(this.id2Value[e.id]!=null)throw new Be(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(s,o){if(s.dtype==null||s.dtype===o.dtype)return o;try{return zt(o,s.dtype)}catch{throw new Be(`The dtype of the feed (${o.dtype}) can not be cast to the dtype of the key '${s.name}' (${s.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,r!=null&&(this.id2Mask[e.id]=r),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof MA){if(this.id2Value[e.id]==null)throw new Be(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{const t=this.name2Id[e];if(t==null)throw new Be(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof MA){if(this.id2Value[e.id]==null)throw new Be(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{const t=this.name2Id[e];if(t==null)throw new Be(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&Rn(this.id2Mask)}}const w3={},p5={};function Jm(n,e,t,r){const s=t!=null&&t.training,o=Array.isArray(n),A=o?n:[n],u=A.map(b=>b.name),h=[],l=e.names();for(const b of u)l.indexOf(b)!==-1?h.push(e.getValue(b)):h.push(null);const c=u.join(",")+"|"+e.names().join(",");let d,m;if(w3[c]==null){const b=function(v,w){J(v!=null&&v.length>0,()=>"Expected at least one fetch, got none");let I=[],S={};if(v.length===1){const T=h5(v[0],w);I=T.sorted,S=T.recipientMap}else{const T=new Set;for(const D of v){const{sorted:L,recipientMap:W}=h5(D,w);for(const K of L)T.has(K.name)||(I.push(K),T.add(K.name));for(const K in W)S[K]==null&&(S[K]=new Set),W[K].forEach(U=>S[K].add(U))}}return{sorted:I,recipientCounts:sre(S)}}(A,e);d=b.sorted,m=b.recipientCounts,w3[c]=d,p5[c]=m}d=w3[c],m={},s||Object.assign(m,p5[c]);const y=new gu(e);for(let b=0;b<d.length;++b){const v=d[b],w=v.sourceLayer;if(w instanceof Qm)continue;const I=[],S=[],T=[];let D=!1;for(const _ of v.inputs){const ee=y.getValue(_),re=y.getMask(_);I.push(ee),S.push(re),re!=null&&(D=!0),s||(m[_.name]--,m[_.name]!==0||e.hasKey(_)||u.indexOf(_.name)!==-1||ee.isDisposed||_.sourceLayer.stateful===!0||T.push(ee))}D&&((t=t||{}).mask=S[0]);const L=Dr(w.apply(I,t));let W=null;w.supportsMasking&&(W=w.computeMask(I,S));const K=are(v),U=Array.isArray(K)?K:[K];for(let _=0;_<U.length;++_){y.hasKey(U[_])||y.add(U[_],L[_],Array.isArray(W)?W[0]:W);const ee=u.indexOf(U[_].name);ee!==-1&&(h[ee]=L[_])}s||Rn(T)}return y.disposeMasks(),o?h:h[0]}function sre(n){const e={};for(const t in n)e[t]=n[t].size;return e}function h5(n,e){const t=new Set,r=[],s={};for(const u of e.names())t.add(u);const o=[],A=[];for(o.push(n);o.length>0;){const u=o[o.length-1];if(t.has(u.name)){o.pop();continue}const h=A[A.length-1]===o.length-1;if(u.inputs.length===0||h)o.pop(),r.push(u),t.add(u.name),h&&A.pop();else{A.push(o.length-1);for(const l of u.inputs)s[l.name]==null&&(s[l.name]=new Set),s[l.name].add(u.name),t.has(l.name)||o.push(l)}}return{sorted:r,recipientMap:s}}function are(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let r=0;r<n.sourceLayer.inboundNodes.length;++r)for(const s of n.sourceLayer.inboundNodes[r].outputTensors)if(s.id===n.id){t=r;break}e=n.sourceLayer.getOutputAt(t)}return e}class Ji extends Un{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const S=this.getClassName().toLowerCase();this.name=vx(S)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],hu(this.inputs).length!==this.inputs.length)throw new Be(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(S=>S.name)}`);hu(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(S=>S.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const S of this.outputs){const T=S.sourceLayer,D=S.nodeIndex,L=S.tensorIndex;this.outputLayers.push(T),this.outputLayersNodeIndices.push(D),this.outputLayersTensorIndices.push(L)}for(const S of this.inputs){const T=S.sourceLayer,D=S.nodeIndex,L=S.tensorIndex;TA(D===0,"input layer has >1 nodes"),TA(L===0,"input layer has >1 tensors"),this.inputLayers.push(T),this.inputLayersNodeIndices.push(D),this.inputLayersTensorIndices.push(L)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let S=0;S<this.inputLayers.length;S++){const T=this.inputLayers[S];if(!(T instanceof Qm))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${S} (0-based) originates from layer type ${T.getClassName()}.`);this.inputNames.push(T.name),this.feedInputShapes.push(T.batchInputShape),this.feedInputNames.push(T.name)}for(const S of this.outputLayers)this.outputNames.push(S.name);this.internalInputShapes=this.inputs.map(S=>S.shape),this.internalOutputShapes=this.outputs.map(S=>S.shape);const t={},r={},s={},o={},A={},u=[],h=(S,T,D,L,W,K)=>{L!=null&&W!=null&&K!=null||(L=S.sourceLayer,W=S.nodeIndex,K=S.tensorIndex);const U=L.inboundNodes[W];if(D.indexOf(U)!==-1)throw new wi(`The tensor ${S.name} at layer "${L.name}" is part of a cycle.`);if(T.indexOf(U)!==-1)return;this.containerNodes.add(Ji.nodeKey(L,W)),L.id in A||(A[L.id]=Object.keys(A).length),D.indexOf(U)===-1&&D.push(U);const _=U.inboundLayers.length;for(let ee=0;ee<_;ee++){const re=U.inputTensors[ee],ce=U.inboundLayers[ee],we=U.nodeIndices[ee],Ee=U.tensorIndices[ee];h(re,T,D,ce,we,Ee)}for(T.push(U);D.indexOf(U)>=0;)D.splice(D.indexOf(U),1);u.push(U)},l=[],c=[];for(const S of this.outputs)h(S,l,c);const d=u.slice().reverse();for(const S of d){r[S.id]=S,S.id in t||(t[S.id]=0);let T=t[S.id];const D=s[S.outboundLayer.id]==null?0:s[S.outboundLayer.id];T=Math.max(T,D),s[S.outboundLayer.id]=T,o[S.outboundLayer.id]=S.outboundLayer,t[S.id]=T;for(let L=0;L<S.inboundLayers.length;L++){const W=S.inboundLayers[L],K=S.nodeIndices[L],U=W.inboundNodes[K],_=t[U.id]==null?0:t[U.id];t[U.id]=Math.max(T+1,_),r[U.id]=U}}const m={};for(const S in t){const T=t[S];T in m||(m[T]=[]),m[T].push(r[S])}const y={};for(const S in s){const T=s[S];T in y||(y[T]=[]),y[T].push(o[S])}let b=Object.keys(y).map(S=>parseInt(S,10)).sort(fx);this.layers=[];for(const S of b){const T=y[S];T.sort((D,L)=>{const W=A[D.id],K=A[L.id];return W<K?-1:W>K?1:0});for(const D of T)D instanceof Ji&&this.internalContainerRefs.push(D),this.layers.push(D)}this.layersByDepth=y,b=Object.keys(m).map(S=>parseInt(S,10)).sort(fx);const v=this.inputs.slice(),w=[];for(const S of b)for(const T of m[S]){const D=T.outboundLayer;if(D!=null){for(const L of T.inputTensors)if(v.indexOf(L)===-1)throw new wi(`Graph disconnected: cannot obtain value for tensor ${L} at layer "${D.name}". The following previous layers were accessed without issue: ${w}`);for(const L of T.outputTensors)v.push(L);w.push(D.name)}}this.nodesByDepth=m;const I=this.layers.map(S=>S.name);for(const S of I){const T=I.filter(D=>D===S).length;if(T!==1)throw new wi(`The name "${S}" is used ${T} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(I))}this.outboundNodes=[],this.inboundNodes=[],new kx({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(S=>null),outputMasks:this.outputs.map(S=>null),inputShapes:this.inputs.map(S=>S.shape),outputShapes:this.outputs.map(S=>S.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount==0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(r=>r.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new Be("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const r of this.layers)t.push(...r.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const r={};let s=0;for(const A of this.layers)for(const u of A.weights){if(r[u.originalName]!=null)throw new Be(`Duplicate weight name: ${u.originalName}`);r[u.originalName]=u,s++}const o=[];for(const A in e){let u=A;if(r[A]==null){const h=A.split("/");u=h.slice(0,-2).concat([h[h.length-1]]).join("/")}if(r[u]!=null)o.push([r[u],e[A]]);else if(t)throw new Be(`Provided weight data has no target variable: ${A}`);delete r[u]}if(t){const A=[];for(const u in r)A.push(u);if(A.length>0)throw new Be(`${A.length} of ${s} weights are not set: ${A}`)}f3(o)}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${d5}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const r=x3(this.updatedConfig());return t?JSON.stringify(r):r}call(e,t){return Ve(()=>{e=Dr(e);const r=new gu;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],e[s]);return Jm(this.outputs,r,t)})}computeMask(e,t){return Ve(()=>{let r;return e=Dr(e),r=t==null?Rc(null,e.length):Dr(t),this.runInternalGraph(e,r)[1]})}computeOutputShape(e){const t=xx(e);if(t.length!==this.inputLayers.length)throw new Be(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let u=0;u<t.length;u++){const h=this.inputLayers[u],l=t[u];r[h.name+"_0_0"]=l}const s=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(fx);if(s.length>1)for(const u of s){const h=this.nodesByDepth[u];for(const l of h){const c=l.outboundLayer;if(this.inputLayers.map(b=>b.id).indexOf(c.id)!==-1)continue;const d=[];for(let b=0;b<l.inboundLayers.length;b++){const v=l.inboundLayers[b],w=l.nodeIndices[b],I=l.tensorIndices[b],S=r[`${v.name}_${w}_${I}`];d.push(S)}const m=xx(c.computeOutputShape(no(d))),y=c.inboundNodes.indexOf(l);for(let b=0;b<m.length;b++)r[`${c.name}_${y}_${b}`]=m[b]}}const o=[],A=[];for(let u=0;u<this.outputLayers.length;u++){const h=this.outputLayers[u],l=this.outputLayersNodeIndices[u],c=this.outputLayersTensorIndices[u],d=`${h.name}_${l}_${c}`;A.push(d)}for(let u=0;u<A.length;u++){const h=A[u];TA(h in r),o.push(r[h])}return no(o)}runInternalGraph(e,t){t==null&&(t=Rc(null,e.length));const r={};for(let h=0;h<this.inputs.length;++h){const l=this.inputs[h],c=e[h],d=t[h];r[l.id]=[c,d]}const s=Object.keys(this.nodesByDepth).map(h=>parseInt(h,10)).sort(fx);for(const h of s){const l=this.nodesByDepth[h];for(const c of l){const d=c.outboundLayer,m=c.inputTensors,y=c.outputTensors,b=new Array;for(const v of m)v.id in r&&b.push(r[v.id]);if(b.length===m.length){let v,w,I,S,T={};if(c.callArgs!=null&&(T=c.callArgs),b.length===1){const[D,L]=b[0];T.mask==null&&(T.mask=L),I=Dr(d.call(D,T)),S=Dr(d.computeMask(D,L)),v=[D],w=[L]}else v=b.map(D=>D[0]),w=b.map(D=>D[1]),T.mask==null&&(T.mask=w),I=Dr(d.call(v,T)),S=Dr(d.computeMask(v,w));if(d.activityRegularizer)throw new En("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let D=0;D<y.length;++D){const L=y[D],W=I[D],K=S[D];r[L.id]=[W,K]}}}}const o=[],A=[],u=[];for(const h of this.outputs){TA(h.id in r,`Could not compute output ${h.name} : ${h.id}`);const[l,c]=r[h.id];u.push(l.shape),o.push(l),A.push(c)}return[o,A,u]}buildNodeConversionMap(e){const t={};let r;for(const s of this.layers){r=s instanceof Ji?1:0;for(let o=0;o<s.inboundNodes.length;o++){const A=Ji.nodeKey(s,o);this.containerNodes.has(A)&&(t[A]=r,r+=1)}}return t}getLayer(e,t){if(t!=null){if(this.layers.length<=t)throw new Be(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}if(e==null)throw new Be("Provide either a layer name or layer index");for(const r of this.layers)if(r.name===e)return r;throw new Be(`No such layer: ${e}`)}calculateLosses(){return Ve(()=>{const e=[];for(const t of this.layers)for(let r=0;r<t.inboundNodes.length;++r){const s=Ji.nodeKey(t,r);this.containerNodes.has(s)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),r=[];for(const A of this.layers){const u=A.getClassName(),h=A.getConfig(),l=[];for(let d=0;d<A.inboundNodes.length;d++){const m=A.inboundNodes[d],y=Ji.nodeKey(A,d);let b={};if(this.containerNodes.has(y)){if(m.callArgs)try{JSON.stringify(m.callArgs),b=m.callArgs}catch{console.warn(`Layer ${A.name} was passed non-serializable keyword arguments: ${m.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),b={}}if(m.inboundLayers.length>0){const v=[];for(let w=0;w<m.inboundLayers.length;w++){const I=m.inboundLayers[w],S=m.nodeIndices[w],T=m.tensorIndices[w];let D=t[Ji.nodeKey(I,S)];D==null&&(D=0),v.push([I.name,D,T,b])}l.push(v)}}}const c={};c.name=A.name,c.className=u,c.config=h,c.inboundNodes=l,r.push(c)}e.layers=r;const s=[];for(let A=0;A<this.inputLayers.length;A++){const u=this.inputLayers[A],h=this.inputLayersNodeIndices[A],l=Ji.nodeKey(u,h);if(!this.containerNodes.has(l))continue;let c=t[l];c==null&&(c=0);const d=this.inputLayersTensorIndices[A];s.push([u.name,c,d])}e.inputLayers=s;const o=[];for(let A=0;A<this.outputLayers.length;A++){const u=this.outputLayers[A],h=this.outputLayersNodeIndices[A],l=Ji.nodeKey(u,h);if(!this.containerNodes.has(l))continue;let c=t[l];c==null&&(c=0);const d=this.outputLayersTensorIndices[A];o.push([u.name,c,d])}return e.outputLayers=o,e}static fromConfig(e,t,r={},s=!1){const o={},A={};function u(w,I){w.name in A?A[w.name].push(I):A[w.name]=[I]}function h(w,I){const S=[];let T;for(const D of I){const L=D[0],W=D[1],K=D[2];if(T=D[3]==null?{}:D[3],!(L in o))return void u(w,I);const U=o[L];if(U.inboundNodes.length<=W)return void u(w,I);const _=U.inboundNodes[W];S.push(_.outputTensors[K])}S.length>0&&w.apply(no(S),T)}function l(w){const I=w.name,S=yl(w,t.customObjects!=null?t.customObjects:{});S.setFastWeightInitDuringBuild(s),o[I]=S,w.inboundNodes.forEach(T=>{if(!(T instanceof Array))throw new Be(`Corrupted configuration, expected array for nodeData: ${T}`);u(S,T)})}const c=t.name,d=t.layers;for(const w of d)l(w);for(;!Fne(A);)for(const w of d){const I=o[w.name];if(I.name in A){const S=A[I.name];delete A[I.name];for(const T of S)h(I,T)}}const m=[],y=[],b=t.inputLayers;for(const w of b){const I=w[0],S=w[1],T=w[2];TA(I in o);const D=o[I].inboundNodes[S].outputTensors;m.push(D[T])}const v=t.outputLayers;for(const w of v){const I=w[0],S=w[1],T=w[2];TA(I in o);const D=o[I].inboundNodes[S].outputTensors;y.push(D[T])}return new e({inputs:m,outputs:y,name:c})}get stateful(){if(this._stateful)throw new Be("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){Ve(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}function f5(n,e){return function(t,r,s){const o=r.length;if(t==null||Array.isArray(t)&&t.length===0)return r.map(A=>null);if(o===1)return Array.isArray(t)&&t.length===1?t:typeof t=="object"&&r[0]in t?[t[r[0]]]:[t];if(Array.isArray(t)){if(t.length!==o)throw new Error(`Provided ${s} is an array of ${t.length} element(s), but the model has ${o} outputs. Make sure a set of weights is provided for each model output.`);return t}if(typeof t=="object"&&Object.keys(t).length>0&&typeof t[Object.keys(t)[0]]=="object"){const A=[];return r.forEach(u=>{u in t?A.push(t[u]):A.push(null)}),A}throw new Error(`The model has multiple (${o}) outputs, so ${s} must be either an array with ${o} elements or an object with ${r} keys. Provided ${s} not understood: ${JSON.stringify(t)}`)}(n,e,"classWeight")}async function m5(n,e,t,r){if(t!=null){const s=Ve(()=>{if(n.shape.length===1)return ou(n);if(n.shape.length===2){if(n.shape[1]>1)return Cp(n,1);if(n.shape[1]===1)return Fe(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),o=Array.from(await s.data());Rn(s);const A=[];return o.forEach(u=>{if(t[u]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${u} exists in the data but not in classWeight`);A.push(t[u])}),Ra(A,"float32")}return null}function ore(n,e){return Me(n,e)}function g5(n,e){let t,r;const s=e;t=s.xs,r=s.ys,J(t!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const o=y5("input",n.inputNames,t),A=y5("output",n.outputNames,r),u=o[0].shape[0];J(o.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${o.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),J(A.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${A.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let h=0;h<o.length;h++)J(o[h].shape[0]===u,()=>`Batch size mismatch: input ${n.inputNames[h]} has ${o[h].shape[0]}; expected  ${u} based on input ${n.inputNames[0]}.`);for(let h=0;h<A.length;h++)J(A[h].shape[0]===u,()=>`Batch size mismatch: output ${n.outputNames[h]} has ${A[h].shape[0]}; expected  ${u} based on input ${n.inputNames[0]}.`);return{xs:o,ys:A}}function y5(n,e,t){if(t instanceof ls)return[t];if(Array.isArray(t))return J(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const r=[];for(const s of e){if(t[s]==null)throw new Be(`The feature data generated by the dataset lacks the required ${n} key '${s}'.`);r.push(t[s])}return r}}function b5(n){return typeof n.iterator=="function"}function k3(n){J(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function $m(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(r=>Gc(r,e,t-e)):Gc(n,e,t-e)}function C3(n,e){return Ve(()=>n==null?null:Array.isArray(n)?n.map(t=>C3(t,e)):HF(n,e.dtype==="int32"?e:zt(e,"int32")))}function I3(n,e){const t=[];let r=0,s=null;for(;r<n;)s=r+e,s>=n&&(s=n),t.push([r,s]),r=s;return t}function v5(n){const e=[];n instanceof ls&&(n=[n]);for(let t=0;t<n.length;++t){const r=n[t];if(r.rank===1)e.push(Zm(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(r)}}return e}function Xc(n,e){if(n==null)return;const t=[];if(e instanceof ls)t.push(e.id);else if(Array.isArray(e))e.forEach(s=>t.push(s.id));else if(e!=null)for(const s in e){const o=e[s];t.push(o.id)}const r=[];if(n instanceof ls)t.indexOf(n.id)===-1&&r.push(n);else if(Array.isArray(n))n.forEach(s=>{t.indexOf(s.id)===-1&&r.push(s)});else if(n!=null)for(const s in n){const o=n[s];t.indexOf(o.id)===-1&&r.push(o)}r.forEach(s=>{s.isDisposed||s.dispose()})}function S3(n){return Array.isArray(n)}function x5(n){return!function(e){return e instanceof ls}(n)&&!S3(n)}function w5(n,e,t,r=!0,s=""){if(e==null||e.length===0){if(n!=null){let A=!1;if(S3(n)&&n.length>0)A=!0;else if(x5(n)){for(const u in n)if(n.hasOwnProperty(u)){A=!0;break}}else A=!0;if(A)throw new Be(`Error when checking model ${s} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(A=>null);let o;if(x5(n)){o=[];for(const A of e){if(n[A]==null)throw new Be(`No data provided for "${A}". Need data for each key in: ${e}`);o.push(n[A])}}else if(S3(n)){if(n.length!==e.length)throw new Be(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);o=n}else{if(e.length>1)throw new Be(`The model ${s} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);o=[n]}if(o=v5(o),t!=null)for(let A=0;A<e.length;++A){if(t[A]==null)continue;const u=o[A];if(u.shape.length!==t[A].length)throw new Be(`Error when checking ${s}: expected ${e[A]} to have ${t[A].length} dimension(s). but got array with shape ${u.shape}`);for(let h=0;h<t[A].length;++h){if(h===0&&!r)continue;const l=u.shape[h],c=t[A][h];if(c!=null&&c>=0&&l!==c)throw new Be(`${s} expected a batch of elements where each example has shape [${t[A].slice(1,t[A].length)}] (i.e.,tensor shape [*,${t[A].slice(1,t[A].length)}]) but the ${s} received an input with ${u.shape[0]} examples, each with shape [${u.shape.slice(1,u.shape.length)}] (tensor shape [${u.shape}])`)}}return o}function k5(n,e,t,r=!0,s=""){let o;if(Array.isArray(n)){if(n.length!==e.length)throw new Be(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);o=n}else{if(e.length>1)throw new Be(`The model expects ${e.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);o=[n]}if(t!=null)for(let A=0;A<e.length;++A){if(t[A]==null)continue;const u=o[A];if(u.shape.length!==t[A].length)throw new Be(`Error when checking ${s}: expected ${e[A]} to have ${t[A].length} dimension(s), but got array with shape ${JSON.stringify(u.shape)}`);for(let h=0;h<t[A].length;++h){if(h===0&&!r)continue;const l=u.shape[h],c=t[A][h];if(c!=null&&c!==l)throw new Be(`Error when checking ${s}: expected ${e[A]} to have shape ${JSON.stringify(t[A])} but got array with shape ${JSON.stringify(u.shape)}.`)}}}class Pp extends Ji{constructor(e){super(e),this.isTraining=!1}summary(e,t,r=console.log){if(!this.built)throw new Be("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");(function(s,o,A,u=console.log){const h=function(b){let v=!0;const w=[],I=[];for(const S in b.nodesByDepth)w.push(b.nodesByDepth[S]);for(const S of w){if(S.length>1||S.length===1&&S[0].inboundLayers.length>1){v=!1;break}I.push(...S)}if(v)for(const S of b.layers){let T=!1;for(const D of S.inboundNodes)if(I.indexOf(D)!==-1){if(T){v=!1;break}T=!0}if(!v)break}return v}(s),l=["Layer (type)","Output shape","Param #"];let c;if(h?(o=o||65,A=A||[.45,.85,1]):(o=o||98,A=A||[.33,.55,.67,1]),A[A.length-1]<=1&&(A=A.map(b=>Math.floor(o*b))),!h){l.push("Receives inputs"),c=[];for(const b in s.nodesByDepth)c.push(...s.nodesByDepth[b])}u("_".repeat(o)),zx(l,A,u),u("=".repeat(o));const d=s.layers;for(let b=0;b<d.length;++b)h?nre(d[b],A,u):rre(d[b],A,c,u),u((b===d.length-1?"=":"_").repeat(o));s.checkTrainableWeightsConsistency();const m=function(b){let v;return v=b.collectedTrainableWeights!=null?wx(b.collectedTrainableWeights):wx(b.trainableWeights),v}(s),y=wx(s.nonTrainableWeights);u(`Total params: ${m+y}`),u(`Trainable params: ${m}`),u(`Non-trainable params: ${y}`),u("_".repeat(o))})(this,e,t,r)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=function(A){const u={Adagrad:()=>Dp.adagrad(.01),Adadelta:()=>Dp.adadelta(1,.95,Ds()),Adam:()=>Dp.adam(.001,.9,.999,Ds()),Adamax:()=>Dp.adamax(.002,.9,.999,Ds(),0),RMSProp:()=>Dp.rmsprop(.001,.9,0,Ds()),SGD:()=>Dp.sgd(.01)};if(u.adagrad=u.Adagrad,u.adadelta=u.Adadelta,u.adam=u.Adam,u.adamax=u.Adamax,u.rmsprop=u.RMSProp,u.sgd=u.SGD,A in u)return u[A]();throw new Be(`Unknown Optimizer ${A}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof iu))throw new Be("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||typeof e.loss=="string"||typeof e.loss=="function")if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new Be(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(u=>y3(u))}else{const A=y3(e.loss);this.outputs.forEach(u=>{t.push(A)})}else{e.loss=e.loss;for(const A in e.loss)if(this.outputNames.indexOf(A)===-1)throw new Be(`Unknown entry in loss dictionary: "${A}". Only expected the following keys: ${this.outputNames}`);for(const A of this.outputNames)e.loss[A]==null&&console.warn(`Output "${A}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${A} during training`),t.push(y3(e.loss[A]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let A=0;A<this.outputs.length;++A){const u=this.internalOutputShapes[A],h=this.outputNames[A];this.feedOutputNames.push(h),this.feedOutputShapes.push(u),this.feedLossFns.push(this.lossFunctions[A])}const r=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Hc("loss",()=>{for(let A=0;A<this.outputs.length;++A){if(r.indexOf(A)!==-1)continue;const u=this.lossFunctions[A];this.outputs.length>1&&(this.metricsTensors.push([u,A]),this.metricsNames.push(this.outputNames[A]+"_loss"))}});const s=function(A,u){if(A==null||Array.isArray(A)&&A.length===0)return u.map(l=>[]);let h;if(typeof A=="string"||typeof A=="function")h=[A];else{if(!Array.isArray(A)&&typeof A!="object")throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${A}`);h=A}if(Array.isArray(h))return u.map(l=>h);{const l=[];for(const c of u){let d=h.hasOwnProperty(c)?h[c]:[];Array.isArray(d)||(d=[d]),l.push(d)}return l}}(e.metrics,this.outputNames),o=(A,u,h)=>{this.outputNames.length>1&&(u=this.outputNames[A]+"_"+u),this.metricsNames.push(u),this.metricsTensors.push([h,A])};Hc("metric",()=>{for(let A=0;A<this.outputs.length;++A)r.indexOf(A)===-1&&(u=>{let h,l,c;for(const d of u){if(typeof d=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(d)!==-1){const y=this.internalOutputShapes[A];let b;y[y.length-1]===1||this.lossFunctions[A]===Tx?["accuracy","acc"].indexOf(d)!==-1?l=o5:["crossentropy","ce"].indexOf(d)!==-1&&(l=_ne):this.lossFunctions[A]===Nx?["accuracy","acc"].indexOf(d)!==-1?l=ere:["crossentropy","ce"].indexOf(d)!==-1&&(l=l5):["accuracy","acc"].indexOf(d)!==-1?l=i5:["crossentropy","ce"].indexOf(d)!==-1&&(l=A5),["accuracy","acc"].indexOf(d)!==-1?b="acc":["crossentropy","ce"].indexOf(d)!==-1&&(b="ce"),c=l,h=""+b}else c=tre(d),h=""+Dx(d);let m;Hc(h,()=>{m=c}),o(A,h,m)}})(s[A])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,r={}){const s=r.batchSize==null?32:r.batchSize;k3(s);const o=this.standardizeUserDataXY(e,t,!0,s);try{const A=o[0].concat(o[1]);this.makeTestFunction();const u=this.testFunction;return no(this.testLoop(u,A,s,r.verbose,r.steps))}finally{Xc(o[0],e),Xc(o[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(r,s,o){const A=(o=o||{}).batches!=null,u=r.testFunction;let h=[];if(o.verbose>0)throw new En("Verbose mode is not implemented yet.");J(!A||o.batches>0&&Number.isInteger(o.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(o.batches)}`);const l=typeof s.next=="function"?s:await s.iterator();let c=0,d=0;for(;!A||d<o.batches;){const m=await l.next();if(h=Ve(()=>{if(m.value){const{xs:y,ys:b}=g5(r,m.value),v=y.concat(b),w=Ve(()=>u(v));if(Rn(v),d===0)for(let S=0;S<w.length;++S)h.push(un(0));const I=v[0].shape[0];for(let S=0;S<w.length;++S){const T=w[S],D=h[S];h[S]=Ve(()=>vt(h[S],Me(I,T))),d>0&&Rn(D)}Rn(w),c+=I,++d}return h}),m.done){A&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${o.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let m=0;m<h.length;++m){const y=h[m];h[m]=an(h[m],c),Rn(y)}return no(h)}(this,e,t)}checkNumSamples(e,t,r,s="steps"){let o;if(r!=null){if(o=null,t!=null)throw new Be(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(e==null)throw new Be(`Either the input data should have a defined shape, or ${s} shoud be specified.`);o=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return o}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new Be("`outputs` is an empty Array, which is not allowed.");const r=Array.isArray(t),s=r?t:[t],o=this.retrieveSymbolicTensors(s),A=new gu;if(e instanceof ls&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new Be(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let h=0;h<this.inputs.length;++h)A.add(this.inputs[h],e[h])}else for(const h of this.inputs){const l=e[h.name];if(l==null)throw new Be(`No value is provided for the model's input ${h.name}`);A.add(h,l)}const u=Jm(o,A);return r?u:u[0]}retrieveSymbolicTensors(e){const t=Rc(null,e.length);let r=e.length;for(const s of this.layers){const o=Array.isArray(s.output)?s.output:[s.output],A=o.map(u=>u.name);for(let u=0;u<e.length;++u){const h=A.indexOf(e[u]);if(h!==-1&&(t[u]=o[h],r--),r===0)break}if(r===0)break}if(r>0){const s=[];throw t.forEach((o,A)=>{o==null&&s.push(e[A])}),new Be(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(s)}`)}return t}predictLoop(e,t=32,r=!1){return Ve(()=>{const s=this.checkNumSamples(e);if(r)throw new En("Verbose predictLoop() is not implemented yet.");const o=I3(s,t),A=this.outputs.map(u=>[]);for(let u=0;u<o.length;++u)Ve(()=>{const h=o[u][0],l=o[u][1],c=$m(e,h,l),d=[];if(Array.isArray(c))for(let y=0;y<c.length;++y)d.push({key:this.inputs[y],value:c[y]});else d.push({key:this.inputs[0],value:c});const m=new gu(d);return Jm(this.outputs,m)}).forEach((h,l)=>A[l].push(h));return no(A.map(u=>ys(u,0)))})}predict(e,t={}){const r=v5(e);k5(r,this.inputNames,this.feedInputShapes,!1);try{const s=t.batchSize==null?32:t.batchSize;return k3(s),this.predictLoop(r,s)}finally{Xc(r,e)}}predictOnBatch(e){k5(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,r=!0,s){if(this.optimizer_==null)throw new wi("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const o=[];for(let A=0;A<this.feedOutputShapes.length;++A){const u=this.feedOutputShapes[A];this.feedLossFns[A]===Nx?o.push(u.slice(0,u.length-1).concat([1])):o.push(u)}if(function(A,u){const h=hu(A.map(c=>c.shape[0]));h.sort();const l=hu(u.map(c=>c.shape[0]));if(l.sort(),h.length>1)throw new Be(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(A.map(c=>c.shape))}`);if(l.length>1)throw new Be(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(u.map(c=>c.shape))}`);if(h.length>0&&l.length>0&&!ht(h,l))throw new Be(`Input Tensors should have the same number of samples as target Tensors. Found ${h[0]} input sample(s) and ${l[0]} target sample(s).`)}(e=w5(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=w5(t,this.feedOutputNames,o,!1,"target")),function(A,u,h){const l=[Sx,Tx,qm];for(let c=0;c<A.length;++c){const d=A[c],m=u[c],y=h[c];if(m!=null){if(m===qm&&d.shape[d.shape.length-1]===1)throw new Be(`You are passing a target array of shape ${d.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(l.indexOf(m)!==-1){const b=d.shape.slice(1),v=y.slice(1);for(let w=0;w<b.length;++w){const I=b[w],S=v[w];if(S!=null&&I!==S)throw new Be(`A target Tensor with shape ${d.shape} was passed for an output of shape ${y}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&s!=null&&s>0&&e[0].shape[0]%s!=0)throw new Be(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,r,s,o=!0,A){const[u,h]=this.standardizeUserDataXY(e,t,o,A);if(r!=null)throw new Error("sample weight is not supported yet.");let l=null;if(s!=null){const c=f5(s,this.outputNames);l=[];for(let d=0;d<c.length;++d)l.push(await m5(h[d],null,c[d]))}return[u,h,l]}testLoop(e,t,r,s=0,o){return Ve(()=>{const A=this.checkNumSamples(t,r,o,"steps"),u=[];if(s>0)throw new En("Verbose mode is not implemented yet.");if(o!=null)throw new En("steps mode in testLoop() is not implemented yet");{const h=I3(A,r),l=Ra(Ki(0,A));for(let c=0;c<h.length;++c){const d=h[c][0],m=h[c][1],y=Gc(l,d,m-d),b=C3(t,y),v=e(b);if(c===0)for(let w=0;w<v.length;++w)u.push(un(0));for(let w=0;w<v.length;++w){const I=v[w];u[w]=vt(u[w],Me(m-d,I))}}for(let c=0;c<u.length;++c)u[c]=an(u[c],A)}return u})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let r=0;r<e.length;++r){const s=e[r];let o=s;NF(e,s)>1&&(o+=`_${NF(e.slice(0,r),s)}`),t.push(o)}return t}makeTrainFunction(){return e=>{const t=[],r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),A=[],u=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(()=>{const h=[];for(let m=0;m<this.inputs.length;++m)h.push({key:this.inputs[m],value:r[m]});const l=new gu(h),c=Jm(this.outputs,l,{training:!0});let d;for(let m=0;m<this.lossFunctions.length;++m){let y=(0,this.lossFunctions[m])(s[m],c[m]);o[m]!=null&&(y=ore(y,o[m]));const b=es(y);t.push(b),d=m===0?y:vt(d,y)}for(let m=0;m<this.metricsTensors.length;++m){let y;if(this.outputs.length>1&&m<this.outputs.length)y=t[m];else{const b=this.metricsTensors[m][0],v=this.metricsTensors[m][1];y=es(b(s[v],c[v]))}aa(y),A.push(y)}return d=es(d),this.calculateLosses().forEach(m=>{d=vt(d,m)}),d},!0,u)].concat(A)}}makeTestFunction(){this.testFunction=e=>Ve(()=>{const t=[];let r;const s=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),A=[];for(let l=0;l<this.inputs.length;++l)A.push({key:this.inputs[l],value:s[l]});const u=new gu(A),h=Jm(this.outputs,u);for(let l=0;l<this.lossFunctions.length;++l){const c=this.lossFunctions[l],d=es(c(o[l],h[l]));r=l===0?d:vt(r,d),t.push(r)}for(let l=0;l<this.metricsTensors.length;++l){const c=this.metricsTensors[l][0],d=this.metricsTensors[l][1],m=es(c(o[d],h[d]));t.push(m)}return t})}async fit(e,t,r={}){return async function(s,o,A,u={}){if(s.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let h,l,c,d,m,y,b;s.isTraining=!0;try{const v=u.batchSize==null?32:u.batchSize;k3(v);const w=!1,I=await s.standardizeUserData(o,A,u.sampleWeight,u.classWeight,w,v);h=I[0],l=I[1],b=I[2];let S,T=!1;if(u.validationData!=null&&u.validationData.length>0){if(T=!0,u.validationData.length!==2)throw u.validationData.length===3?new En("validationData including sample weights is not supported yet."):new Be(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${u.validationData} is invalid.`);c=u.validationData[0],d=u.validationData[1];const re=!0,ce=await s.standardizeUserData(c,d,null,null,re,v);m=ce[0],y=ce[1],S=m.concat(y)}else if(u.validationSplit!=null&&u.validationSplit>0&&u.validationSplit<1){T=!0;const re=Math.floor(h[0].shape[0]*(1-u.validationSplit)),ce=h[0].shape[0];m=$m(h,re,ce),h=$m(h,0,re),y=$m(l,re,ce),l=$m(l,0,re),S=m.concat(y)}else u.validationSteps!=null&&(T=!0);const D=h.concat(l).concat(b);s.checkTrainableWeightsConsistency();const L=s.makeTrainFunction(),W=s.getDedupedMetricsNames();let K,U;T?(s.makeTestFunction(),K=s.testFunction,U=W.slice().concat(W.map(re=>"val_"+re))):(K=null,S=[],U=W.slice());const _=r5(u.callbacks,u.yieldEvery);return await async function(re,ce,we,Ee,Pe,he,de,Ae,Se,Te,Ze,et,qe,Re){Pe==null&&(Pe=32),he==null&&(he=1),Ze==null&&(Ze=!0),qe==null&&(qe=0);let Ue=!1;Se!=null&&Te!=null&&(Ue=!0);const ot=re.checkNumSamples(we,Pe,Re,"steps_per_epoch");let yt;ot!=null&&(yt=Ki(0,ot)),de==null&&(de=1);const{callbackList:Vt,history:ln}=s5(Ae,de,he,qe,ot,Re,Pe,Ue,et);Vt.setModel(re),re.history=ln,await Vt.onTrainBegin(),re.stopTraining_=!1;for(let en=qe;en<he;++en){await Vt.onEpochBegin(en);const Xt={};{if(Ze==="batch")throw new En("batch shuffling is not implemneted yet");Ze&&Rt(yt);const hn=Ra(yt),wn=I3(ot,Pe);for(let Fn=0;Fn<wn.length;++Fn){const In={};if(await Vt.onBatchBegin(Fn,In),Ve(()=>{const zn=wn[Fn][0],Kn=wn[Fn][1],Ls=Gc(hn,zn,Kn-zn);In.batch=Fn,In.size=Kn-zn;const Na=C3(we,Ls),da=ce(Na);for(let Nr=0;Nr<Ee.length;++Nr){const zo=Ee[Nr],pa=da[Nr];In[zo]=pa,aa(pa)}if(Fn===wn.length-1&&Ue){const Nr=re.testLoop(Se,Te,Pe);for(let zo=0;zo<Ee.length;++zo){const pa=Ee[zo],Oo=Nr[zo];aa(Oo),Xt["val_"+pa]=Oo}}}),await Vt.onBatchEnd(Fn,In),t5(In),re.stopTraining_)break}hn.dispose()}if(await Vt.onEpochEnd(en,Xt),re.stopTraining_)break}return await Vt.onTrainEnd(),await re.history.syncData(),re.history}(s,L,D,W,v,u.epochs,u.verbose,_,K,S,u.shuffle,U,u.initialEpoch,null)}finally{s.isTraining=!1,Xc(h,o),Xc(l,A),Xc(m,c),Xc(y,d),b!=null&&Rn(b)}}(this,e,t,r)}async fitDataset(e,t){return async function(r,s,o){const A=o.batchesPerEpoch!=null;if(J(r.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),J(o!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),J(o.epochs!=null&&o.epochs>0&&Number.isInteger(o.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${o.epochs}`),J(!A||o.batchesPerEpoch>0&&Number.isInteger(o.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${o.batchesPerEpoch}`),J(o.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),r.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");r.isTraining=!0;try{const u=o.validationData!=null;let h,l;if(u)if(b5(o.validationData))J(o.validationBatches==null||o.validationBatches>0&&Number.isInteger(o.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${o.validationBatches}`);else{const T=function(D){if(D.length===3)throw new En("Validation with sample weights is not implemented yet.");return{xs:D[0],ys:D[1]}}(o.validationData);h=T.xs,l=T.ys}const c=r.makeTrainFunction(),d=r.getDedupedMetricsNames();let m;m=u?d.slice().concat(d.map(T=>"val_"+T)):d.slice();const y=r5(o.callbacks,o.yieldEvery),b=o.verbose==null?1:o.verbose,{callbackList:v,history:w}=s5(y,b,o.epochs,null,null,function(T,D){let L=null;return D.batchesPerEpoch!=null?L=D.batchesPerEpoch:Number.isFinite(T.size)&&(L=T.size),L}(s,o),null,u,m);v.setModel(r),r.history=w,await v.onTrainBegin(),r.stopTraining_=!1;let I=o.initialEpoch==null?0:o.initialEpoch,S=await s.iterator();for(;I<o.epochs;){const T={};await v.onEpochBegin(I);let D=0,L=0;for(A||(S=await s.iterator());!A||D<o.batchesPerEpoch;){const W=await S.next();if(A&&W.done){console.warn(`You provided \`batchesPerEpoch\` as ${o.batchesPerEpoch}, but your dataset iterator ran out of data after ${D} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+o.batchesPerEpoch*o.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(W.value!=null){const{xs:K,ys:U}=g5(r,W.value),_={};_.batch=L,_.size=K[0].shape[0],await v.onBatchBegin(L,_);const ee=[];if(o.classWeight!=null){const we=f5(o.classWeight,r.outputNames);for(let Ee=0;Ee<we.length;++Ee)ee.push(await m5(U[Ee],null,we[Ee]))}const re=K.concat(U).concat(ee),ce=c(re);Rn(re);for(let we=0;we<d.length;++we){const Ee=d[we],Pe=ce[we];_[Ee]=Pe,aa(Pe)}await v.onBatchEnd(L,_),t5(_),L++,D++}if(A?D>=o.batchesPerEpoch:W.done){if(u){let K;K=b5(o.validationData)?Dr(await r.evaluateDataset(o.validationData,{batches:o.validationBatches})):Dr(r.evaluate(h,l,{batchSize:o.validationBatchSize==null?32:o.validationBatchSize,verbose:0}));for(let U=0;U<r.metricsNames.length;++U)T[`val_${r.metricsNames[U]}`]=K[U]}break}if(r.stopTraining_)break}if(await v.onEpochEnd(I,T),I++,r.stopTraining_)break}return await v.onTrainEnd(),await r.history.syncData(),r.history}finally{r.isTraining=!1}}(this,e,t)}async trainOnBatch(e,t){const r=await this.standardizeUserData(e,t),s=r[0],o=r[1],A=this.makeTrainFunction()(s.concat(o)),u=[];for(const h of A){const l=await h.data();u.push(l[0])}return Rn(A),no(u)}getNamedWeights(e){const t=[],r=e!=null&&e.trainableOnly,s=r?this.trainableWeights:this.weights,o=this.getWeights(r);for(let A=0;A<s.length;++A)r&&!s[A].trainable||t.push({name:s[A].originalName,tensor:o[A]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=BI().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-BI().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=ml(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>ml(t))}else{const t=Object.keys(this.loss);e={};const r=this.loss;for(const s of t){if(typeof r[s]!="string")throw new Error("Serialization of non-string loss is not supported.");e[s]=ml(r[s])}}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[ml(Dx(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>ml(Dx(e)));{const e={};for(const t in this.metrics)e[t]=ml(Dx(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=yl(v3(e.optimizer_config));let r,s;if(typeof e.loss=="string")r=Wc(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(o=>Wc(o));else if(e.loss!=null){r={};for(const o in e.loss)r[o]=Wc(e.loss[o])}if(Array.isArray(e.metrics))s=e.metrics.map(o=>Wc(o));else if(e.metrics!=null){s={};for(const o in e.metrics)s[o]=Wc(e.metrics[o])}this.compile({loss:r,metrics:s,optimizer:t})}async save(e,t){if(typeof e=="string"){const o=X7(e);if(o.length===0)throw new Be(`Cannot find any save handlers for URL '${e}'`);if(o.length>1)throw new Be(`Found more than one (${o.length}) save handlers for URL '${e}'`);e=o[0]}if(e.save==null)throw new Be("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await j7(this.getNamedWeights(t)),s={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${d5}`,convertedBy:null};if(t!=null&&t.includeOptimizer&&this.optimizer!=null){s.trainingConfig=this.getTrainingConfig();const o="optimizer",{data:A,specs:u}=await j7(await this.optimizer.getWeights(),o);r.specs.push(...u),r.data=G7([r.data,A])}return this.userDefinedMetadata!=null&&(u5(this.userDefinedMetadata,this.name,!0),s.userDefinedMetadata=this.userDefinedMetadata),s.weightData=r.data,s.weightSpecs=r.specs,e.save(s)}setUserDefinedMetadata(e){u5(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Pp.className="Model",gt(Pp);class C5 extends Pp{}C5.className="Functional",gt(C5);class _m extends Pp{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:vx("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(t=>t<0))throw new Be(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof _m||e instanceof Pp;let r;if(t){if(r=e,r.outputs.length!==1)throw new Be("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(r.inputs.length!==1)throw new Be("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new Be("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const s=function(o){if(o.batchShape==null&&o.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(o.batchShape!=null&&o.shape!=null)throw new Be("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let A=o.batchShape;o.shape!=null&&A==null&&(A=[null].concat(o.shape));let u=o.dtype;return u==null&&(u="float32"),new Qm({batchInputShape:A,name:o.name,dtype:u,sparse:o.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(s)}if(t)this.outputs=r.outputs,this.inputs=r.inputs;else{if(e.inboundNodes.length!==1)throw new Be(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new Be("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=e5(this.outputs[0])}this.inboundNodes=[],new kx({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Rc(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(s=>s.shape),outputShapes:this.outputs[0].shape})}else{const s=e.apply(this.outputs[0]);if(Array.isArray(s))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[s],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(pr(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Pp({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,r=console.log){this.built||this.build(),super.summary(e,t,r)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,r={}){if(!this.built)throw new wi("The model needs to be compiled before being used.");return this.model.evaluate(e,t,r)}async evaluateDataset(e,t){if(!this.built)throw new wi("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,r={}){if(!this.built)throw new wi("The model needs to be compiled before being used.");return this.model.fit(e,t,r)}async fitDataset(e,t){if(!this.built)throw new wi("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,r={},s=!1){let o,A={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new Be("Legacy serialization format not supported yet.");o=t}else J(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),o=t.layers,delete t.layers,A=t;const u=new e(A);if(!(u instanceof _m))throw new En(`Sequential.fromConfig called on non-Sequential input: ${u}`);for(const h of o){const l=yl(h,void 0,s);s&&l.setFastWeightInitDuringBuild(!0),u.add(l)}return u}set stopTraining(e){if(this.model==null)throw new Be("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new Be("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const r={};r.className=t.getClassName(),r.config=t.getConfig(),e.push(r)}return{name:this.name,layers:e}}}_m.className="Sequential",gt(_m);class ro extends kp{getConfig(){return{}}}class I5 extends ro{apply(e,t=1){return function(r,s=1){if(s!==1)throw new En(`Support for alpha values other than 1 (${s}) is not implemented yet.`);return Mm(r)}(e,t)}}I5.className="elu",gt(I5);class S5 extends ro{apply(e){return QI(e)}}S5.className="selu",gt(S5);class N5 extends ro{apply(e){return IA(e)}}N5.className="relu",gt(N5);class T5 extends ro{apply(e){return Ve(()=>Om(6,IA(e)))}}T5.className="relu6",gt(T5);class M5 extends ro{apply(e){return e}}M5.className="linear",gt(M5);class E5 extends ro{apply(e){return Oc(e)}}E5.className="sigmoid",gt(E5);class D5 extends ro{apply(e){return function(t){return Ve(()=>{const r=vt(.5,Me(.2,t));return ko(r,0,1)})}(e)}}D5.className="hardSigmoid",gt(D5);class z5 extends ro{apply(e){return Mp(e)}}z5.className="softplus",gt(z5);class O5 extends ro{apply(e){return function(t){return Ve(()=>an(t,vt(Ts(t),1)))}(e)}}O5.className="softsign",gt(O5);class P5 extends ro{apply(e){return Jv(e)}}P5.className="tanh",gt(P5);class N3 extends ro{apply(e,t=-1){return qv(e,t)}}N3.className="softmax",gt(N3);class B5 extends ro{apply(e,t=-1){return VI(e,t)}}B5.className="logSoftmax",gt(B5);class F5 extends ro{apply(e,t=1){return Ve(()=>Me(Oc(Me(e,t)),e))}}F5.className="swish",gt(F5);class L5 extends ro{apply(e){return Ve(()=>Me(e,Jv(Mp(e))))}}function yu(n){return n.getClassName()}function T3(n,e={}){return Gm(n,yi.getMap().classNameMap,e,"activation")}function bu(n){if(n==null)return T3({className:"linear",config:{}});if(typeof n=="string"){const e={};return e.className=n,e.config={},T3(e)}return n instanceof ro?n:T3(n)}L5.className="mish",gt(L5);class R5 extends kp{}class W5 extends R5{constructor(e){super(),function(t){if(t!=null&&typeof t!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`)}(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return Ve(()=>{let t=Es([1]);return this.hasL1&&(t=vt(t,Qt(Me(this.l1,Ts(e))))),this.hasL2&&(t=vt(t,Qt(Me(this.l2,Ym(e))))),Fe(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}W5.className="L1L2",gt(W5);const j5={l1l2:"L1L2"};function wr(n){return $S(n)}function H5(n,e={}){return Gm(n,yi.getMap().classNameMap,e,"regularizer")}function Hr(n){return n==null?null:typeof n=="string"?H5({className:n in j5?j5[n]:n,config:{}}):n instanceof R5?n:H5(n)}class G5 extends Un{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Mn(e);let r=IA(e);return this.maxValue!=null&&(r=ko(r,0,this.maxValue)),r}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}G5.className="ReLU",gt(G5);class V5 extends Un{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const r=Mn(e);return Xv(r,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}V5.className="LeakyReLU",gt(V5);class X5 extends Un{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=jr(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Hr(e.alphaRegularizer),this.alphaConstraint=Os(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if(typeof e.sharedAxes!="number")throw new Be(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=pr(e)).slice(1);if(this.sharedAxes!=null)for(const s of this.sharedAxes)t[s-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const r={};if(this.sharedAxes!=null)for(let s=1;s<e.length;++s)r[s]=e[s];this.inputSpec=[new Ps({ndim:e.length,axes:r})],this.built=!0}call(e,t){return e=Mn(e),Qv(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Ur(this.alphaInitializer),alphaRegularizer:wr(this.alphaRegularizer),alphaConstraint:zs(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}X5.className="PReLU",gt(X5);class Z5 extends Un{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new En(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const r=Mn(e);return Mm(r)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}Z5.className="ELU",gt(Z5);class Y5 extends Un{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const r=Mn(e);return Me(r,zt(qo(r,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}Y5.className="ThresholdedReLU",gt(Y5);class U5 extends Un{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new N3().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){const r=Mn(e);return this.softmax(r,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function Bp(n,e,t){if(typeof n=="number")return Rc(n,e);if(n.length!==e)throw new Be(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let s=0;s<e;++s){const o=n[s];if((r=o)!==parseInt(r.toString(),10))throw new Be(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${o}`)}return n;var r}function $i(n,e,t,r,s=1){if(n==null)return n;let o;return o=t==="same"?n:n-(e+(e-1)*(s-1))+1,Math.floor((o+r-1)/r)}function EA(n,e,t,r){if(n==null)return null;if(r==="valid")n=n*e+mu([t-e,0]);else{if(r!=="same")throw new Be(`Unsupport padding mode: ${r}.`);n*=e}return n}function M3(n,e){return Ve(()=>(ds(e),e==="channelsFirst"?Yn(n,[0,2,3,1]):n))}function Q5(n,e){return Ve(()=>(ds(e),e==="channelsFirst"?Yn(n,[0,2,3,4,1]):n))}function K5(n,e,t,r=[1,1],s="valid",o,A,u=null){return Ve(()=>{if(o==null&&(o="channelsLast"),ds(o),n.rank!==3&&n.rank!==4)throw new Be(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new Be(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let h=M3(n,o);if(s==="causal")throw new En("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return h=I4({x:h,filter:e,strides:r,pad:s==="same"?"same":"valid",dilations:A,dataFormat:"NHWC",bias:t,activation:u}),o==="channelsFirst"&&(h=Yn(h,[0,3,1,2])),h})}U5.className="Softmax",gt(U5);class Ox extends Un{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Ox.verifyArgs(t),this.rank=e,Zs(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new En(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Bp(t.kernelSize,e,"kernelSize"),this.strides=Bp(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,_o(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,ds(this.dataFormat),this.activation=bu(t.activation),this.useBias=t.useBias==null||t.useBias,this.biasInitializer=jr(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Os(t.biasConstraint),this.biasRegularizer=Hr(t.biasRegularizer),this.activityRegularizer=Hr(t.activityRegularizer),this.dilationRate=Bp(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new Be(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new Be(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new Be(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(TA("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!e3(e.kernelSize,"number",1,3))throw new Be(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:yu(this.activation),useBias:this.useBias,biasInitializer:Ur(this.biasInitializer),biasRegularizer:wr(this.biasRegularizer),activityRegularizer:wr(this.activityRegularizer),biasConstraint:zs(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class Fp extends Ox{constructor(e,t){super(e,t),this.kernel=null,Fp.verifyArgs(t),this.filters=t.filters,Zs(this.filters,"filters"),this.kernelInitializer=jr(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Os(t.kernelConstraint),this.kernelRegularizer=Hr(t.kernelRegularizer)}build(e){e=pr(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new Be(`The channel dimension of the input should be defined. Found ${e[t]}`);const r=e[t],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:r}}],this.built=!0}call(e,t){return Ve(()=>{let r;e=Mn(e);const s=this.bias==null?null:this.bias.read(),o=MF(this.activation.getClassName());if(o!=null&&this.rank===2)r=K5(e,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,o);else{if(this.rank===1)r=function(A,u,h,l=1,c="valid",d,m=1){return Ve(()=>{if(d==null&&(d="channelsLast"),ds(d),A.shape.length!==3)throw new Be(`The input of a conv1dWithBias operation should be 3, but is ${A.shape.length} instead.`);if(u.shape.length!==3)throw new Be(`The kernel for a conv1dWithBias operation should be 3, but is ${u.shape.length} instead`);if(h!=null&&h.shape.length!==1)throw new Be(`The bias for a conv1dWithBias operation should be 1, but is ${u.shape.length} instead`);if(d==="channelsFirst"&&(A=Yn(A,[0,2,1])),c==="causal")throw new En("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let y=WI(A,u,l,c==="same"?"same":"valid","NWC",m);return h!=null&&(y=qi(y,h)),y})}(e,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=K5(e,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(this.rank!==3)throw new En("convolutions greater than 3D are not implemented yet.");r=function(A,u,h,l=[1,1,1],c="valid",d,m){return Ve(()=>{if(d==null&&(d="channelsLast"),ds(d),A.rank!==4&&A.rank!==5)throw new Be(`conv3dWithBias expects input to be of rank 4 or 5, but received ${A.rank}.`);if(u.rank!==4&&u.rank!==5)throw new Be(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${A.rank}.`);let y=Q5(A,d);if(c==="causal")throw new En("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return y=m4(y,u,l,c==="same"?"same":"valid","NDHWC",m),h!=null&&(y=qi(y,h)),d==="channelsFirst"&&(y=Yn(y,[0,4,1,2,3])),y})}(e,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate)}this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(e){e=pr(e);const t=[],r=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let o=0;o<r.length;++o){const A=$i(r[o],this.kernelSize[o],this.padding,this.strides[o],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[o]);t.push(A)}let s=[e[0]];return this.dataFormat==="channelsLast"?(s=s.concat(t),s.push(this.filters)):(s.push(this.filters),s=s.concat(t)),s}getConfig(){const e={filters:this.filters,kernelInitializer:Ur(this.kernelInitializer),kernelRegularizer:wr(this.kernelRegularizer),kernelConstraint:zs(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new Be(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class eg extends Fp{constructor(e){super(2,e),eg.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!e3(e.kernelSize,"number",1,2))throw new Be(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}eg.className="Conv2D",gt(eg);class tg extends Fp{constructor(e){super(3,e),tg.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&(!Array.isArray(e.kernelSize)||e.kernelSize.length!==1&&e.kernelSize.length!==3))throw new Be(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}tg.className="Conv3D",gt(tg);class q5 extends eg{constructor(e){if(super(e),this.inputSpec=[new Ps({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new Be(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if((e=pr(e)).length!==4)throw new Be("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new Be("The channel dimension of the inputs should be defined. Found `None`.");const r=e[t],s=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ps({ndim:4,axes:{[t]:r}})],this.built=!0}call(e,t){return Ve(()=>{let r=Mn(e);if(r.shape.length!==4)throw new Be(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const s=r.shape,o=s[0];let A,u;this.dataFormat==="channelsFirst"?(A=2,u=3):(A=1,u=2);const h=s[A],l=s[u],c=this.kernelSize[0],d=this.kernelSize[1],m=this.strides[0],y=this.strides[1],b=[o,EA(h,m,c,this.padding),EA(l,y,d,this.padding),this.filters];this.dataFormat!=="channelsLast"&&(r=Yn(r,[0,2,3,1]));let v=HI(r,this.kernel.read(),b,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(v=Yn(v,[0,3,1,2])),this.bias!=null&&(v=qi(v,this.bias.read(),this.dataFormat)),this.activation!=null&&(v=this.activation.apply(v)),v})}computeOutputShape(e){const t=(e=pr(e)).slice();let r,s,o;this.dataFormat==="channelsFirst"?(r=1,s=2,o=3):(r=3,s=1,o=2);const A=this.kernelSize[0],u=this.kernelSize[1],h=this.strides[0],l=this.strides[1];return t[r]=this.filters,t[s]=EA(t[s],h,A,this.padding),t[o]=EA(t[o],l,u,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}q5.className="Conv2DTranspose",gt(q5);class J5 extends tg{constructor(e){if(super(e),this.inputSpec=[new Ps({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new Be(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if((e=pr(e)).length!==5)throw new Be("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new Be("The channel dimension of the inputs should be defined. Found `None`.");const r=e[t],s=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ps({ndim:5,axes:{[t]:r}})],this.built=!0}call(e,t){return Ve(()=>{let r=Mn(e);if(r.shape.length!==5)throw new Be(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const s=r.shape,o=s[0];let A,u,h;this.dataFormat==="channelsFirst"?(h=2,A=3,u=4):(h=1,A=2,u=3);const l=s[h],c=s[A],d=s[u],m=this.kernelSize[0],y=this.kernelSize[1],b=this.kernelSize[2],v=this.strides[0],w=this.strides[1],I=this.strides[2],S=[o,EA(l,v,m,this.padding),EA(c,w,y,this.padding),EA(d,I,b,this.padding),this.filters];this.dataFormat!=="channelsLast"&&(r=Yn(r,[0,2,3,4,1]));let T=fee(r,this.kernel.read(),S,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(T=Yn(T,[0,4,1,2,3])),this.bias!==null&&(T=qi(T,this.bias.read(),this.dataFormat)),this.activation!==null&&(T=this.activation.apply(T)),T})}computeOutputShape(e){const t=(e=pr(e)).slice();let r,s,o,A;this.dataFormat==="channelsFirst"?(r=1,s=2,o=3,A=4):(r=4,s=1,o=2,A=3);const u=this.kernelSize[0],h=this.kernelSize[1],l=this.kernelSize[2],c=this.strides[0],d=this.strides[1],m=this.strides[2];return t[r]=this.filters,t[s]=EA(t[s],c,u,this.padding),t[o]=EA(t[o],d,h,this.padding),t[A]=EA(t[A],m,l,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}J5.className="Conv3DTranspose",gt(J5);class $5 extends Fp{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new Be("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new Be("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new Be(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=jr(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Hr(t.depthwiseRegularizer),this.depthwiseConstraint=Os(t.depthwiseConstraint),this.pointwiseInitializer=jr(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Hr(t.pointwiseRegularizer),this.pointwiseConstraint=Os(t.pointwiseConstraint)}build(e){if((e=pr(e)).length<this.rank+2)throw new Be(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new Be(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const r=e[t],s=this.kernelSize.concat([r,this.depthMultiplier]),o=[];for(let u=0;u<this.rank;++u)o.push(1);o.push(r*this.depthMultiplier,this.filters);const A=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,A,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",o,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,A,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,A,this.biasConstraint):this.bias=null,this.inputSpec=[new Ps({ndim:this.rank+2,axes:{[t]:r}})],this.built=!0}call(e,t){return Ve(()=>{let r;if(e=Mn(e),this.rank===1)throw new En("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Yn(e,[0,2,3,1])),r=w4(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(r=qi(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),this.dataFormat==="channelsFirst"&&(r=Yn(r,[0,3,1,2])),r})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Ur(this.depthwiseInitializer),e.pointwiseInitializer=Ur(this.pointwiseInitializer),e.depthwiseRegularizer=wr(this.depthwiseRegularizer),e.pointwiseRegularizer=wr(this.pointwiseRegularizer),e.depthwiseConstraint=zs(this.depthwiseConstraint),e.pointwiseConstraint=zs(this.pointwiseConstraint),e}}$5.className="SeparableConv";class _5 extends $5{constructor(e){super(2,e)}}_5.className="SeparableConv2D",gt(_5);class Px extends Fp{constructor(e){super(1,e),Px.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!e3(e.kernelSize,"number",1,1))throw new Be(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}Px.className="Conv1D",gt(Px);class e9 extends Un{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return Ve(()=>{if(e=Mn(e),this.dataFormat==="channelsLast"){const r=gx(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return gx(r,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const r=gx(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return gx(r,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}e9.className="Cropping2D",gt(e9);class t9 extends Un{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ds(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,t=this.interpolation,jc(Rne,"InterpolationFormat",t)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],r=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,r]}{const t=e[1]==null?null:this.size[0]*e[1],r=e[2]==null?null:this.size[1]*e[2];return[e[0],t,r,e[3]]}}call(e,t){return Ve(()=>{let r=Mn(e);const s=r.shape;if(this.dataFormat==="channelsFirst"){r=Yn(r,[0,2,3,1]);const o=this.size[0]*s[2],A=this.size[1]*s[3],u=this.interpolation==="nearest"?Qi.resizeNearestNeighbor(r,[o,A]):Qi.resizeBilinear(r,[o,A]);return Yn(u,[0,3,1,2])}{const o=this.size[0]*s[1],A=this.size[1]*s[2];return this.interpolation==="nearest"?Qi.resizeNearestNeighbor(r,[o,A]):Qi.resizeBilinear(r,[o,A])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}t9.className="UpSampling2D",gt(t9);class n9 extends Ox{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=jr(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Os(e.depthwiseConstraint),this.depthwiseRegularizer=Hr(e.depthwiseRegularizer)}build(e){if((e=pr(e)).length<4)throw new Be(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new Be(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const r=e[t],s=[this.kernelSize[0],this.kernelSize[1],r,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",s,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[r*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Ve(()=>{let r=function(s,o,A=[1,1],u="valid",h,l){return Ve(()=>{h==null&&(h="channelsLast"),ds(h);let c=M3(s,h);if(s.rank!==4)throw new Be(`Input for depthwiseConv2d is required to be 4-D, but is instead ${s.rank}-D`);if(o.rank!==4)throw new Be(`depthwiseKernel is required to be 4-D, but is instead ${o.rank}-D`);return c=Tm(c,o,A,u==="same"?"same":"valid","NHWC",l),h==="channelsFirst"&&(c=Yn(c,[0,3,1,2])),c})}(e=Mn(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(r=qi(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),r})}computeOutputShape(e){e=pr(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2],s=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,o=$i(t,this.kernelSize[0],this.padding,this.strides[0]),A=$i(r,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],s,o,A]:[e[0],o,A,s]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Ur(this.depthwiseInitializer),e.depthwiseRegularizer=wr(this.depthwiseRegularizer),e.depthwiseConstraint=zs(this.depthwiseRegularizer),e}}function r9(n,e,t,r){if(Array.isArray(n)){if(e!=null||t!=null)throw new Be("When inputs is an array, neither initialState or constants should be provided");r!=null&&(t=n.slice(n.length-r,n.length),n=n.slice(0,n.length-r)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function s(o){return o==null||Array.isArray(o)?o:[o]}return{inputs:n,initialState:e=s(e),constants:t=s(t)}}function s9(n,e,t,r=!1,s,o,A=!1,u=!1){return Ve(()=>{const h=e.shape.length;if(h<3)throw new Be(`Input should be at least 3D, but is ${h}D.`);const l=[1,0].concat(Ki(2,h));e=Yn(e,l),o!=null,A&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),s!=null&&((s=zt(zt(s,"bool"),"float32")).rank===h-1&&(s=Ko(s,-1)),s=Yn(s,l)),r&&(e=hl(e,0),s!=null&&(s=hl(s,0)));const c=[];let d,m=t;const y=e.shape[0],b=Ui(e);let v,w;s!=null&&(v=Ui(s));for(let I=0;I<y;++I){const S=b[I],T=Ve(()=>n(S,m));if(s==null)d=T[0],m=T[1];else{const D=Ve(()=>{const L=v[I],W=Ut($o(L),L);return{output:vt(Me(T[0],L),Me(m[0],W)),newStates:m.map((K,U)=>vt(Me(T[1][U],L),Me(K,W)))}});d=D.output,m=D.newStates}u&&c.push(d)}return u&&(w=xi(c,1)),[d,w,m]})}n9.className="DepthwiseConv2D",gt(n9);class vu extends Un{constructor(e){let t;if(super(e),e.cell==null)throw new Be("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new z3({cells:e.cell}):e.cell,t.stateSize==null)throw new Be("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences!=null&&e.returnSequences,this.returnState=e.returnState!=null&&e.returnState,this.goBackwards=e.goBackwards!=null&&e.goBackwards,this._stateful=e.stateful!=null&&e.stateful,this.unroll=e.unroll!=null&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new Ps({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return this.states_==null?Ki(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(e=>null):this.states_}setStates(e){this.states_=e}computeOutputShape(e){p3(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const r=t[0];let s;if(s=this.returnSequences?[e[0],e[1],r]:[e[0],r],this.returnState){const o=[];for(const A of t)o.push([e[0],A]);return[s].concat(o)}return s}computeMask(e,t){return Ve(()=>{Array.isArray(t)&&(t=t[0]);const r=this.returnSequences?t:null;if(this.returnState){const s=this.states.map(o=>null);return[r].concat(s)}return r})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let r=0;r<e;++r)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new En("Constants support is not implemented in RNN yet.");p3(e)&&(e=e[0]);const t=this.stateful?e[0]:null,r=e.slice(2);this.inputSpec[0]=new Ps({shape:[t,null,...r]});const s=[e[0]].concat(e.slice(2));let o;if(this.cell.build(s),o=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],this.stateSpec!=null){if(!ht(this.stateSpec.map(A=>A.shape[A.shape.length-1]),o))throw new Be(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=o.map(A=>new Ps({shape:[null,A]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){Ve(()=>{if(!this.stateful)throw new NA("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape[0];if(r==null)throw new Be("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>Es([r,s])):this.states_=[Es([r,this.cell.stateSize])];else if(e==null)Rn(this.states_),this.keptStates!=null&&(Rn(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>Es([r,s])):this.states_[0]=Es([r,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Be(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):Rn(this.states_);for(let s=0;s<this.states_.length;++s){const o=e[s],A=Array.isArray(this.cell.stateSize)?this.cell.stateSize[s]:this.cell.stateSize,u=[r,A];if(!ht(o.shape,u))throw new Be(`State ${s} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${o.shape}`);this.states_[s]=o}}this.states_=this.states_.map(s=>aa(s.clone()))})}apply(e,t){let r=t==null?null:t.initialState,s=t==null?null:t.constants;t==null&&(t={});const o=r9(e,r,s,this.numConstants);e=o.inputs,r=o.initialState,s=o.constants;let A=[],u=[];if(r!=null){t.initialState=r,A=A.concat(r),this.stateSpec=[];for(const h of r)this.stateSpec.push(new Ps({shape:h.shape}));u=u.concat(this.stateSpec)}if(s!=null&&(t.constants=s,A=A.concat(s),this.numConstants=s.length),A[0]instanceof MA){const h=[e].concat(A),l=this.inputSpec.concat(u),c=this.inputSpec;this.inputSpec=l;const d=super.apply(h,t);return this.inputSpec=c,d}return super.apply(e,t)}call(e,t){return Ve(()=>{const r=t==null?null:t.mask,s=t==null?null:t.training;let o=t==null?null:t.initialState;e=Mn(e),o==null&&(o=this.stateful?this.states_:this.getInitialState(e));const A=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(o.length!==A)throw new Be(`RNN Layer has ${A} state(s) but was passed ${o.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const u={training:s},h=s9((y,b)=>{const v=this.cell.call([y].concat(b),u);return[v[0],v.slice(1)]},e,o,this.goBackwards,r,null,this.unroll,this.returnSequences),l=h[0],c=h[1],d=h[2];this.stateful&&this.resetStates(d,s);const m=this.returnSequences?c:l;return this.returnState?[m].concat(d):m})}getInitialState(e){return Ve(()=>{let t=Es(e.shape);return t=Qt(t,[1,2]),t=Zm(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?s3(t,[1,r]):t):this.cell.stateSize>1?[s3(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const r=this.cell.getConfig();return this.getClassName()===vu.className&&(t.cell={className:this.cell.getClassName(),config:r}),Object.assign({},r,e,t)}static fromConfig(e,t,r={}){const s=yl(t.cell,r);return new e(Object.assign(t,{cell:s}))}}vu.className="RNN",gt(vu);class Bx extends Un{}class E3 extends Bx{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Zs(this.units,"units"),this.activation=bu(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null||e.useBias,this.kernelInitializer=jr(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=jr(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=jr(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Hr(e.kernelRegularizer),this.recurrentRegularizer=Hr(e.recurrentRegularizer),this.biasRegularizer=Hr(e.biasRegularizer),this.kernelConstraint=Os(e.kernelConstraint),this.recurrentConstraint=Os(e.recurrentConstraint),this.biasConstraint=Os(e.biasConstraint),this.dropout=Op([1,mu([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Op([1,mu([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=pr(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Ve(()=>{if(e.length!==2)throw new Be(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let r=e[1];e=e[0];const s=t.training!=null&&t.training;let o;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=xu({ones:()=>$o(e),rate:this.dropout,training:s})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=xu({ones:()=>$o(r),rate:this.recurrentDropout,training:s}));const A=this.dropoutMask,u=this.recurrentDropoutMask;o=gl(A!=null?Me(e,A):e,this.kernel.read()),this.bias!=null&&(o=qi(o,this.bias.read())),u!=null&&(r=Me(r,u));let h=vt(o,gl(r,this.recurrentKernel.read()));return this.activation!=null&&(h=this.activation.apply(h)),[h,h]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:yu(this.activation),useBias:this.useBias,kernelInitializer:Ur(this.kernelInitializer),recurrentInitializer:Ur(this.recurrentInitializer),biasInitializer:Ur(this.biasInitializer),kernelRegularizer:wr(this.kernelRegularizer),recurrentRegularizer:wr(this.recurrentRegularizer),biasRegularizer:wr(this.biasRegularizer),activityRegularizer:wr(this.activityRegularizer),kernelConstraint:zs(this.kernelConstraint),recurrentConstraint:zs(this.recurrentConstraint),biasConstraint:zs(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},e,t)}}E3.className="SimpleRNNCell",gt(E3);class a9 extends vu{constructor(e){e.cell=new E3(e),super(e)}call(e,t){return Ve(()=>{this.cell.dropoutMask!=null&&(Rn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Rn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=t==null?null:t.mask,s=t==null?null:t.training,o=t==null?null:t.initialState;return super.call(e,{mask:r,training:s,initialState:o})})}static fromConfig(e,t){return new e(t)}}a9.className="SimpleRNN",gt(a9);class D3 extends Bx{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new Be("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Zs(this.units,"units"),this.activation=bu(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=bu(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null||e.useBias,this.kernelInitializer=jr(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=jr(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=jr(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Hr(e.kernelRegularizer),this.recurrentRegularizer=Hr(e.recurrentRegularizer),this.biasRegularizer=Hr(e.biasRegularizer),this.kernelConstraint=Os(e.kernelConstraint),this.recurrentConstraint=Os(e.recurrentConstraint),this.biasConstraint=Os(e.biasConstraint),this.dropout=Op([1,mu([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Op([1,mu([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=pr(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Ve(()=>{if(e.length!==2)throw new Be(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const r=t.training!=null&&t.training;let s=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=xu({ones:()=>$o(e),rate:this.dropout,training:r,count:3})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=xu({ones:()=>$o(s),rate:this.recurrentDropout,training:r,count:3}));const o=this.dropoutMask,A=this.recurrentDropoutMask;let u,h,l;0<this.dropout&&this.dropout<1&&(e=Me(e,o[0]));let c=gl(e,this.kernel.read());this.useBias&&(c=qi(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=Me(s,A[0]));const d=this.recurrentKernel.read(),[m,y]=_a(d,[2*this.units,this.units],d.rank-1),b=gl(s,m),[v,w,I]=_a(c,3,c.rank-1),[S,T]=_a(b,2,b.rank-1);u=this.recurrentActivation.apply(vt(v,S)),h=this.recurrentActivation.apply(vt(w,T));const D=gl(Me(h,s),y);l=this.activation.apply(vt(I,D));const L=vt(Me(u,s),Me(vt(1,Yr(u)),l));return[L,L]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:yu(this.activation),recurrentActivation:yu(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ur(this.kernelInitializer),recurrentInitializer:Ur(this.recurrentInitializer),biasInitializer:Ur(this.biasInitializer),kernelRegularizer:wr(this.kernelRegularizer),recurrentRegularizer:wr(this.recurrentRegularizer),biasRegularizer:wr(this.biasRegularizer),activityRegularizer:wr(this.activityRegularizer),kernelConstraint:zs(this.kernelConstraint),recurrentConstraint:zs(this.recurrentConstraint),biasConstraint:zs(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},e,t)}}D3.className="GRUCell",gt(D3);class o9 extends vu{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new D3(e),super(e)}call(e,t){return Ve(()=>{this.cell.dropoutMask!=null&&(Rn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Rn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=t==null?null:t.mask,s=t==null?null:t.training,o=t==null?null:t.initialState;return super.call(e,{mask:r,training:s,initialState:o})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}o9.className="GRU",gt(o9);class Fx extends Bx{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Zs(this.units,"units"),this.activation=bu(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=bu(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null||e.useBias,this.kernelInitializer=jr(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=jr(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=jr(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Hr(e.kernelRegularizer),this.recurrentRegularizer=Hr(e.recurrentRegularizer),this.biasRegularizer=Hr(e.biasRegularizer),this.kernelConstraint=Os(e.kernelConstraint),this.recurrentConstraint=Os(e.recurrentConstraint),this.biasConstraint=Os(e.biasConstraint),this.dropout=Op([1,mu([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Op([1,mu([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const r=(e=pr(e))[e.length-1];let s;if(this.kernel=this.addWeight("kernel",[r,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const o=this.biasInitializer,A=this.units;s=new((t=class extends Ci{apply(u,h){const l=o.apply([A]),c=new o3().apply([A]),d=o.apply([2*A]);return jF(jF(l,c),d)}}).className="CustomInit",t)}else s=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,s,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return Ve(()=>{const r=t.training!=null&&t.training;if(e.length!==3)throw new Be(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let s=e[1];const o=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=xu({ones:()=>$o(e),rate:this.dropout,training:r,count:4})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=xu({ones:()=>$o(s),rate:this.recurrentDropout,training:r,count:4}));const A=this.dropoutMask,u=this.recurrentDropoutMask;let h,l,c,d;0<this.dropout&&this.dropout<1&&(e=Me(e,A[0]));let m=gl(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=Me(s,u[0])),m=vt(m,gl(s,this.recurrentKernel.read())),this.useBias&&(m=qi(m,this.bias.read()));const[y,b,v,w]=_a(m,4,m.rank-1);h=this.recurrentActivation.apply(y),l=this.recurrentActivation.apply(b),c=vt(Me(l,o),Me(h,this.activation.apply(v))),d=this.recurrentActivation.apply(w);const I=Me(d,this.activation.apply(c));return[I,I,c]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:yu(this.activation),recurrentActivation:yu(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Ur(this.kernelInitializer),recurrentInitializer:Ur(this.recurrentInitializer),biasInitializer:Ur(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:wr(this.kernelRegularizer),recurrentRegularizer:wr(this.recurrentRegularizer),biasRegularizer:wr(this.biasRegularizer),activityRegularizer:wr(this.activityRegularizer),kernelConstraint:zs(this.kernelConstraint),recurrentConstraint:zs(this.recurrentConstraint),biasConstraint:zs(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},e,t)}}Fx.className="LSTMCell",gt(Fx);class i9 extends vu{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Fx(e),super(e)}call(e,t){return Ve(()=>{this.cell.dropoutMask!=null&&(Rn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Rn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=t==null?null:t.mask,s=t==null?null:t.training,o=t==null?null:t.initialState;return super.call(e,{mask:r,training:s,initialState:o})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}i9.className="LSTM",gt(i9);class z3 extends Bx{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return Ve(()=>{let r=e.slice(1);const s=[];for(const u of this.cells.slice().reverse())Array.isArray(u.stateSize)?s.push(r.splice(0,u.stateSize.length)):s.push(r.splice(0,1));s.reverse();const o=[];let A;for(let u=0;u<this.cells.length;++u){const h=this.cells[u];r=s[u],A=u===0?[e[0]].concat(r):[A[0]].concat(r),A=h.call(A,t),o.push(A.slice(1))}r=[];for(const u of o.slice().reverse())r.push(...u);return[A[0]].concat(r)})}build(e){let t;p3(e)&&(e=e[0]),this.cells.forEach((r,s)=>{Hc(`RNNCell_${s}`,()=>{r.build(e),t=Array.isArray(r.stateSize)?r.stateSize[0]:r.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map(r=>({className:r.getClassName(),config:r.getConfig()}))};return Object.assign({},e,t)}static fromConfig(e,t,r={}){const s=[];for(const o of t.cells)s.push(yl(o,r));return new e({cells:s})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const r of this.cells)t.push(...r.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return h3(e)}setWeights(e){const t=[];for(const r of this.cells){const s=r.weights.length,o=e.splice(s);for(let A=0;A<r.weights.length;++A)t.push([r.weights[A],o[A]])}f3(t)}}function xu(n){const{ones:e,rate:t,training:r=!1,count:s=1}=n,o=()=>GF(e(),t),A=()=>Um(o,e,r);return!s||s<=1?aa(A().clone()):Array(s).fill(void 0).map(A).map(u=>aa(u.clone()))}z3.className="StackedRNNCells",gt(z3);var _i,An,A9;class l9 extends vu{constructor(e){if(e.unroll)throw new En("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new En("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Ps({ndim:5})]}call(e,t){return Ve(()=>{if(this.cell.dropoutMask!=null&&(Rn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Rn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new Be("ConvRNN2D cell does not support constants");const r=t==null?null:t.mask,s=t==null?null:t.training,o=t==null?null:t.initialState;return super.call(e,{mask:r,training:s,initialState:o})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return Ve(()=>{const{stateSize:t}=this.cell,r=e.shape,s=this.computeSingleOutputShape(r),o=Es([s[0],...s.slice(2)]);return Array.isArray(t)?Array(t.length).fill(o):[o]})}resetStates(e,t=!1){Ve(()=>{if(!this.stateful)throw new NA("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape,s=this.computeSingleOutputShape(r),o=[s[0],...s.slice(2)];if(r[0]==null)throw new Be("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Es(o)):this.states_=[Es(o)];else if(e==null)Rn(this.states_),this.keptStates!=null&&(Rn(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Es(o)):this.states_[0]=Es(o);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Be(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Rn(this.states_);for(let A=0;A<this.states_.length;++A){const u=e[A],h=o;if(!ht(u.shape,h))throw new Be(`State ${A} is incompatible with layer ${this.name}: expected shape=${h}, received shape=${u.shape}`);this.states_[A]=u}}this.states_=this.states_.map(A=>aa(A.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:r,kernelSize:s,padding:o,strides:A,dilationRate:u}=this.cell,h=t==="channelsFirst",l=e[h?3:2],c=e[h?4:3],d=$i(l,s[0],o,A[0],u[0]),m=$i(c,s[1],o,A[1],u[1]);return[...e.slice(0,2),...h?[r,d,m]:[d,m,r]]}}l9.className="ConvRNN2D";class O3 extends Fx{constructor(e){const{filters:t,kernelSize:r,strides:s,padding:o,dataFormat:A,dilationRate:u}=e;super(Object.assign({},e,{units:t})),this.filters=t,Zs(this.filters,"filters"),this.kernelSize=Bp(r,2,"kernelSize"),this.kernelSize.forEach(h=>Zs(h,"kernelSize")),this.strides=Bp(s||1,2,"strides"),this.strides.forEach(h=>Zs(h,"strides")),this.padding=o||"valid",_o(this.padding),this.dataFormat=A||"channelsLast",ds(this.dataFormat),this.dilationRate=Bp(u||1,2,"dilationRate"),this.dilationRate.forEach(h=>Zs(h,"dilationRate"))}build(e){var t;e=pr(e);const r=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[r]==null)throw new Be(`The channel dimension of the input should be defined. Found ${e[r]}`);const s=e[r],o=this.kernelSize.concat([s,4*this.filters]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const A=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",A,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){const h=this.biasInitializer,l=this.filters;u=new((t=class extends Ci{apply(c,d){return r3([h.apply([l]),pl([l]),h.apply([2*l])])}}).className="CustomInit",t)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return Ve(()=>{if(e.length!==3)throw new Be(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const r=t.training||!1,s=e[0],o=e[1],A=e[2];0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=xu({ones:()=>$o(s),rate:this.dropout,training:r,count:4}));const u=this.dropoutMask,h=(Ae,Se,Te)=>Se&&Se[Te]?Me(Se[Te],Ae):Ae;let l=h(s,u,0),c=h(s,u,1),d=h(s,u,2),m=h(s,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=xu({ones:()=>$o(o),rate:this.recurrentDropout,training:r,count:4}));const y=this.recurrentDropoutMask;let b=h(o,y,0),v=h(o,y,1),w=h(o,y,2),I=h(o,y,3);const[S,T,D,L]=_a(this.kernel.read(),4,3),[W,K,U,_]=this.useBias?_a(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,S,W,this.padding),c=this.inputConv(c,T,K,this.padding),d=this.inputConv(d,D,U,this.padding),m=this.inputConv(m,L,_,this.padding);const[ee,re,ce,we]=_a(this.recurrentKernel.read(),4,3);b=this.recurrentConv(b,ee),v=this.recurrentConv(v,re),w=this.recurrentConv(w,ce),I=this.recurrentConv(I,we);const Ee=this.recurrentActivation.apply(vt(l,b)),Pe=this.recurrentActivation.apply(vt(c,v)),he=vt(Me(Pe,A),Me(Ee,this.activation.apply(vt(d,w)))),de=Me(this.recurrentActivation.apply(vt(m,I)),this.activation.apply(he));return[de,de,he]})}getConfig(){const e=super.getConfig(),t=function(s,o){var A={};for(var u in s)Object.prototype.hasOwnProperty.call(s,u)&&o.indexOf(u)<0&&(A[u]=s[u]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function"){var h=0;for(u=Object.getOwnPropertySymbols(s);h<u.length;h++)o.indexOf(u[h])<0&&Object.prototype.propertyIsEnumerable.call(s,u[h])&&(A[u[h]]=s[u[h]])}return A}(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},t,r)}inputConv(e,t,r,s){const o=uu(e,t,this.strides,s||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return r?qi(o,r,this.dataFormat):o}recurrentConv(e,t){return uu(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}O3.className="ConvLSTM2DCell",gt(O3);class u9 extends l9{constructor(e){const t=new O3(e);super(Object.assign({},e,{cell:t}))}static fromConfig(e,t){return new e(t)}}u9.className="ConvLSTM2D",gt(u9);class P3 extends Un{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,r=[];for(let s=0;s<this.noiseShape.length;++s)r.push(this.noiseShape[s]==null?t[s]:this.noiseShape[s]);return r}call(e,t){return Ve(()=>{this.invokeCallHook(e,t);const r=Mn(e);if(0<this.rate&&this.rate<1){const s=t.training!=null&&t.training,o=this.getNoiseShape(r);return Um(()=>GF(r,this.rate,o,this.seed),()=>r,s)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}P3.className="Dropout",gt(P3);class c9 extends P3{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}c9.className="SpatialDropout1D",gt(c9);class d9 extends Un{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Zs(this.units,"units"),this.activation=bu(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=jr(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=jr(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Os(e.kernelConstraint),this.biasConstraint=Os(e.biasConstraint),this.kernelRegularizer=Hr(e.kernelRegularizer),this.biasRegularizer=Hr(e.biasRegularizer),this.activityRegularizer=Hr(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=pr(e))[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=pr(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return Ve(()=>{this.invokeCallHook(e,t);const r=Mn(e),s=MF(this.activation.getClassName());let o;return s!=null?o=gl(r,this.kernel.read(),s,this.bias?this.bias.read():null):(o=gl(r,this.kernel.read()),this.bias!=null&&(o=qi(o,this.bias.read())),this.activation!=null&&(o=this.activation.apply(o))),o})}getConfig(){const e={units:this.units,activation:yu(this.activation),useBias:this.useBias,kernelInitializer:Ur(this.kernelInitializer),biasInitializer:Ur(this.biasInitializer),kernelRegularizer:wr(this.kernelRegularizer),biasRegularizer:wr(this.biasRegularizer),activityRegularizer:wr(this.activityRegularizer),kernelConstraint:zs(this.kernelConstraint),biasConstraint:zs(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}d9.className="Dense",gt(d9);class p9 extends Un{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=pr(e);for(const t of e.slice(1))if(t==null)throw new Be(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],fu(e,1)]}call(e,t){return Ve(()=>{this.invokeCallHook(e,t);let r=Mn(e);if(this.dataFormat==="channelsFirst"&&r.rank>1){const s=[0];for(let o=2;o<r.rank;++o)s.push(o);s.push(1),r=Yn(r,s)}return function(s){if(s.rank<=1)throw new Be(`batchFlatten requires a minimum rank of 2. Got rank: ${s.rank}.`);const o=[s.shape[0],fu(s.shape,1)];return Fe(s,o)}(r)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}p9.className="Flatten",gt(p9);class h9 extends Un{constructor(e){super(e),this.supportsMasking=!0,this.activation=bu(e.activation)}call(e,t){return Ve(()=>{this.invokeCallHook(e,t);const r=Mn(e);return this.activation.apply(r)})}getConfig(){const e={activation:yu(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}h9.className="Activation",gt(h9);class f9 extends Un{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return Ve(()=>{return e=Mn(e),r=e,s=this.n,Ve(()=>{if(r.shape.length!==2)throw new Be(`repeat() expects a rank-2 tensor, but received a rank-${r.shape.length} tensor.`);return s3(Zm(r,1),[1,s,1])});var r,s})}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}f9.className="RepeatVector",gt(f9);class m9 extends Un{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const r="Total size of new array must be unchanged.",s=t.slice();let o=1,A=null;for(let h=0;h<s.length;++h){const l=s[h];if(this.isUnknown(l)){if(A!==null)throw new Be("Can only specifiy one unknown dimension.");A=h}else o*=l}const u=fu(e);if(A!==null){if(o===0||u%o!=0)throw new Be(r);s[A]=u/o}else if(u!==o)throw new Be(r);return s}computeOutputShape(e){let t=!1;for(let r=0;r<e.length;++r)if(this.isUnknown(e[r])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return Ve(()=>{this.invokeCallHook(e,t);const r=Mn(e),s=r.shape,o=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return Fe(r,o)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}m9.className="Reshape",gt(m9);class g9 extends Un{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=Ki(1,e.dims.length+1);if(!ht(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Ps({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=pr(e)).slice();return this.dims.forEach((r,s)=>{t[s+1]=e[r]}),t}call(e,t){return Yn(Mn(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}g9.className="Permute",gt(g9);class y9 extends Un{constructor(e){super(e??{}),this.supportsMasking=!0,this.maskValue=e!=null?e.maskValue==null?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const r=Mn(e);return Hv(Tp(r,this.maskValue),-1)}call(e,t){return Ve(()=>{this.invokeCallHook(e,t);const r=Mn(e),s=Hv(Tp(r,this.maskValue),-1,!0);return Me(r,zt(s,r.dtype))})}}y9.className="Masking",gt(y9);class b9 extends Un{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Dr(e.inputLength))}this.inputDim=e.inputDim,Zs(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Zs(this.outputDim,"outputDim"),this.embeddingsInitializer=jr(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Hr(e.embeddingsRegularizer),this.activityRegularizer=Hr(e.activityRegularizer),this.embeddingsConstraint=Os(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return Ve(()=>this.maskZero?(e=Mn(e),Tp(e,Vn(e))):null)}computeOutputShape(e){if(e=pr(e),this.inputLength==null)return[...e,this.outputDim];const t=Dr(this.inputLength);if(t.length!==e.length-1)throw new Be(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let r=0;for(let s=0;s<t.length;++s){const o=t[s],A=e[s+1];if(o!=null&&A!=null&&o!==A)throw new Be(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);o==null&&(t[r]=A),r++}}return[e[0],...t,this.outputDim]}call(e,t){return Ve(()=>{this.invokeCallHook(e,t);let r=Mn(e);r.dtype!=="int32"&&(r=mx(r,"int32"));const s=HF(this.embeddings.read(),Fe(r,[r.size]));return Fe(s,pr(this.computeOutputShape(r.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Ur(this.embeddingsInitializer),embeddingsRegularizer:wr(this.embeddingsRegularizer),activityRegularizer:wr(this.activityRegularizer),embeddingsConstraint:zs(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}b9.className="Embedding",gt(b9);class Zc extends Un{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new En}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const r=e.slice(0,e.length-t.length);for(let s=0;s<t.length;++s){const o=e[e.length-t.length+s],A=t[s];if(o==null||A==null||o<0||A<0)r.push(null);else if(o===1)r.push(A);else if(A===1)r.push(o);else{if(o!==A)throw new Be("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));r.push(o)}}return r}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[pr(e)]),e.length<2)throw new Be(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const o of e)o!=null&&o[0]!==null&&t.push(o[0]);if(t=hu(t),t.length>1)throw new Be(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let r=e[0]==null?null:e[0].slice(1);for(let o=1;o<e.length;++o){const A=e[o]==null?null:e[o].slice(1);r=this.computeElementwiseOpOutputShape(r,A)}const s=e.map(o=>o.length);e.indexOf(null)===-1&&hu(s).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return Ve(()=>{if(this.reshapeRequired){const r=[],s=e.map(o=>o.rank);if(s.indexOf(null)===-1){const o=mu(s);for(let A of e){const u=A.rank;for(let h=0;h<o-u;++h)A=Zm(A,1);r.push(A)}return this.mergeFunction(r)}{let o=!1;for(const h of e){const l=h.rank;if(l==null){const c=h.shape,d=c[0],m=c.slice(1).concat([d]);let y=Fe(h,[d].concat(fu(c.slice(1))));y=Yn(y,[1,0]),y=Fe(y,m),r.push(y),o=!0}else if(l>1){const c=Ki(1,l).concat([0]);r.push(Yn(h,c)),o=!0}else r.push(h)}let A=this.mergeFunction(r);const u=A.rank;if(o){if(u==null){const h=A.shape,l=h[h.length-1],c=[l].concat(h.slice(0,h.length-1));A=Fe(Yn(Fe(A,[-1,l]),[1,0]),c)}else if(u>1){const h=[u-1].concat(Ki(0,u-1));A=Yn(A,h)}}return A}}return this.mergeFunction(e)})}computeOutputShape(e){let t;t=e[0]==null?null:e[0].slice(1);for(let s=1;s<e.length;++s){const o=e[s]==null?null:e[s].slice(1);t=this.computeElementwiseOpOutputShape(t,o)}let r=[];for(const s of e)s!=null&&s[0]!==null&&r.push(s[0]);return r=hu(r),t=r.length===1?r.concat(t):[null].concat(t),t}computeMask(e,t){return Ve(()=>{if(t==null)return null;if(!Array.isArray(t))throw new Be("`mask` should be an Array");if(!Array.isArray(e))throw new Be("`inputs` should be an Array");if(t.length!==e.length)throw new Be(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(s=>s==null))return null;let r=(t=t.map(s=>s==null?s:Ko(s,0)))[0];for(let s=1;s<t.length-1;++s)r=CA(r,t[s]);return r})}}class v9 extends Zc{constructor(e){super(e)}mergeFunction(e){return Ve(()=>{let t=e[0].clone();for(let r=1;r<e.length;++r)t=vt(t,e[r]);return t})}}v9.className="Add",gt(v9);class x9 extends Zc{constructor(e){super(e)}mergeFunction(e){return Ve(()=>{let t=e[0].clone();for(let r=1;r<e.length;++r)t=Me(t,e[r]);return t})}}x9.className="Multiply",gt(x9);class w9 extends Zc{constructor(e){super(e)}mergeFunction(e){return Ve(()=>{let t=e[0].clone();for(let r=1;r<e.length;++r)t=vt(t,e[r]);return Me(1/e.length,t)})}}w9.className="Average",gt(w9);class k9 extends Zc{constructor(e){super(e)}mergeFunction(e){return Ve(()=>{let t=e[0];for(let r=1;r<e.length;++r)t=dl(t,e[r]);return t})}}k9.className="Maximum",gt(k9);class C9 extends Zc{constructor(e){super(e)}mergeFunction(e){return Ve(()=>{let t=e[0];for(let r=1;r<e.length;++r)t=Om(t,e[r]);return t})}}C9.className="Minimum",gt(C9);class I9 extends Zc{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||e.length===1)throw new Be("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const s of e)if(s!=null){t=!1;break}if(t)return;const r=[];for(let s=0;s<e.length;++s){const o=e[s].slice();o.splice(this.axis,1);let A=!1;for(const u of r)if(ht(u,o)){A=!0;break}A||r.push(o)}if(r.length>1)throw new Be("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Ve(()=>r3(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new Be("A `Concatenate` layer should be called on a list of inputs.");const t=e,r=t[0].slice(),s=this.axis<0?r.length+this.axis:this.axis;for(const o of t.slice(1)){if(r[s]==null||o[s]==null){r[s]=null;break}r[s]+=o[s]}return r}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new Be("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new Be("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new Be(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return Ve(()=>{let r=!0;if(t.forEach(A=>{A==null||(r=!1)}),r)return null;const s=[];for(let A=0;A<e.length;++A)t[A]==null?s.push(zt($o(e[A]),"bool")):t[A].rank<e[A].rank?s.push(Ko(t[A],-1)):s.push(t[A]);const o=ys(s,this.axis);return FI(o,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function ng(n,e){for(;n<0;)n+=e;return n}I9.className="Concatenate",gt(I9);class S9 extends Zc{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize!=null&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){J(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],r=e[1];if(t.length>3||r.length>3)throw new En("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(t,r);if(t[s[0]]!==r[s[1]])throw new Be(`Dimension incompatibility: ${t[s[0]]} !== ${r[s[1]]}`)}mergeFunction(e){if(e.length!==2)throw new Be(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,r=e[0],s=e[1];return t=Array.isArray(this.axes)?this.axes.map((o,A)=>ng(o,e[A].shape.length)):[ng(this.axes,r.shape.length),ng(this.axes,s.shape.length)],this.normalize&&(r=Ix(r,t[0]),s=Ix(s,t[1])),function(o,A,u){if(o.shape.length>3||A.shape.length>3)throw new En("batchDot is not implemented for tensors of 4D or higher rank yet");if(J(o.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${o.shape.length}`),J(o.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${A.shape.length}`),typeof u=="number"&&(u=[u,u]),o.dtype==="complex64"||A.dtype==="complex64")throw new En("batchDot is not implemented for complex64-type Tensors yet.");const h=o.shape.length,l=A.shape.length;u==null&&(u=[h-1,l-2]);const c=u;return Ve(()=>{let d,m;if(h>l){d=h-l;const y=[];for(let b=0;b<d;++b)y.push(1);A=Fe(A,A.shape.concat(y))}else if(l>h){d=l-h;const y=[];for(let b=0;b<d;++b)y.push(1);o=Fe(o,o.shape.concat(y))}else d=0;if(o.shape.length===2&&A.shape.length===2)m=c[0]===c[1]?Qt(Me(o,A),c[0]):Qt(Me(Yn(o,[1,0]),A),c[1]);else{const y=c[0]!==o.shape.length-1,b=c[1]===A.shape.length-1;m=nr(o,A,y,b)}if(d>0){let y;y=h>l?h+l-3:h-1;const b=[];for(let v=y;v<y+d;++v)b.push(v);m=cu(m,b)}return m.shape.length===1&&(m=Ko(m,1)),m})}(r,s,t)}interpretAxes(e,t){let r;return r=Array.isArray(this.axes)?this.axes:[ng(this.axes,e.length),ng(this.axes,t.length)],r}computeOutputShape(e){J(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),r=e[1].slice();if(t.length>3||r.length>3)throw new En("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(t,r);t.splice(s[0],1),r.splice(s[1],1),r.splice(0,1);const o=t.concat(r);return o.length===1&&o.push(1),o}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}S9.className="Dot",gt(S9);class N9 extends Un{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return Ve(()=>{this.invokeCallHook(e,t);const r=Mn(e);return Um(()=>vt(yx(r.shape,0,this.stddev),r),()=>r,t.training||!1)})}}N9.className="GaussianNoise",gt(N9);class T9 extends Un{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Ve(()=>{this.invokeCallHook(e,t);const r=Mn(e);return this.rate>0&&this.rate<1?Um(()=>{const s=Math.sqrt(this.rate/(1-this.rate));return Me(r,yx(r.shape,1,s))},()=>r,t.training||!1):r})}}T9.className="GaussianDropout",gt(T9);class M9 extends Un{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Mn(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Ve(()=>{if(this.rate<1&&this.rate>0){const r=this._getNoiseShape(e);return Um(()=>{const s=Mn(e),o=-1.7580993408473766;let A=zc(Pm(r),this.rate);A=mx(A,"float32");const u=((1-this.rate)*(1+this.rate*o**2))**-.5,h=-u*o*this.rate,l=vt(Me(s,A),Me(vt(A,-1),o));return vt(Me(l,u),h)},()=>Mn(e),t.training||!1)}return e})}}function rg(n,e,t,r,s,o=.001){let A;if(n.rank===2)A=Aee(n,e,t,r,s,o);else if(n.rank===3)A=lee(n,e,t,r,s,o);else{if(n.rank!==4)throw new En(`batchNormalization is not implemented for array of rank ${n.rank} yet`);A=uee(n,e,t,r,s,o)}return A}M9.className="AlphaDropout",gt(M9);class E9 extends Un{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null||e.center,this.scale=e.scale==null||e.scale,this.betaInitializer=jr(e.betaInitializer||"zeros"),this.gammaInitializer=jr(e.gammaInitializer||"ones"),this.movingMeanInitializer=jr(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=jr(e.movingVarianceInitializer||"ones"),this.betaConstraint=Os(e.betaConstraint),this.gammaConstraint=Os(e.gammaConstraint),this.betaRegularizer=Hr(e.betaRegularizer),this.gammaRegularizer=Hr(e.gammaRegularizer)}build(e){e=pr(e);const t=this.axis>=0?this.axis:this.axis+e.length,r=e[t];if(r==null)throw new Be(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Ps({ndim:e.length,axes:{[t]:r}})];const s=[r];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return Ve(()=>{const r=t.training!=null&&t.training,s=Mn(e),o=s.shape,A=o.length,u=Ki(0,A),h=this.axis>=0?this.axis:this.axis+A;u.splice(h,1);const l=Rc(1,A);l[h]=o[h];const c=u.slice();c.sort();const d=!ht(c,Ki(0,A).slice(0,A-1));if(!r)return(()=>{if(d){const w=Fe(this.movingMean.read(),l),I=Fe(this.movingVariance.read(),l),S=this.center?Fe(this.beta.read(),l):null,T=this.scale?Fe(this.gamma.read(),l):null;return rg(s,w,I,S,T,this.epsilon)}return rg(s,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)})();const[m,y,b]=function(w,I,S,T,D=.001){return ht(T.slice().sort(),Ki(0,w.rank-1))?function(L,W,K,U,_=.001){return Ve(()=>{const ee=ZI(L,U),re=ee.mean,ce=ee.variance;return[rg(L,re,ce,K,W,_),re,ce]})}(w,I,S,T,D):function(L,W,K,U,_=.001){return Ve(()=>{const ee=ZI(L,U),re=ee.mean,ce=ee.variance,we=[];for(const Ae of Ki(0,L.rank))U.indexOf(Ae)!==-1?we.push(1):we.push(L.shape[Ae]);const Ee=Fe(re,we),Pe=Fe(ce,we),he=W==null?null:Fe(W,we),de=K==null?null:Fe(K,we);return[rg(L,Ee,Pe,de,he,_),re,ce]})}(w,I,S,T,D)}(s,this.gamma.read(),this.beta.read(),u,this.epsilon),v=(w,I,S)=>{Ve(()=>{const T=1-S,D=w.read(),L=Me(Ut(D,I),T);w.write(Ut(D,L))})};return v(this.movingMean,y,this.momentum),v(this.movingVariance,b,this.momentum),m})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ur(this.betaInitializer),gammaInitializer:Ur(this.gammaInitializer),movingMeanInitializer:Ur(this.movingMeanInitializer),movingVarianceInitializer:Ur(this.movingVarianceInitializer),betaRegularizer:wr(this.betaRegularizer),gammaRegularizer:wr(this.gammaRegularizer),betaConstraint:zs(this.betaConstraint),gammaConstraint:zs(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}E9.className="BatchNormalization",gt(E9);class D9 extends Un{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null||e.center,this.scale=e.scale==null||e.scale,this.betaInitializer=jr(e.betaInitializer||"zeros"),this.gammaInitializer=jr(e.gammaInitializer||"ones"),this.betaRegularizer=Hr(e.betaRegularizer),this.gammaRegularizer=Hr(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=pr(e)).length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let o=0;o<this.axis.length;++o)this.axis[o]<0&&(this.axis[o]+=t);for(const o of this.axis)if(o<0||o>=t)throw new Error(`Invalid axis: ${o}`);if(this.axis.length!==hu(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const r=this.axis.map(o=>e[o]),s=!0;this.scale?this.gamma=this.addWeight("gamma",r,"float32",this.gammaInitializer,this.gammaRegularizer,s):this.gamma=null,this.center?this.beta=this.addWeight("beta",r,"float32",this.betaInitializer,this.betaRegularizer,s):this.beta=null,this.built=!0}call(e,t){const r=Mn(e),s=r.shape,o=s.length;return Ve(()=>{let{mean:A,variance:u}=ZI(r,this.axis,!0);const h=Rc(1,o);for(const b of this.axis)h[b]=s[b];const l=b=>b!=null&&b.shape.length!==o&&this.axis!==[o-1]?Fe(b,h):b;let c=l(this.gamma.read()),d=l(this.beta.read());const m=[],y=[];for(let b=0;b<o;++b)this.axis.indexOf(b)!==-1?(m.push(s[b]),y.push(1)):(m.push(1),y.push(s[b]));return A=vi(A,m),u=vi(u,m),c=vi(c,y),d=vi(d,y),rg(r,A,u,d,c,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Ur(this.betaInitializer),gammaInitializer:Ur(this.gammaInitializer),betaRegularizer:wr(this.betaRegularizer),gammaRegularizer:wr(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}D9.className="LayerNormalization",gt(D9);class z9 extends Un{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new Be(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,r;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],r=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new Be(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new Be(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);r=e.padding[1]}this.padding=[t,r]}this.inputSpec=[new Ps({ndim:4})]}computeOutputShape(e){let t,r;return e=pr(e),this.dataFormat==="channelsFirst"?(t=e[2]!=null&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,r=e[3]!=null&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,r]):(t=e[1]!=null&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,r=e[2]!=null&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,r,e[3]])}call(e,t){return Ve(()=>{return r=Mn(e),s=this.padding,o=this.dataFormat,Ve(()=>{if(r.rank!==4)throw new Be(`temporalPadding expects input tensor to be 4-D, but received a ${r.rank}-D tensor.`);if(s==null&&(s=[[1,1],[1,1]]),s.length!==2||s[0].length!==2||s[1].length!==2)throw new Be("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(o==null&&(o="channelsLast"),o!=="channelsLast"&&o!=="channelsFirst")throw new Be(`Unknown data format: ${o}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let A;return A=o==="channelsFirst"?[[0,0],[0,0],s[0],s[1]]:[[0,0],s[0],s[1],[0,0]],Uv(r,A)});var r,s,o})}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function Lx(n,e,t,r,s,o){return Ve(()=>{let A;ds(s),FF(o),_o(r),t==null&&(t=[1,1]),r==null&&(r="valid"),s==null&&(s="channelsLast"),o==null&&(o="max"),n=M3(n,s);const u=r==="same"?"same":"valid";return A=o==="max"?Yv(n,e,t,u):Vv(n,e,t,u),s==="channelsFirst"&&(A=Yn(A,[0,3,1,2])),A})}function O9(n,e,t,r,s,o){return Ve(()=>{let A;ds(s),FF(o),_o(r),t==null&&(t=[1,1,1]),r==null&&(r="valid"),s==null&&(s="channelsLast"),o==null&&(o="max"),n=Q5(n,s);const u=r==="same"?"same":"valid";return A=o==="max"?b4(n,e,t,u):f4(n,e,t,u),s==="channelsFirst"&&(A=Yn(A,[0,4,1,2,3])),A})}z9.className="ZeroPadding2D",gt(z9);class P9 extends Un{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||e.poolSize.length!==1||typeof e.poolSize[0]!="number")throw new Be(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(Zs(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else{if(!Array.isArray(e.strides)||e.strides.length!==1||typeof e.strides[0]!="number")throw new Be(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}Zs(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,_o(this.padding),this.inputSpec=[new Ps({ndim:3})]}computeOutputShape(e){const t=$i((e=pr(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return Ve(()=>{this.invokeCallHook(e,t),e=Zm(Mn(e),2);const r=this.poolingFunction(Mn(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return cu(r,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class B9 extends P9{constructor(e){super(e)}poolingFunction(e,t,r,s,o){return ds(o),_o(s),Lx(e,t,r,s,o,"max")}}B9.className="MaxPooling1D",gt(B9);class F9 extends P9{constructor(e){super(e)}poolingFunction(e,t,r,s,o){return ds(o),_o(s),Lx(e,t,r,s,o,"avg")}}F9.className="AveragePooling1D",gt(F9);class L9 extends Un{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new Be(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Zs(this.poolSize,"poolSize"),Zs(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ds(this.dataFormat),_o(this.padding),this.inputSpec=[new Ps({ndim:4})]}computeOutputShape(e){e=pr(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=$i(t,this.poolSize[0],this.padding,this.strides[0]),r=$i(r,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,r]:[e[0],t,r,e[3]]}call(e,t){return Ve(()=>(this.invokeCallHook(e,t),this.poolingFunction(Mn(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class R9 extends L9{constructor(e){super(e)}poolingFunction(e,t,r,s,o){return ds(o),_o(s),Lx(e,t,r,s,o,"max")}}R9.className="MaxPooling2D",gt(R9);class W9 extends L9{constructor(e){super(e)}poolingFunction(e,t,r,s,o){return ds(o),_o(s),Lx(e,t,r,s,o,"avg")}}W9.className="AveragePooling2D",gt(W9);class j9 extends Un{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new Be(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Zs(this.poolSize,"poolSize"),Zs(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ds(this.dataFormat),_o(this.padding),this.inputSpec=[new Ps({ndim:5})]}computeOutputShape(e){e=pr(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2],s=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=$i(t,this.poolSize[0],this.padding,this.strides[0]),r=$i(r,this.poolSize[1],this.padding,this.strides[1]),s=$i(s,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,r,s]:[e[0],t,r,s,e[4]]}call(e,t){return Ve(()=>(this.invokeCallHook(e,t),this.poolingFunction(Mn(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class H9 extends j9{constructor(e){super(e)}poolingFunction(e,t,r,s,o){return ds(o),_o(s),O9(e,t,r,s,o,"max")}}H9.className="MaxPooling3D",gt(H9);class G9 extends j9{constructor(e){super(e)}poolingFunction(e,t,r,s,o){return ds(o),_o(s),O9(e,t,r,s,o,"avg")}}G9.className="AveragePooling3D",gt(G9);class V9 extends Un{constructor(e){super(e),this.inputSpec=[new Ps({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new En}}class X9 extends V9{constructor(e){super(e||{})}call(e,t){return Ve(()=>{const r=Mn(e);return es(r,1)})}}X9.className="GlobalAveragePooling1D",gt(X9);class Z9 extends V9{constructor(e){super(e||{})}call(e,t){return Ve(()=>{const r=Mn(e);return Yi(r,1)})}}Z9.className="GlobalMaxPooling1D",gt(Z9);class Y9 extends Un{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ds(this.dataFormat),this.inputSpec=[new Ps({ndim:4})]}computeOutputShape(e){return this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new En}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class U9 extends Y9{call(e,t){return Ve(()=>{const r=Mn(e);return this.dataFormat==="channelsLast"?es(r,[1,2]):es(r,[2,3])})}}U9.className="GlobalAveragePooling2D",gt(U9);class Q9 extends Y9{call(e,t){return Ve(()=>{const r=Mn(e);return this.dataFormat==="channelsLast"?Yi(r,[1,2]):Yi(r,[2,3])})}}Q9.className="GlobalMaxPooling2D",gt(Q9);class K9 extends Un{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null&&this.layer.trainable}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,r={}){const s=yl(t.layer,r);delete t.layer;const o={layer:s};return Object.assign(o,t),new e(o)}}class q9 extends K9{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=pr(e)).length<3)throw new Be(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=pr(e))[0]].concat(e.slice(2)),r=this.layer.computeOutputShape(t),s=e[1];return[r[0],s].concat(r.slice(1))}call(e,t){return Ve(()=>s9((r,s)=>[Mn(this.layer.call(r,t)),[]],e=Mn(e),[],!1,null,null,!1,!0)[1])}}q9.className="TimeDistributed",gt(q9);class J9 extends K9{constructor(e){super(e);const t=e.layer.getConfig(),r={};r.className=e.layer.getClassName(),r.config=t,this.forwardLayer=yl(r),t.goBackwards=t.goBackwards!==!0;const s={};var o;if(s.className=e.layer.getClassName(),s.config=t,this.backwardLayer=yl(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?"concat":e.mergeMode,o=this.mergeMode,jc(Hne,"BidirectionalMergeMode",o),e.weights)throw new En("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,r=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,r)),this.backwardLayer.setWeights(e.slice(r))}computeOutputShape(e){let t,r,s,o=this.forwardLayer.computeOutputShape(e);return Array.isArray(o)&&Array.isArray(o[0])||(o=[o]),this.returnState&&(s=o.slice(1)),t=o[0],this.mergeMode==="concat"?(t[t.length-1]*=2,r=[t]):r=this.mergeMode==null?[t,t.slice()]:[t],this.returnState?this.mergeMode==null?r.concat(s).concat(s.slice()):[t].concat(s).concat(s.slice()):no(r)}apply(e,t){let r=t==null?null:t.initialState,s=t==null?null:t.constants;t==null&&(t={});const o=r9(e,r,s,this.numConstants);if(e=o.inputs,r=o.initialState,s=o.constants,Array.isArray(e)&&(r=e.slice(1),e=e[0]),(r==null||r.length===0)&&s==null)return super.apply(e,t);const A=[],u=[];if(r!=null){const l=r.length;if(l%2>0)throw new Be("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=r,A.push(...r);const c=r.map(d=>new Ps({shape:d.shape}));this.forwardLayer.stateSpec=c.slice(0,l/2),this.backwardLayer.stateSpec=c.slice(l/2),u.push(...c)}if(s!=null)throw new En("Support for constants in Bidirectional layers is not implemented yet.");const h=A[0]instanceof MA;for(const l of A)if(l instanceof MA!==h)throw new Be("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(h){const l=[e].concat(A),c=this.inputSpec.concat(u),d=this.inputSpec;this.inputSpec=c;const m=super.apply(l,t);return this.inputSpec=d,m}return super.apply(e,t)}call(e,t){return Ve(()=>{const r=t.initialState;let s,o,A,u;if(r==null)s=this.forwardLayer.call(e,t),o=this.backwardLayer.call(e,t);else{const h=r.slice(0,r.length/2),l=r.slice(r.length/2);s=this.forwardLayer.call(e,Object.assign(t,{initialState:h})),o=this.backwardLayer.call(e,Object.assign(t,{initialState:l}))}return this.returnState&&(Array.isArray(s)&&(A=s.slice(1).concat(o.slice(1))),s=s[0],o=o[0]),this.returnSequences&&(o=hl(o,1)),this.mergeMode==="concat"?u=r3([s,o]):this.mergeMode==="sum"?u=vt(s,o):this.mergeMode==="ave"?u=Me(.5,vt(s,o)):this.mergeMode==="mul"?u=Me(s,o):this.mergeMode==null&&(u=[s,o]),this.returnState?this.mergeMode==null?u.concat(A):[u].concat(A):u})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Hc(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Hc(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){let r;if(Array.isArray(t)&&(t=t[0]),r=this.returnSequences?this.mergeMode==null?[t,t]:t:this.mergeMode==null?[null,null]:null,this.returnState){const s=this.forwardLayer.states.map(o=>null);return Array.isArray(r)?r.concat(s).concat(s):[r].concat(s).concat(s)}return r}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const r=yl(t.layer);if(delete t.layer,t.numConstants!=null)throw new En("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const s=t;return s.layer=r,new e(s)}}J9.className="Bidirectional",gt(J9),(An=_i||(_i={}))[An.DT_INVALID=0]="DT_INVALID",An[An.DT_FLOAT=1]="DT_FLOAT",An[An.DT_DOUBLE=2]="DT_DOUBLE",An[An.DT_INT32=3]="DT_INT32",An[An.DT_UINT8=4]="DT_UINT8",An[An.DT_INT16=5]="DT_INT16",An[An.DT_INT8=6]="DT_INT8",An[An.DT_STRING=7]="DT_STRING",An[An.DT_COMPLEX64=8]="DT_COMPLEX64",An[An.DT_INT64=9]="DT_INT64",An[An.DT_BOOL=10]="DT_BOOL",An[An.DT_QINT8=11]="DT_QINT8",An[An.DT_QUINT8=12]="DT_QUINT8",An[An.DT_QINT32=13]="DT_QINT32",An[An.DT_BFLOAT16=14]="DT_BFLOAT16",An[An.DT_FLOAT_REF=101]="DT_FLOAT_REF",An[An.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",An[An.DT_INT32_REF=103]="DT_INT32_REF",An[An.DT_UINT8_REF=104]="DT_UINT8_REF",An[An.DT_INT16_REF=105]="DT_INT16_REF",An[An.DT_INT8_REF=106]="DT_INT8_REF",An[An.DT_STRING_REF=107]="DT_STRING_REF",An[An.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",An[An.DT_INT64_REF=109]="DT_INT64_REF",An[An.DT_BOOL_REF=110]="DT_BOOL_REF",An[An.DT_QINT8_REF=111]="DT_QINT8_REF",An[An.DT_QUINT8_REF=112]="DT_QUINT8_REF",An[An.DT_QINT32_REF=113]="DT_QINT32_REF",An[An.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))}(A9||(A9={}));const ire={};function $9(n){return ire[n]}function V(n,e,t,r,s){const o=e.inputParams[n];if(o&&o.inputIndexStart!==void 0){const u=o.inputIndexStart,h=o.inputIndexEnd===0?void 0:o.inputIndexEnd===void 0?u+1:o.inputIndexEnd;if(o.type==="tensor")return Wa(e.inputNames[o.inputIndexStart],t,r,s);if(o.type==="tensors")return e.inputNames.slice(u,h).map(d=>Wa(d,t,r,s));const l=Wa(e.inputNames.slice(u)[0],t,r,s),c=l.dataSync();return o.type==="number"?c[0]:vr(l.shape,c)}const A=e.attrParams[n];return A&&A.value}function Wa(n,e,t,r){const[s,o]=Io(n);if(r!=null){const u=r.getHashTableHandleByName(s);if(u!=null)return u}const A=t.currentContextIds.find(u=>!!e[Rx(s,u)]);return A!==void 0?e[Rx(s,A)][o]:void 0}function bl(n,e){const[t,r,s]=Io(n);return[Rx(t,e&&e.currentContextId),r,s]}function Rx(n,e){return e?`${n}-${e}`:n}function Io(n){const e=n.split(":");if(e.length===1)return[n,0,void 0];const t=e[0],r=e.length===3?e[1]:void 0;return[t,Number(e[e.length-1]),r]}function Wx(n,e,t){let r=V("pad",n,e,t);if(r==="explicit"){r=V("explicitPaddings",n,e,t);const s=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)s[o][0]=r[2*o],s[o][1]=r[2*o+1];return s}return r}function wu(n){return n.kept?n:ou(n)}const Are=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],lre=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],ure=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}],cre=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],dre=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],pre=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],hre=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],fre=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],mre=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],gre=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],yre=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],bre=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],vre=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],xre=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],wre=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],kre=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Cre=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Ire=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Sre=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class _9{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[N,E,z,G,j,M,R,B,P,H,C,O,F,Y,ae,te,oe,fe,ue].map(t=>t.json));this.opMappers=e.reduce((t,r)=>(t[r.tfOpName]=r,t),{})}transformGraph(e,t={}){const r=e.node,s=[],o=[],A=[],u=r.reduce((v,w)=>(v[w.name]=this.mapNode(w),w.op.startsWith("Placeholder")?s.push(v[w.name]):w.op==="Const"?o.push(v[w.name]):w.input!=null&&w.input.length!==0||A.push(v[w.name]),v),{});let h=[];const l=[];let c={},d={};t!=null&&(c=this.mapSignatureEntries(t.inputs),d=this.mapSignatureEntries(t.outputs));const m=Object.keys(u);m.forEach(v=>{const w=u[v];w.inputNames.forEach((I,S)=>{const[T,,D]=bl(I),L=u[T];if(L.outputs!=null){const W=L.outputs.indexOf(D);if(W!==-1){const K=`${T}:${W}`;w.inputNames[S]=K}}w.inputs.push(L),L.children.push(w)})}),Object.keys(d).length===0?m.forEach(v=>{const w=u[v];w.children.length===0&&l.push(w)}):Object.keys(d).forEach(v=>{const[w]=bl(v),I=u[w];I!=null&&(I.signatureKey=d[v],l.push(I))}),Object.keys(c).length>0?Object.keys(c).forEach(v=>{const[w]=bl(v),I=u[w];I&&(I.signatureKey=c[v],h.push(I))}):h=s;let y={};e.library!=null&&e.library.function!=null&&(y=e.library.function.reduce((v,w)=>(v[w.signature.name]=this.mapFunction(w),v),{}));const b={nodes:u,inputs:h,outputs:l,weights:o,placeholders:s,signature:t,functions:y};return A.length>0&&(b.initNodes=A),b}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,r)=>(t[e[r].name]=r,t),{})}mapNode(e){const t=$9(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const r={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(s=>s.startsWith("^")?s.substr(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(r.inputParams=t.inputs.reduce((s,o)=>(s[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},s),{})),t.attrs!=null&&(r.attrParams=t.attrs.reduce((s,o)=>{const A=o.type;let u;switch(o.type){case"string":u=B3(e.attr,o.tfName,o.defaultValue),u===void 0&&o.tfDeprecatedName&&(u=B3(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":u=V3(e.attr,o.tfName,o.defaultValue),u===void 0&&o.tfDeprecatedName&&(u=V3(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":u=L3(e.attr,o.tfName,o.defaultValue||0),u===void 0&&o.tfDeprecatedName&&(u=L3(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":u=G3(e.attr,o.tfName,o.defaultValue),u===void 0&&o.tfDeprecatedName&&(u=G3(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":u=F3(e.attr,o.tfName,o.defaultValue),u===void 0&&o.tfDeprecatedName&&(u=F3(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":u=Z3(e.attr,o.tfName,o.defaultValue),u===void 0&&o.tfDeprecatedName&&(u=Z3(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":u=H3(e.attr,o.tfName,o.defaultValue),u===void 0&&o.tfDeprecatedName&&(u=H3(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":u=X3(e.attr,o.tfName,o.defaultValue),u===void 0&&o.tfDeprecatedName&&(u=X3(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":u=W3(e.attr,o.tfName,o.defaultValue),u===void 0&&o.tfDeprecatedName&&(u=W3(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":u=j3(e.attr,o.tfName,o.defaultValue),u===void 0&&o.tfDeprecatedName&&(u=j3(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":u=tL(e.attr,o.tfName,o.defaultValue),u===void 0&&o.tfDeprecatedName&&(u=tL(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${e.op}`)}return s[o.name]={value:u,type:A},s},{})),r}mapFunction(e){const t=e.nodeDef,r=[];let s={};t!=null&&(s=t.reduce((l,c)=>(l[c.name]=this.mapNode(c),c.op==="Const"&&r.push(l[c.name]),l),{}));const o=[],A=[];e.signature.inputArg.forEach(l=>{const[c]=bl(l.name),d={name:c,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:R3(l.type),type:"dtype"}},children:[]};d.signatureKey=l.name,o.push(d),s[c]=d}),Object.keys(s).forEach(l=>{const c=s[l];c.inputNames.forEach((d,m)=>{const[y,,b]=bl(d),v=s[y];if(v.outputs!=null){const w=v.outputs.indexOf(b);if(w!==-1){const I=`${y}:${w}`;c.inputNames[m]=I}}c.inputs.push(v),v.children.push(c)})});const u=e.ret;e.signature.outputArg.forEach(l=>{const[c,d]=bl(u[l.name]),m=s[c];m!=null&&(m.defaultOutput=d,A.push(m))});const h=this.mapArgsToSignature(e);return{nodes:s,inputs:o,outputs:A,weights:r,placeholders:[],signature:h}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r),t),{}),outputs:e.signature.outputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r,e.ret),t),{})}}mapArgToTensorInfo(e,t){let r=e.name;return t!=null&&(r=t[r]),{name:r,dtype:e.type}}}function eL(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):function(r){const s=st().global;if(s.atob!==void 0)return s.atob(r);if(typeof Buffer<"u")return new Buffer(r,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(n);return e?t:t.toLowerCase()}function B3(n,e,t,r=!1){const s=n[e];return s!=null?eL(s.s,r):t}function F3(n,e,t){const r=n[e];return r?r.b:t}function L3(n,e,t){const r=n[e]||{},s=r.i!=null?r.i:r.f!=null?r.f:t;return typeof s=="number"?s:parseInt(s,10)}function R3(n){switch(typeof n=="string"&&(n=_i[n]),n){case _i.DT_FLOAT:return"float32";case _i.DT_INT32:case _i.DT_INT64:case _i.DT_INT8:case _i.DT_UINT8:return"int32";case _i.DT_BOOL:return"bool";case _i.DT_DOUBLE:return"float32";case _i.DT_STRING:return"string";default:return null}}function tL(n,e,t){const r=n[e];return r&&r.func?r.func.name:t}function W3(n,e,t){const r=n[e];return r&&r.type?R3(r.type):t}function j3(n,e,t){const r=n[e];return r&&r.list&&r.list.type?r.list.type.map(s=>R3(s)):t}function nL(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function H3(n,e,t){const r=n[e];return r&&r.shape?nL(r.shape):t}function G3(n,e,t){const r=n[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):t}function V3(n,e,t,r=!1){const s=n[e];return s&&s.list&&s.list.s?s.list.s.map(o=>eL(o,r)):t}function X3(n,e,t){const r=n[e];return r&&r.list&&r.list.shape?r.list.shape.map(s=>nL(s)):t}function Z3(n,e,t){const r=n[e];return r&&r.list&&r.list.b?r.list.b:t}class Nre{constructor(e,t,r){this.node=e,this.tensorMap=t,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(s=>this.getInput(s)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((s,o)=>(s[o]=this.getAttr(o),s),{}))}getInput(e){return Wa(e,this.tensorMap,this.context)}getAttr(e,t){const r=this.node.rawAttrs[e];if(r.tensor!=null)return Wa(e,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return L3(this.node.rawAttrs,e,t);if(r.s!=null)return B3(this.node.rawAttrs,e,t);if(r.b!=null)return F3(this.node.rawAttrs,e,t);if(r.shape!=null)return H3(this.node.rawAttrs,e,t);if(r.type!=null)return W3(this.node.rawAttrs,e,t);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return G3(this.node.rawAttrs,e,t);if(r.list.s!=null)return V3(this.node.rawAttrs,e,t);if(r.list.shape!=null)return X3(this.node.rawAttrs,e,t);if(r.list.b!=null)return Z3(this.node.rawAttrs,e,t);if(r.list.type!=null)return j3(this.node.rawAttrs,e,t)}return t}}const Tre=De({addN_:function(n){J(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),J(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((s,o)=>le(s,`tensors${o}`,"addN")),t=e[0];e.forEach(s=>{if(s.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(s=>{if(!ht(s.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=e;return Ne.runKernel(Le,r)}});function Si(n,e,t=""){if(typeof n!="number"&&typeof e!="number"){J(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let r=0;r<n.length;r++){const s=n[r],o=e[r];J(s<0||o<0||s===o,()=>t+` Shapes ${n} and ${e} must match`)}}}function rL(n){return typeof n!="number"&&!n.some(e=>e<0)}function sg(n,e,t){let r=Y3(n,t);const s=!rL(r);if(s&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&e.forEach(o=>{r=Y3(o.shape,r)}),!rL(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function Y3(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let r=0;r<n.length;++r){const s=n[r],o=e[r];if(s>=0&&o>=0&&s!==o)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[r]=s>=0?s:o}return t}class Mre{constructor(e,t,r,s,o,A,u){this.name=e,this.dtype=t,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=o,this.dynamicSize=A,this.clearAfterRead=u,this.tensors=[],this.closed_=!1,this.idTensor=un(0),aa(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{e!=null&&e.has(t.tensor.id)||t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()!==0||this.elementShape!=null&&this.elementShape.length!==0||(this.elementShape=t.shape),Si(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);r.tensor=t,aa(t),r.written=!0,this.tensors[e]=r}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((r,s)=>this.write(r,t[s]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let s=0;s<this.size();s++)e.push(s)}if(e.length===0)return ru([],[0].concat(this.elementShape));const r=this.readMany(e);return Si(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),xi(r,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return ru([],[0].concat(this.elementShape));const t=[];for(let s=0;s<this.size();s++)t.push(s);const r=this.readMany(t);return Si(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),ys(r,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const r=Math.max(...e);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(e,Ui(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let r=0;const s=e.map(h=>(r+=h,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const o=r===0?0:t.size/r,A=[];Ve(()=>{t=Fe(t,[1,r,o]);for(let h=0;h<e.length;++h){const l=[0,h===0?0:s[h-1],0],c=[1,e[h],o];A[h]=Fe(or(t,l,c),this.elementShape)}return A});const u=[];for(let h=0;h<e.length;h++)u[h]=h;this.writeMany(u,A)}}class Lp{constructor(e,t,r,s=-1){this.tensors=e,this.elementShape=t,this.elementDtype=r,e!=null&&e.forEach(o=>{if(r!==o.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${o.dtype}`);Si(t,o.shape,"TensorList shape mismatch: "),aa(o)}),this.idTensor=un(0),this.maxNumElements=s,aa(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Lp([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{e!=null&&e.has(t.id)||t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,r=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);Si(e,this.elementShape,"TensorList shape mismatch: ");const s=sg(this.elementShape,this.tensors,e);return Ve(()=>{const o=this.tensors.map(A=>Fe(A,s));return xi(o,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const r=sg(this.elementShape,this.tensors,e),s=this.tensors.pop();return Si(s.shape,e,"TensorList shape mismatch: "),Fe(s,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Si(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");aa(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Si(this.tensors[e].shape,t,"TensorList shape mismatch: ");const s=sg(this.elementShape,this.tensors,t);return Fe(this.tensors[e],s)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Si(this.elementShape,t.shape,"TensorList shape mismatch: "),aa(t),this.tensors[e]=t}gather(e,t,r){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Si(this.elementShape,r,"TensorList shape mismatch: "),e=e.slice(0,this.size());const s=sg(this.elementShape,this.tensors,r);return e.length===0?ru([],[0].concat(s)):Ve(()=>{const o=e.map(A=>Fe(this.tensors[A],s));return xi(o,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Si(this.elementShape,t,"TensorList shape mismatch: ");const r=sg(this.elementShape,this.tensors,t);return this.size()===0?ru([],[0].concat(r)):Ve(()=>{const s=this.tensors.map(o=>Fe(o,r));return ys(s,0)})}}const Ere=De({maxPoolWithArgmax_:function(n,e,t,r,s=!1){const o={x:le(n,"x","maxPoolWithArgmax")},A={filterSize:e,strides:t,pad:r,includeBatchInIndex:s},u=Ne.runKernel(VC,o,A);return{result:u[0],indexes:u[1]}}});function sL(n,e,t){const[r,s]=V("fusedOps",n,e,t),o=r==="biasadd",A=!o,u=s==="prelu",h=r==="fusedbatchnorm",l=V("numArgs",n,e,t);if(o){if(u&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!u&&o&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(h)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=V("strides",n,e,t),d=Wx(n,e,t),m=V("dataFormat",n,e,t).toUpperCase(),y=V("dilations",n,e,t);let[b,v]=V("args",n,e,t);return A&&(v=b,b=void 0),{stride:c,pad:d,dataFormat:m,dilations:y,biasArg:b,preluArg:v,activationFunc:s,leakyreluAlpha:V("leakyreluAlpha",n,e,t)}}function Dre(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const r={start:n,stop:e,num:t};return Ne.runKernel(WC,{},r)}const zre=De({multinomial_:function(n,e,t,r=!1){const s=le(n,"logits","multinomial"),o=s.size,A=s.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(A>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${A}`);t=t||Math.random();const u={logits:A===1?Fe(s,[1,-1]):s},h={numSamples:e,seed:t,normalized:r},l=Ne.runKernel(XC,u,h);return A===1?Fe(l,[l.size]):l}}),Ore=async function(n){const e=le(n,"condition","whereAsync","bool"),t=await e.data(),r=jS(e.shape,t);return n!==e&&e.dispose(),r};function U3(n,e,t){return{boxes:V("boxes",n,e,t),scores:V("scores",n,e,t),maxOutputSize:V("maxOutputSize",n,e,t),iouThreshold:V("iouThreshold",n,e,t),scoreThreshold:V("scoreThreshold",n,e,t),softNmsSigma:V("softNmsSigma",n,e,t)}}class Pre{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=un(0),this.tensorMap=new Map,aa(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return un(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const r=await e.data();return this.tensorMap.forEach(s=>s.dispose()),this.tensorMap.clear(),Ve(()=>{const s=Ui(t),o=r.length,A=s.length;J(o===A,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${A} elements.`);for(let u=0;u<o;u++){const h=r[u],l=s[u];aa(l),this.tensorMap.set(h,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const r=await e.data();return Ve(()=>{const s=[];for(let o=0;o<r.length;o++){const A=r[o],u=this.findWithDefault(A,t);s.push(u)}return xi(s)})}findWithDefault(e,t){const r=this.tensorMap.get(e);return r??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}const Bre=De({einsum_:function(n,...e){const t=e.map((s,o)=>le(s,`tensors${o}`,"einsum")),r={equation:n};return Ne.runKernel(_l,t,r)}}),aL=De({sparseToDense_:function(n,e,t,r=0){const s=le(n,"sparseIndices","sparseToDense","int32"),o=le(e,"sparseValues","sparseToDense"),A=le(r,"defaultValue","sparseToDense",o.dtype);(function(l,c,d,m){if(l.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${l.dtype}.`);if(l.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${l.shape}.`);const y=l.rank>0?l.shape[0]:1,b=l.rank>1?l.shape[1]:1;if(d.length!==b)throw new Error(`outputShape has incorrect number of elements:, ${d.length}, should be: ${b}.`);const v=c.size;if(c.rank!==0&&(c.rank!==1||v!==y))throw new Error(`sparseValues has incorrect shape ${c.shape}, should be [] or [${y}]`);if(c.dtype!==m.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")})(s,o,t,A);const u={sparseIndices:s,sparseValues:o,defaultValue:A},h={outputShape:t};return Ne.runKernel(sI,u,h)}}),Fre=De({denseBincount_:function(n,e,t,r=!1){const s=le(n,"x","denseBincount"),o=le(e,"weights","denseBincount");J(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),J(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),J(t>=0,()=>`size must be non-negative, but got ${t}.`),J(o.size===s.size||o.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${o.shape}.`);const A={x:s,weights:o},u={size:t,binaryOutput:r};return Ne.runKernel(xo,A,u)}}),Lre=De({scatterND_:function(n,e,t){const r=le(n,"indices","scatterND","int32"),s=le(e,"updates","scatterND");L4(s,r,t);const o={indices:r,updates:s},A={shape:t};return Ne.runKernel(_C,o,A)}}),Rre=De({gatherND_:function(n,e){const t=le(e,"indices","gatherND","int32"),r={params:le(n,"x","gatherND","string_or_numeric"),indices:t};return Ne.runKernel(FC,r)}}),Wre=De({broadcastArgs_:function(n,e){const t=le(n,"s0","broadcastArgs","int32"),r=le(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:t,s1:r};return Ne.runKernel(Gi,s)}});function oL(n,e,t,r){const s=((o,A,u)=>{switch(o.category){case"arithmetic":return Ve(()=>((l,c,d)=>{switch(l.op){case"BiasAdd":case"AddV2":case"Add":return[vt(V("a",l,c,d),V("b",l,c,d))];case"AddN":return[Tre(V("tensors",l,c,d))];case"FloorMod":case"Mod":return[xF(V("a",l,c,d),V("b",l,c,d))];case"Mul":return[Me(V("a",l,c,d),V("b",l,c,d))];case"RealDiv":case"Div":return[an(V("a",l,c,d),V("b",l,c,d))];case"DivNoNan":return[fF(V("a",l,c,d),V("b",l,c,d))];case"FloorDiv":return[GI(V("a",l,c,d),V("b",l,c,d))];case"Sub":return[Ut(V("a",l,c,d),V("b",l,c,d))];case"Minimum":return[Om(V("a",l,c,d),V("b",l,c,d))];case"Maximum":return[dl(V("a",l,c,d),V("b",l,c,d))];case"Pow":return[Bc(V("a",l,c,d),V("b",l,c,d))];case"SquaredDifference":return[uS(V("a",l,c,d),V("b",l,c,d))];default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"basic_math":return Ve(()=>((l,c,d)=>{switch(l.op){case"Abs":case"ComplexAbs":return[Ts(V("x",l,c,d))];case"Acos":return[sF(V("x",l,c,d))];case"Acosh":return[aF(V("x",l,c,d))];case"Asin":return[iF(V("x",l,c,d))];case"Asinh":return[AF(V("x",l,c,d))];case"Atan":return[lF(V("x",l,c,d))];case"Atan2":return[uF(V("x",l,c,d),V("y",l,c,d))];case"Atanh":return[cF(V("x",l,c,d))];case"Ceil":return[dF(V("x",l,c,d))];case"Complex":return[Sc(V("real",l,c,d),V("imag",l,c,d))];case"Cos":return[px(V("x",l,c,d))];case"Cosh":return[YS(V("x",l,c,d))];case"Elu":return[Mm(V("x",l,c,d))];case"Erf":return[mF(V("x",l,c,d))];case"Exp":return[Qo(V("x",l,c,d))];case"Expm1":return[gF(V("x",l,c,d))];case"Floor":return[Dm(V("x",l,c,d))];case"Log":return[Jo(V("x",l,c,d))];case"Log1p":return[Zv(V("x",l,c,d))];case"Imag":return[$I(V("x",l,c,d))];case"Neg":return[Yr(V("x",l,c,d))];case"Reciprocal":return[wF(V("x",l,c,d))];case"Real":return[_v(V("x",l,c,d))];case"Relu":return[IA(V("x",l,c,d))];case"Round":return[AS(V("x",l,c,d))];case"Selu":return[QI(V("x",l,c,d))];case"Sigmoid":return[Oc(V("x",l,c,d))];case"Sin":return[HS(V("x",l,c,d))];case"Sign":return[kF(V("x",l,c,d))];case"Sinh":return[GS(V("x",l,c,d))];case"Softplus":return[Mp(V("x",l,c,d))];case"Sqrt":return[wa(V("x",l,c,d))];case"Square":return[xr(V("x",l,c,d))];case"Tanh":return[Jv(V("x",l,c,d))];case"Tan":return[IF(V("x",l,c,d))];case"ClipByValue":return[ko(V("x",l,c,d),V("clipValueMin",l,c,d),V("clipValueMax",l,c,d))];case"Relu6":return[nS(V("x",l,c,d))];case"Rsqrt":return[XS(Wa(l.inputNames[0],c,d))];case"Prod":return[QS(V("x",l,c,d),V("axes",l,c,d))];case"LeakyRelu":return[Xv(V("x",l,c,d),V("alpha",l,c,d))];case"Prelu":return[Qv(V("x",l,c,d),V("alpha",l,c,d))];case"IsNan":return[yF(Wa(l.inputNames[0],c,d))];default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"control":return(async(l,c,d)=>{switch(l.op){case"If":case"StatelessIf":{const m=V("thenBranch",l,c,d),y=V("elseBranch",l,c,d),b=V("cond",l,c,d),v=V("args",l,c,d);return(await b.data())[0]?d.functionMap[m].executeFunctionAsync(v,d.tensorArrayMap,d.tensorListMap):d.functionMap[y].executeFunctionAsync(v,d.tensorArrayMap,d.tensorListMap)}case"While":case"StatelessWhile":{const m=V("body",l,c,d),y=V("cond",l,c,d),b=V("args",l,c,d),v=await d.functionMap[y].executeFunctionAsync(b,d.tensorArrayMap,d.tensorListMap),w=b.map(T=>T.id);let I=await v[0].data();v.forEach(T=>{T.kept||w.indexOf(T.id)!==-1||T.dispose()});let S=b;for(;I[0];){const T=S;S=await d.functionMap[m].executeFunctionAsync(S,d.tensorArrayMap,d.tensorListMap);const D=S.map(W=>W.id);T.forEach(W=>{W.kept||w.indexOf(W.id)!==-1||D.indexOf(W.id)!==-1||W.dispose()});const L=await d.functionMap[y].executeFunctionAsync(S,d.tensorArrayMap,d.tensorListMap);I=await L[0].data(),L.forEach(W=>{W.kept||w.indexOf(W.id)!==-1||D.indexOf(W.id)!==-1||W.dispose()})}return S}case"LoopCond":return[wu(V("pred",l,c,d))];case"Switch":{const m=V("pred",l,c,d);let y=V("data",l,c,d);return y.kept||(y=wu(y)),(await m.data())[0]?[void 0,y]:[y,void 0]}case"Merge":{const m=l.inputNames.find(y=>Wa(y,c,d)!==void 0);return m?[wu(Wa(m,c,d))]:void 0}case"Enter":{const m=V("frameName",l,c,d),y=V("tensor",l,c,d);return d.enterFrame(m),[wu(y)]}case"Exit":{const m=V("tensor",l,c,d);return d.exitFrame(),[wu(m)]}case"NextIteration":{const m=V("tensor",l,c,d);return d.nextIteration(),[wu(m)]}case"TensorArrayV3":{const m=V("size",l,c,d),y=V("dtype",l,c,d),b=V("elementShape",l,c,d),v=V("dynamicSize",l,c,d),w=V("clearAfterRead",l,c,d),I=V("identicalElementShapes",l,c,d),S=V("name",l,c,d),T=new Mre(S,y,m,b,I,v,w);return d.addTensorArray(T),[T.idTensor,un(1)]}case"TensorArrayWriteV3":{const m=V("tensorArrayId",l,c,d),y=V("index",l,c,d),b=V("tensor",l,c,d),v=d.getTensorArray(m.id);return v.write(y,b),[v.idTensor]}case"TensorArrayReadV3":{const m=V("tensorArrayId",l,c,d),y=V("index",l,c,d);return[d.getTensorArray(m.id).read(y)]}case"TensorArrayGatherV3":{const m=V("tensorArrayId",l,c,d),y=V("indices",l,c,d),b=V("dtype",l,c,d);return[d.getTensorArray(m.id).gather(y,b)]}case"TensorArrayScatterV3":{const m=V("tensorArrayId",l,c,d),y=V("indices",l,c,d),b=V("tensor",l,c,d),v=d.getTensorArray(m.id);return v.scatter(y,b),[v.idTensor]}case"TensorArrayConcatV3":{const m=V("tensorArrayId",l,c,d),y=d.getTensorArray(m.id),b=V("dtype",l,c,d);return[y.concat(b)]}case"TensorArraySplitV3":{const m=V("tensorArrayId",l,c,d),y=V("tensor",l,c,d),b=V("lengths",l,c,d),v=d.getTensorArray(m.id);return v.split(b,y),[v.idTensor]}case"TensorArraySizeV3":{const m=V("tensorArrayId",l,c,d);return[un(d.getTensorArray(m.id).size(),"int32")]}case"TensorArrayCloseV3":{const m=V("tensorArrayId",l,c,d),y=d.getTensorArray(m.id);return y.clearAndClose(),[y.idTensor]}case"TensorListSetItem":{const m=V("tensorListId",l,c,d),y=V("index",l,c,d),b=V("tensor",l,c,d),v=d.getTensorList(m.id);return v.setItem(y,b),[v.idTensor]}case"TensorListGetItem":{const m=V("tensorListId",l,c,d),y=V("index",l,c,d),b=V("elementShape",l,c,d),v=V("elementDType",l,c,d);return[d.getTensorList(m.id).getItem(y,b,v)]}case"TensorListScatterV2":case"TensorListScatter":{const m=V("indices",l,c,d),y=function(b,v,w,I){if(v.length!==b.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${v.length} vs. ${b.shape[0]}`);const S=Math.max(...v);if(I!=null&&I!==-1&&S>=I)throw new Error(`Max index must be < array size (${S}  vs. ${I})`);const T=new Lp([],w,b.dtype,I),D=Ui(b,0);return v.forEach((L,W)=>{T.setItem(L,D[W])}),T}(V("tensor",l,c,d),m,V("elementShape",l,c,d),V("numElements",l,c,d));return d.addTensorList(y),[y.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const m=V("elementShape",l,c,d),y=V("elementDType",l,c,d);let b;b=l.op==="TensorListReserve"?"numElements":"maxNumElements";const v=function(w,I,S){return new Lp([],w,I,S)}(m,y,V(b,l,c,d));return d.addTensorList(v),[v.idTensor]}case"TensorListGather":{const m=V("tensorListId",l,c,d),y=V("indices",l,c,d),b=V("elementShape",l,c,d),v=V("elementDType",l,c,d);return[d.getTensorList(m.id).gather(y,v,b)]}case"TensorListStack":{const m=V("tensorListId",l,c,d),y=V("elementShape",l,c,d),b=V("elementDType",l,c,d),v=V("numElements",l,c,d);return[d.getTensorList(m.id).stack(y,b,v)]}case"TensorListFromTensor":{const m=function(y,b,v){const w=y.dtype;if(y.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${y.shape}`);if(y.dtype!==v)throw new Error(`Invalid data types; op elements ${y.dtype}, but list elements ${v}`);Si(y.shape.slice(1),b,"TensorList shape mismatch: ");const I=Ui(y);return new Lp(I,b,w)}(V("tensor",l,c,d),V("elementShape",l,c,d),V("elementDType",l,c,d));return d.addTensorList(m),[m.idTensor]}case"TensorListConcat":{const m=V("tensorListId",l,c,d),y=d.getTensorList(m.id),b=V("dtype",l,c,d),v=V("elementShape",l,c,d);return[y.concat(b,v)]}case"TensorListPushBack":{const m=V("tensorListId",l,c,d),y=V("tensor",l,c,d),b=d.getTensorList(m.id);return b.pushBack(y),[b.idTensor]}case"TensorListPopBack":{const m=V("tensorListId",l,c,d),y=V("elementShape",l,c,d),b=V("elementDType",l,c,d);return[d.getTensorList(m.id).popBack(y,b)]}case"TensorListSplit":{const m=V("tensor",l,c,d),y=V("elementShape",l,c,d),b=function(v,w,I){let S=0;const T=w.map(U=>(S+=U,S));if(S!==v.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${S}, and tensor's shape is: ${v.shape}`);const D=Y3(v.shape.slice(1),I),L=S===0?0:v.size/S,W=Ve(()=>{const U=[];v=Fe(v,[1,S,L]);for(let _=0;_<w.length;++_){const ee=[0,_===0?0:T[_-1],0],re=[1,w[_],L];U[_]=Fe(or(v,ee,re),D)}return v.dispose(),U}),K=new Lp([],I,v.dtype,w.length);for(let U=0;U<W.length;U++)K.setItem(U,W[U]);return K}(m,V("lengths",l,c,d),y);return d.addTensorList(b),[b.idTensor]}default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u);case"convolution":return Ve(()=>((l,c,d)=>{switch(l.op){case"Conv1D":{const m=V("stride",l,c,d),y=V("pad",l,c,d),b=V("dataFormat",l,c,d).toUpperCase(),v=V("dilation",l,c,d);return[WI(V("x",l,c,d),V("filter",l,c,d),m,y,b,v)]}case"Conv2D":{const m=V("strides",l,c,d),y=Wx(l,c,d),b=V("dataFormat",l,c,d).toUpperCase(),v=V("dilations",l,c,d);return[uu(V("x",l,c,d),V("filter",l,c,d),[m[1],m[2]],y,b,[v[1],v[2]])]}case"_FusedConv2D":{const{stride:m,pad:y,dataFormat:b,dilations:v,biasArg:w,preluArg:I,activationFunc:S,leakyreluAlpha:T}=sL(l,c,d);return[I4({x:V("x",l,c,d),filter:V("filter",l,c,d),strides:[m[1],m[2]],pad:y,dataFormat:b,dilations:[v[1],v[2]],bias:w,activation:S,preluActivationWeights:I,leakyreluAlpha:T})]}case"FusedDepthwiseConv2dNative":{const{stride:m,pad:y,dataFormat:b,dilations:v,biasArg:w,preluArg:I,activationFunc:S,leakyreluAlpha:T}=sL(l,c,d);return[bee({x:V("x",l,c,d),filter:V("filter",l,c,d),strides:[m[1],m[2]],pad:y,dataFormat:b,dilations:[v[1],v[2]],bias:w,activation:S,preluActivationWeights:I,leakyreluAlpha:T})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const m=V("outputShape",l,c,d),y=V("strides",l,c,d),b=Wx(l,c,d);return[HI(V("x",l,c,d),V("filter",l,c,d),m,[y[1],y[2]],b)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const m=V("strides",l,c,d),y=Wx(l,c,d),b=V("dilations",l,c,d),v=V("dataFormat",l,c,d).toUpperCase();return[Tm(V("input",l,c,d),V("filter",l,c,d),[m[1],m[2]],y,v,[b[1],b[2]])]}case"Conv3D":{const m=V("strides",l,c,d),y=V("pad",l,c,d),b=V("dataFormat",l,c,d).toUpperCase(),v=V("dilations",l,c,d);return[m4(V("x",l,c,d),V("filter",l,c,d),[m[1],m[2],m[3]],y,b,[v[1],v[2],v[3]])]}case"AvgPool":{const m=V("strides",l,c,d),y=V("pad",l,c,d),b=V("kernelSize",l,c,d);return[Vv(V("x",l,c,d),[b[1],b[2]],[m[1],m[2]],y)]}case"MaxPool":{const m=V("strides",l,c,d),y=V("pad",l,c,d),b=V("kernelSize",l,c,d);return[Yv(V("x",l,c,d),[b[1],b[2]],[m[1],m[2]],y)]}case"MaxPoolWithArgmax":{const m=V("strides",l,c,d),y=V("pad",l,c,d),b=V("kernelSize",l,c,d),v=V("includeBatchInIndex",l,c,d),{result:w,indexes:I}=Ere(V("x",l,c,d),[b[1],b[2]],[m[1],m[2]],y,v);return[w,I]}case"AvgPool3D":{const m=V("strides",l,c,d),y=V("pad",l,c,d),b=V("kernelSize",l,c,d);return[f4(V("x",l,c,d),[b[1],b[2],b[3]],[m[1],m[2],m[3]],y)]}case"MaxPool3D":{const m=V("strides",l,c,d),y=V("pad",l,c,d),b=V("kernelSize",l,c,d);return[b4(V("x",l,c,d),[b[1],b[2],b[3]],[m[1],m[2],m[3]],y)]}case"Dilation2D":{const m=V("strides",l,c,d),y=V("pad",l,c,d),b=V("dilations",l,c,d),v=m[1],w=m[2],I=b[1],S=b[2];return[hF(V("x",l,c,d),V("filter",l,c,d),[v,w],y,[I,S],"NHWC")]}default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"creation":return Ve(()=>((l,c,d)=>{switch(l.op){case"Fill":{const m=V("shape",l,c,d),y=V("dtype",l,c,d);return[Em(m,V("value",l,c,d),y)]}case"LinSpace":return[Dre(V("start",l,c,d),V("stop",l,c,d),V("num",l,c,d))];case"Multinomial":{const m=V("logits",l,c,d),y=V("numSamples",l,c,d),b=V("seed",l,c,d);return[zre(m,y,b)]}case"OneHot":{const m=V("indices",l,c,d),y=V("depth",l,c,d),b=V("onValue",l,c,d),v=V("offValue",l,c,d);return[YI(m,y,b,v)]}case"Ones":return[pl(V("shape",l,c,d),V("dtype",l,c,d))];case"OnesLike":return[$o(V("x",l,c,d))];case"RandomUniform":return[Pm(V("shape",l,c,d),V("minval",l,c,d),V("maxval",l,c,d),V("dtype",l,c,d))];case"Range":return[Lm(V("start",l,c,d),V("stop",l,c,d),V("step",l,c,d),V("dtype",l,c,d))];case"TruncatedNormal":{const m=V("shape",l,c,d),y=V("mean",l,c,d),b=V("stdDev",l,c,d),v=V("seed",l,c,d);return[JI(m,y,b,V("dtype",l,c,d),v)]}case"Zeros":return[Es(V("shape",l,c,d),V("dtype",l,c,d))];case"ZerosLike":return[Vn(V("x",l,c,d))];default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"dynamic":return(async(l,c,d)=>{switch(l.op){case"NonMaxSuppressionV5":{const{boxes:m,scores:y,maxOutputSize:b,iouThreshold:v,scoreThreshold:w,softNmsSigma:I}=U3(l,c,d),S=await Qi.nonMaxSuppressionWithScoreAsync(m,y,b,v,w,I);return[S.selectedIndices,S.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:m,scores:y,maxOutputSize:b,iouThreshold:v,scoreThreshold:w}=U3(l,c,d),I=V("padToMaxOutputSize",l,c,d),S=await Qi.nonMaxSuppressionPaddedAsync(m,y,b,v,w,I);return[S.selectedIndices,S.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:m,scores:y,maxOutputSize:b,iouThreshold:v,scoreThreshold:w}=U3(l,c,d);return[await Qi.nonMaxSuppressionAsync(m,y,b,v,w)]}case"Where":{const m=zt(V("condition",l,c,d),"bool"),y=[await Ore(m)];return m.dispose(),y}case"ListDiff":return async function(m,y){const b=le(m,"x","setdiff1d"),v=le(y,"y","setdiff1d");J(b.dtype===v.dtype,()=>`x and y should have the same dtype, but got x (${b.dtype}) and y (${v.dtype}).`),J(b.rank===1,()=>`x should be 1D tensor, but got x (${b.shape}).`),J(v.rank===1,()=>`y should be 1D tensor, but got y (${v.shape}).`);const w=await b.data(),I=await v.data(),S=new Set(I);let T=0;for(let W=0;W<w.length;W++)S.has(w[W])||T++;const D=new Gs([T],b.dtype),L=new Gs([T],"int32");for(let W=0,K=0;W<w.length;W++)S.has(w[W])||(D.values[K]=w[W],L.values[K]=W,K++);return[D.toTensor(),L.toTensor()]}(V("x",l,c,d),V("y",l,c,d));default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u);case"evaluation":return Ve(()=>((l,c,d)=>{switch(l.op){case"TopKV2":{const m=V("x",l,c,d),y=V("k",l,c,d),b=V("sorted",l,c,d),v=SF(m,y,b);return[v.values,v.indices]}case"Unique":{const m=V("x",l,c,d),y=KS(m);return[y.values,y.indices]}case"UniqueV2":{const m=V("x",l,c,d),y=V("axis",l,c,d),b=KS(m,y);return[b.values,b.indices]}default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"image":return Ve(()=>((l,c,d)=>{switch(l.op){case"ResizeBilinear":{const m=V("images",l,c,d),y=V("size",l,c,d),b=V("alignCorners",l,c,d),v=V("halfPixelCenters",l,c,d);return[Qi.resizeBilinear(m,[y[0],y[1]],b,v)]}case"ResizeNearestNeighbor":{const m=V("images",l,c,d),y=V("size",l,c,d),b=V("alignCorners",l,c,d),v=V("halfPixelCenters",l,c,d);return[Qi.resizeNearestNeighbor(m,[y[0],y[1]],b,v)]}case"CropAndResize":{const m=V("image",l,c,d),y=V("boxes",l,c,d),b=V("boxInd",l,c,d),v=V("cropSize",l,c,d),w=V("method",l,c,d),I=V("extrapolationValue",l,c,d);return[Qi.cropAndResize(m,y,b,v,w,I)]}default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"graph":return Ve(()=>((l,c,d)=>{switch(l.op){case"Const":return c[l.name];case"PlaceholderWithDefault":const m=V("default",l,c,d);return[Wa(l.name,c,d)||m];case"Placeholder":return[Wa(l.name,c,d)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[wu(V("x",l,c,d))];case"IdentityN":return V("x",l,c,d).map(I=>wu(I));case"Shape":return[Ra(V("x",l,c,d).shape,"int32")];case"ShapeN":return V("x",l,c,d).map(I=>Ra(I.shape));case"Size":return[un(V("x",l,c,d).size,"int32")];case"Rank":return[un(V("x",l,c,d).rank,"int32")];case"NoOp":return[un(1)];case"Print":const y=V("x",l,c,d),b=V("data",l,c,d),v=V("message",l,c,d),w=V("summarize",l,c,d);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(v);for(let I=0;I<b.length;I++)console.log(Array.prototype.slice.call(b[I].dataSync()).slice(0,w));return[y];default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"logical":return Ve(()=>((l,c,d)=>{switch(l.op){case"Equal":return[Zi(V("a",l,c,d),V("b",l,c,d))];case"NotEqual":return[Tp(V("a",l,c,d),V("b",l,c,d))];case"Greater":return[qo(V("a",l,c,d),V("b",l,c,d))];case"GreaterEqual":return[zc(V("a",l,c,d),V("b",l,c,d))];case"Less":return[ZS(V("a",l,c,d),V("b",l,c,d))];case"LessEqual":return[Pc(V("a",l,c,d),V("b",l,c,d))];case"LogicalAnd":return[CA(V("a",l,c,d),V("b",l,c,d))];case"LogicalNot":return[dx(V("a",l,c,d))];case"LogicalOr":return[US(V("a",l,c,d),V("b",l,c,d))];case"Select":case"SelectV2":return[eo(V("condition",l,c,d),V("a",l,c,d),V("b",l,c,d))];default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"matrices":return Ve(()=>((l,c,d)=>{switch(l.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[nr(V("a",l,c,d),V("b",l,c,d),V("transposeA",l,c,d),V("transposeB",l,c,d))];case"Einsum":return[Bre(V("equation",l,c,d),...V("tensors",l,c,d))];case"Transpose":return[Yn(V("x",l,c,d),V("perm",l,c,d))];case"_FusedMatMul":const[m,y]=V("fusedOps",l,c,d),b=m==="biasadd",v=y==="prelu",w=V("numArgs",l,c,d),I=V("leakyreluAlpha",l,c,d);if(b){if(v&&w!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!v&&w!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[S,T]=V("args",l,c,d);return[rS({a:V("a",l,c,d),b:V("b",l,c,d),transposeA:V("transposeA",l,c,d),transposeB:V("transposeB",l,c,d),bias:S,activation:y,preluActivationWeights:T,leakyreluAlpha:I})];default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"normalization":return Ve(()=>((l,c,d)=>{switch(l.op){case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[Nm(V("x",l,c,d),V("mean",l,c,d),V("variance",l,c,d),V("offset",l,c,d),V("scale",l,c,d),V("epsilon",l,c,d))];case"LRN":return[bF(V("x",l,c,d),V("radius",l,c,d),V("bias",l,c,d),V("alpha",l,c,d),V("beta",l,c,d))];case"Softmax":return[qv(V("x",l,c,d))];case"LogSoftmax":return[VI(V("x",l,c,d))];case"SparseToDense":return[aL(V("sparseIndices",l,c,d),V("outputShape",l,c,d),V("sparseValues",l,c,d),V("defaultValue",l,c,d))];default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"reduction":return Ve(()=>((l,c,d)=>{switch(l.op){case"Max":{const v=V("axis",l,c,d),w=V("keepDims",l,c,d);return[Yi(V("x",l,c,d),v,w)]}case"Mean":{const v=V("axis",l,c,d),w=V("keepDims",l,c,d);return[es(V("x",l,c,d),v,w)]}case"Min":{const v=V("axis",l,c,d),w=V("keepDims",l,c,d);return[ax(V("x",l,c,d),v,w)]}case"Sum":{const v=V("axis",l,c,d),w=V("keepDims",l,c,d);return[Qt(V("x",l,c,d),v,w)]}case"All":{const v=V("axis",l,c,d),w=V("keepDims",l,c,d);return[FI(V("x",l,c,d),v,w)]}case"Any":{const v=V("axis",l,c,d),w=V("keepDims",l,c,d);return[Hv(V("x",l,c,d),v,w)]}case"ArgMax":{const v=V("axis",l,c,d);return[Cp(V("x",l,c,d),v)]}case"ArgMin":{const v=V("axis",l,c,d);return[oF(V("x",l,c,d),v)]}case"Prod":{const v=V("axis",l,c,d),w=V("keepDims",l,c,d);return[QS(V("x",l,c,d),v,w)]}case"Cumsum":{const v=V("axis",l,c,d),w=V("exclusive",l,c,d),I=V("reverse",l,c,d);return[VS(V("x",l,c,d),v,w,I)]}case"Bincount":const m=V("x",l,c,d),y=V("weights",l,c,d),b=V("size",l,c,d);return[z4(m,y,b)];case"DenseBincount":{const v=V("x",l,c,d),w=V("weights",l,c,d),I=V("size",l,c,d),S=V("binaryOutput",l,c,d);return[Fre(v,w,I,S)]}default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"slice_join":return Ve(()=>((l,c,d)=>{switch(l.op){case"ConcatV2":case"Concat":{const m=V("n",l,c,d),y=V("axis",l,c,d);let b=V("tensors",l,c,d);return b=b.slice(0,m),[ys(b,y)]}case"Gather":{const m=V("x",l,c,d),y=V("indices",l,c,d);return[zm(m,zt(y,"int32"),0)]}case"GatherV2":{const m=V("axis",l,c,d),y=V("batchDims",l,c,d),b=V("x",l,c,d),v=V("indices",l,c,d);return[zm(b,zt(v,"int32"),m,y)]}case"Reverse":{const m=V("dims",l,c,d),y=[];for(let v=0;v<m.length;v++)m[v]&&y.push(v);const b=V("x",l,c,d);return[hl(b,y)]}case"ReverseV2":{const m=V("axis",l,c,d),y=V("x",l,c,d);return[hl(y,m)]}case"Slice":{const m=V("begin",l,c,d),y=V("size",l,c,d);return[or(V("x",l,c,d),m,y)]}case"StridedSlice":{const m=V("begin",l,c,d),y=V("end",l,c,d),b=V("strides",l,c,d),v=V("beginMask",l,c,d),w=V("endMask",l,c,d),I=V("ellipsisMask",l,c,d),S=V("newAxisMask",l,c,d),T=V("shrinkAxisMask",l,c,d),D=V("x",l,c,d);return[CF(D,m,y,b,v,w,I,S,T)]}case"Pack":return Ve(()=>{const m=V("axis",l,c,d),y=V("tensors",l,c,d),b=y[0].shape,v=cu(y[0]).shape,w=y.map(I=>{const S=ht(I.shape,b);if(!S&&!ht(cu(I).shape,v))throw new Error("the input tensors shape does not match");return S?I:Fe(I,b)});return[xi(w,m)]});case"Unpack":{const m=V("axis",l,c,d),y=V("tensor",l,c,d);return Ui(y,m)}case"Tile":{const m=V("reps",l,c,d);return[vi(V("x",l,c,d),m)]}case"Split":case"SplitV":{const m=V("axis",l,c,d),y=V("numOrSizeSplits",l,c,d),b=V("x",l,c,d);return _a(b,y,m)}case"ScatterNd":{const m=V("indices",l,c,d),y=V("values",l,c,d),b=V("shape",l,c,d);return[Lre(m,y,b)]}case"GatherNd":{const m=V("x",l,c,d),y=V("indices",l,c,d);return[Rre(m,y)]}case"SparseToDense":{const m=V("sparseIndices",l,c,d),y=V("outputShape",l,c,d),b=V("sparseValues",l,c,d),v=V("defaultValue",l,c,d);return[aL(m,b,y,b.dtype===v.dtype?v:zt(v,b.dtype))]}default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"sparse":return Ve(()=>((l,c,d)=>{switch(l.op){case"SparseFillEmptyRows":{const{outputIndices:m,outputValues:y,emptyRowIndicator:b,reverseIndexMap:v}=ox.sparseFillEmptyRows(V("indices",l,c,d),V("values",l,c,d),V("denseShape",l,c,d),V("defaultValue",l,c,d));return[m,y,b,v]}case"SparseReshape":{const{outputIndices:m,outputShape:y}=ox.sparseReshape(V("inputIndices",l,c,d),V("inputShape",l,c,d),V("newShape",l,c,d));return[m,y]}case"SparseSegmentMean":return[ox.sparseSegmentMean(V("data",l,c,d),V("indices",l,c,d),V("segmentIds",l,c,d))];case"SparseSegmentSum":return[ox.sparseSegmentSum(V("data",l,c,d),V("indices",l,c,d),V("segmentIds",l,c,d))];default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"spectral":return Ve(()=>((l,c,d)=>{switch(l.op){case"FFT":return[_I(V("x",l,c,d))];case"IFFT":return[ex(V("x",l,c,d))];case"RFFT":return[eS(V("x",l,c,d))];case"IRFFT":return[C4(V("x",l,c,d))];default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"string":return Ve(()=>((l,c,d)=>{switch(l.op){case"StringNGrams":{const{nGrams:m,nGramsSplits:y}=cS.stringNGrams(V("data",l,c,d),V("dataSplits",l,c,d),V("separator",l,c,d),V("nGramWidths",l,c,d),V("leftPad",l,c,d),V("rightPad",l,c,d),V("padWidth",l,c,d),V("preserveShortSequences",l,c,d));return[m,y]}case"StringSplit":{const{indices:m,values:y,shape:b}=cS.stringSplit(V("input",l,c,d),V("delimiter",l,c,d),V("skipEmpty",l,c,d));return[m,y,b]}case"StringToHashBucketFast":return[cS.stringToHashBucketFast(V("input",l,c,d),V("numBuckets",l,c,d))];default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"transformation":return Ve(()=>((l,c,d)=>{switch(l.op){case"Cast":return[zt(V("x",l,c,d),V("dtype",l,c,d))];case"ExpandDims":{const m=V("axis",l,c,d);return[Ko(V("x",l,c,d),m)]}case"Squeeze":{const m=V("axis",l,c,d);return[cu(V("x",l,c,d),m)]}case"Reshape":return[Fe(V("x",l,c,d),V("shape",l,c,d))];case"MirrorPad":return[vF(V("x",l,c,d),V("padding",l,c,d),V("mode",l,c,d))];case"PadV2":case"Pad":return[Uv(V("x",l,c,d),V("padding",l,c,d),V("constantValue",l,c,d))];case"SpaceToBatchND":{const m=V("blockShape",l,c,d),y=V("paddings",l,c,d);return[cx(V("x",l,c,d),m,y)]}case"BatchToSpaceND":{const m=V("blockShape",l,c,d),y=V("crops",l,c,d);return[hx(V("x",l,c,d),m,y)]}case"DepthToSpace":{const m=V("blockSize",l,c,d),y=V("dataFormat",l,c,d).toUpperCase();return[pF(V("x",l,c,d),m,y)]}case"BroadcastTo":return[Bm(V("x",l,c,d),V("shape",l,c,d))];case"BroadcastArgs":return[Wre(V("s0",l,c,d),V("s1",l,c,d))];default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"hash_table":return(async(l,c,d,m)=>{switch(l.op){case"HashTable":case"HashTableV2":{const y=V("keyDType",l,c,d),b=V("valueDType",l,c,d),v=new Pre(y,b);return m.addHashTable(l.name,v),[v.handle]}case"LookupTableImport":case"LookupTableImportV2":{const y=V("tableHandle",l,c,d,m),b=V("keys",l,c,d),v=V("values",l,c,d);return[await m.getHashTableById(y.id).import(b,v)]}case"LookupTableFind":case"LookupTableFindV2":{const y=V("tableHandle",l,c,d,m),b=V("keys",l,c,d),v=V("defaultValue",l,c,d);return[await m.getHashTableById(y.id).find(b,v)]}case"LookupTableSize":case"LookupTableSizeV2":{const y=V("tableHandle",l,c,d,m);return[m.getHashTableById(y.id).tensorSize()]}default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u,r);case"custom":const h=$9(o.op);if(h&&h.customExecutor)return h.customExecutor(new Nre(o,A,u));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return Nn(s)?s.then(o=>[].concat(o)):[].concat(s)}class iL{constructor(e={},t={},r={},s={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=r,this.functionMap=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const r=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(r))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function AL(n,e,t,r){const s=new Set,o=[];let A=null,u=null;const h=new Set,l=Object.keys(n).map(m=>Io(m)[0]);let c=[];r!=null&&(c=r.map(m=>Io(m.name)[0]));const d=[...e];for(;d.length>0;){const m=d.pop();(lL(m)||Vre(m)||Xre(m))&&A==null&&(A=m,u=A.children.map(y=>y.name).filter(y=>s.has(y))),s.add(m.name),t[m.name]==null&&l.indexOf(m.name)===-1&&c.indexOf(m.name)===-1&&(m.inputs.length!==0?m.inputs.forEach(y=>{h.has(y.name)||(h.add(y.name),d.push(y))}):o.push(m.name))}return{inputs:n,outputs:e,usedNodes:s,missingInputs:o,dynamicNode:A,syncInputs:u}}const jre=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],Hre=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],Gre=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function lL(n){return jre.indexOf(n.op)>=0}function Vre(n){return Hre.indexOf(n.op)>=0}function Xre(n){return Gre.indexOf(n.op)>=0}class jx{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(r=>{this._functionExecutorMap[r]=new jx(e.functions[r],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(r=>e[r].map(s=>s.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){const r=e.map(o=>o.name).sort(),s=t.map(o=>o.name).sort();return r.join(this.SEPERATOR)+"--"+s.join(this.SEPERATOR)}compile(e,t){const r=AL(e,t,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:o,syncInputs:A}=r;if(o!=null)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${A}]`);if(s.length>0){const u=t.map(l=>l.name),h=Object.keys(e);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${h}]. Missing the following inputs: [${s}]`)}return function(u,h,l){const{usedNodes:c,inputs:d}=l,m=[],y=Object.keys(d).map(I=>Io(I)[0]).map(I=>u.nodes[I]),b=u.initNodes;y.forEach(I=>{c.has(I.name)&&m.push(I)}),u.weights.forEach(I=>{c.has(I.name)&&m.push(I)}),b!=null&&b.forEach(I=>{c.has(I.name)&&m.push(I)});const v=new Set,w=[];for(;m.length>0;){const I=m.pop();v.add(I.name),h[I.name]||w.push(I),I.children.forEach(S=>{!v.has(S.name)&&c.has(S.name)&&S.inputs.every(T=>v.has(T.name))&&m.push(S)})}return w}(this.graph,this.weightMap,r)}execute(e,t){e=this.mapInputs(e);const r=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const s=r.map(d=>this.graph.nodes[Io(d)[0]]),o=t.map(d=>Io(d)[0]);let A=o.map(d=>this.graph.nodes[d]);A.length===0&&(A=this._outputs);const u=this.getCompilationKey(s,A);let h=this.compiledMap.get(u);h==null&&(h=this.compile(e,A),this.compiledMap.set(u,h));const l={},c={};return Ve(()=>{const d=new iL(this.weightMap,l,c,this.functionExecutorMap),m=Object.assign({},this.weightMap);Object.keys(e).forEach(v=>{const[w,I]=Io(v),S=[];S[I]=e[v],m[w]=S});const y=this.getFrozenTensorIds(m),b={};for(let v=0;v<h.length;v++){const w=h[v];if(!m[w.name]){const I=oL(w,m,d,this._resourceManager);if(Nn(I))throw new Error(`The execution of the op '${w.op}' returned a promise. Please use model.executeAsync() instead.`);m[w.name]=I,this.checkTensorForDisposal(w.name,w,m,d,y,o,b)}}return this.parent==null&&d.dispose(y),t.map(v=>Wa(v,m,d))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(r=>e[r]).map(r=>r.map(s=>s.id)));return new Set(t)}checkTensorForDisposal(e,t,r,s,o,A,u){t.category!=="control"&&A.indexOf(e)===-1&&(r[e].forEach(h=>{h!=null&&(u[h.id]=(u[h.id]||0)+t.children.length)}),t.inputs.forEach(h=>{if(h.category!=="control"){const l=function(c,d,m){return d[Rx(c,m.currentContextId)]}(h.name,r,s);l!=null&&l.forEach(c=>{if(c&&!c.kept&&!o.has(c.id)){const d=u[c.id];d===1?(c.dispose(),delete u[c.id]):d!=null&&u[c.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}async _executeAsync(e,t,r=!1,s={},o={}){r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));const A=new iL(this.weightMap,s,o,this.functionExecutorMap),u=await this.executeWithControlFlow(e,A,t,r),h=t.map(m=>Wa(m,u,A)),l=h.map(m=>m.id),c=Object.keys(e).map(m=>e[m].id),d=new Set([...l,...c,...this.weightIds]);return Object.keys(u).forEach(m=>{u[m].forEach(y=>{!y||y.kept||y.isDisposed||d.has(y.id)||y.dispose()})}),this.parent==null&&A.dispose(d),h}async executeFunctionAsync(e,t,r){const s=e.reduce((o,A,u)=>(o[this.inputs[u].name]=A,o),{});return this._executeAsync(s,this.outputNodes,!0,t,r)}async executeWithControlFlow(e,t,r,s){const o=Object.keys(e),A=o.map(T=>this.graph.nodes[Io(T)[0]]),u=r.map(T=>Io(T)[0]);let h=u.map(T=>this.graph.nodes[T]);h.length===0&&(h=this._outputs);const{usedNodes:l,missingInputs:c,dynamicNode:d,syncInputs:m}=AL(e,h,this.weightMap,this._initNodes),y=[...A,...this.graph.weights,...this._initNodes||[]].map(T=>({node:T,contexts:t.currentContext})),b=Object.assign({},this.weightMap);Object.keys(e).forEach(T=>{const[D,L]=Io(T),W=[];W[L]=e[T],b[D]=W});const v={},w=this.getFrozenTensorIds(b),I={};for(;y.length>0;){const T=this.processStack(A,y,t,b,I,w,u,v,l);await Promise.all(T)}d!=null||s||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const S=h.filter(T=>!lL(T)&&!Wa(T.name,b,t)).map(T=>T.name);if(S.length>0){let T="";throw d!=null&&(T=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${m}]`),new Error(`Cannot compute the outputs [${S}] from the provided inputs [${o}]. Consider providing the following inputs: [${c}]. ${T}`)}return b}processStack(e,t,r,s,o,A,u,h,l){const c=[];for(;t.length>0;){const d=t.pop();r.currentContext=d.contexts;let m="";if(d.node.op==="Enter"&&V("isConstant",d.node,s,r)&&([m]=bl(d.node.name,r)),s[d.node.name]==null){const y=oL(d.node,s,r,this._resourceManager);m||([m]=bl(d.node.name,r));const b=r.currentContext;Nn(y)?c.push(y.then(v=>(s[m]=v,r.currentContext=b,this.checkTensorForDisposal(m,d.node,s,r,A,u,h),this.processChildNodes(d.node,t,r,s,o,l),v))):(s[m]=y,this.checkTensorForDisposal(m,d.node,s,r,A,u,h),this.processChildNodes(d.node,t,r,s,o,l))}else this.processChildNodes(d.node,t,r,s,o,l)}return c}processChildNodes(e,t,r,s,o,A){e.children.forEach(u=>{const[h]=bl(u.name,r);!o[h]&&A.has(u.name)&&(u.op==="Merge"?u.inputNames.some(l=>!!Wa(l,s,r))&&(o[h]=!0,t.push({contexts:r.currentContext,node:u})):u.inputNames.every(l=>!!Wa(l,s,r))&&(o[h]=!0,t.push({contexts:r.currentContext,node:u})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const r=e[t],[s]=Io(t),o=this.graph.nodes[s];if(o.attrParams.shape&&o.attrParams.shape.value){const A=o.attrParams.shape.value;J(A.length===r.shape.length&&r.shape.every((u,h)=>A[h]===-1||A[h]===u),()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${A}], but was [${r.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&J(r.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){const t={};for(const r in e)this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[r]!=null?t[this._signature.inputs[r].name]=e[r]:t[r]=e[r];return t}checkInputs(e){const t=Object.keys(e).filter(r=>{const[s]=Io(r);return this.graph.nodes[s]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[t]!=null?this._signature.outputs[t].name:t,{})}checkOutputs(e){e.forEach(t=>{const[r]=Io(t);if(!this.graph.nodes[r])throw new Error(`The output '${t}' is not found in the graph`)})}}class Zre{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}class Yre{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",t==null&&(this.loadOptions={}),this.resourceManager=new Zre}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=n4(e,this.loadOptions);else{const s=(t=e,r=this.loadOptions,Ns.getLoadHandlers(t,r));if(s.length===0)s.push(n4(e,this.loadOptions));else if(s.length>1)throw new Error(`Found more than one (${s.length}) load handlers for URL '${[e]}'`);this.handler=s[0]}var t,r}async load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=await this.handler.load();return this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let r;r=this.artifacts.userDefinedMetadata!=null&&this.artifacts.userDefinedMetadata.signature!=null?this.artifacts.userDefinedMetadata.signature:this.artifacts.signature,this.signature=r,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const s=function(o,A){const u={};let h,l=0;for(const c of A){const d=c.name,m=c.dtype,y=c.shape,b=Ye(y);let v;if("quantization"in c){const w=c.quantization;if(w.dtype==="uint8"||w.dtype==="uint16"){if(!("min"in w)||!("scale"in w))throw new Error(`Weight ${c.name} with quantization ${w.dtype} doesn't have corresponding metadata min and scale.`)}else{if(w.dtype!=="float16")throw new Error(`Weight ${c.name} has unknown quantization dtype ${w.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if(m!=="float32")throw new Error(`Weight ${c.name} is quantized with ${w.dtype} which only supports weights of type float32 not ${m}.`)}const I=W7[w.dtype],S=o.slice(l,l+b*I),T=w.dtype==="uint8"?new Uint8Array(S):new Uint16Array(S);if(m==="float32")if(w.dtype==="uint8"||w.dtype==="uint16"){v=new Float32Array(T.length);for(let D=0;D<T.length;D++){const L=T[D];v[D]=L*w.scale+w.min}}else{if(w.dtype!=="float16")throw new Error(`Unsupported quantization type ${w.dtype} for weight type float32.`);h===void 0&&(h=$_()),v=h(T)}else{if(m!=="int32")throw new Error(`Unsupported dtype in weight '${d}': ${m}`);if(w.dtype!=="uint8"&&w.dtype!=="uint16")throw new Error(`Unsupported quantization type ${w.dtype} for weight type int32.`);v=new Int32Array(T.length);for(let D=0;D<T.length;D++){const L=T[D];v[D]=Math.round(L*w.scale+w.min)}}l+=b*I}else if(m==="string"){const w=Ye(c.shape);v=[];for(let I=0;I<w;I++){const S=new Uint32Array(o.slice(l,l+4))[0];l+=4;const T=new Uint8Array(o.slice(l,l+S));v.push(T),l+=S}}else{const w=W7[m],I=o.slice(l,l+b*w);if(m==="float32")v=new Float32Array(I);else if(m==="int32")v=new Int32Array(I);else if(m==="bool")v=new Uint8Array(I);else{if(m!=="complex64")throw new Error(`Unsupported dtype in weight '${d}': ${m}`);{v=new Float32Array(I);const S=new Float32Array(v.length/2),T=new Float32Array(v.length/2);for(let W=0;W<S.length;W++)S[W]=v[2*W],T[W]=v[2*W+1];const D=ru(S,y,"float32"),L=ru(T,y,"float32");u[d]=Sc(D,L),D.dispose(),L.dispose()}}l+=b*w}m!=="complex64"&&(u[d]=ru(v,y,m))}return u}(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new jx(_9.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(s),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const o=_9.Instance.transformGraph(e.modelInitializer);this.initializer=new jx(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if(typeof e=="string"){const r=X7(e);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof ls||Array.isArray(e)))return e;if((e=Array.isArray(e)?e:[e]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((t,r,s)=>(t[r]=e[s],t),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=this.executor.execute(e,t);return r.length>1?r:r[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=await this.executor.executeAsync(e,t);return r.length>1?r:r[0]}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,r)=>(t[r]=[e[r]],t),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}var uL,Rp;(Rp=uL||(uL={}))[Rp.FAIL=0]="FAIL",Rp[Rp.SHORTEST=1]="SHORTEST",Rp[Rp.LONGEST=2]="LONGEST";function Kt(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&J(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}const Ure=jS;class Hx extends Wt{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Ht(this,Al())}nextDataId(){return Hx.nextDataId++}write(e,t,r){this.firstUse&&(this.firstUse=!1,st().get("IS_NODE")&&Zr(`
============================
Hi there . Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.
============================`));const s={id:this.nextDataId()};return this.data.set(s,{values:e,dtype:r,refCount:1}),s}makeTensorInfo(e,t,r){let s;if(t==="string"&&r!=null&&r.length>0&&rn(r[0])){const o=r.map(A=>nu(A));s=this.write(o,e,t)}else s=this.write(r,e,t);return{dataId:s,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,t,r,s,o){this.data.set(e,{values:t,dtype:s,refCount:o})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:r}=this.data.get(e);return t==="complex64"?fl(this.readSync(r.real.dataId),this.readSync(r.imag.dataId)):this.data.get(e).values}bufferSync(e){const t=this.readSync(e.dataId);let r=t;if(e.dtype==="string")try{r=t.map(s=>yp(s))}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Wn(e.shape,e.dtype,r)}makeOutput(e,t,r){const s=this.write(e,t,r);return Al().makeTensorFromDataId(s,t,r,this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:r}=this.data.get(e);r!=null&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=$a();return e(),{kernelMs:$a()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Kt([e],"where");const t=this.readSync(e.dataId);return Ure(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}function hr(n,e,t){return({inputs:r,attrs:s,backend:o})=>{const{x:A}=r;if(Kt(A,n),A.dtype==="string"||t==="string")throw new Error("unaryKernelFunc does not support string input/output");const u=o,h=u.data.get(A.dataId).values,l=Ye(A.shape),c=t||A.dtype,d=Tt(c,l);for(let m=0;m<l;++m)d[m]=e(h[m],s);return u.makeTensorInfo(A.shape,c,d)}}function Wp(n,e,t){return({inputs:r,attrs:s,backend:o})=>{const{x:A}=r;if(Kt(A,n),A.dtype==="string"||t==="string")throw new Error("unaryKernelFunc does not support string input/output");const u=o,h=u.data.get(A.dataId).values,l=A.dtype,c=e(h,l,s);return u.makeTensorInfo(A.shape,l,c)}}Hx.nextDataId=0,h4("cpu",()=>new Hx,1);const cL=hr(Yo,n=>n>=0?n:Math.exp(n)-1),Qre={kernelName:Yo,backendName:"cpu",kernelFunc:cL};function DA(n){const{inputs:e,backend:t}=n,{x:r}=e;return t.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const Kre={kernelName:Uf,backendName:"cpu",kernelFunc:DA};function dL(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{alpha:o}=r;Kt([s],"leakyRelu");const A=Ye(s.shape),u=t.data.get(s.dataId).values,h=Oe("float32",A);for(let l=0;l<u.length;l++)h[l]=u[l]<0?o*u[l]:u[l];return t.makeTensorInfo(s.shape,"float32",h)}const qre={kernelName:Y0,backendName:"cpu",kernelFunc:dL};function vs(n){return(e,t,r,s,o)=>{const A=Bn(e,t),u=A.length,h=Je(A),l=Oe(o,Ye(A)),c=e.length,d=t.length,m=Je(e),y=Je(t),b=Sp(e,A),v=Sp(t,A);if(b.length+v.length===0)for(let w=0;w<l.length;++w)l[w]=n(r[w%r.length],s[w%s.length]);else for(let w=0;w<l.length;++w){const I=is(w,u,h),S=I.slice(-c);b.forEach(W=>S[W]=0);const T=ms(S,c,m),D=I.slice(-d);v.forEach(W=>D[W]=0);const L=ms(D,d,y);l[w]=n(r[T],s[L])}return[l,A]}}const Jre=vs((n,e)=>n<0?e*n:n);function pL(n){const{inputs:e,backend:t}=n,{x:r,alpha:s}=e;Kt([r,s],"prelu");const o=t.data.get(r.dataId).values,A=t.data.get(s.dataId).values,[u,h]=Jre(r.shape,s.shape,o,A,r.dtype);return t.makeTensorInfo(h,r.dtype,u)}const $re={kernelName:cv,backendName:"cpu",kernelFunc:pL},hL=hr(am,n=>Math.max(0,n)),_re={kernelName:am,backendName:"cpu",kernelFunc:hL},fL=hr(om,n=>Math.min(Math.max(0,n),6)),ese={kernelName:om,backendName:"cpu",kernelFunc:fL};function ku(n){return(e,t,r)=>{const s=Oe(t,e.length);for(let o=0;o<e.length;++o)s[o]=n(e[o],r);return s}}const tse=ku(n=>1/(1+Math.exp(-n))),mL=hr(pm,n=>1/(1+Math.exp(-n))),nse={kernelName:pm,backendName:"cpu",kernelFunc:mL};function Q3(n,e,t,r,s){if(t==="linear")return DA({inputs:{x:e},backend:n});if(t==="relu")return hL({inputs:{x:e},backend:n});if(t==="elu")return cL({inputs:{x:e},backend:n});if(t==="relu6")return fL({inputs:{x:e},backend:n});if(t==="prelu")return pL({inputs:{x:e,alpha:r},backend:n});if(t==="leakyrelu")return dL({inputs:{x:e},backend:n,attrs:{alpha:s}});if(t==="sigmoid")return mL({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}function So(n){const{inputs:e,backend:t}=n,{real:r,imag:s}=e,o=t.data.get(r.dataId).values,A=t.data.get(s.dataId).values,u=t.makeTensorInfo(r.shape,"complex64");return t.data.get(u.dataId).complexTensorInfos={real:t.makeTensorInfo(r.shape,"float32",o),imag:t.makeTensorInfo(s.shape,"float32",A)},u}const rse={kernelName:Fa,backendName:"cpu",kernelFunc:So};function Gx(n,e,t="float32"){if(t==="complex64")return So({inputs:{real:Gx(n,e,"float32"),imag:Gx(n,e,"float32")},backend:n});const r=Mr(Ye(e),t);return n.makeTensorInfo(e,t,r)}function Yc(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.data.get(r.dataId).complexTensorInfos.real,o=t.data.get(s.dataId).values;return t.makeTensorInfo(s.shape,s.dtype,o)}const sse={kernelName:qC,backendName:"cpu",kernelFunc:Yc};function Cu(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dtype:o}=r;if(o==="complex64"){if(s.dtype==="complex64")return DA({inputs:{x:s},backend:t});const A=Gx(t,s.shape,s.dtype),u=Cu({inputs:{x:s},backend:t,attrs:{dtype:"float32"}}),h=So({inputs:{real:u,imag:A},backend:t});return t.disposeIntermediateTensorInfo(A),t.disposeIntermediateTensorInfo(u),h}if(s.dtype==="complex64"){const A=Yc({inputs:{input:s},backend:t}),u=Cu({inputs:{x:A},backend:t,attrs:{dtype:o}});return t.disposeIntermediateTensorInfo(A),u}if(!nn(s.dtype,o)){const A=DA({inputs:{x:s},backend:t});return{dataId:A.dataId,shape:A.shape,dtype:o}}if(o==="int32"){const A=t.data.get(s.dataId).values,u=Int32Array.from(A);return t.makeTensorInfo(s.shape,"int32",u)}if(o==="bool"){const A=t.data.get(s.dataId).values,u=Cc([0],s.dtype),[h,l]=vs((c,d)=>c!==d?1:0)(s.shape,[],A,u,"bool");return t.makeTensorInfo(l,"bool",h)}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}const ase={kernelName:ra,backendName:"cpu",kernelFunc:Cu};function Ys(n,e,t,r){return t==null?({inputs:s,backend:o})=>{const{a:A,b:u}=s,h=o;Kt([A,u],n);const l=h.data.get(A.dataId).values,c=h.data.get(u.dataId).values,d=A.dtype==="string"?Lc(l):l,m=A.dtype==="string"?Lc(c):c,y=r||A.dtype,[b,v]=e(A.shape,u.shape,d,m,y);return h.makeTensorInfo(v,y,b)}:({inputs:s,backend:o})=>{const{a:A,b:u}=s,h=o;if(A.dtype==="complex64"||u.dtype==="complex64"){const l=Cu({inputs:{x:A},backend:h,attrs:{dtype:"complex64"}}),c=h.data.get(l.dataId),d=c.complexTensorInfos.real,m=c.complexTensorInfos.imag,y=h.data.get(d.dataId).values,b=h.data.get(m.dataId).values,v=Cu({inputs:{x:u},backend:h,attrs:{dtype:"complex64"}}),w=h.data.get(v.dataId),I=w.complexTensorInfos.real,S=w.complexTensorInfos.imag,T=h.data.get(I.dataId).values,D=h.data.get(S.dataId).values,[L,W,K]=t(A.shape,u.shape,y,b,T,D),U=h.makeTensorInfo(K,"float32",L),_=h.makeTensorInfo(K,"float32",W),ee=So({inputs:{real:U,imag:_},backend:h});return h.disposeIntermediateTensorInfo(l),h.disposeIntermediateTensorInfo(v),h.disposeIntermediateTensorInfo(U),h.disposeIntermediateTensorInfo(_),ee}{const l=h.data.get(A.dataId).values,c=h.data.get(u.dataId).values,d=r||A.dtype,[m,y]=e(A.shape,u.shape,l,c,d);return h.makeTensorInfo(y,d,m)}}}function K3(n){return(e,t,r,s,o,A)=>{const u=Bn(e,t),h=Ye(u),l=u.length,c=Je(u),d=Oe("float32",h),m=Oe("float32",h),y=Sp(e,u),b=Sp(t,u),v=fl(r,s),w=fl(o,A),I=e.length,S=Je(e),T=t.length,D=Je(t);if(y.length+b.length===0)for(let L=0;L<d.length;L++){const W=L%v.length,K=L%w.length,U=n(v[2*W],v[2*W+1],w[2*K],w[2*K+1]);d[L]=U.real,m[L]=U.imag}else for(let L=0;L<d.length;L++){const W=is(L,l,c),K=W.slice(-I);y.forEach(ce=>K[ce]=0);const U=ms(K,I,S),_=W.slice(-T);b.forEach(ce=>_[ce]=0);const ee=ms(_,T,D),re=n(v[2*U],v[2*U+1],w[2*ee],w[2*ee+1]);d[L]=re.real,m[L]=re.imag}return[d,m,u]}}const gL=vs((n,e)=>n+e),ose=K3((n,e,t,r)=>({real:n+t,imag:e+r})),ag=Ys(be,gL,ose),ise={kernelName:be,backendName:"cpu",kernelFunc:ag};function zr(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{shape:o}=r,A=Ye(s.shape),u=yn(o,A),h=Ye(u);J(A===h,()=>`The new shape (${u}) has ${h} elements and the old shape (${s.shape}) has ${A} elements. The new shape and old shape must have the same number of elements.`),t.incRef(s.dataId);const l=t.data.get(s.dataId);if(l.complexTensorInfos!=null){const c=l.complexTensorInfos.real,d=l.complexTensorInfos.imag;c.shape=u,d.shape=u}return{dataId:s.dataId,shape:u,dtype:s.dtype}}const Ase={kernelName:dv,backendName:"cpu",kernelFunc:zr};function yL(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:o}=e,{transposeA:A,transposeB:u}=r;Kt([s,o],"matMul");const h=s.shape.length,l=o.shape.length,c=A?s.shape[h-2]:s.shape[h-1],d=u?o.shape[l-1]:o.shape[l-2],m=A?s.shape[h-1]:s.shape[h-2],y=u?o.shape[l-2]:o.shape[l-1],b=s.shape.slice(0,-2),v=o.shape.slice(0,-2),w=Ye(b),I=Ye(v);J(h>=2&&l>=2&&(w===I||w===1||I===1),()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${b}) and (${v}).`);const S=(w>I?s.shape.slice(0,-2):o.shape.slice(0,-2)).concat([m,y]);J(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${s.shape} and ${o.shape} and transposeA=${A} and transposeB=${u} must match.`);const T=u?[I,y,d]:[I,d,y],D=zr({inputs:{x:s},backend:t,attrs:{shape:A?[w,c,m]:[w,m,c]}}),L=zr({inputs:{x:o},backend:t,attrs:{shape:T}}),W=A?D.shape[1]:D.shape[2],K=A?D.shape[2]:D.shape[1],U=u?L.shape[1]:L.shape[2],_=Math.max(w,I),ee=t.data.get(D.dataId).values,re=t.data.get(L.dataId).values,ce=Je(D.shape),we=Je(L.shape),[Ee,Pe,he]=A?[ce[0],1,ce[1]]:[ce[0],ce[1],1],[de,Ae,Se]=u?[1,we[1],we[0]]:[we[1],1,we[0]],Te=K*U,Ze=Wn([_,K,U],D.dtype),et=Ze.values,qe=t.blockSize;for(let Re=0;Re<_;Re++)for(let Ue=0;Ue<K;Ue+=qe)for(let ot=0;ot<U;ot+=qe)for(let yt=0;yt<W;yt+=qe){const Vt=Math.min(Ue+qe,K),ln=Math.min(ot+qe,U),en=Math.min(yt+qe,W);for(let Xt=Ue;Xt<Vt;Xt++)for(let hn=ot;hn<ln;hn++){let wn=0;for(let Fn=yt;Fn<en;Fn++){const In=Math.min(Re,w-1)*Ee,zn=Math.min(Re,I-1)*Se;wn+=ee[In+Xt*Pe+Fn*he]*re[Fn*de+hn*Ae+zn]}et[Re*Te+(Xt*U+hn)]+=wn}}return t.disposeIntermediateTensorInfo(D),t.disposeIntermediateTensorInfo(L),t.makeTensorInfo(S,Ze.dtype,Ze.values)}const lse={kernelName:sr,backendName:"cpu",kernelFunc:yL},use={kernelName:Sv,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:o,bias:A,preluActivationWeights:u}=e,{transposeA:h,transposeB:l,activation:c,leakyreluAlpha:d}=r;let m,y,b;const v=[];m=yL({inputs:{a:s,b:o},attrs:{transposeA:h,transposeB:l},backend:t}),A&&(y=ag({inputs:{a:m,b:A},backend:t}),v.push(m),m=y),c&&(b=Q3(t,m,c,u,d),v.push(m),m=b);for(const w of v)t.disposeIntermediateTensorInfo(w);return m}};function bL(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const cse={kernelName:sl,backendName:"cpu",kernelFunc:n=>{const{x:e}=n.inputs,t=n.backend;Kt(e,"abs");let r=new Float32Array(Ye(e.shape));return r=bL(t.data.get(e.dataId).values),t.makeOutput(r,e.shape,"float32")}},dse=hr(Hi,n=>Math.acos(n)),pse={kernelName:Hi,backendName:"cpu",kernelFunc:dse},hse=hr(ve,n=>Math.acosh(n)),fse={kernelName:ve,backendName:"cpu",kernelFunc:hse},mse={kernelName:Le,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t}=n,r=e;Kt(e,"addN");const s=r.map(u=>t.data.get(u.dataId).values),o=Wn(r[0].shape,r[0].dtype),A=o.values;for(let u=0;u<r.length;u++){const h=s[u];for(let l=0;l<A.length;l++)A[l]+=h[l]}return t.makeTensorInfo(o.shape,o.dtype,o.values)}};function q3(n,e,t,r,s){const o=e.length,A=Ye(e),u=Je(e),h=Je(s),l=Oe(t,Ye(s));for(let c=0;c<A;++c){const d=is(c,o,u),m=new Array(d.length);for(let y=0;y<m.length;y++)m[y]=d[r[y]];l[ms(m,o,h)]=n[c]}return l}function ei(n){const{inputs:e,attrs:t,backend:r}=n,{x:s}=e,{perm:o}=t;Kt(s,"transpose");const A=s.shape.length,u=new Array(A);for(let l=0;l<u.length;l++)u[l]=s.shape[o[l]];const h=q3(r.data.get(s.dataId).values,s.shape,s.dtype,o,u);return{dataId:r.write(h,u,s.dtype),shape:u,dtype:s.dtype}}const gse={kernelName:wv,backendName:"cpu",kernelFunc:ei},yse={kernelName:at,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:A}=r;Kt(s,"all");const u=pt(o,s.shape);let h=u;const l=cs(h,s.shape.length);let c=s;l!=null&&(c=ei({inputs:{x:s},backend:t,attrs:{perm:l}}),h=bs(h.length,s.shape.length)),ia("all",h,c.shape.length);const[d,m]=Xs(c.shape,h),y=Ye(m),b=Mr(Ye(d),c.dtype),v=t.data.get(c.dataId).values;for(let I=0;I<b.length;++I){const S=I*y;let T=v[S];for(let D=0;D<y;++D){const L=v[S+D];T=T&&L}b[I]=T}l!=null&&t.disposeIntermediateTensorInfo(c);const w=t.makeTensorInfo(d,c.dtype,b);if(A){const I=zr({inputs:{x:w},backend:t,attrs:{shape:us(d,u)}});return t.disposeIntermediateTensorInfo(w),I}return w}},bse={kernelName:lt,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:A}=r;Kt(s,"any");const u=pt(o,s.shape);let h=u;const l=cs(h,s.shape.length);let c=s;l!=null&&(c=ei({inputs:{x:s},backend:t,attrs:{perm:l}}),h=bs(h.length,s.shape.length)),ia("any",h,c.shape.length);const[d,m]=Xs(c.shape,h),y=Ye(m),b=Mr(Ye(d),c.dtype),v=t.data.get(c.dataId).values;for(let I=0;I<b.length;++I){const S=I*y;let T=v[S];for(let D=0;D<y;++D){const L=v[S+D];T=T||L}b[I]=T}l!=null&&t.disposeIntermediateTensorInfo(c);const w=t.makeTensorInfo(d,c.dtype,b);if(A){const I=zr({inputs:{x:w},backend:t,attrs:{shape:us(d,u)}});return t.disposeIntermediateTensorInfo(w),I}return w}},vse={kernelName:ct,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o}=r;Kt(s,"argMax");let A=pt(o,s.shape);const u=cs(A,s.shape.length);let h=s;const l=[];u!=null&&(h=ei({inputs:{x:s},backend:t,attrs:{perm:u}}),l.push(h),A=bs(A.length,h.shape.length)),A=[A[0]],ia("argMax",A,h.shape.length);const[c,d]=Xs(h.shape,A),m=Mr(Ye(c),"int32"),y=Ye(d),b=t.data.get(h.dataId).values;for(let v=0;v<m.length;++v){const w=v*y;let I=b[w],S=0;for(let T=0;T<y;++T){const D=b[w+T];D>I&&(I=D,S=T)}m[v]=S}return l.forEach(v=>t.disposeIntermediateTensorInfo(v)),t.makeTensorInfo(c,"int32",m)}},xse={kernelName:St,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o}=r;Kt(s,"argMin");let A=pt(o,s.shape);const u=cs(A,s.shape.length);let h=s;const l=[];u!=null&&(h=ei({inputs:{x:s},backend:t,attrs:{perm:u}}),l.push(h),A=bs(A.length,h.shape.length)),A=[A[0]],ia("argMin",A,h.shape.length);const[c,d]=Xs(h.shape,A),m=Mr(Ye(c),"int32"),y=Ye(d),b=t.data.get(h.dataId).values;for(let v=0;v<m.length;++v){const w=v*y;let I=b[w],S=0;for(let T=0;T<y;++T){const D=b[w+T];D<I&&(I=D,S=T)}m[v]=S}return l.forEach(v=>t.disposeIntermediateTensorInfo(v)),t.makeTensorInfo(c,"int32",m)}},wse=hr(nt,n=>Math.asin(n)),kse={kernelName:nt,backendName:"cpu",kernelFunc:wse},Cse=hr(Ot,n=>Math.asinh(n)),Ise={kernelName:Ot,backendName:"cpu",kernelFunc:Cse},Sse=hr(Pt,n=>Math.atan(n)),Nse={kernelName:Pt,backendName:"cpu",kernelFunc:Sse},Tse=vs((n,e)=>Math.atan2(n,e)),Mse=Ys(Pn,Tse),Ese={kernelName:Pn,backendName:"cpu",kernelFunc:Mse},Dse=hr(Bt,n=>Math.atanh(n)),zse={kernelName:Bt,backendName:"cpu",kernelFunc:Dse};function J3(n,e,t,r,s,o){const A=s.strideHeight,u=s.strideWidth,h=s.dilationHeight,l=s.dilationWidth,c=s.effectiveFilterHeight,d=s.effectiveFilterWidth,m=s.padInfo.top,y=s.padInfo.left,b=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=Wn(s.outShape,t),w=v.values,I=s.outShape[1]*s.outShape[2]*s.outShape[3],S=s.outShape[2]*s.outShape[3],T=s.outShape[3];for(let D=0;D<s.batchSize;++D){const L=D*I,W=D*r[0];for(let K=0;K<s.inChannels;++K)for(let U=0;U<s.outHeight;++U){const _=U*A-m,ee=Math.max(0,_),re=Math.min(s.inHeight,c+_),ce=L+U*S;for(let we=0;we<s.outWidth;++we){const Ee=we*u-y,Pe=Math.max(0,Ee),he=Math.min(s.inWidth,d+Ee);let de=b,Ae=0,Se=0;for(let Te=ee;Te<re;Te+=h){const Ze=W+Te*r[1];for(let et=Pe;et<he;et+=l){const qe=n[Ze+et*r[2]+K];o==="max"&&qe>de?de=qe:o==="avg"&&(Ae+=qe,Se++)}if(isNaN(de))break}w[ce+we*T+K]=o==="avg"?Ae/Se:de}}}return v}function vL(n,e,t,r,s=!1,o=!1){const A=Wn(r.outShape,"int32"),u=r.strideHeight,h=r.strideWidth,l=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,m=r.effectiveFilterWidth,y=r.padInfo.top,b=r.padInfo.left,v=Wn(e,t,n);for(let w=0;w<r.batchSize;++w)for(let I=0;I<r.inChannels;++I)for(let S=0;S<r.outHeight;++S){const T=S*u-y;let D=T;for(;D<0;)D+=l;const L=Math.min(r.inHeight,d+T);for(let W=0;W<r.outWidth;++W){const K=W*h-b;let U=K;for(;U<0;)U+=c;const _=Math.min(r.inWidth,m+K);let ee=Number.NEGATIVE_INFINITY,re=-1;for(let ce=D;ce<L;ce+=l){const we=ce-T;for(let Ee=U;Ee<_;Ee+=c){const Pe=Ee-K,he=v.get(w,ce,Ee,I);he>ee&&(ee=he,re=s?o?((w*r.inHeight+ce)*r.inWidth+Ee)*r.inChannels+I:(ce*r.inWidth+Ee)*r.inChannels+I:we*m+Pe)}}A.set(re,w,S,W,I)}}return A}function xL(n,e,t,r,s,o){const A=s.strideDepth,u=s.strideHeight,h=s.strideWidth,l=s.dilationDepth,c=s.dilationHeight,d=s.dilationWidth,m=s.effectiveFilterDepth,y=s.effectiveFilterHeight,b=s.effectiveFilterWidth,v=s.padInfo.front,w=s.padInfo.top,I=s.padInfo.left,S=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,T=Wn(s.outShape,t),D=T.values,L=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],W=s.outShape[2]*s.outShape[3]*s.outShape[4],K=s.outShape[3]*s.outShape[4],U=s.outShape[4];for(let _=0;_<s.batchSize;++_){const ee=_*L,re=_*r[0];for(let ce=0;ce<s.inChannels;++ce)for(let we=0;we<s.outDepth;++we){const Ee=we*A-v;let Pe=Ee;for(;Pe<0;)Pe+=l;const he=Math.min(s.inDepth,m+Ee),de=ee+we*W;for(let Ae=0;Ae<s.outHeight;++Ae){const Se=Ae*u-w;let Te=Se;for(;Te<0;)Te+=c;const Ze=Math.min(s.inHeight,y+Se),et=de+Ae*K;for(let qe=0;qe<s.outWidth;++qe){const Re=qe*h-I;let Ue=Re;for(;Ue<0;)Ue+=d;const ot=Math.min(s.inWidth,b+Re),yt=et+qe*U;let Vt=S,ln=0,en=0;for(let Xt=Pe;Xt<he;Xt+=l){const hn=re+Xt*r[1];for(let wn=Te;wn<Ze;wn+=c){const Fn=hn+wn*r[2];for(let In=Ue;In<ot;In+=d){const zn=n[Fn+In*r[3]+ce];if(o==="max"&&zn>Vt?Vt=zn:o==="avg"&&(ln+=zn,en++),isNaN(Vt))break}if(isNaN(Vt))break}if(isNaN(Vt))break}D[yt+ce]=o==="avg"?ln/en:Vt}}}}return T}const Ose={kernelName:Zn,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;Kt(s,"avgPool");const{filterSize:o,strides:A,pad:u,dimRoundingMode:h}=r;J(oa(A,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${A} and dilations '1'`);const l=bi(s.shape,o,A,1,u,h);let c;if(l.filterWidth===1&&l.filterHeight===1&&ht(l.inShape,l.outShape))c=DA({inputs:{x:s},backend:t});else{const d=t.data.get(s.dataId).values,m=Je(s.shape),y=J3(d,s.shape,s.dtype,m,l,"avg");c=t.makeTensorInfo(l.outShape,s.dtype,y.values)}return c}},Pse={kernelName:$r,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:o,strides:A,pad:u,dimRoundingMode:h,dataFormat:l}=r;Kt(s,"avgPool3d");const c=ul(s.shape,o,A,1,u,h,l),d=xL(t.data.get(s.dataId).values,s.shape,s.dtype,Je(s.shape),c,"avg");return t.makeTensorInfo(d.shape,"float32",d.values)}},Bse={kernelName:gs,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:o}=e,{filterSize:A,strides:u,pad:h,dimRoundingMode:l}=r;Kt([s,o],"avgPool3DGrad");const c=ul(o.shape,A,u,1,h,l),d=c.strideDepth,m=c.strideHeight,y=c.strideWidth,b=c.filterDepth,v=c.filterHeight,w=c.filterWidth,I=c.dilationDepth,S=c.dilationHeight,T=c.dilationWidth,D=c.effectiveFilterDepth,L=c.effectiveFilterHeight,W=c.effectiveFilterWidth,K=D-1-c.padInfo.front,U=W-1-c.padInfo.left,_=L-1-c.padInfo.top,ee=Wn(o.shape,"float32"),re=1/(b*v*w),ce=t.bufferSync(s);for(let we=0;we<c.batchSize;++we)for(let Ee=0;Ee<c.inChannels;++Ee)for(let Pe=0;Pe<c.inDepth;++Pe)for(let he=0;he<c.inHeight;++he)for(let de=0;de<c.inWidth;++de){const Ae=Pe-K,Se=he-_,Te=de-U;let Ze=0;for(let et=0;et<D;et+=I){const qe=(Ae+et)/d;if(!(qe<0||qe>=c.outDepth||Math.floor(qe)!==qe))for(let Re=0;Re<L;Re+=S){const Ue=(Se+Re)/m;if(!(Ue<0||Ue>=c.outHeight||Math.floor(Ue)!==Ue))for(let ot=0;ot<W;ot+=T){const yt=(Te+ot)/y;yt<0||yt>=c.outWidth||Math.floor(yt)!==yt||(Ze+=ce.get(we,qe,Ue,yt,Ee))}}}ee.set(Ze*re,we,Pe,he,de,Ee)}return t.makeTensorInfo(ee.shape,ee.dtype,ee.values)}},Fse={kernelName:Rr,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:o}=e,A=o;Kt([s,o],"avgPoolGrad");const{filterSize:u,strides:h,pad:l}=r,c=bi(A.shape,u,h,1,l),d=c.strideHeight,m=c.strideWidth,y=c.filterHeight,b=c.filterWidth,v=c.dilationHeight,w=c.dilationWidth,I=c.effectiveFilterHeight,S=c.effectiveFilterWidth,T=S-1-c.padInfo.left,D=I-1-c.padInfo.top,L=Wn(A.shape,"float32"),W=1/(y*b),K=t.data.get(s.dataId).values,U=Wn(s.shape,"float32",K);for(let _=0;_<c.batchSize;++_)for(let ee=0;ee<c.inChannels;++ee)for(let re=0;re<c.inHeight;++re)for(let ce=0;ce<c.inWidth;++ce){const we=re-D,Ee=ce-T;let Pe=0;for(let he=0;he<I;he+=v){const de=(we+he)/d;if(!(de<0||de>=c.outHeight||Math.floor(de)!==de))for(let Ae=0;Ae<S;Ae+=w){const Se=(Ee+Ae)/m;Se<0||Se>=c.outWidth||Math.floor(Se)!==Se||(Pe+=U.get(_,de,Se,ee))}}L.set(Pe*W,_,re,ce,ee)}return t.makeTensorInfo(L.shape,L.dtype,L.values)}},Lse={kernelName:V0,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,scale:o,offset:A,mean:u,variance:h}=e;J(u.shape.length===h.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),J(A==null||u.shape.length===A.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),J(o==null||u.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Kt([s,u,h,o,A],"batchNorm");let{varianceEpsilon:l}=r;l==null&&(l=.001);const c=t.data.get(s.dataId).values,d=t.data.get(u.dataId).values,m=t.data.get(h.dataId).values,y=o?t.data.get(o.dataId).values:new Float32Array([1]),b=A?t.data.get(A.dataId).values:new Float32Array([0]),v=new Float32Array(c.length),w=b.length,I=y.length,S=m.length,T=d.length;let D=0,L=0,W=0,K=0;for(let U=0;U<c.length;++U)v[U]=b[D++]+(c[U]-d[L++])*y[W++]/Math.sqrt(m[K++]+l),D>=w&&(D=0),L>=T&&(L=0),W>=I&&(W=0),K>=S&&(K=0);return t.makeTensorInfo(s.shape,s.dtype,v)}};function wL(n,e,t,r,s){const o=zI(r,e,t),A=Ye(t),u=Je(r);if(o){const c=OI(e,u);return s==="string"?n.slice(c,c+A):n.subarray(c,c+A)}const h=Wn(r,s,s==="string"?Lc(n):n),l=Wn(t,s);for(let c=0;c<l.size;++c){const d=l.indexToLoc(c),m=d.map((y,b)=>y+e[b]);l.set(h.get(...m),...d)}return s==="string"?Q4(l.values):l.values}function Uc(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:o,size:A}=r;Kt(s,"slice");const[u,h]=jv(s,o,A);DI(s,u,h);const l=wL(t.data.get(s.dataId).values,u,h,s.shape,s.dtype);return t.makeTensorInfo(h,s.dtype,l)}const Rse={kernelName:gv,backendName:"cpu",kernelFunc:Uc},Wse={kernelName:vn,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:o,crops:A}=r;Kt([s],"batchToSpaceND");const u=o.reduce((I,S)=>I*S),h=Rm(s.shape,o,u),l=Wm(h.length,o.length),c=jm(s.shape,o,u),d=wS(A,o.length),m=kS(c,A,o.length),y=zr({inputs:{x:s},backend:t,attrs:{shape:h}}),b=ei({inputs:{x:y},backend:t,attrs:{perm:l}}),v=zr({inputs:{x:b},backend:t,attrs:{shape:c}}),w=Uc({inputs:{x:v},backend:t,attrs:{begin:d,size:m}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(v),w}};function $3(n,e,t,r,s){const o=Ye(r),A=Mr(s,t);for(let u=0;u<n.length;u++){const h=n[u];if(h<0)throw new Error("Input x must be non-negative!");h>=s||(A[h]+=o>0?e[u]:1)}return A}function kL(n,e,t,r=!1){const s=n.shape[0],o=n.shape[1],A=Wn([s,t],e.dtype);for(let u=0;u<s;u++)for(let h=0;h<o;h++){const l=n.get(u,h);if(l<0)throw new Error("Input x must be non-negative!");l>=t||(r?A.set(1,u,l):e.size>0?A.set(A.get(u,l)+e.get(u,h),u,l):A.set(A.get(u,l)+1,u,l))}return A}const jse={kernelName:va,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:o}=e,{size:A}=r,u=$3(t.data.get(s.dataId).values,t.data.get(o.dataId).values,o.dtype,o.shape,A);return t.makeTensorInfo([A],o.dtype,u)}},Hse={kernelName:Gi,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t}=n,{s0:r,s1:s}=e,o=t.data.get(r.dataId).values,A=t.data.get(s.dataId).values,u=Bn(Array.from(o),Array.from(A));return t.makeTensorInfo([u.length],"int32",Int32Array.from(u))}},CL=ku(n=>Math.ceil(n)),Gse=Wp(Wr,CL),Vse={kernelName:Wr,backendName:"cpu",kernelFunc:Gse},Xse=hr(xa,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),Zse={kernelName:xa,backendName:"cpu",kernelFunc:Xse},Yse={kernelName:$,backendName:"cpu",kernelFunc:n=>{const{x:e}=n.inputs,t=n.backend,r=new Float32Array(Ye(e.shape)),s=t.data.get(e.dataId),o=s.complexTensorInfos.real,A=s.complexTensorInfos.imag,u=t.data.get(o.dataId).values,h=t.data.get(A.dataId).values;for(let l=0;l<u.length;l++){const c=u[l],d=h[l];r[l]=Math.hypot(c,d)}return t.makeOutput(r,e.shape,"float32")}};function IL(n,e,t,r){const s=Tt(t,Ye(e));if(r&&t!=="string"){let o=0;n.forEach(A=>{const u=Ye(A.shape);s.set(A.vals,o),o+=u})}else{let o=0;n.forEach(A=>{const u=t==="string"?Lc(A.vals):A.vals;let h=0;for(let l=0;l<A.shape[0];++l){const c=l*e[1]+o;for(let d=0;d<A.shape[1];++d)s[c+d]=u[h++]}o+=A.shape[1]})}return s}function jp(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.data.get(r.dataId).complexTensorInfos.imag,o=t.data.get(s.dataId).values;return t.makeTensorInfo(s.shape,s.dtype,o)}const Use={kernelName:RC,backendName:"cpu",kernelFunc:jp};function Hp(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r,o=pt(s,e[0].shape)[0];let A=SA(e.map(b=>b.shape),o);if(Ye(A)===0)return t.makeTensorInfo(A,e[0].dtype,[]);const u=e.filter(b=>Ye(b.shape)>0);if(u.length===1)return DA({inputs:{x:u[0]},backend:t});if(bS(u.map(b=>b.shape),o),u[0].dtype==="complex64"){const b=u.map(T=>Yc({inputs:{input:T},backend:t})),v=u.map(T=>jp({inputs:{input:T},backend:t})),w=Hp({inputs:b,backend:t,attrs:{axis:o}}),I=Hp({inputs:v,backend:t,attrs:{axis:o}}),S=So({inputs:{real:w,imag:I},backend:t});return b.forEach(T=>t.disposeIntermediateTensorInfo(T)),v.forEach(T=>t.disposeIntermediateTensorInfo(T)),t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(I),S}const h=u.map(b=>{const v=Ye(b.shape.slice(o));return zr({inputs:{x:b},backend:t,attrs:{shape:[-1,v]}})}),l=h.map(b=>({vals:t.data.get(b.dataId).values,shape:b.shape}));A=SA(h.map(b=>b.shape),1);const c=h[0].shape[0]===1,d=IL(l,A,e[0].dtype,c),m=SA(u.map(b=>b.shape),o),y=t.makeTensorInfo(m,e[0].dtype,d);return h.forEach(b=>t.disposeIntermediateTensorInfo(b)),y}const Qse={kernelName:ne,backendName:"cpu",kernelFunc:Hp};function SL(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o}=e,{strides:A,pad:u,dataFormat:h,dilations:l,dimRoundingMode:c}=r;Kt([s,o],"conv2d");const d=cl(h),m=Vs(s.shape,o.shape,A,l,u,c,!1,d),y=m.filterHeight,b=m.filterWidth,v=m.dilationHeight,w=m.dilationWidth,I=m.padInfo.left,S=m.padInfo.top,T=m.dataFormat==="channelsLast",D=new Gs(m.outShape,s.dtype),L=Je(s.shape),W=Je(o.shape),K=L[0],U=T?L[1]:L[2],_=T?L[2]:1,ee=T?1:L[1],re=D.strides[0],ce=T?D.strides[1]:D.strides[2],we=T?D.strides[2]:1,Ee=T?1:D.strides[1],Pe=t.data.get(s.dataId).values,he=t.data.get(o.dataId).values,de=D.values;for(let Ae=0;Ae<m.batchSize;++Ae){const Se=Ae*K,Te=Ae*re;for(let Ze=0;Ze<m.outHeight;++Ze){const et=Te+Ze*ce,qe=Ze*m.strideHeight-S;for(let Re=0;Re<y;++Re){const Ue=qe+Re*v;if(Ue<0||Ue>=m.inHeight)continue;const ot=Re*W[0],yt=Se+Ue*U;for(let Vt=0;Vt<m.outWidth;++Vt){const ln=et+Vt*we,en=Vt*m.strideWidth-I;for(let Xt=0;Xt<b;++Xt){const hn=en+Xt*w;if(hn<0||hn>=m.inWidth)continue;const wn=yt+hn*_;let Fn=ot+Xt*W[1];for(let In=0;In<m.inChannels;++In){const zn=Pe[wn+In*ee];for(let Kn=0;Kn<m.outChannels;++Kn)de[ln+Kn*Ee]+=zn*he[Fn+Kn];Fn+=m.outChannels}}}}}}return t.makeTensorInfo(D.shape,D.dtype,de)}const Kse={kernelName:Ce,backendName:"cpu",kernelFunc:SL},qse={kernelName:He,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:o}=e,{strides:A,pad:u,dataFormat:h,dimRoundingMode:l,filterShape:c}=r;Kt([s,o],"conv2dBackpropFilter");const d=cl(h),m=Vs(s.shape,c,A,1,u,l,!1,d),{strideHeight:y,strideWidth:b,filterHeight:v,filterWidth:w}=m,I=m.dataFormat==="channelsLast",S=new Gs(m.filterShape,"float32"),T=m.padInfo.left,D=m.padInfo.top,L=t.data.get(s.dataId).values,W=t.data.get(o.dataId).values,K=new Gs(s.shape,s.dtype,L),U=new Gs(o.shape,o.dtype,W);for(let _=0;_<v;++_){const ee=Math.max(0,Math.ceil((D-_)/y)),re=Math.min(m.outHeight,(m.inHeight+D-_)/y);for(let ce=0;ce<w;++ce){const we=Math.max(0,Math.ceil((T-ce)/b)),Ee=Math.min(m.outWidth,(m.inWidth+T-ce)/b);for(let Pe=0;Pe<m.inChannels;++Pe)for(let he=0;he<m.outChannels;++he){let de=0;for(let Ae=0;Ae<m.batchSize;++Ae)for(let Se=ee;Se<re;++Se){const Te=_+Se*y-D;for(let Ze=we;Ze<Ee;++Ze){const et=ce+Ze*b-T;de+=I?K.get(Ae,Te,et,Pe)*U.get(Ae,Se,Ze,he):K.get(Ae,Pe,Te,et)*U.get(Ae,he,Se,Ze)}}S.set(de,_,ce,Pe,he)}}}return t.makeTensorInfo(S.shape,S.dtype,S.values)}},Jse={kernelName:_e,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:o}=e,{inputShape:A,strides:u,pad:h,dataFormat:l,dimRoundingMode:c}=r;Kt([s,o],"conv2dBackpropInput");const d=Je(o.shape),m=Je(s.shape);let y=cl(l);const b=Vs(A,o.shape,u,1,h,c,!1,y),v=new Gs(b.inShape,"float32"),w=v.values,I=t.data.get(s.dataId).values,S=t.data.get(o.dataId).values,[T,D,L]=d,{batchSize:W,filterHeight:K,filterWidth:U,inChannels:_,inHeight:ee,inWidth:re,outChannels:ce,outHeight:we,outWidth:Ee,strideHeight:Pe,strideWidth:he}=b;y=b.dataFormat;const de=K-1-b.padInfo.top,Ae=U-1-b.padInfo.left,Se=y==="channelsLast",Te=v.strides[0],Ze=Se?v.strides[1]:v.strides[2],et=Se?v.strides[2]:1,qe=Se?1:v.strides[1],Re=m[0],Ue=Se?m[1]:m[2],ot=Se?m[2]:1,yt=Se?1:m[1];for(let Vt=0;Vt<W;++Vt)for(let ln=0;ln<_;++ln)for(let en=0;en<ee;++en){const Xt=en-de,hn=Math.max(0,Math.ceil(Xt/Pe)),wn=Math.min(we,(K+Xt)/Pe);for(let Fn=0;Fn<re;++Fn){const In=Fn-Ae,zn=Math.max(0,Math.ceil(In/he)),Kn=Math.min(Ee,(U+In)/he);let Ls=0;for(let Na=hn;Na<wn;++Na){const da=Na*Pe-Xt;for(let Nr=zn;Nr<Kn;++Nr){const zo=Re*Vt+Ue*Na+ot*Nr,pa=T*(K-1-da)+D*(U-1-(Nr*he-In))+L*ln;for(let Oo=0;Oo<ce;++Oo)Ls+=I[zo+yt*Oo]*S[pa+Oo]}}w[Te*Vt+Ze*en+et*Fn+qe*ln]=Ls}}return t.makeTensorInfo(v.shape,v.dtype,v.values)}},$se={kernelName:$e,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o}=e,{strides:A,pad:u,dilations:h}=r;Kt([s,o],"conv3d");const l=Au(s.shape,o.shape,A,h,u),{filterDepth:c,filterHeight:d,filterWidth:m,dilationDepth:y,dilationHeight:b,dilationWidth:v,padInfo:w}=l,I=w.front,S=w.left,T=w.top,D=new Gs(l.outShape,s.dtype),L=t.data.get(s.dataId).values,W=t.data.get(o.dataId).values,K=D.values,U=Je(s.shape),_=Je(o.shape);for(let ee=0;ee<l.batchSize;++ee){const re=ee*U[0],ce=ee*D.strides[0];for(let we=0;we<l.outDepth;++we){const Ee=ce+we*D.strides[1],Pe=we*l.strideDepth-I;for(let he=0;he<c;++he){const de=Pe+he*y;if(de<0||de>=l.inDepth)continue;const Ae=he*_[0],Se=re+de*U[1];for(let Te=0;Te<l.outHeight;++Te){const Ze=Ee+Te*D.strides[2],et=Te*l.strideHeight-T;for(let qe=0;qe<d;++qe){const Re=et+qe*b;if(Re<0||Re>=l.inHeight)continue;const Ue=Ae+qe*_[1],ot=Se+Re*U[2];for(let yt=0;yt<l.outWidth;++yt){const Vt=Ze+yt*l.outChannels,ln=yt*l.strideWidth-S;for(let en=0;en<m;++en){const Xt=ln+en*v;if(Xt<0||Xt>=l.inWidth)continue;const hn=Ue+en*_[2],wn=ot+Xt*l.inChannels;let Fn=hn;for(let In=0;In<l.inChannels;++In){const zn=L[wn+In];for(let Kn=0;Kn<l.outChannels;++Kn)K[Vt+Kn]+=zn*W[Fn+Kn];Fn+=l.outChannels}}}}}}}}return t.makeTensorInfo(D.shape,D.dtype,D.values)}},_se={kernelName:xt,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:o}=e,{strides:A,pad:u,filterShape:h}=r;Kt([s,o],"conv3dBackpropFilterV2");const l=Je(s.shape),c=Je(o.shape),d=Au(s.shape,h,A,1,u),m=d.strideDepth,y=d.strideHeight,b=d.strideWidth,v=d.filterDepth,w=d.filterHeight,I=d.filterWidth,S=new Gs(d.filterShape,"float32"),T=S.values,[D,L,W,K]=S.strides,U=t.data.get(o.dataId).values,[_,ee,re,ce]=c,we=t.data.get(s.dataId).values,[Ee,Pe,he,de]=l,Ae=d.padInfo.front,Se=d.padInfo.left,Te=d.padInfo.top;for(let Ze=0;Ze<v;++Ze){const et=Math.max(0,Math.ceil((Ae-Ze)/m)),qe=Math.min(d.outDepth,(d.inDepth+Ae-Ze)/m),Re=Ze*D;for(let Ue=0;Ue<w;++Ue){const ot=Math.max(0,Math.ceil((Te-Ue)/y)),yt=Math.min(d.outHeight,(d.inHeight+Te-Ue)/y),Vt=Ue*L+Re;for(let ln=0;ln<I;++ln){const en=Math.max(0,Math.ceil((Se-ln)/b)),Xt=Math.min(d.outWidth,(d.inWidth+Se-ln)/b),hn=ln*W+Vt;for(let wn=0;wn<d.inChannels;++wn){const Fn=wn*K+hn;for(let In=0;In<d.outChannels;++In){let zn=0;for(let Kn=0;Kn<d.batchSize;++Kn){const Ls=Kn*Ee,Na=Kn*_;for(let da=et;da<qe;++da){const Nr=(Ze+da*m-Ae)*Pe+Ls,zo=da*ee+Na;for(let pa=ot;pa<yt;++pa){const Oo=(Ue+pa*y-Te)*he+Nr,aA=pa*re+zo;for(let qu=en;qu<Xt;++qu){const Nl=qu*ce+aA;zn+=we[(ln+qu*b-Se)*de+Oo+wn]*U[Nl+In]}}}}T[Fn+In]=zn}}}}}return t.makeTensorInfo(S.shape,S.dtype,S.values)}},eae={kernelName:sn,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:o}=e,{pad:A,strides:u,inputShape:h}=r;Kt([s],"conv3dBackpropInputV2");const l=Je(s.shape),c=Je(o.shape),d=Au(h,o.shape,u,1,A),m=new Gs(d.inShape,"float32"),y=m.values,[b,v,w,I]=m.strides,S=t.data.get(s.dataId).values,[T,D,L,W]=l,K=t.data.get(o.dataId).values,[U,_,ee,re]=c,{batchSize:ce,filterDepth:we,filterHeight:Ee,filterWidth:Pe,inChannels:he,inDepth:de,inHeight:Ae,inWidth:Se,outChannels:Te,outDepth:Ze,outHeight:et,outWidth:qe,strideDepth:Re,strideHeight:Ue,strideWidth:ot}=d,yt=we-1-d.padInfo.front,Vt=Ee-1-d.padInfo.top,ln=Pe-1-d.padInfo.left;for(let en=0;en<ce;++en)for(let Xt=0;Xt<he;++Xt)for(let hn=0;hn<de;++hn){const wn=hn-yt,Fn=Math.max(0,Math.ceil(wn/Re)),In=Math.min(Ze,(we+wn)/Re);for(let zn=0;zn<Ae;++zn){const Kn=zn-Vt,Ls=Math.max(0,Math.ceil(Kn/Ue)),Na=Math.min(et,(Ee+Kn)/Ue);for(let da=0;da<Se;++da){const Nr=da-ln,zo=Math.max(0,Math.ceil(Nr/ot)),pa=Math.min(qe,(Pe+Nr)/ot);let Oo=0;for(let aA=Fn;aA<In;++aA){const qu=aA*Re-wn;for(let Nl=Ls;Nl<Na;++Nl){const Hbe=Nl*Ue-Kn;for(let Z1=zo;Z1<pa;++Z1){const Gbe=T*en+D*aA+L*Nl+W*Z1,Vbe=U*(we-1-qu)+_*(Ee-1-Hbe)+ee*(Pe-1-(Z1*ot-Nr))+re*Xt;for(let Y1=0;Y1<Te;++Y1)Oo+=S[Gbe+Y1]*K[Vbe+Y1]}}}y[b*en+v*hn+w*zn+I*da+Xt]=Oo}}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}},tae=hr(Cn,n=>Math.cos(n)),nae={kernelName:Cn,backendName:"cpu",kernelFunc:tae},rae=hr(ar,n=>Math.cosh(n)),sae={kernelName:ar,backendName:"cpu",kernelFunc:rae},aae={kernelName:Ja,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{image:s,boxes:o,boxInd:A}=e,{cropSize:u,method:h,extrapolationValue:l}=r,[c,d,m,y]=s.shape,b=o.shape[0],[v,w]=u,I=Wn([b,v,w,y],"float32"),S=t.data.get(o.dataId).values,T=t.data.get(A.dataId).values,D=t.data.get(s.dataId).values,L=Je(s.shape),W=Je(I.shape);for(let K=0;K<b;K++){const U=4*K,_=S[U],ee=S[U+1],re=S[U+2],ce=S[U+3],we=T[K];if(we>=c)continue;const Ee=v>1?(re-_)*(d-1)/(v-1):0,Pe=w>1?(ce-ee)*(m-1)/(w-1):0;for(let he=0;he<v;he++){const de=v>1?_*(d-1)+he*Ee:.5*(_+re)*(d-1);if(de<0||de>d-1)for(let Ae=0;Ae<w;Ae++)for(let Se=0;Se<y;Se++){const Te=Se+Ae*W[2]+he*W[1]+K*W[0];I.values[Te]=l}else if(h==="bilinear"){const Ae=Math.floor(de),Se=Math.ceil(de),Te=de-Ae;for(let Ze=0;Ze<w;Ze++){const et=w>1?ee*(m-1)+Ze*Pe:.5*(ee+ce)*(m-1);if(et<0||et>m-1){for(let ot=0;ot<y;ot++){const yt=ot+Ze*W[2]+he*W[1]+K*W[0];I.values[yt]=l}continue}const qe=Math.floor(et),Re=Math.ceil(et),Ue=et-qe;for(let ot=0;ot<y;ot++){let yt=ot+qe*L[2]+Ae*L[1]+we*L[0];const Vt=D[yt];yt=ot+Re*L[2]+Ae*L[1]+we*L[0];const ln=D[yt];yt=ot+qe*L[2]+Se*L[1]+we*L[0];const en=D[yt];yt=ot+Re*L[2]+Se*L[1]+we*L[0];const Xt=Vt+(ln-Vt)*Ue,hn=en+(D[yt]-en)*Ue;yt=ot+Ze*W[2]+he*W[1]+K*W[0],I.values[yt]=Xt+(hn-Xt)*Te}}}else for(let Ae=0;Ae<w;++Ae){const Se=w>1?ee*(m-1)+Ae*Pe:.5*(ee+ce)*(m-1);if(Se<0||Se>m-1){for(let et=0;et<y;et++){const qe=et+Ae*W[2]+he*W[1]+K*W[0];I.values[qe]=l}continue}const Te=Math.round(Se),Ze=Math.round(de);for(let et=0;et<y;et++){const qe=et+Te*L[2]+Ze*L[1]+we*L[0],Re=et+Ae*W[2]+he*W[1]+K*W[0];I.values[Re]=D[qe]}}}}return t.makeTensorInfo(I.shape,I.dtype,I.values)}},oae={kernelName:Jn,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,exclusive:A,reverse:u}=r;Kt(s,"cumsum");const h=cs([o],s.shape.length);let l=s;h!=null&&(l=ei({inputs:{x:s},backend:t,attrs:{perm:h}}));const c=bs(1,s.shape.length)[0];if(c!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);const d=Uo(l.dtype,"int32"),m=Mr(Ye(l.shape),d),y=t.data.get(l.dataId).values,b=l.shape[l.shape.length-1],v=u?(I,S)=>I+b-S-1:(I,S)=>I+S;for(let I=0;I<y.length;I+=b)for(let S=0;S<b;S++){const T=v(I,S);if(S===0)m[T]=A?0:y[T];else{const D=v(I,S-1);m[T]=A?y[D]+m[D]:y[T]+m[D]}}const w=t.makeTensorInfo(l.shape,d,m);if(h!=null){const I=ei({inputs:{x:w},backend:t,attrs:{perm:Np(h)}});return t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(l),I}return w}},iae={kernelName:xo,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:o}=e,{size:A,binaryOutput:u}=r;if(s.shape.length===1){const h=$3(t.data.get(s.dataId).values,t.data.get(o.dataId).values,o.dtype,o.shape,A);return t.makeTensorInfo([A],o.dtype,h)}if(s.shape.length===2){const h=kL(t.bufferSync(s),t.bufferSync(o),A,u);return t.makeTensorInfo(h.shape,o.dtype,h.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}},Aae={kernelName:Zo,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockSize:o,dataFormat:A}=r;J(A==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${A}`),J(o>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${o}`);const u=s.shape[0],h=s.shape[1],l=s.shape[2],c=s.shape[3],d=h*o,m=l*o,y=c/(o*o),b=t.data.get(s.dataId).values,v=new Float32Array(u*d*m*y);let w=0;for(let I=0;I<u;++I)for(let S=0;S<d;++S){const T=Math.floor(S/o),D=S%o;for(let L=0;L<m;++L){const W=Math.floor(L/o),K=(D*o+L%o)*y;for(let U=0;U<y;++U){const _=U+K+c*(W+l*(T+h*I));v[w++]=b[_]}}}return t.makeTensorInfo([u,d,m,y],s.dtype,v)}};function NL(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o}=e,{strides:A,pad:u,dilations:h,dimRoundingMode:l}=r;Kt([s,o],"depthwiseConv2DNative");const c=Je(s.shape),d=Je(o.shape);let m=h;m==null&&(m=[1,1]),J(oa(A,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${A} and dilations '${m}'`);const y=Vs(s.shape,o.shape,A,m,u,l,!0),{filterHeight:b,filterWidth:v,dilationHeight:w,dilationWidth:I,padInfo:S}=y,T=S.left,D=S.top,L=y.outChannels/y.inChannels,W=new Gs(y.outShape,s.dtype),K=t.data.get(s.dataId).values,U=t.data.get(o.dataId).values,_=W.values;for(let ee=0;ee<y.batchSize;++ee){const re=ee*c[0],ce=ee*W.strides[0];for(let we=0;we<y.outHeight;++we){const Ee=ce+we*W.strides[1],Pe=we*y.strideHeight-D;for(let he=0;he<b;++he){const de=Pe+he*w;if(de<0||de>=y.inHeight)continue;const Ae=he*d[0],Se=re+de*c[1];for(let Te=0;Te<y.outWidth;++Te){const Ze=Ee+Te*W.strides[2],et=Te*y.strideWidth-T;for(let qe=0;qe<v;++qe){const Re=et+qe*I;if(Re<0||Re>=y.inWidth)continue;const Ue=Ae+qe*d[1],ot=Se+Re*y.inChannels;let yt=Ze,Vt=Ue;for(let ln=0;ln<y.inChannels;++ln){const en=K[ot+ln];for(let Xt=0;Xt<L;++Xt)_[yt+Xt]+=en*U[Vt+Xt];yt+=L,Vt+=L}}}}}}return t.makeTensorInfo(W.shape,W.dtype,W.values)}const lae={kernelName:xA,backendName:"cpu",kernelFunc:NL},uae={kernelName:Vi,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:o}=e,{strides:A,dilations:u,pad:h,dimRoundingMode:l,filterShape:c}=r;Kt([s,o],"depthwiseConv2dNativeBackpropFilter");const d=Vs(s.shape,c,A,u,h,l,!0),{strideHeight:m,strideWidth:y,filterHeight:b,filterWidth:v}=d,w=new Gs(d.filterShape,"float32"),I=d.padInfo.left,S=d.padInfo.top,T=d.outChannels/d.inChannels,D=t.data.get(s.dataId).values,L=new Gs(s.shape,s.dtype,D),W=t.data.get(o.dataId).values,K=new Gs(o.shape,o.dtype,W);for(let U=0;U<b;++U){const _=Math.max(0,Math.ceil((S-U)/m)),ee=Math.min(d.outHeight,(d.inHeight+S-U)/m);for(let re=0;re<v;++re){const ce=Math.max(0,Math.ceil((I-re)/y)),we=Math.min(d.outWidth,(d.inWidth+I-re)/y);for(let Ee=0;Ee<d.outChannels;++Ee){const Pe=Math.trunc(Ee/T),he=Ee%T;let de=0;for(let Ae=0;Ae<d.batchSize;++Ae)for(let Se=_;Se<ee;++Se){const Te=U+Se*m-S;for(let Ze=ce;Ze<we;++Ze){const et=re+Ze*y-I;de+=L.get(Ae,Te,et,Pe)*K.get(Ae,Se,Ze,Ee)}}w.set(de,U,re,Pe,he)}}}return t.makeTensorInfo(w.shape,w.dtype,w.values)}},cae={kernelName:sa,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:o}=e,{strides:A,dilations:u,pad:h,dimRoundingMode:l,inputShape:c}=r;Kt([s,o],"depthwiseConv2DNativeBackpropInput");const d=Je(s.shape),m=Je(o.shape),y=Vs(c,o.shape,A,u,h,l,!0),b=new Gs(y.inShape,"float32"),v=b.values,[w,I,S]=b.strides,T=t.data.get(s.dataId).values,[D,L,W]=d,K=t.data.get(o.dataId).values,[U,_,ee]=m,{batchSize:re,filterHeight:ce,filterWidth:we,inChannels:Ee,inHeight:Pe,inWidth:he,outChannels:de,outHeight:Ae,outWidth:Se,strideHeight:Te,strideWidth:Ze}=y,et=ce-1-y.padInfo.top,qe=we-1-y.padInfo.left,Re=de/Ee;for(let Ue=0;Ue<re;++Ue)for(let ot=0;ot<Ee;++ot)for(let yt=0;yt<Pe;++yt){const Vt=yt-et,ln=Math.max(0,Math.ceil(Vt/Te)),en=Math.min(Ae,(ce+Vt)/Te);for(let Xt=0;Xt<he;++Xt){const hn=Xt-qe,wn=Math.max(0,Math.ceil(hn/Ze)),Fn=Math.min(Se,(we+hn)/Ze);let In=0;for(let zn=ln;zn<en;++zn){const Kn=zn*Te-Vt;for(let Ls=wn;Ls<Fn;++Ls){const Na=D*Ue+L*zn+W*Ls,da=U*(ce-1-Kn)+_*(we-1-(Ls*Ze-hn))+ee*ot;for(let Nr=0;Nr<Re;++Nr)In+=T[Na+(ot*Re+Nr)]*K[da+Nr]}}v[w*Ue+I*yt+S*Xt+ot]=In}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}},dae={kernelName:wA,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t}=n,{x:r}=e,s=Ye(r.shape),o=t.data.get(r.dataId).values,A=Wn([s,s],r.dtype),u=A.values;for(let l=0;l<o.length;l++)u[l*s+l]=o[l];const h=[...r.shape,...r.shape];return t.makeTensorInfo(h,A.dtype,A.values)}},pae={kernelName:wo,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:r,filter:s}=n,{strides:o,pad:A,dilations:u}=t,h=e,l=h.data.get(r.dataId).values,c=r.shape.length,d=h.data.get(s.dataId).values,m=s.shape.length,{batchSize:y,inHeight:b,inWidth:v,inChannels:w,outHeight:I,outWidth:S,padInfo:T,strideHeight:D,strideWidth:L,filterHeight:W,filterWidth:K,dilationHeight:U,dilationWidth:_,outShape:ee}=Sm(r.shape,s.shape,o,A,"NHWC",u),re=Ye(ee),ce=ee.length,we=Tt(r.dtype,re);for(let Ee=0;Ee<y;++Ee)for(let Pe=0;Pe<I;++Pe){const he=Pe*D-T.top;for(let de=0;de<S;++de){const Ae=de*L-T.left;for(let Se=0;Se<w;++Se){let Te=Number.MIN_SAFE_INTEGER;for(let Ze=0;Ze<W;++Ze){const et=he+Ze*U;if(et>=0&&et<b)for(let qe=0;qe<K;++qe){const Re=Ae+qe*_;if(Re>=0&&Re<v){const Ue=ms([Ee,et,Re,Se],c,Je(r.shape)),ot=ms([Ze,qe,Se],m,Je(s.shape)),yt=l[Ue]+d[ot];yt>Te&&(Te=yt)}}}we[ms([Ee,Pe,de,Se],ce,Je(ee))]=Te}}}return{dataId:h.write(Cc(we,r.dtype),ee,r.dtype),shape:ee,dtype:r.dtype}}},hae={kernelName:xc,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:r,filter:s,dy:o}=n,{strides:A,pad:u,dilations:h}=t,l=e,c=vr(r.shape,l.data.get(r.dataId).values),d=vr(s.shape,l.data.get(s.dataId).values),{batchSize:m,inHeight:y,inWidth:b,inChannels:v,outHeight:w,outWidth:I,padInfo:S,strideHeight:T,strideWidth:D,filterHeight:L,filterWidth:W,dilationHeight:K,dilationWidth:U,outShape:_}=Sm(r.shape,s.shape,A,u,"NHWC",h);J(o.rank===_.length,()=>`Error in ${xc}, dy must have the same rank as output ${_.length}, but got ${o.rank}`);const ee=vr(_,l.data.get(o.dataId).values),re=Ss(s.shape,s.dtype);for(let ce=0;ce<m;++ce)for(let we=0;we<w;++we){const Ee=we*T-S.top;for(let Pe=0;Pe<I;++Pe){const he=Pe*D-S.left;for(let de=0;de<v;++de){let Ae=Number.MIN_SAFE_INTEGER,Se=0,Te=0;for(let Ze=0;Ze<L;++Ze){const et=Ee+Ze*K;if(et>=0&&et<y)for(let qe=0;qe<W;++qe){const Re=he+qe*U;if(Re>=0&&Re<b){const Ue=c[ce][et][Re][de]+d[Ze][qe][de];Ue>Ae&&(Ae=Ue,Se=Ze,Te=qe)}}}re[Se][Te][de]+=ee[ce][we][Pe][de]}}}return{dataId:l.write(Cc(re,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},fae={kernelName:al,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:r,filter:s,dy:o}=n,{strides:A,pad:u,dilations:h}=t,l=e,c=vr(r.shape,l.data.get(r.dataId).values),d=vr(s.shape,l.data.get(s.dataId).values),{batchSize:m,inHeight:y,inWidth:b,inChannels:v,outHeight:w,outWidth:I,padInfo:S,strideHeight:T,strideWidth:D,filterHeight:L,filterWidth:W,dilationHeight:K,dilationWidth:U,outShape:_}=Sm(r.shape,s.shape,A,u,"NHWC",h);J(o.rank===_.length,()=>`Error in ${al}, dy must have the same rank as output ${_.length}, but got ${o.rank}`);const ee=vr(_,l.data.get(o.dataId).values),re=Ss(r.shape,r.dtype);for(let ce=0;ce<m;++ce)for(let we=0;we<w;++we){const Ee=we*T-S.top;for(let Pe=0;Pe<I;++Pe){const he=Pe*D-S.left;for(let de=0;de<v;++de){let Ae=Number.MIN_SAFE_INTEGER,Se=Ee<0?0:Ee,Te=he<0?0:he;for(let Ze=0;Ze<L;++Ze){const et=Ee+Ze*K;if(et>=0&&et<y)for(let qe=0;qe<W;++qe){const Re=he+qe*U;if(Re>=0&&Re<b){const Ue=c[ce][et][Re][de]+d[Ze][qe][de];Ue>Ae&&(Ae=Ue,Se=et,Te=Re)}}}re[ce][Se][Te][de]+=ee[ce][we][Pe][de]}}}return{dataId:l.write(Cc(re,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},_3=vs((n,e)=>n*e),mae=K3((n,e,t,r)=>({real:n*t-e*r,imag:n*r+e*t})),Vx=Ys(nm,_3,mae),gae={kernelName:nm,backendName:"cpu",kernelFunc:Vx};function og(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:A}=r;let u;Kt(s,"sum"),u=s.dtype==="bool"?Cu({inputs:{x:s},backend:t,attrs:{dtype:"int32"}}):DA({inputs:{x:s},backend:t});const h=u.shape.length,l=pt(o,u.shape),c=cs(l,h);let d=l,m=u;c!=null&&(m=ei({inputs:{x:u},backend:t,attrs:{perm:c}}),d=bs(d.length,h)),ia("sum",d,m.shape.length);const[y,b]=Xs(m.shape,d);let v=Gx(t,y,Uo(m.dtype,"int32"));const w=Ye(b),I=t.data.get(v.dataId).values,S=t.data.get(m.dataId).values;for(let T=0;T<I.length;++T){const D=T*w;let L=0;for(let W=0;W<w;++W)L+=S[D+W];I[T]=L}if(A){const T=v;v=zr({inputs:{x:v},backend:t,attrs:{shape:us(v.shape,l)}}),t.disposeIntermediateTensorInfo(T)}return t.disposeIntermediateTensorInfo(u),c!=null&&t.disposeIntermediateTensorInfo(m),v}const yae={kernelName:yv,backendName:"cpu",kernelFunc:og},bae={kernelName:_l,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{equation:s}=r,o=e,{allDims:A,summedDims:u,idDims:h}=OS(s,o.length);BS(A.length,h,o);const{path:l,steps:c}=FS(u,h),d=c.length;let m=null,y=A.length;const b=[];for(let v=0;v<d;++v){for(const w of c[v]){const{permutationIndices:I,expandDims:S}=PS(y,h[w]);let T;LS(I)?T=o[w]:(T=ei({inputs:{x:o[w]},backend:t,attrs:{perm:I}}),b.push(T));const D=T.shape.slice();for(let L=0;L<S.length;++L)D.splice(S[L],0,1);ht(T.shape,D)||(T=zr({inputs:{x:T},backend:t,attrs:{shape:D}}),b.push(T)),m===null?m=T:(m=Vx({inputs:{a:T,b:m},backend:t}),b.push(m))}v<d-1&&(l[v]>=0&&(m=og({inputs:{x:m},backend:t,attrs:{axis:l[v]-(A.length-y),keepDims:!1}}),b.push(m)),y--)}for(const v of b)v!==m&&t.disposeIntermediateTensorInfo(v);return m}},vae={kernelName:zC,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t}=n,{dy:r,y:s}=e;Kt([r,s],"eluGrad");const o=new Float32Array(Ye(s.shape)),A=t.data.get(s.dataId).values,u=t.data.get(r.dataId).values;for(let h=0;h<A.length;++h){const l=A[h];o[h]=l>=1?u[h]:u[h]*(l+1)}return t.makeTensorInfo(s.shape,"float32",o)}},TL=vs((n,e)=>n===e?1:0),ML=Ys(H0,TL,null,"bool"),xae={kernelName:H0,backendName:"cpu",kernelFunc:ML},wae=IS,kae=SS,Cae=NS,Iae=TS,Sae=MS,Nae=ES,Tae=hr(Hf,n=>{const e=Math.sign(n),t=Math.abs(n),r=1/(1+wae*t);return e*(1-((((Nae*r+Sae)*r+Iae)*r+Cae)*r+kae)*r*Math.exp(-t*t))}),Mae={kernelName:Hf,backendName:"cpu",kernelFunc:Tae},EL=ku(n=>Math.exp(n)),DL=Wp(Gf,EL),Eae={kernelName:Gf,backendName:"cpu",kernelFunc:DL};function Xx(n){const{inputs:e,backend:t,attrs:r}=n,{input:s}=e,{dim:o}=r,A=s.shape.length,u=s.shape.slice();let h=o;return o<0&&(J(-(A+1)<=o,()=>`Axis must be in the interval [${-(A+1)}, ${A}]`),h=A+o+1),u.splice(h,0,1),zr({inputs:{x:s},backend:t,attrs:{shape:u}})}const Dae={kernelName:G0,backendName:"cpu",kernelFunc:Xx},zL=ku(n=>Math.expm1(n)),zae=Wp(Vf,zL),Oae={kernelName:Vf,backendName:"cpu",kernelFunc:zae},Pae=vs((n,e)=>n/e),eN=Ys(ol,Pae),tN={kernelName:ol,backendName:"cpu",kernelFunc:eN},OL=vs((n,e)=>n-e),Bae=K3((n,e,t,r)=>({real:n-t,imag:e-r})),nN=Ys(gm,OL,Bae),Fae={kernelName:gm,backendName:"cpu",kernelFunc:nN};function PL(n,e,t){const r=n.shape,s=r[0],o=r[1],A=t.data.get(n.dataId),u=A.complexTensorInfos.real,h=A.complexTensorInfos.imag,l=[s,o],c=Ye(l),d=Oe("float32",c),m=Oe("float32",c);for(let w=0;w<s;w++){const I=Uc({inputs:{x:u},backend:t,attrs:{begin:[w,0],size:[1,o]}}),S=Uc({inputs:{x:h},backend:t,attrs:{begin:[w,0],size:[1,o]}}),T=So({inputs:{real:I,imag:S},backend:t}),{real:D,imag:L}=Lae(T,e,t),W=fl(D,L);for(let K=0;K<o;K++){const U=DS(W,K);d[w*o+K]=U.real,m[w*o+K]=U.imag}t.disposeIntermediateTensorInfo(I),t.disposeIntermediateTensorInfo(S),t.disposeIntermediateTensorInfo(T)}const y=t.makeTensorInfo(l,"float32",d),b=t.makeTensorInfo(l,"float32",m),v=So({inputs:{real:y,imag:b},backend:t});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),v}function Lae(n,e,t){const r=Ye(n.shape),s=t.data.get(n.dataId),o=t.data.get(s.complexTensorInfos.real.dataId).values,A=t.data.get(s.complexTensorInfos.imag.dataId).values;if((u=r)&u-1){const h=function(l,c,d){const m=new Float32Array(2*c);for(let y=0;y<c;y++){let b=0,v=0;for(let w=0;w<c;w++){const I=V4(y*w,c,d),S=DS(l,w);b+=S.real*I.real-S.imag*I.imag,v+=S.real*I.imag+S.imag*I.real}d&&(b/=c,v/=c),H4(m,b,v,y)}return m}(fl(o,A),r,e);return R4(h)}{const h=rN(o,A,r,e,t),l=[n.shape[0],n.shape[1]];if(e){const c=t.makeTensorInfo(l,"float32",h.real),d=t.makeTensorInfo(l,"float32",h.imag),m=t.makeTensorInfo([],"float32",tu(r,"float32")),y=DA({inputs:{x:m},backend:t}),b=tN.kernelFunc({inputs:{a:c,b:m},backend:t}),v=tN.kernelFunc({inputs:{a:d,b:y},backend:t}),w=t.data.get(b.dataId).values,I=t.data.get(v.dataId).values;return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(v),{real:w,imag:I}}return h}var u}function rN(n,e,t,r,s){if(t===1)return{real:n,imag:e};const o=fl(n,e),A=t/2,u=W4(o),h=u.real,l=u.imag,c=[h.length],d=s.makeTensorInfo(c,"float32",h),m=s.makeTensorInfo(c,"float32",l),y=So({inputs:{real:d,imag:m},backend:s}),b=j4(o),v=b.real,w=b.imag,I=[v.length],S=s.makeTensorInfo(I,"float32",v),T=s.makeTensorInfo(I,"float32",w),D=So({inputs:{real:S,imag:T},backend:s}),L=rN(h,l,A,r,s),W=L.real,K=L.imag,U=[W.length],_=s.makeTensorInfo(U,"float32",W),ee=s.makeTensorInfo(U,"float32",K),re=So({inputs:{real:_,imag:ee},backend:s}),ce=rN(v,w,A,r,s),we=ce.real,Ee=ce.imag,Pe=[we.length],he=s.makeTensorInfo(Pe,"float32",we),de=s.makeTensorInfo(Pe,"float32",Ee),Ae=So({inputs:{real:he,imag:de},backend:s}),Se=G4(t,r),Te=[Se.real.length],Ze=s.makeTensorInfo(Te,"float32",Se.real),et=s.makeTensorInfo(Te,"float32",Se.imag),qe=So({inputs:{real:Ze,imag:et},backend:s}),Re=Vx({inputs:{a:qe,b:Ae},backend:s}),Ue=ag({inputs:{a:re,b:Re},backend:s}),ot=nN({inputs:{a:re,b:Re},backend:s}),yt=Yc({inputs:{input:Ue},backend:s}),Vt=Yc({inputs:{input:ot},backend:s}),ln=jp({inputs:{input:Ue},backend:s}),en=jp({inputs:{input:ot},backend:s}),Xt=Hp({inputs:[yt,Vt],backend:s,attrs:{axis:0}}),hn=Hp({inputs:[ln,en],backend:s,attrs:{axis:0}}),wn=s.data.get(Xt.dataId).values,Fn=s.data.get(hn.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(m),s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo(S),s.disposeIntermediateTensorInfo(T),s.disposeIntermediateTensorInfo(D),s.disposeIntermediateTensorInfo(_),s.disposeIntermediateTensorInfo(ee),s.disposeIntermediateTensorInfo(re),s.disposeIntermediateTensorInfo(he),s.disposeIntermediateTensorInfo(de),s.disposeIntermediateTensorInfo(Ae),s.disposeIntermediateTensorInfo(Ze),s.disposeIntermediateTensorInfo(et),s.disposeIntermediateTensorInfo(qe),s.disposeIntermediateTensorInfo(Re),s.disposeIntermediateTensorInfo(Ue),s.disposeIntermediateTensorInfo(ot),s.disposeIntermediateTensorInfo(yt),s.disposeIntermediateTensorInfo(ln),s.disposeIntermediateTensorInfo(Vt),s.disposeIntermediateTensorInfo(en),s.disposeIntermediateTensorInfo(Xt),s.disposeIntermediateTensorInfo(hn),{real:wn,imag:Fn}}const Rae={kernelName:OC,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t}=n,{input:r}=e,s=Ye(r.shape),o=r.shape[r.shape.length-1],A=zr({inputs:{x:r},backend:t,attrs:{shape:[s/o,o]}}),u=PL(A,!1,t),h=zr({inputs:{x:u},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(A),t.disposeIntermediateTensorInfo(u),h}};function sN(n){const{backend:e,attrs:t}=n,{shape:r,value:s,dtype:o}=t,A=o||kt(s),u=Tt(A,Ye(r));return function(h,l){h.fill(l)}(u,s),e.makeTensorInfo(r,A,u)}const Wae={kernelName:PC,backendName:"cpu",kernelFunc:sN},jae={kernelName:BC,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,s=t,o=Oe(r.dtype,Ye(r.shape)),[A,u,h,l]=r.shape,c=s.data.get(r.dataId).values;for(let d=0;d<A;d++){const m=d*h*u*l;for(let y=0;y<u;y++){const b=y*(h*l);for(let v=0;v<h;v++){const w=v*l;for(let I=0;I<l;I++){const S=Math.round(h-v-1),T=m+b+w+I;let D=c[T];S>=0&&S<h&&(D=c[m+b+S*l+I]),o[T]=D}}}}return{dataId:s.write(o,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},BL=ku(n=>Math.floor(n)),Hae=Wp(Xf,BL),Gae={kernelName:Xf,backendName:"cpu",kernelFunc:Hae},Vae=vs((n,e)=>Math.floor(n/e)),Xae=Ys(Zf,Vae,null,"int32"),Zae={kernelName:Zf,backendName:"cpu",kernelFunc:Xae},Yae={kernelName:Nv,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o,bias:A,preluActivationWeights:u}=e,{strides:h,pad:l,dataFormat:c,dilations:d,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=r;let v=SL({inputs:{x:s,filter:o},backend:t,attrs:{strides:h,pad:l,dataFormat:c,dilations:d,dimRoundingMode:m}});if(A){const w=v;v=ag({inputs:{a:v,b:A},backend:t}),t.disposeIntermediateTensorInfo(w)}if(y){const w=v;v=Q3(t,v,y,u,b),t.disposeIntermediateTensorInfo(w)}return v}},Uae={kernelName:Tv,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o,bias:A,preluActivationWeights:u}=e,{strides:h,pad:l,dataFormat:c,dilations:d,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=r;let v=NL({inputs:{x:s,filter:o},backend:t,attrs:{strides:h,pad:l,dataFormat:c,dilations:d,dimRoundingMode:m}});if(A){const w=v;v=ag({inputs:{a:v,b:A},backend:t}),t.disposeIntermediateTensorInfo(w)}if(y){const w=v;v=Q3(t,v,y,u,b),t.disposeIntermediateTensorInfo(w)}return v}};function FL(n,e,t,r,s,o,A,u,h){const l=Wn([r,o],t);for(let c=0;c<r;c++){const d=[];let m=0;for(let y=0;y<s;y++){const b=n[c*s+y];m+=b*A[y],d.push(b)}if(m<0||m>=h/o)throw new Error(`Invalid indices: ${d} does not index into ${u}`);for(let y=0;y<o;y++)l.values[c*o+y]=e.get(...e.indexToLoc(m*o+y))}return l}const Qae={kernelName:FC,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t}=n,{params:r,indices:s}=e,o=Ye(r.shape),A=s.shape,u=A[A.length-1],[h,l,c,d]=CS(r,s);if(l===0)return t.makeTensorInfo(h,r.dtype,[]);const m=FL(t.data.get(s.dataId).values,t.bufferSync(r),r.dtype,l,u,c,d,r.shape,o);return t.makeTensorInfo(h,r.dtype,m.values)}};function LL(n,e,t){const r=Wn(t,n.dtype);for(let s=0;s<r.size;++s){const o=r.indexToLoc(s).slice(),A=o[0],u=o[2],h=e.locToIndex([A,u]);o[2]=e.values[h];const l=n.locToIndex(o);r.values[s]=n.values[l]}return r}const Kae={kernelName:X0,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,indices:o}=e,{axis:A,batchDims:u}=r;Kt([s,o],"gatherV2");let h=u;u==null&&(h=0);const l=Ye(o.shape),c=WS(s,o,pt(A,s.shape)[0],h),d=zr({inputs:{x:s},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),m=zr({inputs:{x:o},backend:t,attrs:{shape:[c.batchSize,l/c.batchSize]}}),y=[c.batchSize,c.outerSize,l/c.batchSize,c.sliceSize],b=t.bufferSync(m),v=LL(t.bufferSync(d),b,y);return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(m),t.makeTensorInfo(c.outputShape,v.dtype,v.values)}},RL=vs((n,e)=>n>e?1:0),qae=Ys(Z0,RL,null,"bool"),Jae={kernelName:Z0,backendName:"cpu",kernelFunc:qae},WL=vs((n,e)=>n>=e?1:0),$ae=Ys(Yf,WL,null,"bool"),_ae={kernelName:Yf,backendName:"cpu",kernelFunc:$ae},eoe={kernelName:LC,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t}=n,{input:r}=e,s=Ye(r.shape),o=r.shape[r.shape.length-1],A=zr({inputs:{x:r},backend:t,attrs:{shape:[s/o,o]}}),u=PL(A,!0,t),h=zr({inputs:{x:u},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(A),t.disposeIntermediateTensorInfo(u),h}},toe=hr(Qf,n=>Number.isFinite(n)?1:0,"bool"),noe={kernelName:Qf,backendName:"cpu",kernelFunc:toe},roe=hr(Kf,n=>Math.abs(n)===1/0?1:0,"bool"),soe={kernelName:Kf,backendName:"cpu",kernelFunc:roe},aoe=hr(qf,n=>Number.isNaN(n)?1:0,"bool"),ooe={kernelName:qf,backendName:"cpu",kernelFunc:aoe},jL=vs((n,e)=>n<e?1:0),ioe=Ys(U0,jL,null,"bool"),Aoe={kernelName:U0,backendName:"cpu",kernelFunc:ioe},HL=vs((n,e)=>n<=e?1:0),loe=Ys(Q0,HL,null,"bool"),uoe={kernelName:Q0,backendName:"cpu",kernelFunc:loe};function GL(n,e,t){const r=(e-n)/(t-1),s=Mr(t,"float32");s[0]=n;for(let o=1;o<s.length;o++)s[o]=s[o-1]+r;return s}const coe={kernelName:WC,backendName:"cpu",kernelFunc:function(n){const{backend:e,attrs:t}=n,{start:r,stop:s,num:o}=t,A=GL(r,s,o);return e.makeTensorInfo([A.length],"float32",A)}},VL=ku(n=>Math.log(n)),doe=Wp(Jf,VL),poe={kernelName:Jf,backendName:"cpu",kernelFunc:doe},hoe=hr($f,n=>Math.log1p(n)),foe={kernelName:$f,backendName:"cpu",kernelFunc:hoe},moe=vs((n,e)=>n&&e),goe=Ys(K0,moe,null,"bool"),yoe={kernelName:K0,backendName:"cpu",kernelFunc:goe},boe=hr(q0,n=>n?0:1,"bool"),voe={kernelName:q0,backendName:"cpu",kernelFunc:boe},xoe=vs((n,e)=>n||e),woe=Ys(J0,xoe,null,"bool"),koe={kernelName:J0,backendName:"cpu",kernelFunc:woe},Coe={kernelName:$0,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{depthRadius:o,bias:A,alpha:u,beta:h}=r;Kt(s,"LRN");const l=s.shape[3],c=l-1,d=t.data.get(s.dataId).values,m=Ye(s.shape),y=new Float32Array(m);function b(v){const w=v%l;let I=v-w+Math.max(0,w-o);const S=v-w+Math.min(w+o,c);let T=0;for(;I<=S;I++){const D=d[I];T+=D*D}return T}for(let v=0;v<m;v++){const w=b(v),I=d[v]*Math.pow(A+u*w,-h);y[v]=I}return t.makeTensorInfo(s.shape,s.dtype,y)}},Ioe={kernelName:jC,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,y:o,dy:A}=e,{depthRadius:u,bias:h,alpha:l,beta:c}=r;Kt(A,"LRNGrad");const d=Ye(A.shape),m=A.shape[3],y=t.data.get(A.dataId).values,b=t.data.get(s.dataId).values,v=t.data.get(o.dataId).values,w=new Float32Array(d),I=d;for(let S=0;S<I;S++){const T=S%m,D=S-T+Math.max(0,T-u),L=S-T+Math.min(m,T+u+1);let W=0;for(let K=D;K<L;K++)W+=Math.pow(b[K],2);W=l*W+h;for(let K=D;K<L;K++){let U=-2*l*c*b[K]*v[S]/W;S===K&&(U+=Math.pow(W,-c)),U*=y[S],w[K]+=U}}return t.makeTensorInfo(A.shape,s.dtype,w)}};function XL(n,e,t,r){const s=Oe(r,Ye(t));for(let o=0;o<s.length;++o){const A=o*e;let u=n[A];for(let h=0;h<e;++h){const l=n[A+h];(Number.isNaN(l)||l>u)&&(u=l)}s[o]=u}return s}function ZL(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reductionIndices:o,keepDims:A}=r,u=t;let h=s.shape;const l=h.length,c=pt(o,h);let d=c;const m=cs(d,l);let y=u.data.get(s.dataId).values;if(m!=null){const T=new Array(l);for(let D=0;D<T.length;D++)T[D]=h[m[D]];y=q3(y,h,s.dtype,m,T),d=bs(d.length,l),h=T}Kt(s,"max"),ia("max",d,l);const[b,v]=Xs(h,d),w=XL(y,Ye(v),b,s.dtype),I=u.write(w,b,s.dtype);let S=b;return A&&(S=us(b,c)),{dataId:I,shape:S,dtype:s.dtype}}const Soe={kernelName:_0,backendName:"cpu",kernelFunc:ZL},YL=vs((n,e)=>Math.max(n,e)),Noe=Ys(_f,YL),Toe={kernelName:_f,backendName:"cpu",kernelFunc:Noe},Moe={kernelName:ev,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;Kt(s,"maxPool");const{filterSize:o,strides:A,pad:u,dimRoundingMode:h}=r;J(oa(A,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${A} and dilations '1'`);const l=bi(s.shape,o,A,1,u,h);let c;if(l.filterWidth===1&&l.filterHeight===1&&ht(l.inShape,l.outShape))c=DA({inputs:{x:s},backend:t});else{const d=t.data.get(s.dataId).values,m=Je(s.shape),y=J3(d,s.shape,s.dtype,m,l,"max");c=t.makeTensorInfo(l.outShape,s.dtype,y.values)}return c}},Eoe={kernelName:tv,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:o,strides:A,pad:u,dimRoundingMode:h,dataFormat:l}=r;Kt(s,"maxPool3d");const c=ul(s.shape,o,A,1,u,h,l),d=xL(t.data.get(s.dataId).values,s.shape,s.dtype,Je(s.shape),c,"max");return t.makeTensorInfo(d.shape,"float32",d.values)}},Doe={kernelName:GC,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:o}=e,{filterSize:A,strides:u,pad:h,dimRoundingMode:l}=r;Kt([s,o],"maxPool3DGrad");const c=ul(o.shape,A,u,1,h,l),d=function(ee,re){const ce=Wn(re.outShape,"int32"),we=re.strideDepth,Ee=re.strideHeight,Pe=re.strideWidth,he=re.dilationDepth,de=re.dilationHeight,Ae=re.dilationWidth,Se=re.effectiveFilterDepth,Te=re.effectiveFilterHeight,Ze=re.effectiveFilterWidth,et=re.padInfo.front,qe=re.padInfo.top,Re=re.padInfo.left;for(let Ue=0;Ue<re.batchSize;++Ue)for(let ot=0;ot<re.inChannels;++ot)for(let yt=0;yt<re.outDepth;++yt){const Vt=yt*we-et;let ln=Vt;for(;ln<0;)ln+=he;const en=Math.min(re.inDepth,Se+Vt);for(let Xt=0;Xt<re.outHeight;++Xt){const hn=Xt*Ee-qe;let wn=hn;for(;wn<0;)wn+=de;const Fn=Math.min(re.inHeight,Te+hn);for(let In=0;In<re.outWidth;++In){const zn=In*Pe-Re;let Kn=zn;for(;Kn<0;)Kn+=Ae;const Ls=Math.min(re.inWidth,Ze+zn);let Na=Number.NEGATIVE_INFINITY,da=-1;for(let Nr=ln;Nr<en;Nr+=he){const zo=Nr-Vt;for(let pa=wn;pa<Fn;pa+=de){const Oo=pa-hn;for(let aA=Kn;aA<Ls;aA+=Ae){const qu=aA-zn,Nl=ee.get(Ue,Nr,pa,aA,ot);Nl>=Na&&(Na=Nl,da=zo*Te*Ze+Oo*Te+qu)}}}ce.set(da,Ue,yt,Xt,In,ot)}}}return ce}(t.bufferSync(o),c),m=c.strideDepth,y=c.strideHeight,b=c.strideWidth,v=c.dilationDepth,w=c.dilationHeight,I=c.dilationWidth,S=c.effectiveFilterDepth,T=c.effectiveFilterHeight,D=c.effectiveFilterWidth,L=S-1-c.padInfo.front,W=D-1-c.padInfo.left,K=T-1-c.padInfo.top,U=Wn(o.shape,"float32"),_=t.bufferSync(s);for(let ee=0;ee<c.batchSize;++ee)for(let re=0;re<c.inChannels;++re)for(let ce=0;ce<c.inDepth;++ce)for(let we=0;we<c.inHeight;++we)for(let Ee=0;Ee<c.inWidth;++Ee){const Pe=ce-L,he=we-K,de=Ee-W;let Ae=0;for(let Se=0;Se<S;Se+=v){const Te=(Pe+Se)/m;if(!(Te<0||Te>=c.outDepth||Math.floor(Te)!==Te))for(let Ze=0;Ze<T;Ze+=w){const et=(he+Ze)/y;if(!(et<0||et>=c.outHeight||Math.floor(et)!==et))for(let qe=0;qe<D;qe+=I){const Re=(de+qe)/b;if(Re<0||Re>=c.outWidth||Math.floor(Re)!==Re)continue;const Ue=S*T*D-1-d.get(ee,Te,et,Re,re)===Se*T*D+Ze*D+qe?1:0;Ue!==0&&(Ae+=_.get(ee,Te,et,Re,re)*Ue)}}}U.set(Ae,ee,ce,we,Ee,re)}return t.makeTensorInfo(U.shape,U.dtype,U.values)}},zoe={kernelName:HC,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:o,output:A}=e,u=o;Kt([o,A],"maxPoolGrad");const{filterSize:h,strides:l,pad:c,dimRoundingMode:d}=r,m=bi(u.shape,h,l,1,c,d),y=t.data.get(u.dataId).values,b=Wn(m.outShape,u.dtype,vL(y,u.shape,u.dtype,m).values),v=m.strideHeight,w=m.strideWidth,I=m.dilationHeight,S=m.dilationWidth,T=m.effectiveFilterHeight,D=m.effectiveFilterWidth,L=D-1-m.padInfo.left,W=T-1-m.padInfo.top,K=Wn(u.shape,"float32"),U=t.data.get(s.dataId).values,_=Wn(s.shape,"float32",U);for(let ee=0;ee<m.batchSize;++ee)for(let re=0;re<m.inChannels;++re)for(let ce=0;ce<m.inHeight;++ce)for(let we=0;we<m.inWidth;++we){const Ee=ce-W,Pe=we-L;let he=0;for(let de=0;de<T;de+=I){const Ae=(Ee+de)/v;if(!(Ae<0||Ae>=m.outHeight||Math.floor(Ae)!==Ae))for(let Se=0;Se<D;Se+=S){const Te=(Pe+Se)/w;if(Te<0||Te>=m.outWidth||Math.floor(Te)!==Te)continue;const Ze=T*D-1-b.get(ee,Ae,Te,re)===de*D+Se?1:0;Ze!==0&&(he+=_.get(ee,Ae,Te,re)*Ze)}}K.set(he,ee,ce,we,re)}return t.makeTensorInfo(K.shape,K.dtype,K.values)}},Ooe={kernelName:VC,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{filterSize:s,strides:o,pad:A,includeBatchInIndex:u}=e,h=t;Kt(r,"MaxPoolWithArgmax");const l=h.data.get(r.dataId).values,c=bi(r.shape,s,o,[1,1],A),[d,m]=function(v,w,I,S,T){const D=J3(v,0,I,Je(w),T,"max"),L=vL(v,w,I,T,!0,S);return[D.values,L.values]}(l,r.shape,r.dtype,u,c),y=h.write(d,c.outShape,r.dtype),b=h.write(m,c.outShape,r.dtype);return[{dataId:y,shape:c.outShape,dtype:r.dtype},{dataId:b,shape:c.outShape,dtype:"int32"}]}},Poe={kernelName:nv,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:A}=r,u=pt(o,s.shape),h=Ye(Xs(s.shape,u)[1]),l=[],c=t.makeTensorInfo([],"float32",new Float32Array([h]));l.push(c);const d=Cu({inputs:{x:s},backend:t,attrs:{dtype:"float32"}});l.push(d);const m=eN({inputs:{a:d,b:c},backend:t});l.push(m);const y=og({inputs:{x:m},backend:t,attrs:{axis:o,keepDims:A}});return l.forEach(b=>t.disposeIntermediateTensorInfo(b)),y}},Boe={kernelName:rv,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:A}=r;Kt(s,"min");const u=pt(o,s.shape);let h=u;const l=cs(h,s.shape.length);let c=s;l!=null&&(c=ei({inputs:{x:s},backend:t,attrs:{perm:l}}),h=bs(h.length,s.shape.length)),ia("min",h,c.shape.length);const[d,m]=Xs(c.shape,h),y=Ye(m),b=Mr(Ye(d),c.dtype),v=t.data.get(c.dataId).values;for(let I=0;I<b.length;++I){const S=I*y;let T=v[S];for(let D=0;D<y;++D){const L=v[S+D];(Number.isNaN(L)||L<T)&&(T=L)}b[I]=T}l!=null&&t.disposeIntermediateTensorInfo(c);const w=t.makeTensorInfo(d,c.dtype,b);if(A){const I=zr({inputs:{x:w},backend:t,attrs:{shape:us(d,u)}});return t.disposeIntermediateTensorInfo(w),I}return w}},UL=vs((n,e)=>Math.min(n,e)),Foe=Ys(em,UL),Loe={kernelName:em,backendName:"cpu",kernelFunc:Foe},Roe={kernelName:sv,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{paddings:o,mode:A}=r;Kt(s,"mirrorPad");const u=o.map((S,T)=>S[0]+s.shape[T]+S[1]),h=o.map(S=>S[0]),l=o.map((S,T)=>S[0]+s.shape[T]),c=A==="reflect"?0:1,d=t.data.get(s.dataId).values,m=s.shape.length,y=Je(s.shape),b=Ye(u),v=u.length,w=Je(u),I=Oe(s.dtype,b);for(let S=0;S<b;S++){let T=is(S,v,w);for(let L=0;L<v;L++)T[L]<h[L]?T[L]=2*h[L]-T[L]-c:T[L]>=l[L]&&(T[L]=2*(l[L]-1)-T[L]+c);T=T.map((L,W)=>L-h[W]);const D=ms(T,m,y);I[S]=d[D]}return{dataId:t.write(I,u,s.dtype),shape:u,dtype:s.dtype}}},Woe=vs((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e}),joe=Ys(tm,Woe),Hoe={kernelName:tm,backendName:"cpu",kernelFunc:joe};function QL(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{dim:o}=r,A=s.shape.length;let u=o;if(u===-1&&(u=A-1),u!==A-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${A} and dim was ${u}`);const h=pt([u],s.shape),l=ZL({inputs:{x:s},backend:t,attrs:{reductionIndices:h,keepDims:!1}}),c=us(l.shape,h),d=zr({inputs:{x:l},backend:t,attrs:{shape:c}}),m=nN({inputs:{a:s,b:d},backend:t}),y=DL({inputs:{x:m},backend:t}),b=og({inputs:{x:y},backend:t,attrs:{axis:h,keepDims:!1}}),v=zr({inputs:{x:b},backend:t,attrs:{shape:c}}),w=eN({inputs:{a:y,b:v},backend:t});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(v),w}const Goe={kernelName:xv,backendName:"cpu",kernelFunc:QL},Voe={kernelName:XC,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{numSamples:o,seed:A,normalized:u}=r;Kt(s,"multinomial");const h=u?s:QL({inputs:{logits:s},backend:t,attrs:{dim:-1}}),l=h.shape[0],c=h.shape[1],d=t.data.get(h.dataId).values,m=[l,o],y=Mr(Ye(m),"int32");for(let b=0;b<l;++b){const v=b*c,w=new Float32Array(c-1);w[0]=d[v];for(let T=1;T<w.length;++T)w[T]=w[T-1]+d[v+T];const I=UI.alea(A.toString()),S=b*o;for(let T=0;T<o;++T){const D=I();y[S+T]=w.length;for(let L=0;L<w.length;L++)if(D<w[L]){y[S+T]=L;break}}}return u||t.disposeIntermediateTensorInfo(h),t.makeTensorInfo(m,"int32",y)}};function KL(n,e,t){const r=tu(-1,t);return _3([],e,r,n,t)}const Xoe={kernelName:av,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t}=n,{x:r}=e;Kt(r,"neg");const s=t.data.get(r.dataId).values,[o,A]=KL(s,r.shape,r.dtype);return t.makeTensorInfo(A,r.dtype,o)}},Zoe=sS,Yoe={kernelName:ZC,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:o}=e,{maxOutputSize:A,iouThreshold:u,scoreThreshold:h}=r;Kt(s,"NonMaxSuppression");const l=t.data.get(s.dataId).values,c=t.data.get(o.dataId).values,{selectedIndices:d}=Zoe(l,c,A,u,h);return t.makeTensorInfo([d.length],"int32",new Int32Array(d))}},Uoe=aS,Qoe={kernelName:YC,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:o}=e,{maxOutputSize:A,iouThreshold:u,scoreThreshold:h,padToMaxOutputSize:l}=r;Kt(s,"NonMaxSuppressionPadded");const c=t.data.get(s.dataId).values,d=t.data.get(o.dataId).values,{selectedIndices:m,validOutputs:y}=Uoe(c,d,A,u,h,l);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([],"int32",new Int32Array([y]))]}},Koe=oS,qoe={kernelName:UC,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:o}=e,{maxOutputSize:A,iouThreshold:u,scoreThreshold:h,softNmsSigma:l}=r;Kt(s,"NonMaxSuppressionWithScore");const c=t.data.get(s.dataId).values,d=t.data.get(o.dataId).values,m=A,y=u,b=h,v=l,{selectedIndices:w,selectedScores:I}=Koe(c,d,m,y,b,v);return[t.makeTensorInfo([w.length],"int32",new Int32Array(w)),t.makeTensorInfo([I.length],"float32",new Float32Array(I))]}},qL=vs((n,e)=>n!==e?1:0),Joe=Ys(ov,qL,null,"bool"),$oe={kernelName:ov,backendName:"cpu",kernelFunc:Joe},_oe={kernelName:Av,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s}=e,{depth:o,onValue:A,offValue:u}=r;Kt(s,"oneHot");const h=Ye(s.shape),l=new Float32Array(h*o);l.fill(u);const c=t.data.get(s.dataId).values;for(let d=0;d<h;++d)c[d]>=0&&c[d]<o&&(l[d*o+c[d]]=A);return t.makeTensorInfo([...s.shape,o],"int32",l)}};function Zx(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){const s=Yc({inputs:{input:r},backend:t}),o=Zx({inputs:{x:s},backend:t}),A=jp({inputs:{input:r},backend:t}),u=Zx({inputs:{x:A},backend:t}),h=So({inputs:{real:o,imag:u},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(A),t.disposeIntermediateTensorInfo(u),h}return sN({backend:t,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const eie={kernelName:Iv,backendName:"cpu",kernelFunc:Zx},tie={kernelName:iv,backendName:"cpu",kernelFunc:function n(e){const{inputs:t,backend:r}=e,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const o=Yc({inputs:{input:s},backend:r}),A=n({inputs:{x:o},backend:r}),u=jp({inputs:{input:s},backend:r}),h=Zx({inputs:{x:u},backend:r}),l=So({inputs:{real:A,imag:h},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(A),r.disposeIntermediateTensorInfo(u),r.disposeIntermediateTensorInfo(h),l}return sN({backend:r,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}};function JL(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r;if(e.length===1)return Xx({inputs:{input:e[0]},backend:t,attrs:{dim:s}});const o=e[0].shape,A=e[0].dtype;e.forEach(l=>{gn(o,l.shape,"All tensors passed to stack must have matching shapes"),J(A===l.dtype,()=>"All tensors passed to stack must have matching dtypes")});const u=[],h=Hp({inputs:e.map(l=>{const c=Xx({inputs:{input:l},backend:t,attrs:{dim:s}});return u.push(c),c}),backend:t,attrs:{axis:s}});return u.forEach(l=>t.disposeIntermediateTensorInfo(l)),h}const nie={kernelName:lv,backendName:"cpu",kernelFunc:JL},$L={kernelName:uv,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{paddings:o,constantValue:A}=r;Kt(s,"pad");const u=o.map((I,S)=>I[0]+s.shape[S]+I[1]),h=o.map(I=>I[0]),l=t.data.get(s.dataId).values,c=Ye(s.shape),d=s.shape.length,m=Je(s.shape),y=Ye(u),b=u.length,v=Je(u),w=Oe(s.dtype,y);A!==0&&w.fill(A);for(let I=0;I<c;I++)w[ms(is(I,d,m).map((S,T)=>S+h[T]),b,v)]=l[I];return{dataId:t.write(w,u,s.dtype),shape:u,dtype:s.dtype}}},rie=vs((n,e)=>Math.pow(n,e)),sie=Ys(rm,rie),aie={kernelName:rm,backendName:"cpu",kernelFunc:sie};function _L(n,e,t,r){const[s,o]=Xs(n,r),A=Uo(e,"int32"),u=Mr(Ye(s),A),h=Ye(o);for(let l=0;l<u.length;++l){const c=l*h;let d=1;for(let m=0;m<h;++m)d*=t[c+m];u[l]=d}return{outVals:u,outShape:s,outDtype:A}}const oie={kernelName:QC,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:A}=r;Kt(s,"prod");const u=s.shape.length,h=pt(o,s.shape),l=cs(h,u);let c=h,d=s;const m=[];l!=null&&(d=ei({inputs:{x:s},backend:t,attrs:{perm:l}}),m.push(d),c=bs(c.length,u));const y=t.data.get(d.dataId).values,{outVals:b,outShape:v,outDtype:w}=_L(d.shape,d.dtype,y,c);let I=v;return A&&(I=us(v,h)),m.forEach(S=>t.disposeIntermediateTensorInfo(S)),t.makeTensorInfo(I,w,b)}};function e6(n,e,t,r){if(n===e||n<e&&t<0||e<n&&t>1)return Mr(0,r);const s=Mr(Math.abs(Math.ceil((e-n)/t)),r);e<n&&t===1&&(t=-1),s[0]=n;for(let o=1;o<s.length;o++)s[o]=s[o-1]+t;return s}const iie={kernelName:KC,backendName:"cpu",kernelFunc:function(n){const{backend:e,attrs:t}=n,{start:r,stop:s,dtype:o,step:A}=t,u=e6(r,s,A,o);return e.makeTensorInfo([u.length],o,u)}},Aie=hr(sm,n=>1/n),lie={kernelName:sm,backendName:"cpu",kernelFunc:Aie},uie={kernelName:hv,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:o,halfPixelCenters:A,size:u}=r;Kt(s,"resizeBilinear");const h=Je(s.shape),[l,c]=u,[d,m,y,b]=s.shape,v=t.data.get(s.dataId).values,w=new Float32Array(Ye([d,l,c,b])),I=[o&&l>1?m-1:m,o&&c>1?y-1:y],S=[o&&l>1?l-1:l,o&&c>1?c-1:c];let T=0;const D=I[0]/S[0],L=I[1]/S[1];for(let W=0;W<d;W++)for(let K=0;K<l;K++){let U;U=A?D*(K+.5)-.5:D*K;const _=Math.max(0,Math.floor(U)),ee=U-_,re=Math.min(m-1,Math.ceil(U)),ce=W*h[0]+_*h[1],we=W*h[0]+re*h[1];for(let Ee=0;Ee<c;Ee++){let Pe;Pe=A?L*(Ee+.5)-.5:L*Ee;const he=Math.max(0,Math.floor(Pe)),de=Pe-he,Ae=Math.min(y-1,Math.ceil(Pe)),Se=ce+he*h[2],Te=we+he*h[2],Ze=ce+Ae*h[2],et=we+Ae*h[2];for(let qe=0;qe<b;qe++){const Re=v[Se+qe],Ue=v[Te+qe],ot=Re+(v[Ze+qe]-Re)*de,yt=ot+(Ue+(v[et+qe]-Ue)*de-ot)*ee;w[T++]=yt}}}return t.makeTensorInfo([d,l,c,b],"float32",w)}},cie={kernelName:$C,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:o}=e,{alignCorners:A}=r;Kt([o,s],"resizeBilinearGrad");const u=Je(s.shape),[h,l,c,d]=s.shape,[,m,y]=o.shape,b=new Float32Array(h*l*c*d),v=[A&&m>1?l-1:l,A&&y>1?c-1:c],w=[A&&m>1?m-1:m,A&&y>1?y-1:y],I=v[0]/w[0],S=v[1]/w[1],T=t.data.get(o.dataId).values;let D=0;for(let L=0;L<h;L++){const W=L*u[0];for(let K=0;K<m;K++){const U=K*I,_=Math.floor(U),ee=Math.min(Math.ceil(U),l-1),re=W+_*u[1],ce=W+ee*u[1],we=U-_,Ee=1-we;for(let Pe=0;Pe<y;Pe++){const he=Pe*S,de=Math.floor(he),Ae=Math.min(Math.ceil(he),c-1),Se=he-de,Te=1-Se,Ze=re+de*u[2],et=re+Ae*u[2],qe=ce+de*u[2],Re=ce+Ae*u[2],Ue=Ee*Te,ot=Ee*Se,yt=we*Te,Vt=we*Se;for(let ln=0;ln<d;ln++){const en=T[D++];b[Ze+ln]+=en*Ue,b[et+ln]+=en*ot,b[qe+ln]+=en*yt,b[Re+ln]+=en*Vt}}}}return t.makeTensorInfo([h,c,l,d],"float32",b)}},die={kernelName:pv,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:o,halfPixelCenters:A,size:u}=r;Kt(s,"resizeNearestNeighbor");const h=Je(s.shape),[l,c]=u,[d,m,y,b]=s.shape,v=t.data.get(s.dataId).values,w=new Float32Array(d*l*c*b),I=[o&&l>1?m-1:m,o&&c>1?y-1:y],S=[o&&l>1?l-1:l,o&&c>1?c-1:c],T=I[0]/S[0],D=I[1]/S[1];let L=0;for(let W=0;W<d;W++){const K=W*h[0];for(let U=0;U<l;U++){const _=A?T*(U+.5):T*U;let ee=Math.min(m-1,o?Math.round(_):Math.floor(_));A&&(ee=Math.max(0,ee));const re=K+ee*h[1];for(let ce=0;ce<c;ce++){const we=A?D*(ce+.5):D*ce;let Ee=Math.min(y-1,o?Math.round(we):Math.floor(we));A&&(Ee=Math.max(0,Ee));const Pe=re+Ee*h[2];for(let he=0;he<b;he++){const de=v[Pe+he];w[L++]=de}}}}return t.makeTensorInfo([d,l,c,b],s.dtype,w)}},pie={kernelName:JC,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:o}=e,{alignCorners:A}=r;Kt([o,s],"resizeNearestNeighborGrad");const u=Je(s.shape),h=Je(o.shape),[l,c,d,m]=s.shape,[,y,b]=o.shape,v=new Float32Array(l*c*d*m),w=t.data.get(o.dataId).values,I=[A&&y>1?c-1:c,A&&b>1?d-1:d],S=[A&&y>1?y-1:y,A&&b>1?b-1:b],T=I[0]/S[0],D=I[1]/S[1],L=1/T,W=1/D,K=2*Math.ceil(L)+2,U=2*Math.ceil(W)+2;for(let _=0;_<l;_++){const ee=_*u[0];for(let re=0;re<c;re++){const ce=ee+re*u[1],we=Math.floor(re*L),Ee=Math.floor(we-K/2);for(let Pe=0;Pe<d;Pe++){const he=ce+Pe*u[2],de=Math.floor(Pe*W),Ae=Math.floor(de-U/2);for(let Se=0;Se<m;Se++){let Te=0;for(let Ze=0;Ze<K;Ze++){const et=Ze+Ee;if(et<0||et>=y)continue;const qe=ee+et*h[1],Re=et*T;if(re===Math.min(c-1,A?Math.round(Re):Math.floor(Re)))for(let Ue=0;Ue<U;Ue++){const ot=Ue+Ae;if(ot<0||ot>=b)continue;const yt=qe+ot*h[2],Vt=ot*D;Pe===Math.min(d-1,A?Math.round(Vt):Math.floor(Vt))&&(Te+=w[yt+Se])}}v[he+Se]=Te}}}}return t.makeTensorInfo(s.shape,s.dtype,v)}},hie={kernelName:fv,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dims:o}=r;Kt(s,"reverse");const A=s.shape.length,u=pt(o,s.shape);if(A===0)return DA({inputs:{x:s},backend:t});const h=new Gs(s.shape,s.dtype),l=t.bufferSync(s);for(let c=0;c<h.size;c++){const d=h.indexToLoc(c),m=d.slice();u.forEach(y=>m[y]=s.shape[y]-1-m[y]),h.set(l.get(...m),...d)}return t.makeTensorInfo(h.shape,h.dtype,h.values)}},fie={kernelName:hI,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,{radians:s,fillValue:o,center:A}=e,u=t,h=Oe(r.dtype,Ye(r.shape)),[l,c,d,m]=r.shape,[y,b]=xS(A,c,d),v=Math.sin(s),w=Math.cos(s),I=u.data.get(r.dataId).values;for(let S=0;S<l;S++){const T=S*d*c*m;for(let D=0;D<c;D++){const L=D*(d*m);for(let W=0;W<d;W++){const K=W*m;for(let U=0;U<m;U++){const _=[l,D,W,U],ee=_[2],re=_[1];let ce=(ee-y)*w-(re-b)*v,we=(ee-y)*v+(re-b)*w;ce=Math.round(ce+y),we=Math.round(we+b);let Ee=o;typeof o!="number"&&(Ee=U===3?255:o[U]),ce>=0&&ce<d&&we>=0&&we<c&&(Ee=I[T+we*(d*m)+ce*m+U]),h[T+L+K+U]=Ee}}}}return{dataId:u.write(h,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},mie=hr(im,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2==0?e:e+1}),gie={kernelName:im,backendName:"cpu",kernelFunc:mie},t6=ku(n=>1/Math.sqrt(n)),yie=Wp(Am,t6),bie={kernelName:Am,backendName:"cpu",kernelFunc:yie};function n6(n,e,t,r,s,o,A,u,h,l){const c=[r/s,s],d=n.values,m=e.values;if(r===0)return Wn(t,e.dtype);const y=Wn(c,e.dtype);y.values.fill(h);for(let b=0;b<o;b++){const v=[];let w=0;for(let I=0;I<A;I++){const S=d[b*A+I];v.push(S),w+=S*u[I]}if(w<0||w>=r/s)throw new Error(`Invalid indices: ${v} does not index into ${t}`);for(let I=0;I<s;I++)l?y.values[w*s+I]+=m[b*s+I]:y.values[w*s+I]=e.rank===0?m[0]:m[b*s+I]}return y}const vie={kernelName:_C,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s,updates:o}=e,{shape:A}=r,{sliceRank:u,numUpdates:h,sliceSize:l,strides:c,outputSize:d}=Hm(0,s,A),m=n6(t.bufferSync(s),t.bufferSync(o),A,d,l,h,u,c,0,!0);return t.makeTensorInfo(A,m.dtype,m.values)}},xie={kernelName:mv,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t}=n,{condition:r,t:s,e:o}=e;Kt([r,s,o],"select");const A=r.shape.length,u=t.data.get(r.dataId).values,h=t.data.get(s.dataId).values,l=t.data.get(o.dataId).values,c=Uo(s.dtype,o.dtype),d=Mr(Ye(s.shape),c);let m=0;const y=A===0||A>1||s.shape.length===1?1:Ye(s.shape.slice(1));for(let b=0;b<u.length;b++)for(let v=0;v<y;v++)u[b]===1?d[m++]=h[b]:d[m++]=l[b];return t.makeTensorInfo(s.shape,c,d)}},wie=lx,kie=ux,Cie=hr(lm,n=>n>=0?kie*n:wie*(Math.exp(n)-1)),Iie={kernelName:lm,backendName:"cpu",kernelFunc:Cie},Sie=hr(dm,n=>n<0?-1:n>0?1:0),Nie={kernelName:dm,backendName:"cpu",kernelFunc:Sie},Tie=hr(um,n=>Math.sin(n)),Mie={kernelName:um,backendName:"cpu",kernelFunc:Tie},Eie=hr(cm,n=>Math.sinh(n)),Die={kernelName:cm,backendName:"cpu",kernelFunc:Eie},r6=Math.log(11920928955078125e-23)+2,zie=hr(hm,n=>{const e=n>-r6,t=n<r6,r=Math.exp(n);let s;return s=t?r:e?n:Math.log(1+r),s}),Oie={kernelName:hm,backendName:"cpu",kernelFunc:zie},Pie={kernelName:bv,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:o,paddings:A}=r;Kt([s],"spaceToBatchND");const u=Ye(o),h=[[0,0]];h.push(...A);for(let w=1+o.length;w<s.shape.length;++w)h.push([0,0]);const l=$L.kernelFunc({inputs:{x:s},backend:t,attrs:{paddings:h,constantValue:0}}),c=Rm(l.shape,o,u,!1),d=Wm(c.length,o.length,!1),m=jm(l.shape,o,u,!1),y=zr({inputs:{x:l},backend:t,attrs:{shape:c}}),b=ei({inputs:{x:y},backend:t,attrs:{perm:d}}),v=zr({inputs:{x:b},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),v}};function s6(n,e,t,r,s,o,A){const u=e[0],h=o[0],l=new Array(h),c=new Array(u),d=e[1];if(h===0){if(u!==0)throw new Error(`Received SparseTensor with denseShape[0] = 0 but
         indices.shape[0] = ${u}`);return[Tt(t,0),[0,d],Tt(s,0),l,c]}let m=!0,y=0;const b=new Array(h).fill(0);for(let w=0;w<u;++w){const I=n[w*d];if(I<0)throw new Error(`indices(${w}, 0) is invalid: ${I} < 0`);if(I>=h)throw new Error(`indices(${w}, 0) is invalid: ${I} >= ${h}`);++b[I],m=m&&I>=y,y=I}let v=!0;for(let w=0;w<h;++w){const I=b[w]===0;l[w]=I,v=v&&!I,b[w]=Math.max(b[w],1),w>0&&(b[w]+=b[w-1])}if(v&&m){const w=n,I=r;for(let S=0;S<u;++S)c[S]=S;return[w,[u,d],I,l,c]}{const w=b[h-1],I=Tt(t,w*d),S=Tt(s,w),T=new Array(h).fill(0);for(let D=0;D<u;++D){const L=n[D*d],W=T[L],K=(L===0?0:b[L-1])+W;T[L]++;for(let U=0;U<d;++U)I[K*d+U]=n[D*d+U];S[K]=r[D],c[D]=K}for(let D=0;D<h;++D)if(T[D]===0){const L=D===0?0:b[D-1];I[L*d+0]=D;for(let W=1;W<d;++W)I[L*d+W]=0;S[L]=A}return[I,[w,d],S,l,c]}}const Bie={kernelName:eI,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t}=n,{indices:r,values:s,denseShape:o,defaultValue:A}=e;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${o.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${s.shape}`);if(A.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${A.shape}`);const u=t.data.get(r.dataId).values,h=t.data.get(s.dataId).values,l=t.data.get(o.dataId).values,c=t.data.get(A.dataId).values[0],[d,m,y,b,v]=s6(u,r.shape,r.dtype,h,s.dtype,l,c);return[t.makeTensorInfo(m,r.dtype,d),t.makeTensorInfo([m[0]],s.dtype,y),t.makeTensorInfo([b.length],"bool",new Uint8Array(b.map(w=>Number(w)))),t.makeTensorInfo([v.length],r.dtype,new Int32Array(v))]}};function a6(n,e,t,r,s){const o=Ye(r),A=e[0],u=s.length,h=[];let l=1,c=-1;for(let w=0;w<u;++w){const I=s[w];if(I===-1){if(c!==-1)throw new Error(`only one output dimension may be -1, not both ${c} and ${w}`);c=w,h.push(1)}else{if(I<0)throw new Error(`size ${w} must be non-negative, not ${I}`);l*=I,h.push(I)}}if(c!==-1){if(l<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const w=Math.trunc(o/l);if(l*w!==o)throw new Error(`Input to reshape is a SparseTensor with ${o}
          dense values, but the requested shape requires a multiple of ${l}. inputShape=${r} outputShape= ${h}`);h[c]=w}const d=Ye(h);if(d!==o)throw new Error(`Input to reshape is a tensor with ${o} dense values, but the requested shape has ${d}. inputShape=${r} outputShape=${h}`);const m=r.length,y=[];if(m>0){y[m-1]=1;for(let w=m-2;w>=0;--w)y[w]=y[w+1]*r[w+1]}const b=[];if(u>0){b[u-1]=1;for(let w=u-2;w>=0;--w)b[w]=b[w+1]*h[w+1]}const v=Tt(t,A*u);for(let w=0;w<A;++w){let I=0;for(let S=0;S<m;++S)I+=n[w*m+S]*y[S];for(let S=0;S<u;++S)v[w*u+S]=Math.trunc(I/b[S]),I%=b[S]}return[v,[A,u],h]}const Fie={kernelName:tI,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t}=n,{inputIndices:r,inputShape:s,newShape:o}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const A=Array.from(t.data.get(s.dataId).values),u=t.data.get(r.dataId).values,h=Array.from(t.data.get(o.dataId).values),[l,c,d]=a6(u,r.shape,r.dtype,A,h);return[t.makeTensorInfo(c,r.dtype,l),t.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}};function aN(n,e,t,r,s,o=!1,A=0){const u=r.length;if(u!==s.length)throw new Error("segmentIds and indices should have same size.");const h=[e[0],n.length/e[0]],l=h[1],c=u>0?s[u-1]+1:0;if(c<0)throw new Error("segment ids must be >= 0");const d=e.slice();d[0]=c;const m=Tt(t,d.reduce((I,S)=>I*S,1));if(u===0)return c>0&&m.fill(A),[m,d];if(c<=0)throw new Error("segment ids must be >= 0");let y=0,b=1,v=0,w=s[y];for(;;){let I=0;if(b<u){if(I=s[b],w===I){++b;continue}if(w>=I)throw new Error("segment ids are not increasing")}if(w<0||w>=c)throw new Error(`Segment id ${w} out of range [0, ${c}), possibly because segmentIds input is not sorted.`);w>v&&m.fill(A,v*l,w*l);for(let S=y;S<b;++S){const T=r[S];if(T<0||T>=h[0])throw new Error(`Bad: indices[${S}] == ${r[S]} out of range [0, ${h[0]})`);for(let D=0;D<l;D++)m[w*l+D]+=n[T*l+D]}if(o)for(let S=0;S<l;S++)m[w*l+S]/=b-y;if(y=b,++b,v=w+1,w=I,b>u)break}return v<c&&m.fill(A,v*l,c*l),[m,d]}const Lie={kernelName:nI,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:o}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${o.shape}`);const A=t.data.get(r.dataId).values,u=t.data.get(s.dataId).values,h=t.data.get(o.dataId).values,[l,c]=aN(A,r.shape,r.dtype,u,h,!0);return t.makeTensorInfo(c,r.dtype,l)}},Rie={kernelName:rI,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:o}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${o.shape}`);const A=t.data.get(r.dataId).values,u=t.data.get(s.dataId).values,h=t.data.get(o.dataId).values,[l,c]=aN(A,r.shape,r.dtype,u,h);return t.makeTensorInfo(c,r.dtype,l)}},Wie={kernelName:sI,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{sparseIndices:s,sparseValues:o,defaultValue:A}=e,{outputShape:u}=r,{sliceRank:h,numUpdates:l,sliceSize:c,strides:d,outputSize:m}=Hm(0,s,u),y=n6(t.bufferSync(s),t.bufferSync(o),u,m,c,l,h,d,t.data.get(A.dataId).values[0],!1);return t.makeTensorInfo(u,y.dtype,y.values)}},jie={kernelName:vv,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{numOrSizeSplits:o,axis:A}=r,u=pt(A,s.shape)[0],h=RS(s,o,u),l=new Array(s.shape.length).fill(0),c=s.shape.slice();return h.map(d=>{const m=[...c];m[u]=d;const y=Uc({inputs:{x:s},backend:t,attrs:{begin:l,size:m}});return l[u]+=d,y})}},Hie=ku(n=>Math.sqrt(n)),Gie=hr(fm,n=>Math.sqrt(n)),Vie={kernelName:fm,backendName:"cpu",kernelFunc:Gie},Xie={kernelName:aI,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,r=e;Kt(t,"square");const s=r.data.get(t.dataId).values,o=new Float32Array(s.length);for(let A=0;A<s.length;++A){const u=s[A];o[A]=u*u}return{dataId:r.write(o,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}},Zie=vs((n,e)=>{const t=n-e;return t*t}),Yie=Ys(mm,Zie),Uie={kernelName:mm,backendName:"cpu",kernelFunc:Yie},Qie=hr(xm,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),Kie={kernelName:xm,backendName:"cpu",kernelFunc:Qie};function o6(n,e,t,r){const s=Wn(n,e.dtype);for(let o=0;o<s.size;o++){const A=s.indexToLoc(o),u=new Array(A.length);for(let h=0;h<u.length;h++)u[h]=A[h]*t[h]+r[h];s.set(e.get(...u),...A)}return s}const qie={kernelName:oI,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:o,end:A,strides:u,beginMask:h,endMask:l,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:m}=r;Kt(s,"stridedSlice");const{nonStrided:y,$begin:b,$strides:v,size:w,newShape:I,outShape:S}=PI(s.shape,o,A,u,h,l,c,d,m),T=zr({inputs:{x:s},backend:t,attrs:{shape:I}});let D;if(y){const W=Uc({inputs:{x:T},backend:t,attrs:{begin:b,size:w}});D=zr({inputs:{x:W},backend:t,attrs:{shape:S}}),t.disposeIntermediateTensorInfo(W)}else if(S.some(W=>W===0))D=t.makeTensorInfo(S,s.dtype,[]);else{const W=o6(S,t.bufferSync(T),v,b);D=t.makeTensorInfo(W.shape,W.dtype,W.values)}const L=zr({inputs:{x:D},backend:t,attrs:{shape:S}});return t.disposeIntermediateTensorInfo(T),t.disposeIntermediateTensorInfo(D),L}};class Jie{constructor(e,t,r,s,o,A){this.separator=nu(e),this.nGramWidths=t,this.leftPad=nu(r),this.rightPad=nu(s),this.padWidth=o,this.preserveShort=A}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const r=this.getPadWidth(t);return Math.max(0,e+2*r-t+1)}createNGrams(e,t,r,s,o,A){for(let u=0;u<o;++u){const h=this.getPadWidth(A),l=Math.max(0,h-u),c=Math.max(0,h-(o-(u+1))),d=A-(l+c),m=t+(l>0?0:u-h);let y=0;y+=l*this.leftPad.length;for(let I=0;I<d;++I)y+=e[m+I].length;y+=c*this.rightPad.length,y+=(l+c+d-1)*this.separator.length,r[s+u]=new Uint8Array(y);const b=r[s+u];let v=0;const w=I=>I.forEach(S=>b[v++]=S);for(let I=0;I<l;++I)w(this.leftPad),w(this.separator);for(let I=0;I<d-1;++I)w(e[m+I]),w(this.separator);if(d>0){w(e[m+d-1]);for(let I=0;I<c;++I)w(this.separator),w(this.rightPad)}else{for(let I=0;I<c-1;++I)w(this.rightPad),w(this.separator);w(this.rightPad)}}}compute(e,t){const r=e.length,s=t.length;if(s>0){let h=t[0];if(h!==0)throw new Error(`First split value must be 0, got ${h}`);for(let l=1;l<s;++l){let c=t[l]>=h;if(c=c&&t[l]<=r,!c)throw new Error(`Invalid split value ${t[l]}, must be in [${h}, ${r}]`);h=t[l]}if(h!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${h}`)}const o=s-1,A=Tt("int32",s);if(r===0||s===0){const h=new Array(r);for(let l=0;l<=o;++l)A[l]=0;return[h,A]}A[0]=0;for(let h=1;h<=o;++h){const l=t[h]-t[h-1];let c=0;this.nGramWidths.forEach(d=>{c+=this.getNumNGrams(l,d)}),this.preserveShort&&l>0&&c===0&&(c=1),A[h]=A[h-1]+c}const u=new Array(A[o]);for(let h=0;h<o;++h){const l=t[h];let c=A[h];if(this.nGramWidths.forEach(d=>{const m=t[h+1]-t[h],y=this.getNumNGrams(m,d);this.createNGrams(e,l,u,c,y,d),c+=y}),this.preserveShort&&c===A[h]){const d=t[h+1]-t[h];if(d===0)continue;const m=d+2*this.padWidth;this.createNGrams(e,l,u,c,1,m)}}return[u,A]}}function i6(n,e,t,r,s,o,A,u){return new Jie(t,r,s,o,A,u).compute(n,e)}const $ie={kernelName:iI,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{separator:s,nGramWidths:o,leftPad:A,rightPad:u,padWidth:h,preserveShortSequences:l}=r,{data:c,dataSplits:d}=e,m=t.data.get(c.dataId).values,y=t.data.get(d.dataId).values,[b,v]=i6(m,y,s,o,A,u,h,l);return[t.makeTensorInfo([b.length],"string",b),t.makeTensorInfo(d.shape,"int32",v)]}};function _ie(n,e,t,r){if(!n.length)return;if(e.length===0){for(let o=0;o<n.length;++o)r.push(n.subarray(o,o+1));return}if(e.length===1){const o=e[0];let A=n.indexOf(o);for(;A!==-1;){const u=n.subarray(0,A);t&&u.length===0||r.push(u),A=(n=n.subarray(A+1)).indexOf(o)}return void(t&&n.length===0||r.push(n))}let s=0;for(let o=0;o<n.length+1;o++)if(o===n.length||e.indexOf(n[o])!==-1){const A=n.subarray(s,o);t&&A.length===0||r.push(A),s=o+1}}function A6(n,e,t){const r=n.length,s=[];let o=0,A=0;const u=new Array(r);for(let m=0;m<r;++m){const y=s.length;_ie(n[m],e,t,s);const b=s.length-y;u[m]=b,o+=b,A=Math.max(A,b)}const h=Tt("int32",2*o),l=new Array(o),c=[r,A];let d=0;for(let m=0;m<r;++m)for(let y=0;y<u[m];++y)h[2*d]=m,h[2*d+1]=y,l[d]=s[d],++d;return[h,l,c]}const eAe={kernelName:AI,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{skipEmpty:s}=r,{input:o,delimiter:A}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(A.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${A.shape}`);const u=t.data.get(o.dataId).values,h=t.data.get(A.dataId).values[0],[l,c,d]=A6(u,h,s),m=c.length;return[t.makeTensorInfo([m,2],"int32",l),t.makeTensorInfo([m],"string",c),t.makeTensorInfo([2],"int32",new Int32Array(d))]}};function l6(n,e){const t=Tt("int32",n.length);for(let r=0;r<n.length;++r)t[r]=X_(n[r]).modulo(e).getLowBitsUnsigned();return t}const tAe={kernelName:lI,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{numBuckets:s}=r,{input:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const A=l6(t.data.get(o.dataId).values,s);return t.makeTensorInfo(o.shape,"int32",A)}},nAe=hr(ym,n=>Math.tan(n)),rAe={kernelName:ym,backendName:"cpu",kernelFunc:nAe},sAe=hr(bm,n=>Math.tanh(n));function u6(n,e){const t=new Array(n.rank);for(let s=0;s<t.length;s++)t[s]=n.shape[s]*e[s];const r=Wn(t,n.dtype);for(let s=0;s<r.values.length;++s){const o=r.indexToLoc(s),A=new Array(n.rank);for(let h=0;h<A.length;h++)A[h]=o[h]%n.shape[h];const u=n.locToIndex(A);r.values[s]=n.values[u]}return r}const ig=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function c6(n,e,t=0,r=n.length-1){for(;r>t;){if(r-t>600){const u=r-t+1,h=e-t+1,l=Math.log(u),c=.5*Math.exp(2*l/3),d=.5*Math.sqrt(l*c*(u-c)/u)*Math.sign(h-u/2);c6(n,e,Math.max(t,Math.floor(e-h*c/u+d)),Math.min(r,Math.floor(e+(u-h)*c/u+d)))}const s=n[e];let o=t,A=r;for(Sn(n,t,e),ig(n[r],s)>0&&Sn(n,t,r);o<A;){for(Sn(n,o,A),o++,A--;ig(n[o],s)<0;)o+=1;for(;ig(n[A],s)>0;)A-=1}ig(n[t],s)===0?Sn(n,t,A):(A+=1,Sn(n,A,r)),A<=e&&(t=A+1),e<=A&&(r=A-1)}}function d6(n,e,t,r,s){const o=e[e.length-1],[A,u]=[n.length/o,o],h=Oe(t,A*r),l=Oe("int32",A*r);for(let d=0;d<A;d++){const m=d*u,y=n.subarray(m,m+u);let b=new Array(y.length);y.forEach((S,T)=>b[T]={value:S,index:T}),r<b.length&&(c6(b,r),b=b.slice(0,r)),s&&b.sort(ig);const v=d*r,w=h.subarray(v,v+r),I=l.subarray(v,v+r);for(let S=0;S<r;S++)w[S]=b[S].value,I[S]=b[S].index}const c=e.slice();return c[c.length-1]=r,[Wn(c,t,h),Wn(c,"int32",l)]}function p6(n,e,t){switch(t){case"reflect":return function(r,s){let o=r;if(o<0)if(s<=1)o=0;else{const A=2*s;o<A&&(o=A*Math.trunc(-o/A)+o),o=o<-s?o+A:-o-1}else if(o>s-1)if(s<=1)o=0;else{const A=2*s;o-=A*Math.trunc(o/A),o>=s&&(o=A-o-1)}return Mt(0,o,s-1)}(n,e);case"wrap":return function(r,s){let o=r;if(o<0)if(s<=1)o=0;else{const A=s-1;o+=s*(Math.trunc(-o/A)+1)}else if(o>s-1)if(s<=1)o=0;else{const A=s-1;o-=s*Math.trunc(o/A)}return Mt(0,o,s-1)}(n,e);case"nearest":return function(r,s){return Mt(0,r,s-1)}(n,e);default:return n}}function Ag(n,e,t,r,s,o,A,u,h,l,c){return 0<=u&&u<e&&0<=h&&h<t?n[A*r+u*s+h*o+l]:c}function aAe(n,e,t,r,s,o,A,u,h,l,c){return Ag(n,e,t,r,s,o,A,Math.round(u),Math.round(h),l,c)}function oAe(n,e,t,r,s,o,A,u,h,l,c){const d=Math.floor(u),m=Math.floor(h),y=d+1,b=m+1;return(y-u)*((b-h)*Ag(n,e,t,r,s,o,A,d,m,l,c)+(h-m)*Ag(n,e,t,r,s,o,A,d,b,l,c))+(u-d)*((b-h)*Ag(n,e,t,r,s,o,A,y,m,l,c)+(h-m)*Ag(n,e,t,r,s,o,A,y,b,l,c))}function h6(n,e,t,r){const s=pt(e,t)[0],o=[1,t[0],1];for(let b=0;b<s;b++)o[0]*=t[b];o[1]=t[s];for(let b=s+1;b<t.length;b++)o[2]*=t[b];const A={},u=new Int32Array(t[s]),h=new Gs(o,r,n),l=[],c=o[0]===1&&o[2]===1;for(let b=0;b<t[s];b++){let v;if(c)v=n[b].toString();else{const w=[];for(let I=0;I<o[0];I++)for(let S=0;S<o[2];S++)w.push(h.get(I,b,S));v=w.join(",")}if(A[v]!==void 0)u[b]=A[v];else{const w=Object.keys(A).length;A[v]=w,u[b]=w,l.push(b)}}const d=o.slice();d[1]=Object.keys(A).length;const m=new Gs(d,r);l.forEach((b,v)=>{for(let w=0;w<o[0];w++)for(let I=0;I<o[2];I++)m.set(h.get(w,b,I),w,v,I)});const y=t.slice();return y[s]=d[1],{outputValues:m.values,outputShape:y,indices:u}}const iAe=[use,cse,pse,fse,ise,mse,yse,bse,vse,xse,kse,Ise,Nse,Ese,zse,Ose,Pse,Bse,Fse,lse,Lse,Wse,jse,Hse,ase,Vse,Zse,rse,Yse,Qse,qse,Jse,Kse,_se,eae,$se,nae,sae,aae,oae,iae,Aae,lae,uae,cae,dae,pae,fae,hae,tN,bae,Qre,vae,xae,Mae,Eae,Dae,Oae,Rae,Wae,jae,Gae,Zae,Yae,Uae,Qae,Kae,Jae,_ae,Kre,eoe,Use,noe,soe,ooe,qre,Aoe,uoe,coe,poe,foe,yoe,voe,koe,Coe,Ioe,Toe,Moe,Eoe,Doe,zoe,Ooe,Soe,Poe,Boe,Loe,Roe,Hoe,Voe,gae,Xoe,Yoe,Qoe,qoe,$oe,_oe,tie,nie,$L,aie,$re,oie,iie,sse,lie,_re,ese,Ase,uie,cie,die,pie,hie,fie,gie,bie,vie,xie,Iie,nse,Nie,Mie,Die,Rse,Goe,Oie,Pie,Bie,Fie,Lie,Rie,Wie,jie,Vie,Xie,Uie,Kie,qie,$ie,eAe,tAe,Fae,yae,rAe,{kernelName:bm,backendName:"cpu",kernelFunc:sAe},{kernelName:vm,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reps:o}=r;Kt(s,"tile");const A=u6(t.bufferSync(s),o);return t.makeTensorInfo(A.shape,A.dtype,A.values)}},{kernelName:uI,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{k:o,sorted:A}=r;Kt(s,"topk");const u=t.data.get(s.dataId).values,[h,l]=d6(u,s.shape,s.dtype,o,A);return[t.makeTensorInfo(h.shape,h.dtype,h.values),t.makeTensorInfo(l.shape,l.dtype,l.values)]}},gse,{kernelName:cI,backendName:"cpu",kernelFunc:function(n){const{inputs:e,attrs:t,backend:r}=n,{image:s,transforms:o}=e,{interpolation:A,fillMode:u,fillValue:h,outputShape:l}=t,[c,d,m,y]=s.shape,[b,v]=l??[d,m],w=[c,b,v,y],I=Je(s.shape),S=I[0],T=I[1],D=I[2],L=Oe(s.dtype,Ye(w));L.fill(h);const W=r.data.get(s.dataId).values,K=r.data.get(o.dataId).values;for(let U=0;U<c;++U){const _=o.shape[0]===1?K:K.subarray(8*U,8*U+8);for(let ee=0;ee<b;++ee)for(let re=0;re<v;++re)for(let ce=0;ce<y;++ce){let we;const Ee=_[6]*re+_[7]*ee+1;if(Ee===0)continue;const Pe=(_[0]*re+_[1]*ee+_[2])/Ee,he=(_[3]*re+_[4]*ee+_[5])/Ee,de=p6(Pe,m,u),Ae=p6(he,d,u);switch(A){case"nearest":we=aAe(W,d,m,S,T,D,U,Ae,de,ce,h);break;case"bilinear":we=oAe(W,d,m,S,T,D,U,Ae,de,ce,h);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${A}`)}L[U*S+ee*T+re*D+ce]=we}return r.makeTensorInfo(w,s.dtype,L)}return{dataId:r.write(L,w,s.dtype),shape:s.shape,dtype:s.dtype}}},{kernelName:dI,backendName:"cpu",kernelFunc:function(n){const{inputs:e,attrs:t,backend:r}=n,{axis:s}=t,{x:o}=e;Kt(o,"unique");const A=r.data.get(o.dataId).values,{outputValues:u,outputShape:h,indices:l}=h6(A,s,o.shape,o.dtype);return[r.makeTensorInfo(h,o.dtype,u),r.makeTensorInfo([l.length],"int32",l)]}},{kernelName:kv,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{value:s}=e;let{axis:o}=r;o<0&&(o+=s.shape.length);const A=s.shape.length,u=s.shape[o],h=new Array(A-1);let l=0;for(let y=0;y<A;y++)y!==o&&(h[l++]=s.shape[y]);const c=new Array(A).fill(0),d=s.shape.slice();d[o]=1;const m=new Array(u);for(let y=0;y<m.length;y++){c[o]=y;const b=Uc({inputs:{x:s},backend:t,attrs:{begin:c,size:d}});m[y]=zr({inputs:{x:b},backend:t,attrs:{shape:h}}),t.disposeIntermediateTensorInfo(b)}return m}},{kernelName:Cv,backendName:"cpu",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,segmentIds:o}=e,{numSegments:A}=r;Kt(s,"unsortedSegmentSum");const u=[],h=[],l=s.shape.length-o.shape.length;let c=o;for(let m=0;m<l;++m){const y=Xx({inputs:{input:c},backend:t,attrs:{dim:m+1}});c=y,h.push(y)}for(let m=0;m<A;++m){const y=tu(m,"int32"),b=t.makeTensorInfo([],"int32",y),v=ML({inputs:{a:b,b:c},backend:t}),w=Cu({inputs:{x:v},backend:t,attrs:{dtype:"float32"}}),I=Vx({inputs:{a:w,b:s},backend:t}),S=og({inputs:{x:I},backend:t,attrs:{axis:0,keepDims:!1}});u.push(S),h.push(b),h.push(v),h.push(w),h.push(I),h.push(S)}const d=JL({inputs:u,backend:t,attrs:{axis:0}});return h.forEach(m=>t.disposeIntermediateTensorInfo(m)),d}},eie];for(const n of iAe)w7(n);const Qc={},oN={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function zA(n){if(!(n in Qc)){const t=function(r){if(r!==1&&r!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const s=function(o){if(typeof OffscreenCanvas<"u"&&o===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(r);return s.addEventListener("webglcontextlost",o=>{o.preventDefault(),delete Qc[r]},!1),r===1?s.getContext("webgl",oN)||s.getContext("experimental-webgl",oN):s.getContext("webgl2",oN)}(n);if(t===null)return console.log("Could not get context for WebGL version",n),null;Qc[n]=t}const e=Qc[n];return e.isContextLost()?(delete Qc[n],zA(n)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),Qc[n])}var lg,Yx,ti,Iu,Aa,OA;function ug(n,e){return[e,n]}function Ux(n){const e=Ye(n);return cn(Math.ceil(e/4))}function Gp(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function iN(n,e){const t=n;let r,s,o,A,u,h,l,c,d,m;return st().getNumber("WEBGL_VERSION")===2?(r=t.R32F,s=t.R16F,o=t.RGBA16F,A=t.RGBA32F,u=t.RED,l=4,c=1,d=t.HALF_FLOAT,m=t.FLOAT):(r=n.RGBA,s=n.RGBA,o=n.RGBA,A=t.RGBA,u=n.RGBA,l=4,c=4,d=e!=null?e.HALF_FLOAT_OES:null,m=n.FLOAT),h=n.RGBA,{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:A,textureFormatFloat:u,downloadTextureFormat:h,downloadUnpackNumChannels:l,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:m}}function _t(n,e){const t=e();return st().getBool("DEBUG")&&function(r){const s=r.getError();if(s!==r.NO_ERROR)throw new Error("WebGL Error: "+function(o,A){switch(A){case o.NO_ERROR:return"NO_ERROR";case o.INVALID_ENUM:return"INVALID_ENUM";case o.INVALID_VALUE:return"INVALID_VALUE";case o.INVALID_OPERATION:return"INVALID_OPERATION";case o.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case o.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case o.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${A}`}}(r,s))}(n),t}function AAe(n){return!!(st().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||596e-10<Math.abs(n)&&Math.abs(n)<65504)}function Qx(n,e){return vl(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}(Yx=lg||(lg={}))[Yx.DENSE=0]="DENSE",Yx[Yx.SHARED_BATCH=1]="SHARED_BATCH",(Iu=ti||(ti={}))[Iu.RENDER=0]="RENDER",Iu[Iu.UPLOAD=1]="UPLOAD",Iu[Iu.PIXELS=2]="PIXELS",Iu[Iu.DOWNLOAD=3]="DOWNLOAD",(OA=Aa||(Aa={}))[OA.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",OA[OA.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",OA[OA.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",OA[OA.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",OA[OA.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16";const lAe=/ERROR: [0-9]+:([0-9]+):/g;function AN(n,e){if(_t(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function f6(n,e,t,r,s,o,A){const u=n.getAttribLocation(e,t);return u!==-1&&(_t(n,()=>n.bindBuffer(n.ARRAY_BUFFER,r)),_t(n,()=>n.vertexAttribPointer(u,s,n.FLOAT,!1,o,A)),_t(n,()=>n.enableVertexAttribArray(u)),!0)}function uAe(n,e,t,r){_t(n,()=>function(s,o,A){(function(u,h){const l=u.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,c=h+u.TEXTURE0;if(c<u.TEXTURE0||c>l)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${l}].`)})(s,A),_t(s,()=>s.activeTexture(s.TEXTURE0+A)),_t(s,()=>s.bindTexture(s.TEXTURE_2D,o))}(n,e,r)),_t(n,()=>n.uniform1i(t,r))}function lN(n,e,t){_t(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),_t(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function m6(n,e){_t(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),_t(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Kx(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(t,r){switch(r){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${r}`}}(n,e))}function vl(n,e,t){const r=_t(n,()=>e());if(r==null)throw new Error(t);return r}function Vp(n,e=2){return Ye(n.slice(0,n.length-e))}function Xp(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function uN(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[Vp(n),...Xp(n)]),e}function qx(n){return n%2==0}function Jx(n,e){if(ht(n=n.slice(-2),e=e.slice(-2))||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n.slice(-1)[0],r=e.slice(-1)[0];if(t===r||qx(t)&&qx(r)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&qx(n[0])&&qx(e[0])}let cN,dN;function Ni(n,e){return n.getExtension(e)!=null}function g6(n){try{if(zA(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function pN(n){const e=iN(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const r=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,r),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const s=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(r),s}function cg(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&J(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}const dn=st();function ja(){let n,e,t,r,s,o,A,u,h,l;return st().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",r="in",s="texture",o="outputColor",A="out vec4 outputColor;",u=`
      bool isnan_custom(float val) {
        return (val > 0.0 || val < 0.0) ? false : val != 0.0;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `,h="",l=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",r="varying",s="texture2D",o="gl_FragColor",A="",u=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,h=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,l=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:r,texture2D:s,output:o,defineOutput:A,defineSpecialNaN:u,defineSpecialInf:h,defineRound:l}}function Kc(n,e,t="index"){const r=Je(e);return r.map((s,o)=>`int ${n[o]} = ${t} / ${s}; ${o===r.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${s}`:`index -= ${n[o]} * ${s}`};`).join("")}function $x(n,e,t="index"){const r=Je(e);return r.map((s,o)=>`int ${n[o]} = ${t} / outShapeStrides[${o}]; ${o===r.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * outShapeStrides[${o}]`:`index -= ${n[o]} * outShapeStrides[${o}]`};`).join("")}function hN(n){const e=Je(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}dn.registerFlag("HAS_WEBGL",()=>dn.getNumber("WEBGL_VERSION")>0),dn.registerFlag("WEBGL_VERSION",()=>g6(2)?2:g6(1)?1:0),dn.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),dn.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>dn.get("WEBGL_VERSION")===2),dn.registerFlag("WEBGL_CPU_FORWARD",()=>!0),dn.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),dn.registerFlag("WEBGL_PACK",()=>dn.getBool("HAS_WEBGL")),dn.registerFlag("WEBGL_PACK_NORMALIZATION",()=>dn.getBool("WEBGL_PACK")),dn.registerFlag("WEBGL_PACK_CLIP",()=>dn.getBool("WEBGL_PACK")),dn.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>dn.getBool("WEBGL_PACK")),dn.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>dn.getBool("WEBGL_PACK")),dn.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>dn.getBool("WEBGL_PACK")),dn.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>dn.getBool("WEBGL_PACK")),dn.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>dn.getBool("WEBGL_PACK")),dn.registerFlag("WEBGL_PACK_REDUCE",()=>dn.getBool("WEBGL_PACK")),dn.registerFlag("WEBGL_LAZILY_UNPACK",()=>dn.getBool("WEBGL_PACK")),dn.registerFlag("WEBGL_CONV_IM2COL",()=>dn.getBool("WEBGL_PACK")),dn.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function(n){if(cN==null){const e=zA(n);cN=e.getParameter(e.MAX_TEXTURE_SIZE)}return cN}(dn.getNumber("WEBGL_VERSION"))),dn.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function(n){if(dN==null){const e=zA(n);dN=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,dN)}(dn.getNumber("WEBGL_VERSION"))),dn.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=dn.getNumber("WEBGL_VERSION");return n===0?0:function(e){if(e===0)return 0;let t;const r=zA(e);return t=Ni(r,"EXT_disjoint_timer_query_webgl2")&&e===2?2:Ni(r,"EXT_disjoint_timer_query")?1:0,t}(n)}),dn.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>dn.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!P7()),dn.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function(n){if(n===0)return!1;const e=zA(n);if(n===1){if(!Ni(e,"OES_texture_float"))return!1}else if(!Ni(e,"EXT_color_buffer_float"))return!1;return pN(e)}(dn.getNumber("WEBGL_VERSION"))),dn.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!dn.getBool("WEBGL_FORCE_F16_TEXTURES")&&dn.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),dn.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function(n){if(n===0)return!1;const e=zA(n);if(n!==1){if(Ni(e,"EXT_color_buffer_float"))return pN(e);const t="EXT_color_buffer_half_float";if(Ni(e,t)){const r=e.getExtension(t);return function(s,o){const A=iN(s,o),u=s.createTexture();s.bindTexture(s.TEXTURE_2D,u),s.texImage2D(s.TEXTURE_2D,0,A.internalFormatHalfFloat,1,1,0,A.textureFormatFloat,A.textureTypeHalfFloat,null);const h=s.createFramebuffer();s.bindFramebuffer(s.FRAMEBUFFER,h),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,u,0);const l=s.checkFramebufferStatus(s.FRAMEBUFFER)===s.FRAMEBUFFER_COMPLETE;return s.bindTexture(s.TEXTURE_2D,null),s.bindFramebuffer(s.FRAMEBUFFER,null),s.deleteTexture(u),s.deleteFramebuffer(h),l}(e,r)}return!1}return!!Ni(e,"OES_texture_float")&&!!Ni(e,"WEBGL_color_buffer_float")&&pN(e)}(dn.getNumber("WEBGL_VERSION"))),dn.registerFlag("WEBGL_FENCE_API_ENABLED",()=>{return(n=dn.getNumber("WEBGL_VERSION"))===2&&zA(n).fenceSync!=null;var n}),dn.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>dn.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),dn.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)}),dn.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>P7()&&dn.getBool("IS_CHROME")?1:-1,n=>{if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)}),dn.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),dn.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),dn.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),dn.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);const y6=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:b6}=k;function cAe(n,e,t){const r=[];if(n.forEach(m=>{const y=Ye(m.shapeInfo.logicalShape);if(m.shapeInfo.isUniform?r.push(`uniform float ${m.name}${y>1?`[${y}]`:""};`):(r.push(`uniform sampler2D ${m.name};`),r.push(`uniform int offset${m.name};`)),t.enableShapeUniforms){const{uniformShape:b}=fN(t.packedInputs,m.shapeInfo.logicalShape,m.shapeInfo.texShape);switch(b.length){case 1:r.push(`uniform int ${m.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${m.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${m.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${m.name}Shape;`)}r.push(`uniform ivec2 ${m.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(m=>{r.push(`uniform ${m.type} ${m.name}${m.arrayIndex?`[${m.arrayIndex}]`:""};`)});const s=r.join(`
`),o=n.map(m=>function(y,b,v=!1,w){let I="";I+=v?v6(y,w):Zp(y,w);const S=y.shapeInfo.logicalShape,T=b.logicalShape;return S.length<=T.length&&(I+=v?function(D,L){const W=D.name,K=W.charAt(0).toUpperCase()+W.slice(1),U="get"+K+"AtOutCoords",_=D.shapeInfo.logicalShape.length,ee=L.logicalShape.length,re=b6(D.shapeInfo.logicalShape,L.logicalShape),ce=kr(ee),we=ee-_;let Ee;const Pe=["x","y","z","w","u","v"];Ee=_===0?"":ee<2&&re.length>=1?"coords = 0;":re.map(Te=>`coords.${Pe[Te+we]} = 0;`).join(`
`);let he="";he=ee<2&&_>0?"coords":D.shapeInfo.logicalShape.map((Te,Ze)=>`coords.${Pe[Ze+we]}`).join(", ");let de="return outputValue;";const Ae=Ye(D.shapeInfo.logicalShape)===1,Se=Ye(L.logicalShape)===1;if(_!==1||Ae||Se){if(Ae&&!Se)de=ee===1?`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:`
        return vec4(outputValue.x);
      `;else if(re.length){const Te=_-2,Ze=_-1;re.indexOf(Te)>-1&&re.indexOf(Ze)>-1?de="return vec4(outputValue.x);":re.indexOf(Te)>-1?de="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":re.indexOf(Ze)>-1&&(de="return vec4(outputValue.xx, outputValue.zz);")}}else de=`
      return vec4(outputValue.xy, outputValue.xy);
    `;return`
    vec4 ${U}() {
      ${ce} coords = getOutputCoords();
      ${Ee}
      vec4 outputValue = get${K}(${he});
      ${de}
    }
  `}(y,b):function(D,L){const W=D.name,K=W.charAt(0).toUpperCase()+W.slice(1),U="get"+K+"AtOutCoords",_=L.texShape,ee=D.shapeInfo.texShape,re=D.shapeInfo.logicalShape.length,ce=L.logicalShape.length;if(!D.shapeInfo.isUniform&&re===ce&&D.shapeInfo.flatOffset==null&&ht(ee,_))return`
      float ${U}() {
        return sampleTexture(${W}, resultUV);
      }
    `;const we=kr(ce),Ee=b6(D.shapeInfo.logicalShape,L.logicalShape),Pe=ce-re;let he;const de=["x","y","z","w","u","v"];he=re===0?"":ce<2&&Ee.length>=1?"coords = 0;":Ee.map(Se=>`coords.${de[Se+Pe]} = 0;`).join(`
`);let Ae="";return Ae=ce<2&&re>0?"coords":D.shapeInfo.logicalShape.map((Se,Te)=>`coords.${de[Te+Pe]}`).join(", "),`
    float ${U}() {
      ${we} coords = getOutputCoords();
      ${he}
      return get${K}(${Ae});
    }
  `}(y,b)),I}(m,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),A=e.texShape,u=ja(),h=function(m){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${m.texture2D}(textureSampler, uv).r;
    }
  `}(u);let l,c,d=function(m){return`${m.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${m.varyingFs} vec2 resultUV;
    ${m.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${m.defineSpecialNaN}
    ${m.defineSpecialInf}
    ${m.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${dAe}
    ${pAe}
    ${hAe}
  `}(u);return e.isPacked?(l=function(m,y,b){switch(m.length){case 0:return`
    int getOutputCoords() {
      return 0;
    }
  `;case 1:return function(v,w,I){const S=[Math.ceil(w[0]/2),Math.ceil(w[1]/2)];return S[0]===1?I?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${S[1]}.0);
      }
    `:S[1]===1?I?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${S[0]}.0);
      }
    `:I?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${S[0]}, ${S[1]}));
      return 2 * (resTexRC.x * ${S[1]} + resTexRC.y);
    }
  `}(0,y,b);case 2:return function(v,w,I){const S=[Math.ceil(w[0]/2),Math.ceil(w[1]/2)];if(ht(v,w))return I?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${S[0]}, ${S[1]}));
      }
    `;const T=Math.ceil(v[1]/2);return I?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${S[0]}, ${S[1]}));

      int index = resTexRC.x * ${S[1]} + resTexRC.y;
      int r = 2 * (index / ${T});
      int c = imod(index, ${T}) * 2;

      return ivec2(r, c);
    }
  `}(m,y,b);case 3:return function(v,w,I){if(I)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const S=[Math.ceil(w[0]/2),Math.ceil(w[1]/2)],T=Math.ceil(v[2]/2),D=T*Math.ceil(v[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${S[0]}, ${S[1]}));
      int index = resTexRC.x * ${S[1]} + resTexRC.y;

      int b = index / ${D};
      index -= b * ${D};

      int r = 2 * (index / ${T});
      int c = imod(index, ${T}) * 2;

      return ivec3(b, r, c);
    }
  `}(m,y,b);default:return function(v,w,I){if(I)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const S=[Math.ceil(w[0]/2),Math.ceil(w[1]/2)],T=Math.ceil(v[v.length-1]/2),D=T*Math.ceil(v[v.length-2]/2);let L=D,W="",K="b, r, c";for(let U=2;U<v.length-1;U++)L*=v[v.length-U-1],W=`
      int b${U} = index / ${L};
      index -= b${U} * ${L};
    `+W,K=`b${U}, `+K;return`
    ivec${v.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${S[0]}, ${S[1]}));
      int index = resTexRC.x * ${S[1]} + resTexRC.y;

      ${W}

      int b = index / ${D};
      index -= b * ${D};

      int r = 2 * (index / ${T});
      int c = imod(index, ${T}) * 2;

      return ivec${v.length}(${K});
    }
  `}(m,y,b)}}(e.logicalShape,A,t.enableShapeUniforms),c=function(m){return`
    void setOutput(vec4 val) {
      ${m.output} = val;
    }
  `}(u)):(l=function(m,y,b){switch(m.length){case 0:return`
    int getOutputCoords() {
      return 0;
    }
  `;case 1:return function(v,w,I){return w[0]===1?I?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${w[1]}.0);
      }
    `:w[1]===1?I?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${w[0]}.0);
      }
    `:I?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${w[0]}, ${w[1]}));
      return resTexRC.x * ${w[1]} + resTexRC.y;
    }
  `}(0,y,b);case 2:return function(v,w,I){return ht(v,w)?I?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${w[0]}, ${w[1]}));
      }
    `:v[1]===1?I?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${w[0]}, ${w[1]}));
        int index = resTexRC.x * ${w[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:v[0]===1?I?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${w[0]}, ${w[1]}));
        int index = resTexRC.x * ${w[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:I?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${w[0]}, ${w[1]}));
      int index = resTexRC.x * ${w[1]} + resTexRC.y;
      int r = index / ${v[1]};
      int c = index - r * ${v[1]};
      return ivec2(r, c);
    }
  `}(m,y,b);case 3:return function(v,w,I){if(I)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${$x(["r","c","d"],v)}
    return ivec3(r, c, d);
  }
`;const S=Kc(["r","c","d"],v);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${w[0]}, ${w[1]}));
      int index = resTexRC.x * ${w[1]} + resTexRC.y;
      ${S}
      return ivec3(r, c, d);
    }
  `}(m,y,b);case 4:return function(v,w,I){if(I)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${$x(["r","c","d","d2"],v)}
      return ivec4(r, c, d, d2);
    }
  `;const S=Kc(["r","c","d","d2"],v);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${w[0]}, ${w[1]}));
      int index = resTexRC.x * ${w[1]} + resTexRC.y;
      ${S}
      return ivec4(r, c, d, d2);
    }
  `}(m,y,b);case 5:return function(v,w){const I=Kc(["r","c","d","d2","d3"],v);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${w[0]},
                             ${w[1]}));

      int index = resTexRC.x * ${w[1]} + resTexRC.y;

      ${I}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}(m,y);case 6:return function(v,w){const I=Kc(["r","c","d","d2","d3","d4"],v);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${w[0]}, ${w[1]}));
      int index = resTexRC.x * ${w[1]} + resTexRC.y;

      ${I}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}(m,y);default:throw new Error(`${m.length}-D output sampling is not yet supported`)}}(e.logicalShape,A,t.enableShapeUniforms),c=function(m){return`
    void setOutput(float val) {
      ${m.output} = vec4(val, 0, 0, 0);
    }
  `}(u)),t.packedInputs&&(d+=fAe),[d,h,c,s,l,o,t.userCode].join(`
`)}function Zp(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return function(r,s){const o=r.name,A="get"+o.charAt(0).toUpperCase()+o.slice(1);if(r.shapeInfo.isUniform)return`float ${A}() {return ${o};}`;const[u,h]=r.shapeInfo.texShape;if(u===1&&h===1)return`
      float ${A}() {
        return sampleTexture(${o}, halfCR);
      }
    `;const l=qc(o);if(s)return`
    float ${A}() {
      vec2 uv = uvFromFlat(${o}TexShape[0], ${o}TexShape[1], ${l});
      return sampleTexture(${o}, uv);
    }
  `;const[c,d]=r.shapeInfo.texShape;return`
    float ${A}() {
      vec2 uv = uvFromFlat(${c}, ${d}, ${l});
      return sampleTexture(${o}, uv);
    }
  `}(n,e);case 1:return function(r,s){const o=r.name,A="get"+o.charAt(0).toUpperCase()+o.slice(1);if(r.shapeInfo.isUniform)return`
      float ${A}(int index) {
        ${Yp(r)}
      }
    `;const u=r.shapeInfo.texShape,h=u[0],l=u[1];if(l===1&&h===1)return`
      float ${A}(int index) {
        return sampleTexture(${o}, halfCR);
      }
    `;const c=qc(o);return l===1?s?`
      float ${A}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${c}) + 0.5) / float(${o}TexShape[0]));
        return sampleTexture(${o}, uv);
      }
    `:`
      float ${A}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${c}) + 0.5) / ${h}.0);
        return sampleTexture(${o}, uv);
      }
    `:h===1?s?`
      float ${A}(int index) {
        vec2 uv = vec2((float(index + ${c}) + 0.5) / float(${o}TexShape[1]), 0.5);
        return sampleTexture(${o}, uv);
      }
    `:`
      float ${A}(int index) {
        vec2 uv = vec2((float(index + ${c}) + 0.5) / ${l}.0, 0.5);
        return sampleTexture(${o}, uv);
      }
    `:s?`
    float ${A}(int index) {
      vec2 uv = uvFromFlat(${o}TexShape[0], ${o}TexShape[1], index + ${c});
      return sampleTexture(${o}, uv);
    }
  `:`
    float ${A}(int index) {
      vec2 uv = uvFromFlat(${h}, ${l}, index + ${c});
      return sampleTexture(${o}, uv);
    }
  `}(n,e);case 2:return function(r,s){const o=r.shapeInfo.logicalShape,A=r.name,u="get"+A.charAt(0).toUpperCase()+A.slice(1),h=r.shapeInfo.texShape;if(h!=null&&ht(o,h)){if(s)return`
      float ${u}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${A}TexShape[1], ${A}TexShape[0]);
        return sampleTexture(${A}, uv);
      }
    `;const v=h[0];return`
    float ${u}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${h[1]}.0, ${v}.0);
      return sampleTexture(${A}, uv);
    }
  `}const{newShape:l,keptDims:c}=tt(o),d=l;if(d.length<o.length){const v=["row","col"];return`
      ${Zp(Up(r,d),s)}
      float ${u}(int row, int col) {
        return ${u}(${Qp(v,c)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${u}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${o[1]}, 1)));
        ${Yp(r)}
      }
    `;const m=h[0],y=h[1],b=qc(A);return y===1?s?`
      float ${u}(int row, int col) {
        float index = dot(vec3(row, col, ${b}), vec3(${A}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${A}TexShape[0]));
        return sampleTexture(${A}, uv);
      }
    `:`
    float ${u}(int row, int col) {
      float index = dot(vec3(row, col, ${b}), vec3(${o[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${m}.0);
      return sampleTexture(${A}, uv);
    }
  `:m===1?s?`
      float ${u}(int row, int col) {
        float index = dot(vec3(row, col, ${b}), vec3(${A}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${A}TexShape[1]), 0.5);
        return sampleTexture(${A}, uv);
      }
    `:`
    float ${u}(int row, int col) {
      float index = dot(vec3(row, col, ${b}), vec3(${o[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${y}.0, 0.5);
      return sampleTexture(${A}, uv);
    }
  `:s?`
      float ${u}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${A}Shape[1] + col + ${b};
        vec2 uv = uvFromFlat(${A}TexShape[0], ${A}TexShape[1], index);
        return sampleTexture(${A}, uv);
      }
    `:`
  float ${u}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${o[1]} + col + ${b};
    vec2 uv = uvFromFlat(${m}, ${y}, index);
    return sampleTexture(${A}, uv);
  }
`}(n,e);case 3:return function(r,s){const o=r.shapeInfo.logicalShape,A=r.name,u="get"+A.charAt(0).toUpperCase()+A.slice(1),h=o[1]*o[2],l=o[2],{newShape:c,keptDims:d}=tt(o),m=c;if(m.length<o.length){const S=["row","col","depth"];return`
        ${Zp(Up(r,m),s)}
        float ${u}(int row, int col, int depth) {
          return ${u}(${Qp(S,d)});
        }
      `}if(r.shapeInfo.isUniform)return`
      float ${u}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${h}, ${l}, 1)));
        ${Yp(r)}
      }
    `;const y=r.shapeInfo.texShape,b=y[0],v=y[1],w=r.shapeInfo.flatOffset;if(v===h&&w==null)return s?`
      float ${u}(int row, int col, int depth) {
        int stride1 = ${A}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${A}TexShape[1], ${A}TexShape[0]);
        return sampleTexture(${A}, uv);
      }
    `:`
        float ${u}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${l}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${v}.0, ${b}.0);
          return sampleTexture(${A}, uv);
        }
      `;if(v===l&&w==null)return s?`
      float ${u}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${A}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${A}TexShape[1], ${A}TexShape[0]);
        return sampleTexture(${A}, uv);
      }
    `:`
    float ${u}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${o[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${v}.0, ${b}.0);
      return sampleTexture(${A}, uv);
    }
  `;const I=qc(A);return s?`
    float ${u}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${A}Shape[1] * ${A}Shape[2];
      int stride1 = ${A}Shape[2];
      int index = row * ${h} + col * ${l} + depth + ${I};
      vec2 uv = uvFromFlat(${A}TexShape[0], ${A}TexShape[1], index);
      return sampleTexture(${A}, uv);
    }
    `:`
      float ${u}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${h} + col * ${l} + depth + ${I};
        vec2 uv = uvFromFlat(${b}, ${v}, index);
        return sampleTexture(${A}, uv);
      }
  `}(n,e);case 4:return function(r,s){const o=r.shapeInfo.logicalShape,A=r.name,u="get"+A.charAt(0).toUpperCase()+A.slice(1),h=o[3],l=o[2]*h,c=o[1]*l,{newShape:d,keptDims:m}=tt(o);if(d.length<o.length){const L=["row","col","depth","depth2"];return`
      ${Zp(Up(r,d),s)}
      float ${u}(int row, int col, int depth, int depth2) {
        return ${u}(${Qp(L,m)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${u}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${c}, ${l}, ${h}, 1)));
        ${Yp(r)}
      }
    `;const y=r.shapeInfo.flatOffset,b=r.shapeInfo.texShape,v=b[0],w=b[1],I=`int stride2 = ${A}Shape[3];`,S=`int stride1 = ${A}Shape[2] * stride2;`,T=`int stride0 = ${A}Shape[1] * stride1;`;if(w===c&&y==null)return s?`
      float ${u}(int row, int col, int depth, int depth2) {
        ${I}
        ${S}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${A}TexShape[1], ${A}TexShape[0]);
        return sampleTexture(${A}, uv);
      }
    `:`
      float ${u}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${l}, ${h}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${w}.0, ${v}.0);
        return sampleTexture(${A}, uv);
      }
    `;if(w===h&&y==null)return s?`
      float ${u}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${A}Shape[1] * ${A}Shape[2], ${A}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${A}TexShape[1], ${A}TexShape[0]);
        return sampleTexture(${A}, uv);
      }
    `:`
      float ${u}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${o[1]*o[2]}, ${o[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${w}.0, ${v}.0);
        return sampleTexture(${A}, uv);
      }
    `;const D=qc(A);return s?`
    float ${u}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${I}
      ${S}
      ${T}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${A}TexShape[0], ${A}TexShape[1], index + ${D});
      return sampleTexture(${A}, uv);
    }
  `:`
    float ${u}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${l} +
          depth * ${h} + depth2;
      vec2 uv = uvFromFlat(${v}, ${w}, index + ${D});
      return sampleTexture(${A}, uv);
    }
  `}(n,e);case 5:return function(r){const s=r.shapeInfo.logicalShape,o=r.name,A="get"+o.charAt(0).toUpperCase()+o.slice(1),u=s[4],h=s[3]*u,l=s[2]*h,c=s[1]*l,{newShape:d,keptDims:m}=tt(s);if(d.length<s.length){const I=["row","col","depth","depth2","depth3"];return`
      ${Zp(Up(r,d))}
      float ${A}(int row, int col, int depth, int depth2, int depth3) {
        return ${A}(${Qp(I,m)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${A}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${l}, ${h}, ${u})) +
          depth3;
        ${Yp(r)}
      }
    `;const y=r.shapeInfo.flatOffset,b=r.shapeInfo.texShape,v=b[0],w=b[1];return w===c&&y==null?`
      float ${A}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${l}, ${h}, ${u}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${w}.0, ${v}.0);
        return sampleTexture(${o}, uv);
      }
    `:w===u&&y==null?`
      float ${A}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${s[1]*s[2]*s[3]},
               ${s[2]*s[3]}, ${s[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${w}.0, ${v}.0);
        return sampleTexture(${o}, uv);
      }
    `:`
    float ${A}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${l} + depth * ${h} +
          depth2 * ${u} + depth3 + ${qc(o)};
      vec2 uv = uvFromFlat(${v}, ${w}, index);
      return sampleTexture(${o}, uv);
    }
  `}(n);case 6:return function(r){const s=r.shapeInfo.logicalShape,o=r.name,A="get"+o.charAt(0).toUpperCase()+o.slice(1),{newShape:u,keptDims:h}=tt(s);if(u.length<s.length){const S=["row","col","depth","depth2","depth3","depth4"];return`
      ${Zp(Up(r,u))}
      float ${A}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${A}(${Qp(S,h)});
      }
    `}const l=s[5],c=s[4]*l,d=s[3]*c,m=s[2]*d,y=s[1]*m;if(r.shapeInfo.isUniform)return`
      float ${A}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${y}, ${m}, ${d}, ${c})) +
          dot(
            vec2(depth3, depth4),
            vec2(${l}, 1)));
        ${Yp(r)}
      }
    `;const b=r.shapeInfo.flatOffset,v=r.shapeInfo.texShape,w=v[0],I=v[1];return I===y&&b==null?`
      float ${A}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${m}, ${d}, ${c}, ${l})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${I}.0, ${w}.0);
        return sampleTexture(${o}, uv);
      }
    `:I===l&&b==null?`
      float ${A}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${s[1]*s[2]*s[3]*s[4]},
               ${s[2]*s[3]*s[4]},
               ${s[3]*s[4]},
               ${s[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${I}.0, ${w}.0);
        return sampleTexture(${o}, uv);
      }
    `:`
    float ${A}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${y} + col * ${m} + depth * ${d} +
          depth2 * ${c} + depth3 * ${l} + depth4 + ${qc(o)};
      vec2 uv = uvFromFlat(${w}, ${I}, index);
      return sampleTexture(${o}, uv);
    }
  `}(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function v6(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return function(t){const r=t.name;return`
    vec4 ${"get"+r.charAt(0).toUpperCase()+r.slice(1)}() {
      return ${ja().texture2D}(${r}, halfCR);
    }
  `}(n);case 1:return function(t,r){const s=t.name,o="get"+s.charAt(0).toUpperCase()+s.slice(1),A=t.shapeInfo.texShape,u=ja();if(r)return`
    vec4 ${o}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${u.texture2D}(${s}, uv);
    }
  `;const h=[Math.ceil(A[0]/2),Math.ceil(A[1]/2)];return`
    vec4 ${o}(int index) {
      vec2 uv = packedUVfrom1D(
        ${h[0]}, ${h[1]}, index);
      return ${u.texture2D}(${s}, uv);
    }
  `}(n,e);case 2:return function(t,r){const s=t.shapeInfo.logicalShape,o=t.name,A="get"+o.charAt(0).toUpperCase()+o.slice(1),u=t.shapeInfo.texShape,h=u[0],l=u[1],c=ja();if(u!=null&&ht(s,u))return r?`
      vec4 ${A}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}TexShape[1], ${o}TexShape[0]);

        return ${c.texture2D}(${o}, uv);
      }
    `:`
      vec4 ${A}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${h}.0);

        return ${c.texture2D}(${o}, uv);
      }
    `;if(r)return`
    vec4 ${A}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${o}TexShape[0]) / 2.0), ceil(float(${o}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${o}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${c.texture2D}(${o}, uv);
    }
  `;const d=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];return`
    vec4 ${A}(int row, int col) {
      vec2 uv = packedUVfrom2D(${Math.ceil(s[1]/2)}, ${d[0]}, ${d[1]}, row, col);
      return ${c.texture2D}(${o}, uv);
    }
  `}(n,e);case 3:return function(t,r){const s=t.shapeInfo.logicalShape,o=t.name,A="get"+o.charAt(0).toUpperCase()+o.slice(1),u=t.shapeInfo.texShape,h=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];if(s[0]===1){const y=[1,2],b=["b","row","col"];return`
        ${v6(Up(t,s.slice(1)),r)}
        vec4 ${A}(int b, int row, int col) {
          return ${A}(${Qp(b,y)});
        }
      `}const l=ja();if(r)return`
    vec4 ${A}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${o}TexShape[0]) / 2.0), ceil(float(${o}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${o}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${o}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${l.texture2D}(${o}, uv);
    }
  `;const c=h[0],d=h[1],m=Math.ceil(s[2]/2);return`
    vec4 ${A}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${c}, ${d}, ${m*Math.ceil(s[1]/2)}, ${m}, b, row, col);
      return ${l.texture2D}(${o}, uv);
    }
  `}(n,e);default:return function(t,r){const s=t.name,o="get"+s.charAt(0).toUpperCase()+s.slice(1),A=ja();if(r)return`
    vec4 ${o}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${s}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${s}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${A.texture2D}(${s}, uv);
    }
  `;const u=t.shapeInfo.logicalShape,h=u.length,l=t.shapeInfo.texShape,c=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)],d=c[0],m=c[1],y=Math.ceil(u[h-1]/2);let b=y*Math.ceil(u[h-2]/2),v="int b, int row, int col",w=`b * ${b} + (row / 2) * ${y} + (col / 2)`;for(let I=2;I<h-1;I++)v=`int b${I}, `+v,b*=u[h-I-1],w=`b${I} * ${b} + `+w;return`
    vec4 ${o}(${v}) {
      int index = ${w};
      int texR = index / ${m};
      int texC = index - texR * ${m};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}, ${d});
      return ${A.texture2D}(${s}, uv);
    }
  `}(n,e)}}const dAe=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,pAe=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,hAe=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,fAe=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function qc(n){return`offset${n}`}function Yp(n){const e=n.name,t=Ye(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function kr(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function fN(n,e,t){const{newShape:r,keptDims:s}=tt(e),o=e.length,A=n&&o===3&&e[0]===1,u=A?e.slice(1):r,h=!n&&o>1&&!ht(e,t)&&r.length<o||A;return{useSqueezeShape:h,uniformShape:h?u:e,keptDims:s}}function Up(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function Qp(n,e){return e.map(t=>n[t]).join(", ")}function x6(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,r)=>{const s=t.logicalShape,o=e[r],A=o.shape;if(!ht(s,A))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${A} must match`);if(t.isUniform&&o.isUniform)return;const u=t.texShape,h=o.isUniform?null:o.texData.texShape;if(!ht(u,h))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${u} and ${h} must match`)})}function ni(n){return st().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class mAe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=lg.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=ja();this.outputShape=e,this.enableShapeUniforms=ni(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?$x(["r","c","d"],e):Kc(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}class gAe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=lg.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=ja();this.outputShape=e,this.enableShapeUniforms=ni(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?$x(["r","c","d"],e):Kc(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}class yAe{constructor(e){this.variableNames=["A"],this.outTexUsage=ti.DOWNLOAD;const t=ja();this.outputShape=e,this.userCode=`
      ${y6}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}class bAe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=ti.DOWNLOAD;const t=ja();this.outputShape=e,this.userCode=`
      ${y6}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}class vAe{constructor(e,t=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=ja();this.outputShape=e,this.enableShapeUniforms=ni(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)"),this.userCode=`
      ${this.enableShapeUniforms?`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`:hN(e)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${r.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${r.output} = vec4(${s}, 0., 0., 0.);
      }
    `}}class xAe{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=ja();this.outputShape=e,this.enableShapeUniforms=ni(this.outputShape.length);let s="",o="result";t&&(o="floor(result * 255. + 0.5)");for(let A=0;A<=1;A++)for(let u=0;u<=1;u++){const h=2*A+u;s+=`
          localCoords = coords;
          if(localCoords[2] + ${u} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${u};
          if (localCoords[1] + ${A} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${A};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${h}] = values[0];
            } else if (offset == 1) {
              result[${h}] = values[1];
            } else if (offset == 2) {
              result[${h}] = values[2];
            } else {
              result[${h}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`:hN(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${s}

          ${r.output} = ${o};
        }
    `}}function dg(n,e,t,r,s,o){(function(h,l){const c=st().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(h<=0||l<=0)throw new Error(`Requested texture size [${h}x${l}] is invalid.`);if(h>c||l>c)throw new Error(`Requested texture size [${h}x${l}] greater than WebGL maximum on this browser / GPU [${c}x${c}].`)})(e,t);const A=function(h){return vl(h,()=>h.createTexture(),"Unable to create WebGLTexture.")}(n),u=n.TEXTURE_2D;return _t(n,()=>n.bindTexture(u,A)),_t(n,()=>n.texParameteri(u,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),_t(n,()=>n.texParameteri(u,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),_t(n,()=>n.texParameteri(u,n.TEXTURE_MIN_FILTER,n.NEAREST)),_t(n,()=>n.texParameteri(u,n.TEXTURE_MAG_FILTER,n.NEAREST)),_t(n,()=>n.texImage2D(u,0,r,e,t,0,s,o,null)),_t(n,()=>n.bindTexture(n.TEXTURE_2D,null)),A}function w6(n){return n.internalFormatFloat}function k6(n){return n.internalFormatHalfFloat}function C6(n){return n.downloadTextureFormat}function I6(n){return n.internalFormatPackedFloat}function S6(n){return n.internalFormatPackedHalfFloat}class wAe{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=st().getNumber("WEBGL_VERSION");e!=null?(this.gl=e,function(o,A){Qc[o]=A}(t,e)):this.gl=zA(t);let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(st().getNumber("WEBGL_VERSION")===1){const o="OES_texture_float",A="OES_texture_half_float";if(this.textureFloatExtension=Qx(this.gl,o),Ni(this.gl,A))this.textureHalfFloatExtension=Qx(this.gl,A);else if(st().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),Ni(this.gl,s))this.colorBufferHalfFloatExtension=Qx(this.gl,s);else if(st().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",Ni(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else{if(!Ni(this.gl,s))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(s)}this.vertexBuffer=function(o){return function(A,u){const h=vl(A,()=>A.createBuffer(),"Unable to create WebGLBuffer");return _t(A,()=>A.bindBuffer(A.ARRAY_BUFFER,h)),_t(A,()=>A.bufferData(A.ARRAY_BUFFER,u,A.STATIC_DRAW)),h}(o,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function(o){return function(A,u){const h=vl(A,()=>A.createBuffer(),"Unable to create WebGLBuffer");return _t(A,()=>A.bindBuffer(A.ELEMENT_ARRAY_BUFFER,h)),_t(A,()=>A.bufferData(A.ELEMENT_ARRAY_BUFFER,u,A.STATIC_DRAW)),h}(o,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function(o){return vl(o,()=>o.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=iN(this.gl,this.textureHalfFloatExtension)}get debug(){return st().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;_t(e,()=>e.finish()),_t(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),_t(e,()=>e.deleteFramebuffer(this.framebuffer)),_t(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),_t(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),_t(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(r,s,o,A){const[u,h]=ug(s,o);return dg(r,u,h,w6(A),A.textureFormatFloat,r.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(r,s,o,A){const[u,h]=ug(s,o);return dg(r,u,h,k6(A),A.textureFormatFloat,A.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(r,s,o,A){const[u,h]=ug(s,o);return dg(r,u,h,C6(A),r.RGBA,r.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(r,s,o){_t(r,()=>r.bindTexture(r.TEXTURE_2D,s)),o.data instanceof Uint8Array?_t(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,o.width,o.height,0,r.RGBA,r.UNSIGNED_BYTE,o.data)):_t(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,o)),_t(r,()=>r.bindTexture(r.TEXTURE_2D,null))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,r,s){this.throwIfDisposed(),function(o,A,u,h,l,c){let d,m,y;_t(o,()=>o.bindTexture(o.TEXTURE_2D,A)),l instanceof Uint8Array?(d=new Uint8Array(u*h*4),m=o.UNSIGNED_BYTE,y=o.RGBA):(d=new Float32Array(u*h*4),m=o.FLOAT,y=c.internalFormatPackedFloat),d.set(l),_t(o,()=>o.texImage2D(o.TEXTURE_2D,0,y,u,h,0,o.RGBA,m,d)),_t(o,()=>o.bindTexture(o.TEXTURE_2D,null))}(this.gl,e,t,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(r,s,o,A){const[u,h]=Gp(s,o);return dg(r,u,h,S6(A),r.RGBA,A.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(r,s,o,A){const[u,h]=Gp(s,o);return dg(r,u,h,I6(A),r.RGBA,r.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(m6(this.gl,this.framebuffer),this.outputTexture=null),_t(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,r){return this.downloadMatrixDriver(e,()=>function(s,o,A,u){const[h,l]=ug(o,A),c=new Uint8Array(o*A*4);return _t(s,()=>s.readPixels(0,0,h,l,u.downloadTextureFormat,s.UNSIGNED_BYTE,c)),new Float32Array(c.buffer)}(this.gl,t,r,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,r,s,o,A){return function(u,h,l,c,d,m,y){const b=u,v=new Float32Array(function(w,I){const[S,T]=Gp(w,I);return S*T*4}(m,y));return b.bindBuffer(b.PIXEL_PACK_BUFFER,h),b.getBufferSubData(b.PIXEL_PACK_BUFFER,0,v),b.bindBuffer(b.PIXEL_PACK_BUFFER,null),v}(this.gl,e,0,0,0,o,A,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(r,s,o){const A=r,u=new Float32Array(o);return A.bindBuffer(A.PIXEL_PACK_BUFFER,s),A.getBufferSubData(A.PIXEL_PACK_BUFFER,0,u),A.bindBuffer(A.PIXEL_PACK_BUFFER,null),u}(this.gl,e,t)}createBufferFromTexture(e,t,r){this.bindTextureToFrameBuffer(e);const s=function(o,A,u){const h=o.createBuffer();_t(o,()=>o.bindBuffer(o.PIXEL_PACK_BUFFER,h));const l=16*A*u;return _t(o,()=>o.bufferData(o.PIXEL_PACK_BUFFER,l,o.STREAM_READ)),_t(o,()=>o.readPixels(0,0,u,A,o.RGBA,o.FLOAT,0)),_t(o,()=>o.bindBuffer(o.PIXEL_PACK_BUFFER,null)),h}(this.gl,t,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,r;if(st().getBool("WEBGL_FENCE_API_ENABLED")){const s=e,o=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=()=>{const A=s.clientWaitSync(o,0,0);return A===s.ALREADY_SIGNALED||A===s.CONDITION_SATISFIED},t=o}else st().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(t,st().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:t,isFencePassed:r}}downloadMatrixFromPackedTexture(e,t,r){return this.downloadMatrixDriver(e,()=>function(s,o,A){const u=new Float32Array(o*A*4);return _t(s,()=>s.readPixels(0,0,A,o,s.RGBA,s.FLOAT,u)),u}(this.gl,t,r))}createProgram(e){this.throwIfDisposed();const t=this.gl,r=function(o,A){const u=vl(o,()=>o.createShader(o.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(_t(o,()=>o.shaderSource(u,A)),_t(o,()=>o.compileShader(u)),o.getShaderParameter(u,o.COMPILE_STATUS)===!1)throw function(h,l){const c=lAe.exec(l);if(c==null)return console.log(`Couldn't parse line number in error: ${l}`),void console.log(h);const d=+c[1],m=h.split(`
`),y=m.length.toString().length+2,b=m.map((T,D)=>jt((D+1).toString(),y)+T);let v=0;for(let T=0;T<b.length;T++)v=Math.max(b[T].length,v);const w=b.slice(0,d-1),I=b.slice(d-1,d),S=b.slice(d);console.log(w.join(`
`)),console.log(l.split(`
`)[0]),console.log(`%c ${jt(I[0],v)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(S.join(`
`))}(A,o.getShaderInfoLog(u)),new Error("Failed to compile fragment shader.");return u}(t,e);this.vertexShader==null&&(this.vertexShader=function(o){const A=ja();return function(u,h){const l=vl(u,()=>u.createShader(u.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(_t(u,()=>u.shaderSource(l,h)),_t(u,()=>u.compileShader(l)),u.getShaderParameter(l,u.COMPILE_STATUS)===!1)throw console.log(u.getShaderInfoLog(l)),new Error("Failed to compile vertex shader.");return l}(o,`${A.version}
    precision highp float;
    ${A.attribute} vec3 clipSpacePos;
    ${A.attribute} vec2 uv;
    ${A.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`)}(t));const s=function(o){return vl(o,()=>o.createProgram(),"Unable to create WebGLProgram.")}(t);return _t(t,()=>t.attachShader(s,this.vertexShader)),_t(t,()=>t.attachShader(s,r)),function(o,A){if(_t(o,()=>o.linkProgram(A)),o.getProgramParameter(A,o.LINK_STATUS)===!1)throw console.log(o.getProgramInfoLog(A)),new Error("Failed to link vertex and fragment shaders.")}(t,s),this.debug&&AN(t,s),this.vertexAttrsAreBound||(this.setProgram(s),this.vertexAttrsAreBound=function(o,A,u){return _t(o,()=>o.bindBuffer(o.ARRAY_BUFFER,u)),f6(o,A,"clipSpacePos",u,3,20,0)&&f6(o,A,"uv",u,2,20,12)}(t,this.program,this.vertexBuffer)),s}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&_t(this.gl,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&AN(this.gl,this.program),_t(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,r=!0){return this.throwIfDisposed(),r?function(s,o,A){return vl(s,()=>s.getUniformLocation(o,A),'uniform "'+A+'" not present in program.')}(this.gl,e,t):function(s,o,A){return s.getUniformLocation(o,A)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),_t(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,r){this.throwIfDisposed(),this.throwIfNoProgram(),uAe(this.gl,e,t,r)}setOutputMatrixTexture(e,t,r){this.setOutputMatrixTextureDriver(e,r,t)}setOutputPackedMatrixTexture(e,t,r){this.throwIfDisposed();const[s,o]=Gp(t,r);this.setOutputMatrixTextureDriver(e,s,o)}setOutputMatrixWriteRegion(e,t,r,s){this.setOutputMatrixWriteRegionDriver(r,e,s,t)}setOutputPackedMatrixWriteRegion(e,t,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&AN(this.gl,this.program),Kx(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),_t(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),_t(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Qx(this.gl,st().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(st().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,o),o}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(st().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,r=this.getQueryTimerExtensionWebGL2();return void t.endQuery(r.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await xn(()=>this.disposed||this.isQueryAvailable(e,st().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,st().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const r=this.gl;return r.getQueryParameter(e,r.QUERY_RESULT)/1e6}{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(e,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),o&&!this.disjoint}{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(e,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=function(t){let r=0;for(;r<t.length&&t[r]();++r);return r-1}(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:r}=this.itemsToPoll[t];r()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||xn(()=>(this.pollItems(),this.itemsToPoll.length===0))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),lN(this.gl,e,this.framebuffer),this.debug&&Kx(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(lN(this.gl,this.outputTexture,this.framebuffer),this.debug&&Kx(this.gl)):m6(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const r=t();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(e,t,r){this.throwIfDisposed();const s=this.gl;lN(s,e,this.framebuffer),this.debug&&Kx(s),this.outputTexture=e,_t(s,()=>s.viewport(0,0,t,r)),_t(s,()=>s.scissor(0,0,t,r))}setOutputMatrixWriteRegionDriver(e,t,r,s){this.throwIfDisposed(),_t(this.gl,()=>this.gl.scissor(e,t,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}const{mx:kAe,XI:N6,Nk:CAe,YG:IAe,hH:SAe,z3:NAe,sG:TAe,uM:MAe,vS:EAe,qB:DAe,GG:zAe,rq:OAe,lg:PAe,WR:BAe,cu:FAe,GE:LAe,px:RAe,jC:WAe,He:jAe,hE:HAe,BF:GAe,Dk:VAe,cl:XAe,_B:ZAe,qy:YAe,Zy:UAe,zv:QAe,dH:T6,HS:KAe,yH:qAe,l3:JAe,z9:M6,x6:$Ae,eW:_Ae,GK:ele,SP:tle,f6:nle,dl:rle,Dw:sle,xT:ale,_X:mN,wz:ole}=Z;function E6(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function Ha(n,e){return e===1?[n]:E6(n,e)}class ile{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e;const t=e.length;if(t===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const r=Ha("rc",t),s=kr(t),o=function(h,l,c){if(h===1)return`rc > ${l[0]}`;let d="";for(let m=h-2;m<h;m++)d+=`${c[m]} >= ${l[m]}`,m<h-1&&(d+="||");return d}(t,e,r),A=function(h,l,c,d){if(h===1)return"";const m=d.slice(-2);return`
    int r = ${m[0]};
    int c = ${m[1]};
    int rp1 = r + 1;
    int cp1 = c + 1;

    bool cEdge = cp1 >= ${l};
    bool rEdge = rp1 >= ${c};
  `}(t,e[e.length-1],e[e.length-2],r),u=function(h,l){const c=h.length,d=function(m,y){const b=[];for(let v=0;v<=1;v++)for(let w=0;w<=1;w++){let I=`${v===0?"r":"rp1"}, ${w===0?"c":"cp1"}`;for(let S=2;S<m;S++)I=`${y[y.length-1-S]},`+I;b.push(I)}return b}(c,l);return c===1?`getA(rc),
            rc + 1 >= ${h[0]} ? 0. : getA(rc + 1),
            0, 0`:`getA(${d[0]}),
          cEdge ? 0. : getA(${d[1]}),
          rEdge ? 0. : getA(${d[2]}),
          rEdge || cEdge ? 0. : getA(${d[3]})`}(e,r);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${o}) {
            setOutput(vec4(0));
          } else {
            ${A}

            setOutput(vec4(${u}));
          }
        }
      `}}}class D6{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=ni(this.outputShape.length);let r="";for(let A=0;A<4;A++){let u="thisRC = rc;";A%2==1&&(u+="thisRC.z += 1;"),A>1&&(u+="thisRC.y += 1;"),r+=`
        ${u}
        ${A>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${A}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${A>0?"}":""}
      `}var s,o;this.userCode=`
      ${s=t,o=this.enableShapeUniforms,`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${o?function(A,u,h="index"){const l=function(c,d){const m=c.length,y=c.map(v=>`${d}[${v}]`),b=new Array(m-1);b[m-2]=y[m-1];for(let v=m-3;v>=0;--v)b[v]=`(${b[v+1]} * ${y[v+1]})`;return b}(A.map((c,d)=>d),u);return l.map((c,d)=>`int ${A[d]} = ${h} / ${l[d]}; ${d===l.length-1?`int ${A[d+1]} = ${h} - ${A[d]} * ${l[d]}`:`index -= ${A[d]} * ${l[d]}`};`).join("")}(["r","c","d"],"inputShape"):Kc(["r","c","d"],s)}
      return ivec3(r, c, d);
    }
  `}
      ${this.enableShapeUniforms?`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`:hN(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${r}

        setOutput(result);
      }
    `}}class Ale{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,r){const s=O6(t,r),o=P6(e,s,r);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const A=z6(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=A,this.log();const h=this.freeTextures[o].shift();return this.usedTextures[o].push(h),h}let u;return s===Aa.PACKED_2X2_FLOAT32?u=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):s===Aa.PACKED_2X2_FLOAT16?u=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):s===Aa.UNPACKED_FLOAT32?u=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):s===Aa.UNPACKED_FLOAT16?u=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):s===Aa.PACKED_4X1_UNSIGNED_BYTE&&(u=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[o].push(u),this.numUsedTextures++,this._numBytesAllocated+=A,this.log(),u}releaseTexture(e,t,r,s){if(this.freeTextures==null)return;const o=O6(r,s),A=P6(t,o,s);A in this.freeTextures||(this.freeTextures[A]=[]);const u=z6(t,o,this.gpgpu.gl,this.gpgpu.textureConfig,s),h=st().get("WEBGL_DELETE_TEXTURE_THRESHOLD");h!==-1&&this._numBytesAllocated>h?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=u):(this.freeTextures[A].push(e),this.numFreeTextures++,this._numBytesFree+=u),this.numUsedTextures--;const l=this.usedTextures[A],c=l.indexOf(e);if(c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(c,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function z6(n,e,t,r,s){const o=function(h,l){switch(h){case Aa.PACKED_2X2_FLOAT32:return I6(l);case Aa.PACKED_2X2_FLOAT16:return S6(l);case Aa.UNPACKED_FLOAT32:return w6(l);case Aa.UNPACKED_FLOAT16:return k6(l);case Aa.PACKED_4X1_UNSIGNED_BYTE:return C6(l);default:throw new Error(`Unknown physical texture type ${h}`)}}(e,r);let A;if(s){const[h,l]=Gp(n[0],n[1]);A=h*l}else{const[h,l]=ug(n[0],n[1]);A=h*l}const u=function(h,l){const c=h;if(l===c.R32F)return 4;if(l===c.R16F)return 2;if(l===c.RGBA32F||l===h.RGBA)return 16;if(l===c.RGBA16F)return 8;throw new Error(`Unknown internal format ${l}`)}(t,o);return A*u}function O6(n,e){if(n===ti.UPLOAD)return Aa.PACKED_2X2_FLOAT32;if(n===ti.RENDER||n==null)return function(t){return st().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?Aa.PACKED_2X2_FLOAT32:Aa.UNPACKED_FLOAT32:t?Aa.PACKED_2X2_FLOAT16:Aa.UNPACKED_FLOAT16}(e);if(n===ti.DOWNLOAD||n===ti.PIXELS)return Aa.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function P6(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}class Su{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=ni(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const eA="if (isnan(x)) return x;",B6="return abs(x);",lle=eA+`
  return (x < 0.0) ? 0.0 : x;
`,ule=eA+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,_x="return x;";class Kp{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=ni(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class cle{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e;const t=e.length,r=Ha("rc",t),s=kr(t),o=function(h,l){if(h===1)return"rc";let c="";for(let d=0;d<h;d++)c+=l[d],d<h-1&&(c+=",");return c}(t,r),A=r.slice(-2),u=t<=1?"rc":`vec2(${A.join(",")})`;this.userCode=`
      void main() {
        ${s} rc = getOutputCoords();
        vec4 packedInput = getA(${o});

        setOutput(getChannel(packedInput, ${u}));
      }
    `}}const dle=jS,gN={},ple=st().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class e1 extends Wt{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!st().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(e==null){const r=zA(st().getNumber("WEBGL_VERSION"));this.binaryCache=((t=st().getNumber("WEBGL_VERSION"))in gN||(gN[t]={}),gN[t]),this.gpgpu=new wAe(r),this.canvas=r.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;var t;this.textureManager=new Ale(this.gpgpu),this.numMBBeforeWarning=st().global.screen==null?1024:st().global.screen.height*st().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new Ht(this,Al())}nextDataId(){return e1.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,r){if((st().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||st().getBool("DEBUG"))&&this.checkNumericalProblems(e),r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:t,dtype:r,values:e,usage:ti.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,t,r,s,o){if(st().getBool("DEBUG")&&this.checkNumericalProblems(t),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:s,values:t,usage:ti.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:r,dtype:s,complexTensorInfos:o,slice:A,shape:u,isPacked:h}=t;if(A!=null){let m;m=h?new Kp(u,_x):new Su(u,_x);const y=this.runWebGLProgram(m,[{dataId:e,shape:u,dtype:s}],s),b=this.readSync(y.dataId);return this.disposeIntermediateTensorInfo(y),b}if(r!=null)return this.convertAndCacheOnCPU(e);if(s==="string")return r;const l=this.activeTimers!=null;let c,d;return l&&(c=$a()),d=s==="complex64"?fl(this.readSync(o.real.dataId),this.readSync(o.imag.dataId)):this.getValuesFromTexture(e),l&&(this.downloadWaitMs+=$a()-c),this.convertAndCacheOnCPU(e,d)}async read(e){if(this.pendingRead.has(e)){const b=this.pendingRead.get(e);return new Promise(v=>b.push(v))}const t=this.texData.get(e),{values:r,shape:s,slice:o,dtype:A,complexTensorInfos:u,isPacked:h}=t;if(o!=null){let b;b=h?new Kp(s,_x):new Su(s,_x);const v=this.runWebGLProgram(b,[{dataId:e,shape:s,dtype:A}],A),w=this.read(v.dataId);return this.disposeIntermediateTensorInfo(v),w}if(r!=null)return this.convertAndCacheOnCPU(e);if(!st().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&st().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,c,d=null;if(A!=="complex64"&&st().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const b=this.texData.get(l.dataId);d=this.gpgpu.createBufferFromTexture(b.texture,...Ux(s))}if(this.pendingRead.set(e,[]),A!=="complex64"&&await this.gpgpu.createAndWaitForFence(),A==="complex64"){const b=await Promise.all([this.read(u.real.dataId),this.read(u.imag.dataId)]);c=fl(b[0],b[1])}else if(d==null)c=this.getValuesFromTexture(e);else{const b=Ye(s);c=this.gpgpu.downloadFloat32MatrixFromBuffer(d,b)}if(l!=null&&this.disposeIntermediateTensorInfo(l),d!=null){const b=this.gpgpu.gl;_t(b,()=>b.deleteBuffer(d))}const m=this.convertAndCacheOnCPU(e,c),y=this.pendingRead.get(e);return this.pendingRead.delete(e),y.forEach(b=>b(m)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Al().removeDataId(e,this),this.pendingDeletes--),m}bufferSync(e){const t=this.readSync(e.dataId);let r=t;if(e.dtype==="string")try{r=t.map(s=>yp(s))}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Wn(e.shape,e.dtype,r)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const r=e[t];if(!AAe(r))throw st().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:r,isPacked:s}=this.texData.get(e),o=Ye(t);if(st().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const m=this.decode(e),y=this.texData.get(m.dataId),b=this.gpgpu.downloadMatrixFromPackedTexture(y.texture,...Ux(t)).subarray(0,o);return this.disposeIntermediateTensorInfo(m),b}const A=st().getBool("WEBGL_PACK")&&s===!0,u=A?uN(t):t,h=A?new bAe(u):new yAe(u),l=this.runWebGLProgram(h,[{shape:u,dtype:r,dataId:e}],"float32"),c=this.texData.get(l.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture,c.texShape[0],c.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(l),d}timerAvailable(){return st().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}async time(e){const t=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,e();const o=qt(this.activeTimers.map(h=>h.query)).filter(h=>h!=null),A=qt(this.activeTimers.map(h=>h.name)).filter(h=>h!=null);this.activeTimers=t,s&&(this.programTimersStack=null);const u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(st().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const h=await Promise.all(o);u.kernelMs=function(l){let c=0;for(let d=0;d<l.length;d++)c+=l[d];return c}(h),u.getExtraProfileInfo=()=>h.map((l,c)=>({name:A[c],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", ")}else u.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,u}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return st().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:$a(),endMs:null}}endTimer(e){return st().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=$a(),e)}async getQueryTime(e){if(st().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:r}=this.texData.get(e);return r!=null&&(this.disposeData(r.real.dataId,t),this.disposeData(r.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:r,texShape:s,usage:o,isPacked:A,slice:u}=this.texData.get(e),h=u&&u.origDataId||e,l=this.dataRefCount.get(h);l>1?this.dataRefCount.set(h,l-1):(this.dataRefCount.delete(h),t!=null&&(this.numBytesInGPU-=this.computeBytes(s,r),this.textureManager.releaseTexture(t,s,o,A)));const c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=ple){return st().getBool("WEBGL_CPU_FORWARD")&&e.every(r=>this.texData.get(r.dataId).texture==null&&Ye(r.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){Zr("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return dle(e.shape,t)}packedUnaryOp(e,t,r){const s=new Kp(e.shape,t),o=this.compileAndRun(s,[e],r);return Al().makeTensorFromDataId(o.dataId,o.shape,o.dtype)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const s=T6(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,s)}if(st().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,B6,e.dtype);const t=new Su(e.shape,B6),r=this.compileAndRun(t,[e]);return Al().makeTensorFromDataId(r.dataId,r.shape,r.dtype)}makeTensorInfo(e,t,r){let s;if(t==="string"&&r!=null&&r.length>0&&rn(r[0])){const o=r.map(A=>nu(A));s=this.write(o,e,t)}else s=this.write(r,e,t);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:t}}makeOutput(e,t,r){const{dataId:s}=this.makeTensorInfo(e,t,r);return Al().makeTensorFromDataId(s,e,t,this)}unpackTensor(e){const t=new cle(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new ile(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const r=[Vp(e.shape),...Xp(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},o=[Vp(t),...Xp(t)],A=new D6(o,r),u=[r],h=this.runWebGLProgram(A,[s],e.dtype,u,!0);return{dataId:h.dataId,shape:t,dtype:h.dtype}}decode(e){const t=this.texData.get(e),{isPacked:r,shape:s,dtype:o}=t,A=uN(s);let u;const h=Ux(A);u=r?new gAe(A):new mAe(A);const l=[h];return{dtype:o,shape:s,dataId:this.runWebGLProgram(u,[{shape:A,dtype:o,dataId:e}],o,l,!0).dataId}}runWebGLProgram(e,t,r,s,o=!1){const A=this.makeTensorInfo(e.outputShape,r),u=this.texData.get(A.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===lg.DENSE){const w=Ux(e.outputShape);u.texShape=w.map(I=>2*I)}if(e.outTexUsage!=null&&(u.usage=e.outTexUsage),Ye(A.shape)===0)return u.values=Oe(A.dtype,0),A;const h=[],l=t.map(w=>{if(w.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let I=this.texData.get(w.dataId);if(I.texture==null){if(!e.packedInputs&&Ye(w.shape)<=st().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:w.shape,texData:null,isUniform:!0,uniformValues:I.values};e.packedInputs&&(I.isPacked=!0,I.shape=w.shape)}else if(!!I.isPacked!=!!e.packedInputs)w=I.isPacked?this.unpackTensor(w):this.packTensor(w),h.push(w),I=this.texData.get(w.dataId);else if(I.isPacked&&!Jx(I.shape,w.shape)){const S=w,T=w.shape;w.shape=I.shape,w=this.packedReshape(w,T),h.push(w),I=this.texData.get(w.dataId),S.shape=T}return this.uploadToGPU(w.dataId),{shape:w.shape,texData:I,isUniform:!1}});this.uploadToGPU(A.dataId);const c={shape:A.shape,texData:u,isUniform:!1},d=function(w,I,S){let T="";I.concat(S).forEach(W=>{const K=W.texData!=null&&W.texData.slice!=null&&W.texData.slice.flatOffset>0;if(w.enableShapeUniforms&&!W.isUniform){const U=W.texData.texShape,{useSqueezeShape:_,uniformShape:ee,keptDims:re}=fN(w.packedInputs,W.shape,U);let ce="",we="",Ee="";if(ee.length===1&&w.packedInputs){const Ze=[Math.ceil(U[0]/2),Math.ceil(U[1]/2)];ce=`${Ze[0]>1}_${Ze[1]>1}`}else if(ee.length!==2||w.packedInputs){if(ee.length>2&&!w.packedInputs){const Ze=Je(ee);Ee=`${Ze[0]===U[1]}_${Ze[Ze.length-1]===U[1]}`}}else we=`${ee[0]>1}_${ee[1]>1}`;const Pe=W.shape.length,he=ee.length===2&&ht(W.shape,U),de=Ye(W.shape)===1,Ae=Sp(W.shape,S.shape),Se=!w.packedInputs&&Pe===S.shape.length&&ht(U,S.texData.texShape),Te=w.packedInputs||ee.length>2?"":`${U[0]>1}_${U[1]>1}`;T+=`${Pe}_${Se}_${_?re:""}_${ee.length}_${de}_${Ae}_${he}_${ce}_${we}_${Ee}_${Te}_${K}`}else{const U=W.isUniform?"uniform":W.texData.texShape;T+=`${W.shape}_${U}_${K}`}});const D=w.userCode;let L=w.constructor.name;return L+="_"+T+"_"+D+`${st().getNumber("WEBGL_VERSION")}`,L}(e,l,c),m=this.getAndSaveBinary(d,()=>function(w,I,S,T){const D=S.map((Se,Te)=>{const Ze={logicalShape:Se.shape,texShape:Se.isUniform?null:Se.texData.texShape,isUniform:Se.isUniform,isPacked:!Se.isUniform&&Se.texData.isPacked,flatOffset:null};return Se.texData!=null&&Se.texData.slice!=null&&Se.texData.slice.flatOffset>0&&(Ze.flatOffset=Se.texData.slice.flatOffset),{name:I.variableNames[Te],shapeInfo:Ze}}),L=D.map(Se=>Se.shapeInfo),W={logicalShape:T.shape,texShape:T.texData.texShape,isUniform:!1,isPacked:T.texData.isPacked,flatOffset:null},K=cAe(D,W,I),U=w.createProgram(K);let _=null;const ee=w.getUniformLocation(U,"NAN",!1);st().getNumber("WEBGL_VERSION")===1&&(_=w.getUniformLocation(U,"INFINITY",!1));const re=!1,ce={},we={},Ee={};for(let Se=0;Se<I.variableNames.length;Se++){const Te=I.variableNames[Se];ce[Te]=w.getUniformLocation(U,Te,re),ce[`offset${Te}`]=w.getUniformLocation(U,`offset${Te}`,re),I.enableShapeUniforms&&(we[`${Te}Shape`]=w.getUniformLocation(U,`${Te}Shape`,re),Ee[`${Te}TexShape`]=w.getUniformLocation(U,`${Te}TexShape`,re))}let Pe,he,de;I.enableShapeUniforms&&(Pe=w.getUniformLocation(U,"outShape",re),de=w.getUniformLocation(U,"outShapeStrides",re),he=w.getUniformLocation(U,"outTexShape",re));const Ae=[];return I.customUniforms&&I.customUniforms.forEach((Se,Te)=>{Ae[Te]=w.getUniformLocation(U,Se.name,re)}),{program:I,source:K,webGLProgram:U,uniformLocations:ce,customUniformLocations:Ae,inShapeInfos:L,outShapeInfo:W,infLoc:_,nanLoc:ee,inShapesLocations:we,inTexShapesLocations:Ee,outShapeLocation:Pe,outShapeStridesLocation:de,outTexShapeLocation:he}}(this.gpgpu,e,l,c)),y=this.activeTimers!=null;let b;y&&(b=this.startTimer()),function(w,I,S,T,D){I.program.enableShapeUniforms||(x6(I.inShapeInfos,S),x6([I.outShapeInfo],[T]));const L=T.texData.texture,W=T.texData.texShape;T.texData.isPacked?w.setOutputPackedMatrixTexture(L,W[0],W[1]):w.setOutputMatrixTexture(L,W[0],W[1]),w.setProgram(I.webGLProgram),st().getNumber("WEBGL_VERSION")===1&&I.infLoc!==null&&w.gl.uniform1f(I.infLoc,1/0),I.nanLoc!==null&&w.gl.uniform1f(I.nanLoc,NaN),S.forEach((U,_)=>{const ee=I.program.variableNames[_],re=I.uniformLocations[ee],ce=I.uniformLocations[`offset${ee}`],we=I.inShapesLocations[`${ee}Shape`],Ee=I.inTexShapesLocations[`${ee}TexShape`];if(we){const{uniformShape:Pe}=fN(I.program.packedInputs,U.shape,U.texData.texShape);switch(Pe.length){case 1:w.gl.uniform1iv(we,new Int32Array(Pe));break;case 2:w.gl.uniform2iv(we,new Int32Array(Pe));break;case 3:w.gl.uniform3iv(we,new Int32Array(Pe));break;case 4:w.gl.uniform4iv(we,new Int32Array(Pe))}}if(Ee&&w.gl.uniform2i(Ee,U.texData.texShape[0],U.texData.texShape[1]),re!=null)if(U.isUniform)if(Ye(U.shape)<2)w.gl.uniform1f(re,U.uniformValues[0]);else{let Pe=U.uniformValues;Pe instanceof Float32Array||(Pe=new Float32Array(Pe)),w.gl.uniform1fv(re,Pe)}else U.texData.slice!=null&&ce!=null&&w.gl.uniform1i(ce,U.texData.slice.flatOffset),w.setInputMatrixTexture(U.texData.texture,re,_)});const K=I.outShapeLocation;if(K)switch(T.shape.length){case 1:w.gl.uniform1iv(K,new Int32Array(T.shape));break;case 2:w.gl.uniform2iv(K,new Int32Array(T.shape));break;case 3:w.gl.uniform3iv(K,new Int32Array(T.shape));break;case 4:w.gl.uniform4iv(K,new Int32Array(T.shape))}if(I.outShapeStridesLocation){const U=Je(T.shape);switch(T.shape.length){case 2:w.gl.uniform1iv(I.outShapeStridesLocation,new Int32Array(U));break;case 3:w.gl.uniform2iv(I.outShapeStridesLocation,new Int32Array(U));break;case 4:w.gl.uniform3iv(I.outShapeStridesLocation,new Int32Array(U))}}I.outTexShapeLocation&&w.gl.uniform2i(I.outTexShapeLocation,T.texData.texShape[0],T.texData.texShape[1]),I.program.customUniforms&&D&&I.program.customUniforms.forEach((U,_)=>{const ee=I.customUniformLocations[_],re=D[_];if(U.type==="float")w.gl.uniform1fv(ee,re);else if(U.type==="vec2")w.gl.uniform2fv(ee,re);else if(U.type==="vec3")w.gl.uniform3fv(ee,re);else if(U.type==="vec4")w.gl.uniform4fv(ee,re);else if(U.type==="int")w.gl.uniform1iv(ee,re);else if(U.type==="ivec2")w.gl.uniform2iv(ee,re);else if(U.type==="ivec3")w.gl.uniform3iv(ee,re);else{if(U.type!=="ivec4")throw Error(`uniform type ${U.type} is not supported yet.`);w.gl.uniform4iv(ee,re)}}),w.executeProgram()}(this.gpgpu,m,l,c,s),h.forEach(w=>this.disposeIntermediateTensorInfo(w)),y&&(b=this.endTimer(b),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(b)}));const v=st().get("WEBGL_FLUSH_THRESHOLD");if(v>0){const w=$a();w-this.lastGlFlushTime>v&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=w)}if(!st().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&o===!1){const w=this.unpackTensor(A);return this.disposeIntermediateTensorInfo(A),w}return A}compileAndRun(e,t,r,s,o=!1){return r=r||t[0].dtype,this.runWebGLProgram(e,t,r,s,o)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(st().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=Ve(()=>{if(!st().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=st().getBool("DEBUG");st().set("DEBUG",!1);const t=this.abs(un(1e-8)).dataSync()[0];if(st().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:r,dtype:s,values:o,texture:A,usage:u,isPacked:h}=t;if(A!=null)return;const l=this.activeTimers!=null;let c;l&&(c=$a());let d=t.texShape;if(d==null&&(d=function(m,y=!1){let b=st().getNumber("WEBGL_MAX_TEXTURE_SIZE");y&&(b*=2,(m=m.map((w,I)=>I>=m.length-2?Tn(m[I]):m[I])).length===1&&(m=[2,m[0]])),m.length!==2&&(m=tt(m).newShape);let v=Ye(m);if(m.length<=1&&v<=b)return[1,v];if(m.length===2&&m[0]<=b&&m[1]<=b)return m;if(m.length===3&&m[0]*m[1]<=b&&m[2]<=b)return[m[0]*m[1],m[2]];if(m.length===3&&m[0]<=b&&m[1]*m[2]<=b)return[m[0],m[1]*m[2]];if(m.length===4&&m[0]*m[1]*m[2]<=b&&m[3]<=b)return[m[0]*m[1]*m[2],m[3]];if(m.length===4&&m[0]<=b&&m[1]*m[2]*m[3]<=b)return[m[0],m[1]*m[2]*m[3]];if(y){const w=Vp(m);let I=2,S=2;return m.length&&([I,S]=Xp(m)),v=w*(I/2)*(S/2),cn(v).map(T=>2*T)}return cn(v)}(r,h),t.texShape=d),o!=null){const m=uN(r);let y,b=d[1],v=d[0];const w=o instanceof Uint8Array;h?([b,v]=Gp(d[0],d[1]),y=new xAe(m,w)):y=new vAe(m,w);const I=this.makeTensorInfo([v,b],s);this.texData.get(I.dataId).usage=w?ti.PIXELS:ti.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(I.dataId),b,v,o);const S=[[v,b]],T=!0,D=this.runWebGLProgram(y,[I],s,S,T),L=this.texData.get(D.dataId);t.texture=L.texture,t.texShape=L.texShape,t.isPacked=L.isPacked,t.usage=L.usage,this.disposeIntermediateTensorInfo(I),this.texData.delete(D.dataId),t.values=null,l&&(this.uploadWaitMs+=$a()-c)}else{const m=this.acquireTexture(d,u,s,h);t.texture=m}}convertAndCacheOnCPU(e,t){const r=this.texData.get(e),{dtype:s}=r;return this.releaseGPUData(e),t!=null&&(r.values=function(o,A){if(A==="float32"||A==="complex64")return o;if(A==="int32"||A==="bool"){const u=A==="int32"?new Int32Array(o.length):new Uint8Array(o.length);for(let h=0;h<u.length;++h)u[h]=Math.round(o[h]);return u}throw new Error(`Unknown dtype ${A}`)}(t,s)),r.values}acquireTexture(e,t,r,s){if(this.numBytesInGPU+=this.computeBytes(e,r),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,s)}computeBytes(e,t){return e[0]*e[1]*Dt(t)}}e1.nextDataId=0,B7()&&h4("webgl",()=>new e1,2);const F6=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class qp{constructor(e,t,r){this.variableNames=["A","B"],this.outputShape=Bn(t,r),this.enableShapeUniforms=ni(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}const t1=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;class pg{constructor(e,t,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Bn(t,r);const o=this.outputShape.length;this.enableShapeUniforms=ni(o);let A="";if(s)if(o===0||Ye(this.outputShape)===1)A=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(A=`
          ${kr(o)} coords = getOutputCoords();
        `,o===1)this.enableShapeUniforms?A+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:A+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const u=Ha("coords",o);this.enableShapeUniforms?A+=`
            bool nextRowOutOfBounds =
              (${u[o-2]} + 1) >= outShape[${o} - 2];
            bool nextColOutOfBounds =
              (${u[o-1]} + 1) >= outShape[${o} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:A+=`
            bool nextRowOutOfBounds =
              (${u[o-2]} + 1) >= ${this.outputShape[o-2]};
            bool nextColOutOfBounds =
              (${u[o-1]} + 1) >= ${this.outputShape[o-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${A}

        setOutput(result);
      }
    `}}function No(n){const{inputs:e,backend:t}=n,{x:r}=e;return t.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const hle={kernelName:Uf,backendName:"webgl",kernelFunc:No};function Nu(n){const{inputs:e,backend:t}=n,{real:r,imag:s}=e,o=t.makeTensorInfo(r.shape,"complex64"),A=t.texData.get(o.dataId),u=No({inputs:{x:r},backend:t}),h=No({inputs:{x:s},backend:t});return A.complexTensorInfos={real:u,imag:h},o}const fle={kernelName:Fa,backendName:"webgl",kernelFunc:Nu},L6="return (a < 0.) ? b * a : a;",R6=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`,mle={kernelName:Y0,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{alpha:o}=r,A=t.makeTensorInfo([],"float32",tu(o,"float32")),u=st().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new pg(R6,s.shape,A.shape):new qp(L6,s.shape,A.shape),h=t.runWebGLProgram(u,[s,A],s.dtype);return t.disposeIntermediateTensorInfo(A),h}},W6="return (a < 0.) ? b * a : a;",j6=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`,gle={kernelName:cv,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t}=n,{x:r,alpha:s}=e,o=st().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new pg(j6,r.shape,s.shape):new qp(W6,r.shape,s.shape);return t.runWebGLProgram(o,[r,s],r.dtype)}},H6="if (isnan(x)) return x;";function Qn({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:r}){return({inputs:s,backend:o})=>{const{x:A}=s,u=o,h=r||A.dtype;if(u.shouldExecuteOnCPU([A])&&t!=null){const c=u.texData.get(A.dataId),d=t(c.values,h);return u.makeTensorInfo(A.shape,h,d)}let l;return l=st().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null?new Kp(A.shape,e):new Su(A.shape,n),u.runWebGLProgram(l,[A],h)}}function la({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:o}){return({inputs:A,backend:u})=>{const{a:h,b:l}=A,c=u;if(r&&h.dtype==="complex64"){const y=c.texData.get(h.dataId),b=c.texData.get(l.dataId),[v,w]=[[y.complexTensorInfos.real,b.complexTensorInfos.real],[y.complexTensorInfos.imag,b.complexTensorInfos.imag]].map(S=>{const[T,D]=S,L={dataId:T.dataId,dtype:T.dtype,shape:h.shape},W={dataId:D.dataId,dtype:D.dtype,shape:l.shape},K=new qp(n,h.shape,l.shape);return c.runWebGLProgram(K,[L,W],Uo(T.dtype,D.dtype))}),I=Nu({inputs:{real:v,imag:w},backend:c});return c.disposeIntermediateTensorInfo(v),c.disposeIntermediateTensorInfo(w),I}const d=o||Uo(h.dtype,l.dtype);if((h.dtype==="string"||l.dtype==="string"||c.shouldExecuteOnCPU([h,l]))&&s!=null){const y=c.texData.get(h.dataId).values,b=c.texData.get(l.dataId).values,v=h.dtype==="string"?Lc(y):y,w=h.dtype==="string"?Lc(b):b,[I,S]=s(h.shape,l.shape,v,w,d),T=c.makeTensorInfo(S,d);return c.texData.get(T.dataId).values=I,T}let m;return m=st().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null?new pg(e,h.shape,l.shape,t):new qp(n,h.shape,l.shape),c.runWebGLProgram(m,[h,l],d)}}function n1(n,e=!1){if(n==="linear")return"return x;";if(n==="relu")return e?`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`:lle;if(n==="elu")return e?`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`:"return (x >= 0.0) ? x : (exp(x) - 1.0);";if(n==="relu6")return e?`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`:ule;if(n==="prelu")return e?j6:W6;if(n==="leakyrelu")return e?R6:L6;if(n==="sigmoid")return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class G6{constructor(e,t,r,s=!1,o=!1,A=!1,u=null,h=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=ni(this.outputShape.length);const c=s?e[1]:e[2],d=Math.ceil(c/2),m=s?"i * 2, rc.y":"rc.y, i * 2",y=o?"rc.z, i * 2":"i * 2, rc.z",b=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],v=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let w="",I="";u&&(w=h?`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${u}
        }`:l?`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${u}
        }`:`vec4 activation(vec4 x) {
          ${u}
        }`,I="result = activation(result);");const S=A?"result += getBiasAtOutCoords();":"";A&&this.variableNames.push("bias"),h&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let T="rc.x",D="rc.x";e[0]<t[0]?T=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(D=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`
      ${w}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${d}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${d}; i++) {
          int batchA = ${T};
          int batchB = ${D};
          vec4 a = getMatrixA(batchA, ${m});
          vec4 b = getMatrixB(batchB, ${y});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${b[0]} * ${v[0]});
          result += (${b[1]} * ${v[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${S}

        ${I}

        setOutput(result);
      }
    `}}class V6{constructor(e,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Bn(t,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}const X6="return a * b;";function yN(n){const{inputs:e,backend:t}=n,{a:r,b:s}=e,o=Uo(r.dtype,s.dtype);if(r.dtype==="complex64"){const u=t.texData.get(r.dataId),h=t.texData.get(s.dataId),l=new V6("return areal * breal - aimag * bimag;",r.shape,s.shape),c=new V6("return areal * bimag + aimag * breal;",r.shape,s.shape),d=[{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:r.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:h.complexTensorInfos.real.dataId,dtype:h.complexTensorInfos.real.dtype,shape:s.shape},{dataId:h.complexTensorInfos.imag.dataId,dtype:h.complexTensorInfos.imag.dtype,shape:s.shape}],m=t.runWebGLProgram(l,d,"float32"),y=t.runWebGLProgram(c,d,"float32"),b=Nu({inputs:{real:m,imag:y},backend:t});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),b}if(t.shouldExecuteOnCPU([r,s])){const u=t.texData.get(r.dataId),h=t.texData.get(s.dataId),[l,c]=GAe(r.shape,s.shape,u.values,h.values,o),d=t.makeTensorInfo(c,o);return t.texData.get(d.dataId).values=l,d}let A;return A=st().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new pg(X6,r.shape,s.shape):new qp(X6,r.shape,s.shape),t.runWebGLProgram(A,[r,s],o)}const yle={kernelName:nm,backendName:"webgl",kernelFunc:yN};function Gt(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{shape:o}=r,A=t,u=Ye(s.shape),h=yn(o,u),l=Ye(h);J(u===l,()=>`The new shape (${h}) has ${l} elements and the old shape (${s.shape}) has ${u} elements. The new shape and old shape must have the same number of elements.`);const c=A.texData.get(s.dataId);return!c.isPacked||Jx(s.shape,h)||c.texture!==null&&Jx(c.shape,h)?(A.incRef(s.dataId),{dataId:s.dataId,shape:h,dtype:s.dtype}):function(d,m,y){const b=[Vp(d.shape),...Xp(d.shape)],v={dtype:d.dtype,shape:b,dataId:d.dataId},w=[Vp(m),...Xp(m)],I=new D6(w,b),S=[b],T=y.runWebGLProgram(I,[v],d.dtype,S,!0);return{dataId:T.dataId,shape:m,dtype:T.dtype}}(s,h,A)}const ble={kernelName:dv,backendName:"webgl",kernelFunc:Gt};class Z6{constructor(e,t){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:A}=e;this.outputShape=[s,A];const u=4*Math.floor(r/4),h=r%4;let l="sumValue += dot(values, ones);";if(t!=null){const d=1/t;l=`sumValue += dot(values * ${Et(d)?d.toPrecision(2):d}, ones);`}let c="";o%r>0&&(c=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${u};
        if (${h===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}}class vle{constructor(e,t){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:o,outSize:A}=e;this.outputShape=[s,A];let u="0.0",h="";t==="prod"?u="1.0":t==="min"?(u="1.0 / 1e-20",h="min"):t==="max"&&(u="-1.0 / 1e-20",h="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?l="sumValue":t==="prod"?l="prodValue":t==="all"?l="allValue":t==="any"&&(l="anyValue");const c=4*Math.floor(r/4),d=r%4;let m=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${h}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${h}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,y="vec4";t==="all"?(u="1.0",m=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,y="bvec4"):t==="any"&&(u="0.0",m=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,y="bvec4");let b="";o%r>0&&(b=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${u};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${b}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${u});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${m}
        }

        int inIdx = inOffset + ${c};
        if (${d===1}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${d===2}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${d===3}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${m}
        }
        setOutput(${l});
      }
    `}}function Jc(n,e,t,r){const s=function(A){const u=[];for(;u.length===0||u[u.length-1].outSize!==1;){const h=u.length?u[u.length-1].outSize:A[1],l=Ax(h);u.push({inSize:h,windowSize:l,outSize:Math.ceil(h/l)})}return u}(n.shape);let o=n;for(let A=0;A<s.length;A++){const{inSize:u,windowSize:h,outSize:l}=s[A];let c,d;c=t==="mean"?A===0?new Z6({windowSize:h,inSize:u,batchSize:n.shape[0],outSize:l},u):new Z6({windowSize:h,inSize:u,batchSize:n.shape[0],outSize:l}):new vle({windowSize:h,inSize:u,batchSize:n.shape[0],outSize:l},t),d=o,o=r.runWebGLProgram(c,[o],e),d.dataId!==n.dataId&&r.disposeIntermediateTensorInfo(d)}return o}class xle{constructor(e,t){this.variableNames=["A"];const r=new Array(e.length);for(let A=0;A<r.length;A++)r[A]=e[t[A]];this.outputShape=r,this.rank=r.length;const s=kr(this.rank),o=function(A){const u=A.length;if(u>6)throw Error(`Transpose for rank ${u} is not yet supported`);const h=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],l=new Array(u);for(let c=0;c<A.length;c++)l[A[c]]=h[c];return l.join()}(t);this.userCode=`
    void main() {
      ${s} resRC = getOutputCoords();
      setOutput(getA(${o}));
    }
    `}}class wle{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(e.length);for(let c=0;c<r.length;c++)r[c]=e[t[c]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=kr(this.rank),o=E6("rc",this.rank),A=new Array(this.rank);for(let c=0;c<t.length;c++)A[t[c]]=o[c];const u=`vec2(${A.slice(-2).join()})`,h=`++${o[this.rank-1]} < ${r[this.rank-1]}`,l=`getChannel(getA(${A.join()}), ${u})`;this.userCode=`
    void main() {
      ${s} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${h}) {
        result[1] = ${l};
      }
      --${o[this.rank-1]};
      if(++${o[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${l};
        if(${h}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}}function r1(n,e,t){const r=st().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new wle(n.shape,e):new xle(n.shape,e);return t.runWebGLProgram(r,[n],n.dtype)}function s1(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:A}=r;return function(u,h,l,c){const d=h,m=u.shape.length,y=pt(d,u.shape);let b=y;const v=cs(b,m),w=v!=null;let I=u;w&&(I=r1(u,v,c),b=bs(b.length,m)),ia("sum",b,m);const[S,T]=Xs(I.shape,b);let D=S;l&&(D=us(S,y));const L=Ye(T),W=Gt({inputs:{x:I},attrs:{shape:[Ye(u.shape)/L,L]},backend:c}),K=Jc(W,kI(u.dtype),"sum",c),U=Gt({inputs:{x:K},attrs:{shape:D},backend:c});return c.disposeIntermediateTensorInfo(W),c.disposeIntermediateTensorInfo(K),w&&c.disposeIntermediateTensorInfo(I),U}(s,o,A,t)}const kle={kernelName:yv,backendName:"webgl",kernelFunc:s1};function Ga(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{perm:o}=r,A=t,u=s.shape.length,h=new Array(u);for(let c=0;c<h.length;c++)h[c]=s.shape[o[c]];let l;if(A.shouldExecuteOnCPU([s])){const c=A.texData.get(s.dataId).values,d=mN(c,s.shape,s.dtype,o,h);l=A.makeTensorInfo(h,s.dtype),A.texData.get(l.dataId).values=d}else l=r1(s,o,A);return l}const Cle={kernelName:wv,backendName:"webgl",kernelFunc:Ga};function a1({a:n,b:e,transposeA:t,transposeB:r,backend:s,bias:o=null,preluActivationWeights:A=null,leakyreluAlpha:u=0,activation:h=null}){const l=n.shape.length,c=e.shape.length,d=t?n.shape[l-2]:n.shape[l-1],m=r?e.shape[c-1]:e.shape[c-2],y=t?n.shape[l-1]:n.shape[l-2],b=r?e.shape[c-2]:e.shape[c-1],v=n.shape.slice(0,-2),w=e.shape.slice(0,-2),I=Ye(v),S=Ye(w);J(l>=2&&c>=2&&(I===S||I===1||S===1),()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${v}) and (${w}).`);const T=(I>S?n.shape.slice(0,-2):e.shape.slice(0,-2)).concat([y,b]);J(d===m,()=>`Error in matMul: inner shapes (${d}) and (${m}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${r} must match.`);const D=t?[I,d,y]:[I,y,d],L=r?[S,b,m]:[S,m,b],W=Gt({inputs:{x:n},backend:s,attrs:{shape:D}}),K=Gt({inputs:{x:e},backend:s,attrs:{shape:L}}),U=[W,K],_=Math.max(I,S),ee=t?W.shape[1]:W.shape[2],re=o!=null,ce=A!=null,we=h==="leakyrelu",Ee=h!=null?n1(h,!0):null;let Pe;if((y===1||b===1)&&ee>1e3&&(re||ce||we||Ee!=null)===!1){let de=W,Ae=K;t&&(de=Ga({inputs:{x:W},backend:s,attrs:{perm:[0,2,1]}}),U.push(de)),r&&(Ae=Ga({inputs:{x:K},backend:s,attrs:{perm:[0,2,1]}}),U.push(Ae));const Se=b===1;let Te=de;b!==1&&(Te=Gt({inputs:{x:de},backend:s,attrs:{shape:[_,ee,1]}}),U.push(Te));const Ze=b===1?2:1;let et=Ae;Se&&(et=Gt({inputs:{x:Ae},backend:s,attrs:{shape:[_,1,ee]}}),U.push(et));const qe=yN({inputs:{a:Te,b:et},backend:s});Pe=s1({inputs:{x:qe},backend:s,attrs:{axis:Ze,keepDims:!0}}),U.push(qe)}else{const de=Uo(n.dtype,e.dtype),Ae=new G6(D,L,[_,y,b],t,r,re,Ee,ce,we),Se=[W,K];if(o!=null&&Se.push(o),ce&&Se.push(A),we){const Te=s.makeTensorInfo([],"float32",tu(u,"float32"));Se.push(Te),U.push(Te)}Pe=s.runWebGLProgram(Ae,Se,de)}const he=Gt({inputs:{x:Pe},backend:s,attrs:{shape:T}});U.push(Pe);for(const de of U)s.disposeIntermediateTensorInfo(de);return he}const Ile={kernelName:Sv,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:o,bias:A,preluActivationWeights:u}=e,{transposeA:h,transposeB:l,activation:c,leakyreluAlpha:d}=r;return a1({a:s,b:o,transposeA:h,transposeB:l,backend:t,bias:A,preluActivationWeights:u,leakyreluAlpha:d,activation:c})}},Y6="return abs(x);",Sle={kernelName:sl,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){const o=t.texData.get(r.dataId),A=T6(o.values);return t.makeTensorInfo(r.shape,r.dtype,A)}let s;return s=st().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Kp(r.shape,Y6):new Su(r.shape,Y6),t.runWebGLProgram(s,[r],r.dtype)}},Nle=Qn({opSnippet:eA+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`}),Tle={kernelName:Hi,backendName:"webgl",kernelFunc:Nle},Mle=Qn({opSnippet:eA+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`}),Ele={kernelName:ve,backendName:"webgl",kernelFunc:Mle},U6="return a + b;",Dle=la({opSnippet:U6,packedOpSnippet:U6,supportsComplex:!0,cpuKernelImpl:kAe}),zle={kernelName:be,backendName:"webgl",kernelFunc:Dle};class Ole{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((o,A)=>`T${A}`);const r=[];this.variableNames.forEach(o=>{r.push(`float v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${s};
        setOutput(result);
      }
    `}}class Ple{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((o,A)=>`T${A}`);const r=[];this.variableNames.forEach(o=>{r.push(`vec4 v${o} = get${o}AtOutCoords();`)});const s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${s};
        setOutput(result);
      }
    `}}const Ble={kernelName:Le,backendName:"webgl",kernelFunc:function n(e){const{inputs:t,backend:r}=e,s=t;if(s.length===1)return No({inputs:{x:s[0]},backend:r});if(s.length>st().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const h=Math.floor(s.length/2),l=n({inputs:s.slice(0,h),backend:r}),c=n({inputs:s.slice(h),backend:r});return n({inputs:[l,c],backend:r})}const o=s.map(h=>h.dtype).reduce((h,l)=>Uo(h,l)),A=s.map(h=>h.shape),u=st().getBool("WEBGL_PACK")?new Ple(s[0].shape,A):new Ole(s[0].shape,A);return r.runWebGLProgram(u,s,o)}},Fle={kernelName:at,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:A}=r,u=s.shape.length,h=pt(o,s.shape);let l=h;const c=cs(l,u);let d=s;c!=null&&(d=Ga({inputs:{x:s},backend:t,attrs:{perm:c}}),l=bs(l.length,u)),ia("all",l,u);const[m,y]=Xs(d.shape,l),b=Gt({inputs:{x:d},backend:t,attrs:{shape:[-1,Ye(y)]}}),v=Jc(b,b.dtype,"all",t);let w;return w=Gt(A?{inputs:{x:v},backend:t,attrs:{shape:us(m,h)}}:{inputs:{x:v},backend:t,attrs:{shape:m}}),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(v),c!=null&&t.disposeIntermediateTensorInfo(d),w}},Lle={kernelName:lt,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:A}=r,u=s.shape.length,h=pt(o,s.shape);let l=h;const c=cs(l,u);let d=s;c!=null&&(d=Ga({inputs:{x:s},backend:t,attrs:{perm:c}}),l=bs(l.length,u)),ia("any",l,u);const[m,y]=Xs(d.shape,l),b=Gt({inputs:{x:d},backend:t,attrs:{shape:[-1,Ye(y)]}}),v=Jc(b,b.dtype,"any",t);let w;return w=Gt(A?{inputs:{x:v},backend:t,attrs:{shape:us(m,h)}}:{inputs:{x:v},backend:t,attrs:{shape:m}}),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(v),c!=null&&t.disposeIntermediateTensorInfo(d),w}};class Rle{constructor(e,t,r){this.variableNames=["A"];const{windowSize:s,batchSize:o,outSize:A}=e;r||this.variableNames.push("bestIndicesA"),this.outputShape=[o,A];const u=t==="max"?">":"<",h=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${s}; i++) {
          int inIdx = ${h};
          float candidate = getA(batch, inIdx);
          if (candidate ${u} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}class Wle{constructor(e,t,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,J(e.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const o=e[e.length-1],A=Math.ceil(o/t);this.outputShape=e.slice(0,-1),A>1&&this.outputShape.push(A),s||this.variableNames.push("bestIndicesA");const u=this.outputShape,h=u.length,l=kr(h),c=Ha("coords",h);let d,m;if(A===1){m=h+1;const U=kr(m);d=`
        ${U} sourceLocR = ${U}(${c.join()}, 0);
        ++${c[h-1]};
        ${U} sourceLocG = ${U}(${c.join()}, 0);
        ++${c[h-2]};
        ${U} sourceLocA = ${U}(${c.join()}, 0);
        --${c[h-1]};
        ${U} sourceLocB = ${U}(${c.join()}, 0);
        --${c[h-2]};`}else m=h,d=`
        ${l} sourceLocR = coords;
        ++${c[h-1]};
        ${l} sourceLocG = coords;
        ++${c[h-2]};
        ${l} sourceLocA = coords;
        --${c[h-1]};
        ${l} sourceLocB = coords;
        --${c[h-2]};`;const y=["x","y","z","w","u","v"].slice(0,m),b="."+y[m-1],v=y.map(U=>"int "+U),w=Ha("sourceLocR",m-1).concat("inIdx.r"),I=Ha("sourceLocG",m-1).concat("inIdx.g"),S=Ha("sourceLocB",m-1).concat("inIdx.b"),T=Ha("sourceLocA",m-1).concat("inIdx.a"),D=r==="max"?"greaterThan":"lessThan",L=s?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${I.join()}),
                             getBestIndicesAChannel(${S.join()}),
                             getBestIndicesAChannel(${T.join()})));`,W=`vec4(
            getAChannel(${w.join()}),
            hasNextCol ? getAChannel(${I.join()}) : 0.,
            hasNextRow ? getAChannel(${S.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${T.join()}) : 0.)`,K=s?"":`
      float getBestIndicesAChannel(${v.join()}) {
        return getChannel(getBestIndicesA(${y.join()}),
                                          vec2(${y.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${v.join()}) {
        return getChannel(getA(${y.join()}),
                               vec2(${y.slice(-2).join()}));
      }
      ${K}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${c[h-1]} < ${u[h-1]-1};
        bool hasNextRow = ${c[h-2]} < ${u[h-2]-1};
        ${d}
        ivec4 srcIdx = ivec4(sourceLocR${b}, sourceLocG${b},
          sourceLocB${b}, sourceLocA${b}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${W};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${L}
          vec4 candidate = ${W};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${D}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}function Q6(n,e,t,r=null){let s=e.shape[0],o=e.shape[1];r!=null&&(s=r.shape[0],o=r.shape[1]);const A=Ax(o),u={windowSize:A,inSize:o,batchSize:s,outSize:Math.ceil(o/A)},h=new Rle(u,t,r==null),l=[e];r!=null&&l.push(r);const c=n.runWebGLProgram(h,l,"int32");if(c.shape[1]===1)return c;const d=Q6(n,e,t,c);return n.disposeIntermediateTensorInfo(c),d}function K6(n,e,t,r=null){const s=r!=null?r.shape:e.shape,o=Ax(s[s.length-1]),A=new Wle(s,o,t,r==null),u=r==null?[e]:[e,r],h=n.runWebGLProgram(A,u,"int32");if(h.shape.length===e.shape.length){const l=K6(n,e,t,h);return n.disposeIntermediateTensorInfo(h),l}return h}function q6(n,e,t,r){const s=[t];if(ia("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,e.shape.length),!st().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const o=[],A=n.texData.get(e.dataId);let u=e;A!==null&&A.isPacked&&(u=n.unpackTensor(e),o.push(u));const[h,l]=Xs(u.shape,s),c=Ye(l),d=Gt({inputs:{x:u},backend:n,attrs:{shape:[-1,c]}});o.push(d);const m=Q6(n,d,r);o.push(m);const y=Gt({inputs:{x:m},backend:n,attrs:{shape:h}});return o.forEach(b=>n.disposeIntermediateTensorInfo(b)),y}return K6(n,e,r)}const jle={kernelName:ct,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o}=r;let A=pt(o,s.shape);const u=cs(A,s.shape.length);let h=s;const l=[];u!=null&&(h=Ga({inputs:{x:s},backend:t,attrs:{perm:u}}),l.push(h),A=bs(A.length,h.shape.length)),ia("argMax",[A[0]],h.shape.length);const c=q6(t,h,A[0],"max");return l.forEach(d=>t.disposeIntermediateTensorInfo(d)),c}},Hle={kernelName:St,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o}=r;let A=pt(o,s.shape);const u=cs(A,s.shape.length);let h=s;const l=[];u!=null&&(h=Ga({inputs:{x:s},backend:t,attrs:{perm:u}}),l.push(h),A=bs(A.length,h.shape.length)),ia("argMin",[A[0]],h.shape.length);const c=q6(t,h,A[0],"min");return l.forEach(d=>t.disposeIntermediateTensorInfo(d)),c}},Gle=Qn({opSnippet:eA+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`}),Vle={kernelName:nt,backendName:"webgl",kernelFunc:Gle},Xle=Qn({opSnippet:eA+"return log(x + sqrt(x * x + 1.0));"}),Zle={kernelName:Ot,backendName:"webgl",kernelFunc:Xle},Yle=Qn({opSnippet:eA+`
  return atan(x);
`}),Ule={kernelName:Pt,backendName:"webgl",kernelFunc:Yle},Qle=la({opSnippet:`
  if (isnan(a)) return a;
  if (isnan(b)) return b;

  return atan(a, b);
`,packedOpSnippet:`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;

  return result;
`}),Kle={kernelName:Pn,backendName:"webgl",kernelFunc:Qle},qle=Qn({opSnippet:eA+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`}),Jle={kernelName:Bt,backendName:"webgl",kernelFunc:qle};class hg{constructor(e,t,r,s=!1,o=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const A=e.filterWidth,u=e.strideHeight,h=e.strideWidth,l=e.dilationHeight,c=e.dilationWidth,d=e.effectiveFilterHeight,m=e.effectiveFilterWidth,y=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const v=t==="avg",w=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,I=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let S="0.0";if(v||(S="-1.0 / 1e-20"),r){const K=">=";return void(this.userCode=`
        const ivec2 strides = ivec2(${u}, ${h});
        const ivec2 pads = ivec2(${y}, ${b});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${d};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${K} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${s?o?w:I:`wR * ${m} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `)}let T=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(T="avgValue / count");const D=4*Math.floor(A/4),L=A%4,W=`
      if (${v}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = max(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${u}, ${h});
      const ivec2 pads = ivec2(${y}, ${b});
      const float initializationValue = ${S};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${S});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${d};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${D}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${W}
          }

          int xC = xCCorner + ${D};
          if (${L===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${W}
          } else if (${L===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${W}
          } else if (${L===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${W}
          }
        }
        setOutput(${T});
      }
    `}}class bN{constructor(e,t,r,s=!1,o=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const A=e.filterWidth,u=e.strideDepth,h=e.strideHeight,l=e.strideWidth,c=e.dilationDepth,d=e.dilationHeight,m=e.dilationWidth,y=e.effectiveFilterDepth,b=e.effectiveFilterHeight,v=e.effectiveFilterWidth,w=e.padInfo.front,I=e.padInfo.top,S=e.padInfo.left;this.outputShape=e.outShape;const T=t==="avg";let D="0.0";if(T||(D="-1.0 / 1e-20"),r){const _=">=";return void(this.userCode=`
        const ivec3 strides =
            ivec3(${u}, ${h}, ${l});
        const ivec3 pads = ivec3(${w}, ${I}, ${S});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${y};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${b};
                wR += ${d}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${v};
                  wC += ${m}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${_} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${s?o?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${b} * ${v} +
                      wR * ${v} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `)}let L=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(L="avgValue / count");const W=4*Math.floor(A/4),K=A%4,U=`
      if (${T}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = max(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${u}, ${h}, ${l});
      const ivec3 pads = ivec3(${w}, ${I}, ${S});
      const float initializationValue = ${D};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${D});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${y};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${b};
            wR += ${d}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${W}; wC += 4) {
              int xC = xCCorner + wC * ${m};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                getValue(batch, xD, xR, xC + 3 * ${m}, ch)
              );

              ${U}
            }

            int xC = xCCorner + ${W};
            if (${K===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${U}
            } else if (${K===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                initializationValue,
                initializationValue
              );

              ${U}
            } else if (${K===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                initializationValue
              );

              ${U}
            }
          }
          setOutput(${L});
        }
      }
    `}}const $le={kernelName:Zn,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;cg(s,"avgPool");const{filterSize:o,strides:A,pad:u,dimRoundingMode:h}=r;J(oa(A,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${A} and dilations '1'`);const l=bi(s.shape,o,A,1,u,h);if(l.filterWidth===1&&l.filterHeight===1&&ht(l.inShape,l.outShape))return No({inputs:{x:s},backend:t});const c=new hg(l,"avg",!1);return t.runWebGLProgram(c,[s],"float32")}},_le={kernelName:$r,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:o,strides:A,pad:u,dimRoundingMode:h,dataFormat:l}=r,c=ul(s.shape,o,A,[1,1,1],u,h,l),d=new bN(c,"avg",!1);return t.runWebGLProgram(d,[s],"float32")}};class eue{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,s=e.strideHeight,o=e.strideWidth,A=e.dilationHeight,u=e.dilationWidth,h=e.effectiveFilterHeight,l=e.effectiveFilterWidth,c=h-1-e.padInfo.top,d=l-1-e.padInfo.left,m=1/(t*r);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${d});
      const float avgMultiplier = float(${m});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${h};
            wR += ${A}) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${u}) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class tue{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,r=e.filterHeight,s=e.filterWidth,o=e.strideDepth,A=e.strideHeight,u=e.strideWidth,h=e.dilationDepth,l=e.dilationHeight,c=e.dilationWidth,d=e.effectiveFilterDepth,m=e.effectiveFilterHeight,y=e.effectiveFilterWidth,b=d-1-e.padInfo.front,v=m-1-e.padInfo.top,w=y-1-e.padInfo.left,I=1/(t*r*s);this.userCode=`
      const ivec3 pads = ivec3(${b}, ${v}, ${w});
      const float avgMultiplier = float(${I});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${h}) {
          float dyD = float(dyDCorner + wD) / ${o}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${m};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${A}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${y};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${u}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}const nue={kernelName:gs,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:o}=e,A=o,{filterSize:u,strides:h,pad:l,dimRoundingMode:c}=r,d=ul(A.shape,u,h,[1,1,1],l,c),m=new tue(d);return t.runWebGLProgram(m,[s],A.dtype)}},rue={kernelName:Rr,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:o}=e,A=o;cg([s,o],"avgPoolGrad");const{filterSize:u,strides:h,pad:l}=r,c=bi(A.shape,u,h,1,l),d=new eue(c);return t.runWebGLProgram(d,[s],A.dtype)}},sue={kernelName:sr,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:o}=e,{transposeA:A,transposeB:u}=r;return a1({a:s,b:o,transposeA:A,transposeB:u,backend:t})}};class aue{constructor(e,t,r,s,o,A){this.outputShape=[],this.variableNames=["x","mean","variance"],Bn(e,t),Bn(e,r);let u="0.0";s!=null&&(Bn(e,s),this.variableNames.push("offset"),u="getOffsetAtOutCoords()");let h="1.0";o!=null&&(Bn(e,o),this.variableNames.push("scale"),h="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${u};
        float scale = ${h};
        float inv = scale * inversesqrt(variance + float(${A}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}class oue{constructor(e,t,r,s,o,A){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Bn(e,t),Bn(e,r);let u="vec4(0.0)";s!=null&&(Bn(e,s),this.variableNames.push("offset"),u="getOffsetAtOutCoords()");let h="vec4(1.0)";o!=null&&(Bn(e,o),this.variableNames.push("scale"),h="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${u};
        vec4 scale = ${h};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${A}));

        setOutput((x - mean) * inv + offset);
      }
    `}}const iue={kernelName:V0,backendName:"webgl",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:r,mean:s,variance:o,offset:A,scale:u}=n;J(s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),J(A==null||s.shape.length===A.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),J(u==null||s.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:h}=t;h==null&&(h=.001);const l=[r,s,o];let c=null;A!=null&&(c=A.shape,l.push(A));let d=null;u!=null&&(d=u.shape,l.push(u));const m=st().getBool("WEBGL_PACK_NORMALIZATION")?new oue(r.shape,s.shape,o.shape,c,d,h):new aue(r.shape,s.shape,o.shape,c,d,h);return e.runWebGLProgram(m,l,l[0].dtype)}};class Aue{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=kr(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=function(o){if(o===1)return"sourceLoc";if(o<=6)return vN.slice(0,o).map(A=>"sourceLoc."+A).join(",");throw Error(`Slicing for rank ${o} is not yet supported`)}(this.rank);let s;s=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${e.map((o,A)=>`sourceLoc.${vN[A]} = start[${A}] + coords.${vN[A]};`).join(`
`)}
      `,this.userCode=`
      void main() {
        ${s}
        setOutput(getSource(${r}));
      }
    `}}const vN=["x","y","z","w","u","v"];class lue{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=kr(this.rank),r=Ha("coords",this.rank),s=Ha("sourceLoc",this.rank),o=this.rank===1?"sourceLoc":`vec2(${s.slice(-2).join()})`,A=`getChannel(getSource(${s.join()}), ${o})`,u=`
      result.x = ${A};
      if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
        ++${s[this.rank-1]};
        result.y = ${A};
        --${s[this.rank-1]};
      }
    `,h=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${e[this.rank-2]}) {
        ++${s[this.rank-2]};
        result.z = ${A};
        if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
          ++${s[this.rank-1]};
          result.w = ${A};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((c,d)=>`start[${d}]`).join()});`:e.map((c,d)=>`${s[d]} = ${r[d]} + start[${d}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${u}
        ${h}
        setOutput(result);
      }
    `}}function Jp(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:o,size:A}=r,[u,h]=jv(s,o,A);if(DI(s,u,h),Ye(h)===0)return t.makeTensorInfo(h,s.dtype,[]);if(t.shouldExecuteOnCPU([s])||s.dtype==="string"){const d=t.texData.get(s.dataId),m=KAe(d.values,u,h,s.shape,s.dtype);return t.makeTensorInfo(h,s.dtype,m)}const{isPacked:l}=t.texData.get(s.dataId),c=zI(s.shape,u,h);if(l||!c){const d=st().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new lue(h):new Aue(h),m=[u];return t.runWebGLProgram(d,[s],s.dtype,m)}return t.uploadToGPU(s.dataId),function(d,m,y,b){const v=b.texData.get(d.dataId),w=b.makeTensorInfo(y,d.dtype),I=b.texData.get(w.dataId);Object.assign(I,v),I.refCount=1,I.shape=y,I.dtype=d.dtype;let S=OI(m,Je(d.shape));v.slice&&(S+=v.slice.flatOffset),I.slice={flatOffset:S,origDataId:v.slice&&v.slice.origDataId||d.dataId};const T=b.dataRefCount.get(I.slice.origDataId)||1;return b.dataRefCount.set(I.slice.origDataId,T+1),w}(s,u,h,t)}const uue={kernelName:gv,backendName:"webgl",kernelFunc:Jp},cue={kernelName:vn,backendName:"webgl",kernelFunc:n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:o,crops:A}=r;J(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const u=o.reduce((S,T)=>S*T),h=Rm(s.shape,o,u),l=Wm(h.length,o.length),c=jm(s.shape,o,u),d=wS(A,o.length),m=kS(c,A,o.length),y=[],b=Gt({inputs:{x:s},backend:t,attrs:{shape:h}}),v=Ga({inputs:{x:b},backend:t,attrs:{perm:l}}),w=Gt({inputs:{x:v},backend:t,attrs:{shape:c}}),I=Jp({inputs:{x:w},backend:t,attrs:{begin:d,size:m}});return y.push(b),y.push(v),y.push(w),y.forEach(S=>t.disposeIntermediateTensorInfo(S)),I}},due={kernelName:va,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:o}=e,{size:A}=r,u=t.readSync(s.dataId),h=t.readSync(o.dataId),l=N6(u,h,o.dtype,o.shape,A);return t.makeTensorInfo([A],o.dtype,l)}},J6=la({opSnippet:"return float(a != b);",cpuKernelImpl:XAe,dtype:"bool"}),pue={kernelName:ov,backendName:"webgl",kernelFunc:J6};function fg(n){const{inputs:e,backend:t}=n,{input:r}=e;return No({inputs:{x:t.texData.get(r.dataId).complexTensorInfos.real},backend:t})}const hue={kernelName:qC,backendName:"webgl",kernelFunc:fg},fue={kernelName:ra,backendName:"webgl",kernelFunc:function n(e){const{inputs:t,backend:r,attrs:s}=e,{x:o}=t,{dtype:A}=s;if(A==="complex64"){if(o.dtype==="complex64")return No({inputs:{x:o},backend:r});const u=Es(o.shape),h=n({inputs:{x:o},backend:r,attrs:{dtype:"float32"}}),l=Nu({inputs:{real:h,imag:u},backend:r});return u.dispose(),r.disposeIntermediateTensorInfo(h),l}if(o.dtype==="complex64"){const u=fg({inputs:{input:o},backend:r}),h=n({inputs:{x:u},backend:r,attrs:{dtype:A}});return r.disposeIntermediateTensorInfo(u),h}if(!nn(o.dtype,A)){const u=No({inputs:{x:o},backend:r});return{dataId:u.dataId,shape:u.shape,dtype:A}}if(A==="int32")return function(u,h){const l=new Su(u.shape,"return float(int(x));"),c=h.runWebGLProgram(l,[u],"int32");return{dataId:c.dataId,shape:c.shape,dtype:c.dtype}}(o,r);if(A==="bool"){const u=r.makeTensorInfo([],"bool",Oe("bool",1)),h=J6({inputs:{a:o,b:u},backend:r});return r.disposeIntermediateTensorInfo(u),h}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${A}`)}},$6="return ceil(x);",mue=Qn({opSnippet:$6,packedOpSnippet:$6,cpuKernelImpl:IAe}),gue={kernelName:Wr,backendName:"webgl",kernelFunc:mue};class yue{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}class bue{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}const vue={kernelName:xa,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{clipValueMin:o,clipValueMax:A}=r;let u;u=st().getBool("WEBGL_PACK_CLIP")?new bue(s.shape):new yue(s.shape);const h=[[o],[A]];return t.runWebGLProgram(u,[s],s.dtype,h)}};class xue{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}function _6(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}const wue={kernelName:$,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t}=n,{x:r}=e,s=t.texData.get(r.dataId),o=new xue(r.shape),A=[_6(r,s.complexTensorInfos.real),_6(r,s.complexTensorInfos.imag)];return t.runWebGLProgram(o,A,A[0].dtype)}};class kue{constructor(e){this.outputShape=[],this.outputShape=SA(e,1),this.variableNames=e.map((A,u)=>`T${u}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let A=1;A<t.length;A++)t[A]=t[A-1]+e[A][1];const r=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let A=1;A<t.length;A++){const u=t[A-1];r.push(`else if (yC < ${t[A]}) setOutput(getT${A}(yR, yC-${u}));`)}const s=t.length,o=t[t.length-1];r.push(`else setOutput(getT${s}(yR, yC-${o}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}}class Cue{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=SA(e,t);const r=this.outputShape,s=r.length,o=kr(s),A=Ha("coords",s),u=["x","y","z","w","u","v"].slice(0,s);this.variableNames=e.map((v,w)=>`T${w}`);const h=new Array(e.length-1);h[0]=e[0][t];for(let v=1;v<h.length;v++)h[v]=h[v-1]+e[v][t];const l=u[t],c=u.slice(-2),d=u.join();let m=`if (${l} < ${h[0]}) {
        return getChannel(
            getT0(${d}), vec2(${c.join()}));
        }`;for(let v=1;v<h.length;v++){const w=h[v-1];m+=`
        if (${l} < ${h[v]}  && ${l} >= ${h[v-1]}) {
          return getChannel(
            getT${v}(${o1(u,l,w)}),
            vec2(${o1(c,l,w)}));
        }`}const y=h.length,b=h[h.length-1];m+=`
        return getChannel(
          getT${y}(${o1(u,l,b)}),
          vec2(${o1(c,l,b)}));`,this.userCode=`
      float getValue(${u.map(v=>"int "+v)}) {
        ${m}
      }

      void main() {
        ${o} coords = getOutputCoords();
        vec4 result = vec4(getValue(${A}), 0., 0., 0.);

        ${A[s-1]} = ${A[s-1]} + 1;
        if (${A[s-1]} < ${r[s-1]}) {
          result.g = getValue(${A});
        }

        ${A[s-2]} = ${A[s-2]} + 1;
        if (${A[s-2]} < ${r[s-2]}) {
          result.a = getValue(${A});
        }

        ${A[s-1]} = ${A[s-1]} - 1;
        if (${A[s-2]} < ${r[s-2]} &&
            ${A[s-1]} < ${r[s-1]}) {
          result.b = getValue(${A});
        }
        setOutput(result);
      }
    `}}function o1(n,e,t){const r=n.indexOf(e);return n.map((s,o)=>o===r?`${s} - ${t}`:s).join()}function i1(n){const{inputs:e,backend:t}=n,{input:r}=e;return No({inputs:{x:t.texData.get(r.dataId).complexTensorInfos.imag},backend:t})}const Iue={kernelName:RC,backendName:"webgl",kernelFunc:i1};function $p(n,e,t){const r=n[0].dtype;if(r==="complex64"){const c=n.map(v=>fg({inputs:{input:v},backend:t})),d=n.map(v=>i1({inputs:{input:v},backend:t})),m=$p(c,e,t),y=$p(d,e,t),b=Nu({inputs:{real:m,imag:y},backend:t});return c.forEach(v=>t.disposeIntermediateTensorInfo(v)),d.forEach(v=>t.disposeIntermediateTensorInfo(v)),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),b}let s=t.shouldExecuteOnCPU(n);if(r==="string"&&(s=!0),s){const c=n.map(I=>{const S=Ye(I.shape.slice(e));return Gt({inputs:{x:I},backend:t,attrs:{shape:[-1,S]}})}),d=c.map(I=>({vals:t.readSync(I.dataId),shape:I.shape})),m=SA(c.map(I=>I.shape),1),y=c[0].shape[0]===1,b=SAe(d,m,r,y),v=SA(n.map(I=>I.shape),e),w=t.makeTensorInfo(v,r,b);return c.forEach(I=>t.disposeIntermediateTensorInfo(I)),w}if(n.length>st().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const c=Math.floor(n.length/2),d=$p(n.slice(0,c),e,t),m=$p(n.slice(c),e,t),y=$p([d,m],e,t);return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(m),y}if(st().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&n[0].shape.length>1){const c=new Cue(n.map(d=>d.shape),e);return t.runWebGLProgram(c,n,r)}const{tensors2D:o,outShape:A}=function(c,d,m){const y=SA(c.map(b=>b.shape),d);return{tensors2D:c.map(b=>Gt({inputs:{x:b},attrs:{shape:[-1,Ye(b.shape.slice(d))]},backend:m})),outShape:y}}(n,e,t),u=new kue(o.map(c=>c.shape)),h=t.runWebGLProgram(u,o,r);o.forEach(c=>t.disposeIntermediateTensorInfo(c));const l=Gt({inputs:{x:h},attrs:{shape:A},backend:t});return t.disposeIntermediateTensorInfo(h),l}function eR(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r,o=pt(s,e[0].shape)[0],A=SA(e.map(h=>h.shape),o);if(Ye(A)===0)return t.makeTensorInfo(A,e[0].dtype,[]);const u=e.filter(h=>Ye(h.shape)>0);return u.length===1?No({inputs:{x:u[0]},backend:t}):(bS(u.map(h=>h.shape),o),$p(u,o,t))}const Sue={kernelName:ne,backendName:"webgl",kernelFunc:eR};class tR{constructor(e,t=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const A=e.padInfo.top,u=e.padInfo.left,h=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,d=e.dilationWidth,m=e.filterHeight,y=e.filterWidth,b=4*Math.floor(e.inChannels/4),v=e.inChannels%4,w=e.dataFormat==="channelsLast",I=w?1:2,S=w?2:3,T=w?3:1;let D="",L="";r&&(D=s?`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:`
          float activation(float x) {
            ${r}
          }
        `,L="result = activation(result);");const W=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${D}

      const ivec2 strides = ivec2(${h}, ${l});
      const ivec2 pads = ivec2(${A}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${T}];

        ivec2 xRCCorner =
            ivec2(coords[${I}], coords[${S}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${m}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${y}; wC++) {
            int xC = xCCorner + wC * ${d};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${b}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${w}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${v===1}) {

              if (${w}) {
                dotProd +=
                    getX(batch, xR, xC, ${b}) *
                    getW(wR, wC, ${b}, d2);
              } else {
                dotProd +=
                    getX(batch, ${b}, xR, xC) *
                    getW(wR, wC, ${b}, d2);
              }

            } else if (${v===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${b}, d2),
                getW(wR, wC, ${b} + 1, d2)
              );

              if (${w}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${b}),
                  getX(batch, xR, xC, ${b} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${b}, xR, xC),
                  getX(batch, ${b} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${v===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${b}, d2),
                getW(wR, wC, ${b} + 1, d2),
                getW(wR, wC, ${b} + 2, d2)
              );

              if (${w}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${b}),
                  getX(batch, xR, xC, ${b} + 1),
                  getX(batch, xR, xC, ${b} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${b}, xR, xC),
                  getX(batch, ${b} + 1, xR, xC),
                  getX(batch, ${b} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${W}
        ${L}
        setOutput(result);
      }
    `}}class Nue{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,r=e.padInfo.top,s=e.padInfo.left,o=e.strideDepth,A=e.strideHeight,u=e.strideWidth,h=e.dilationDepth,l=e.dilationHeight,c=e.dilationWidth,d=e.filterDepth,m=e.filterHeight,y=e.filterWidth,b=4*Math.floor(e.inChannels/4),v=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${o}, ${A}, ${u});
      const ivec3 pads = ivec3(${t}, ${r}, ${s});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${d}; wF++) {
          int xF = xFCorner + wF * ${h};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${y}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${b}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${v===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${b}) *
                  getW(wF, wR, wC, ${b}, d2);
              } else if (${v===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${b}),
                  getX(batch, xF, xR, xC, ${b} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${b}, d2),
                  getW(wF, wR, wC, ${b} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${v===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${b}),
                  getX(batch, xF, xR, xC, ${b} + 1),
                  getX(batch, xF, xR, xC, ${b} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${b}, d2),
                  getW(wF, wR, wC, ${b} + 1, d2),
                  getW(wF, wR, wC, ${b} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Tue{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=ni(this.outputShape.length);const{dataFormat:r}=t,s=ja(),o=r==="channelsLast",A=o?0:1,u=o?1:2,h=this.enableShapeUniforms?"if(blockIndex < outShape[1] && pos < outShape[0]) {":`if(blockIndex < ${e[1]} && pos < ${e[0]}) {`;let l="";for(let c=0;c<=1;c++)for(let d=0;d<=1;d++)l+=`
          blockIndex = rc.y + ${d};
          pos = rc.x + ${c};

          ${h}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${A}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${u}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${o}) {
                  innerDims = vec2(d1, ch);
                  result[${2*c+d}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${2*c+d}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${s.output} = result;
      }
    `}}function nR({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:A=0,activation:u=null}){const h=n.shape,l=r.texData.get(n.dataId),c=t.inChannels,d=h[0]*h[1]*h[2],m=t.outChannels,y=t.dataFormat==="channelsLast",b=!1,v=!1;let w;const I=[];if((d!==1&&m!==1||!(c>1e3))&&l.isPacked&&y&&l.texture!=null&&h[2]%2!=0&&ht(l.shape.slice(-3),h.slice(-3))){const S=h[0]*h[1]*(h[2]+1),T={dataId:n.dataId,shape:[1,S,t.inChannels],dtype:n.dtype},D=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,J(Jx(l.shape,T.shape),()=>`packed reshape ${l.shape} to ${T.shape} isn't free`);const L=Gt({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}});I.push(L);const W=a1({a:T,b:L,backend:r,transposeA:b,transposeB:v,bias:s,activation:u,preluActivationWeights:o,leakyreluAlpha:A}),K=r.texData.get(W.dataId);J(K.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=D,K.shape=t.outShape,w=No({inputs:{x:W},backend:r}),w.shape=t.outShape,I.push(W)}else{const S=Gt({inputs:{x:n},backend:r,attrs:{shape:[1,y?h[0]*h[1]*h[2]:h[0]*h[2]*h[3],t.inChannels]}}),T=Gt({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}}),D=a1({a:S,b:T,transposeA:b,transposeB:v,backend:r,bias:s,activation:u,preluActivationWeights:o,leakyreluAlpha:A});w=Gt({inputs:{x:D},backend:r,attrs:{shape:t.outShape}}),I.push(S),I.push(T),I.push(D)}for(const S of I)r.disposeIntermediateTensorInfo(S);return w}function rR({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:A=0,activation:u=null}){const{filterWidth:h,filterHeight:l,inChannels:c,outWidth:d,outHeight:m,dataFormat:y}=t,b=y==="channelsLast",v=h*l*c,w=m*d,I=[v,w],S=[],T=Gt({inputs:{x:n},backend:r,attrs:{shape:n.shape.slice(1)}}),D=Gt({inputs:{x:e},backend:r,attrs:{shape:[1,v,Ye(e.shape)/v]}});S.push(T),S.push(D);const L=new Tue(I,t),W=[T.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],K=r.runWebGLProgram(L,[T],"float32",W),U=Gt({inputs:{x:K},backend:r,attrs:{shape:[1,I[0],I[1]]}});S.push(K),S.push(U);const _=s!=null,ee=o!=null,re=u==="leakyrelu",ce=u?n1(u,!0):null,we=new G6(U.shape,D.shape,[1,w,t.outChannels],!0,!1,_,ce,ee,re),Ee=[U,D];if(s&&Ee.push(s),ee&&Ee.push(o),re){const de=r.makeTensorInfo([],"float32",tu(A,"float32"));Ee.push(de),S.push(de)}const Pe=r.runWebGLProgram(we,Ee,"float32"),he=Gt({inputs:{x:Pe},backend:r,attrs:{shape:b?[1,m,d,t.outChannels]:[1,t.outChannels,m,d]}});S.push(Pe);for(const de of S)r.disposeIntermediateTensorInfo(de);return he}const Mue={kernelName:Ce,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o}=e,{strides:A,pad:u,dataFormat:h,dilations:l,dimRoundingMode:c}=r,d=cl(h),m=Vs(s.shape,o.shape,A,l,u,c,!1,d);let y;if(m.filterHeight!==1||m.filterWidth!==1||m.dilationHeight!==1||m.dilationWidth!==1||m.strideHeight!==1||m.strideWidth!==1||m.padInfo.type!=="SAME"&&m.padInfo.type!=="VALID")if(st().getBool("WEBGL_CONV_IM2COL")&&s.shape[0]===1)y=rR({x:s,filter:o,convInfo:m,backend:t});else{const v=new tR(m);y=t.runWebGLProgram(v,[s,o],"float32")}else y=nR({x:s,filter:o,convInfo:m,backend:t});const b=Gt({inputs:{x:y},backend:t,attrs:{shape:m.outShape}});return t.disposeIntermediateTensorInfo(y),b}};class Eue{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,o=e.padInfo.left,A=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              if (${A}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Due{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,s=e.strideHeight,o=e.strideWidth,A=e.dataFormat==="channelsLast",u=t-1-e.padInfo.top,h=r-1-e.padInfo.left,l=A?1:2,c=A?2:3,d=A?3:1;this.userCode=`
      const ivec2 pads = ivec2(${u}, ${h});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${d}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${A}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class zue{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,r=e.strideHeight,s=e.strideWidth,o=e.padInfo.front,A=e.padInfo.top,u=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${o};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${A};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${s} - ${u};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Oue{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,r=e.filterHeight,s=e.filterWidth,o=e.strideDepth,A=e.strideHeight,u=e.strideWidth,h=t-1-e.padInfo.front,l=r-1-e.padInfo.top,c=s-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${l}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${o}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${A}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${s}; wC++) {
              float dyC = float(dyCCorner + wC) / ${u}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${s} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}const Pue={kernelName:He,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:o}=e,{strides:A,pad:u,dataFormat:h,dimRoundingMode:l,filterShape:c}=r,d=cl(h),m=Vs(s.shape,c,A,1,u,l,!1,d),y=new Eue(m);return t.runWebGLProgram(y,[s,o],"float32")}},Bue={kernelName:_e,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:o}=e,{inputShape:A,strides:u,pad:h,dataFormat:l,dimRoundingMode:c}=r,d=cl(l),m=Vs(A,o.shape,u,1,h,c,!1,d),y=new Due(m);return t.runWebGLProgram(y,[s,o],"float32")}},Fue={kernelName:$e,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o}=e,{strides:A,pad:u,dilations:h}=r,l=Au(s.shape,o.shape,A,h,u),c=new Nue(l);return t.runWebGLProgram(c,[s,o],"float32")}},Lue={kernelName:xt,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:o}=e,{strides:A,pad:u,filterShape:h}=r,l=Au(s.shape,h,A,1,u),c=new zue(l);return t.runWebGLProgram(c,[s,o],"float32")}},Rue={kernelName:sn,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:o}=e,{pad:A,strides:u,inputShape:h}=r,l=Au(h,o.shape,u,1,A),c=new Oue(l);return t.runWebGLProgram(c,[s,o],"float32")}},Wue=Qn({opSnippet:H6+`
  return cos(x);
`}),jue={kernelName:Cn,backendName:"webgl",kernelFunc:Wue},Hue=Qn({opSnippet:`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`}),Gue={kernelName:ar,backendName:"webgl",kernelFunc:Hue};class Vue{constructor(e,t,r,s,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[A,u,h,l]=e,[c]=t,[d,m]=r;this.outputShape=[c,d,m,l];const y=s==="bilinear"?1:0,[b,v]=[u-1+".0",h-1+".0"],[w,I,S]=d>1?[""+(u-1)/(d-1),"(y2-y1) * height_ratio",`y1*${b} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${b}`],[T,D,L]=m>1?[""+(h-1)/(m-1),"(x2-x1) * width_ratio",`x1*${v} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${v}`];this.userCode=`
      const float height_ratio = float(${w});
      const float width_ratio = float(${T});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${A}) {
          return;
        }

        float height_scale = ${I};
        float width_scale = ${D};

        float in_y = ${S};
        if( in_y < 0.0 || in_y > ${b} ) {
          setOutput(float(${o}));
          return;
        }
        float in_x = ${L};
        if( in_x < 0.0 || in_x > ${v} ) {
          setOutput(float(${o}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${y} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}const Xue={kernelName:Ja,backendName:"webgl",kernelFunc:n=>{const{inputs:e,backend:t,attrs:r}=n,{image:s,boxes:o,boxInd:A}=e,{cropSize:u,method:h,extrapolationValue:l}=r,c=new Vue(s.shape,o.shape,u,h,l);return t.runWebGLProgram(c,[s,o,A],"float32")}};class sR{constructor(e,t,r){this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}],this.outputShape=e;const s=e.length,o=t?"0.0":`getX(${aR(s,"coords")})`,A=e[e.length-1];let u="",h="";t?(u=r?"end != "+(A-1):"end != 0",h=r?"end + 1":"end - 1"):(u=r?`end + pow2 < ${A}`:"end >= pow2",h=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${kr(s)} coords = getOutputCoords();
        int end = ${oR(s,"coords")};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${h};
          ${oR(s,"coords")} = idx;
          val += getX(${aR(s,"coords")});
        }
        setOutput(val);
      }
    `}}function aR(n,e){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative sum for rank ${n} is not yet supported`)}function oR(n,e){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw Error(`Cumulative sum for rank ${n} is not yet supported`)}const Zue={kernelName:Jn,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,exclusive:A,reverse:u}=r,h=s.shape.length,l=cs([o],h);let c=s;l!=null&&(c=Ga({inputs:{x:s},backend:t,attrs:{perm:l}}));const d=bs(1,h)[0];if(d!==h-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${s.shape.length-1} but got axis=${o}`);const m=c.shape[d];let y=No({inputs:{x:c},backend:t});for(let b=0;b<=Math.ceil(Math.log2(m))-1;b++){const v=new sR(c.shape,!1,u),w=[[b]],I=y;y=t.runWebGLProgram(v,[y],y.dtype,w),t.disposeIntermediateTensorInfo(I)}if(A){const b=new sR(c.shape,A,u),v=y;y=t.runWebGLProgram(b,[y],y.dtype),t.disposeIntermediateTensorInfo(v)}if(l!=null){const b=Ga({inputs:{x:y},backend:t,attrs:{perm:Np(l)}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(c),b}return y}},Yue={kernelName:xo,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:o}=e,{size:A,binaryOutput:u}=r;if(s.shape.length===1){const h=t.readSync(s.dataId),l=t.readSync(o.dataId),c=N6(h,l,o.dtype,o.shape,A);return t.makeTensorInfo([A],o.dtype,c)}if(s.shape.length===2){const h=t.bufferSync(s),l=t.bufferSync(o),c=CAe(h,l,A,u);return t.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class Uue{constructor(e,t,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const Que={kernelName:Zo,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockSize:o,dataFormat:A}=r;J(o>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${o}`);const u=s.shape[0],h=A==="NHWC"?s.shape[1]:s.shape[2],l=A==="NHWC"?s.shape[2]:s.shape[3],c=A==="NHWC"?s.shape[3]:s.shape[1],d=h*o,m=l*o,y=c/(o*o),b=new Uue(A==="NHWC"?[u,d,m,y]:[u,y,d,m],o,A);return t.runWebGLProgram(b,[s],s.dtype)}};class iR{constructor(e,t=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ni(this.outputShape.length);const A=e.filterHeight,u=e.filterWidth,h=e.outChannels/e.inChannels;let l="",c="";r&&(l=s?`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:`
          float activation(float x) {
            ${r}
          }
        `,c="result = activation(result);");const d=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${h};
        int q = d2 - d1 * ${h};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${A}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${u}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${d}
        ${c}
        setOutput(result);
      }
    `}}class AR{constructor(e,t=!1,r=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ni(this.outputShape.length);const A=e.outChannels/e.inChannels,u=e.padInfo.left,h=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,d=e.filterWidth,m=d;let y=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let I=0;I<d;I++)y+=`
          vec4 xTexelC${2*I};
          int xTexelC${2*I}Ready;
          vec4 xTexelC${2*I+1};
          int xTexelC${2*I+1}Ready;
          vec4 xC${I};`;for(let I=0;I<c;I++){for(let S=0;S<d;S++)y+=`
          xTexelC${2*S} = vec4(0.0);
          xTexelC${2*S}Ready = 0;
          xTexelC${2*S+1} = vec4(0.0);
          xTexelC${2*S+1}Ready = 0;
          xC${S} = vec4(0.0);`;y+=`
        xR = xRCorner + ${I} * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let S=0;S<(m+1)/2;S++){const T=2*S;if(y+=`
          xC = xCCorner + ${T*l};
          `,h===1){if(T<d&&(u%2==1?(y+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }
              `,y+=l===1&&T>0?`
                xC${T} = vec4(xTexelC${T-2}.zw, xTexelC${T}.xy);
                `:`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${T} = vec4(previous.zw, xTexelC${T}.xy);
                  } else {
                    xC${T} = vec4(0.0, 0.0, xTexelC${T}.xy);
                  }
                  `):y+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                xC${T} = xTexelC${T};
                `,T+1<d)){const D=u%2==0?Tn(l):l;l%2==0&&u%2==1||l%2!=0&&u%2!=1?(y+=`
                  xCOffset = xC + imod(pads[1], 2) + ${D};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                    xTexelC${T+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${T+1}.zw = vec2(0.0);
                    }
                    xTexelC${T+1}Ready = 1;
                  }
                  `,l>1&&(y+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T}Ready == 0) {
                      xTexelC${T} = getX(batch, xR, xCOffset, d1);
                      xTexelC${T}Ready = 1;
                    }
                    `),y+=`
                  xC${T+1} = vec4(xTexelC${T}.zw, xTexelC${T+1}.xy);
                  `):y+=D===1?`
                    xC${T+1} = xTexelC${T};
                    `:`
                    xCOffset = xC + ${D};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                      xTexelC${T+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${T+1}.zw = vec2(0.0);
                      }
                      xTexelC${T+1}Ready = 1;
                    }

                    xC${T+1} = xTexelC${T+1};
                    `}}else T<d&&(u%2==1?(y+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${T+1}Ready == 0) {
                  xTexelC${T+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${T+1}.zw = vec2(0.0);
                  }
                  xTexelC${T+1}Ready = 1;
                }

                xC${T} = vec4(xTexelC${T}.zw, xTexelC${T+1}.zw);
              `,T+1<d&&(y+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${T+1} = vec4(xTexelC${T+1}.xy, final.xy);
                `)):(y+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                  xTexelC${T+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T+1}.zw = vec2(0.);
                  }
                  xTexelC${T+1}Ready = 1;
                }

                xC${T} = vec4(
                  xTexelC${T}.xy, xTexelC${T+1}.xy);
              `,T+1<d&&(y+=`
                  xC${T+1} = vec4(xTexelC${T}.zw, xTexelC${T+1}.zw);
                `)));T<d&&(y+=`
            wTexel = getW(${I}, ${T}, d1, q);
            dotProd += xC${T} * vec4(wTexel.xz, wTexel.xz);
          `,T+1<d&&(y+=`
              wTexel = getW(${I}, ${T+1}, d1, q);
              dotProd += xC${T+1} * vec4(wTexel.xz, wTexel.xz);
            `))}y+=`
        }
      `}let b="",v="";r&&(b=s?`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:o?`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:`vec4 activation(vec4 x) {
          ${r}
        }`,v="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${b}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${A};
        int q = d2 - d1 * ${A};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${y}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${w}
        ${v}
        setOutput(result);
      }
    `}}const Kue={kernelName:xA,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o}=e,{strides:A,pad:u,dilations:h,dimRoundingMode:l}=r;let c=h;c==null&&(c=[1,1]),J(oa(A,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${A} and dilations '${c}'`);const d=Vs(s.shape,o.shape,A,c,u,l,!0);let m;m=st().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels==1?new AR(d):new iR(d);const y=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return t.runWebGLProgram(m,[s,o],"float32",y)}};class que{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,o=e.padInfo.left,A=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${A} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Jue{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,s=e.strideHeight,o=e.strideWidth,A=t-1-e.padInfo.top,u=r-1-e.padInfo.left,h=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${A}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${h}; dm++) {
              int d2 = d1 * ${h} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}const $ue={kernelName:Vi,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:o}=e,{strides:A,dilations:u,pad:h,dimRoundingMode:l,filterShape:c}=r,d=Vs(s.shape,c,A,u,h,l,!0),m=new que(d);return t.runWebGLProgram(m,[s,o],"float32")}},_ue={kernelName:sa,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:o}=e,{strides:A,dilations:u,pad:h,dimRoundingMode:l,inputShape:c}=r,d=Vs(c,o.shape,A,u,h,l,!0),m=new Jue(d);return t.runWebGLProgram(m,[s,o],"float32")}};class ece{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}const tce={kernelName:wA,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t}=n,{x:r}=e,s=[...r.shape,...r.shape],o=Ye(r.shape),A=Gt({inputs:{x:r},backend:t,attrs:{shape:[o]}}),u=new ece(o),h=t.runWebGLProgram(u,[A],A.dtype),l=Gt({inputs:{x:h},backend:t,attrs:{shape:s}});return t.disposeIntermediateTensorInfo(A),t.disposeIntermediateTensorInfo(h),l}};class nce{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:r,padInfo:s,strideHeight:o,strideWidth:A,filterHeight:u,filterWidth:h,dilationHeight:l,dilationWidth:c}=e,{top:d,left:m}=s;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${A});
      const ivec2 pads = ivec2(${d}, ${m});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${u}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${h}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}const rce={kernelName:wo,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o}=e,{strides:A,pad:u,dilations:h}=r,l=Sm(s.shape,o.shape,A,u,"NHWC",h);let c;const d=new nce(l);c=t.runWebGLProgram(d,[s,o],"float32");const m=Gt({inputs:{x:c},backend:t,attrs:{shape:l.outShape}});return t.disposeIntermediateTensorInfo(c),m}},sce={kernelName:_l,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{equation:s}=r,o=e,{allDims:A,summedDims:u,idDims:h}=OS(s,o.length);BS(A.length,h,o);const{path:l,steps:c}=FS(u,h),d=c.length;let m=null,y=A.length;const b=[];for(let v=0;v<d;++v){for(const w of c[v]){const{permutationIndices:I,expandDims:S}=PS(y,h[w]);let T;LS(I)?T=o[w]:(T=Ga({inputs:{x:o[w]},backend:t,attrs:{perm:I}}),b.push(T));const D=T.shape.slice();for(let L=0;L<S.length;++L)D.splice(S[L],0,1);ht(T.shape,D)||(T=Gt({inputs:{x:T},backend:t,attrs:{shape:D}}),b.push(T)),m===null?m=T:(m=yN({inputs:{a:T,b:m},backend:t}),b.push(m))}v<d-1&&(l[v]>=0&&(m=s1({inputs:{x:m},backend:t,attrs:{axis:l[v]-(A.length-y),keepDims:!1}}),b.push(m)),y--)}for(const v of b)v!==m&&t.disposeIntermediateTensorInfo(v);return m}},ace=Qn({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`}),oce={kernelName:Yo,backendName:"webgl",kernelFunc:ace},ice={kernelName:zC,backendName:"webgl",kernelFunc:n=>{const{inputs:e,backend:t}=n,{dy:r,y:s}=e,o=st().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new pg(`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,r.shape,s.shape):new qp("return (b >= 1.0) ? a : a * (b + 1.0);",r.shape,s.shape);return t.runWebGLProgram(o,[r,s],r.dtype)}},Ace=la({opSnippet:"return float(a == b);",packedOpSnippet:`
  return vec4(equal(a, b));
`,dtype:"bool",cpuKernelImpl:NAe}),lce={kernelName:H0,backendName:"webgl",kernelFunc:Ace},uce=Qn({opSnippet:`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${IS};
  float a1 = ${SS};
  float a2 = ${NS};
  float a3 = ${TS};
  float a4 = ${MS};
  float a5 = ${ES};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`}),cce={kernelName:Hf,backendName:"webgl",kernelFunc:uce},lR="return exp(x);",uR=Qn({opSnippet:lR,packedOpSnippet:lR,cpuKernelImpl:TAe}),dce={kernelName:Gf,backendName:"webgl",kernelFunc:uR};function xN(n){const{inputs:e,attrs:t,backend:r}=n,{dim:s}=t,{input:o}=e,A=o.shape.length,u=o.shape.slice();let h=s;return s<0&&(J(-(A+1)<=s,()=>`Axis must be in the interval [${-(A+1)}, ${A}]`),h=A+s+1),u.splice(h,0,1),Gt({inputs:{x:o},backend:r,attrs:{shape:u}})}const pce={kernelName:G0,backendName:"webgl",kernelFunc:xN},cR="return exp(x) - 1.0;",hce=Qn({opSnippet:cR,packedOpSnippet:cR,cpuKernelImpl:MAe}),fce={kernelName:Vf,backendName:"webgl",kernelFunc:hce};class dR{constructor(e,t,r){this.variableNames=["real","imag"];const s=t[1];this.outputShape=t;const o=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,A=r?`${s}.0`:"1.0";let u;if(e==="real")u="return real * expR - imag * expI;";else{if(e!=="imag")throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);u="return real * expI + imag * expR;"}this.userCode=`
      const float exponentMultiplier = ${o};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${u}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${s});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${s}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${A};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}function pR(n,e,t){const r=t.texData.get(n.dataId),s=Ye(n.shape),o=n.shape[n.shape.length-1],A=Gt({inputs:{x:n},backend:t,attrs:{shape:[s/o,o]}}),u=A.shape,h=new dR("real",u,e),l=new dR("imag",u,e),c=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:u},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:u}],d=t.runWebGLProgram(h,c,"float32"),m=t.runWebGLProgram(l,c,"float32"),y=Nu({inputs:{real:d,imag:m},backend:t});t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(m);const b=Gt({inputs:{x:y},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(A),t.disposeIntermediateTensorInfo(y),b}const mce={kernelName:OC,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t}=n,{input:r}=e;return pR(r,!1,t)}};class gce{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}function mg(n){const{backend:e,attrs:t}=n,{shape:r,value:s}=t;let{dtype:o}=t;if(o=o||kt(s),o==="string"){const A=Tt(o,Ye(r));return A.fill(s),e.makeTensorInfo(r,o,A)}{const A=new gce(r,s),u=[[s]];return e.runWebGLProgram(A,[],o,u)}}const yce={kernelName:PC,backendName:"webgl",kernelFunc:mg};class bce{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const vce={kernelName:BC,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,r=e,s=new bce(t.shape);return r.runWebGLProgram(s,[t],t.dtype)}},hR="return floor(x);",xce=Qn({opSnippet:hR,packedOpSnippet:hR,cpuKernelImpl:EAe}),wce={kernelName:Xf,backendName:"webgl",kernelFunc:xce},kce=la({opSnippet:`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,packedOpSnippet:`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,dtype:"int32"}),Cce={kernelName:Zf,backendName:"webgl",kernelFunc:kce};class Ice{constructor(e){this.variableNames=["A"];const t=ja(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class Sce{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=ja(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${s}.0, ${r}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}const Nce={kernelName:pI,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n;let{pixels:s}=e;const{numChannels:o}=r,A=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,u=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[h,l]=A?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[l,h],d=[l,h,o];(u||A)&&(_p==null&&(_p=document.createElement("canvas").getContext("2d")),_p.canvas.width=h,_p.canvas.height=l,_p.drawImage(s,0,0,h,l),s=_p.canvas);const m=t.makeTensorInfo(c,"int32");t.texData.get(m.dataId).usage=ti.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(m.dataId),s);const y=st().getBool("WEBGL_PACK")?new Sce(d):new Ice(d),b=t.runWebGLProgram(y,[m],"int32");return t.disposeData(m.dataId),b}};let _p;const Tce={kernelName:Nv,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o,bias:A,preluActivationWeights:u}=e,{strides:h,pad:l,dataFormat:c,dilations:d,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=r,v=cl(c),w=Vs(s.shape,o.shape,h,d,l,m,!1,v);let I;const S=[];if(w.filterHeight!==1||w.filterWidth!==1||w.dilationHeight!==1||w.dilationWidth!==1||w.strideHeight!==1||w.strideWidth!==1||w.padInfo.type!=="SAME"&&w.padInfo.type!=="VALID")if(st().getBool("WEBGL_CONV_IM2COL")&&s.shape[0]===1)I=rR({x:s,filter:o,convInfo:w,backend:t,bias:A,activation:y,preluActivationWeights:u,leakyreluAlpha:b});else{const D=A!=null,L=u!=null,W=y==="leakyrelu",K=y?n1(y,!1):null,U=new tR(w,D,K,L,W),_=[s,o];if(A&&_.push(A),u&&_.push(u),W){const ee=t.makeTensorInfo([],"float32",tu(b,"float32"));_.push(ee),S.push(ee)}I=t.runWebGLProgram(U,_,"float32")}else I=nR({x:s,filter:o,convInfo:w,backend:t,bias:A,activation:y,preluActivationWeights:u,leakyreluAlpha:b});const T=Gt({inputs:{x:I},backend:t,attrs:{shape:w.outShape}});return S.push(I),S.forEach(D=>t.disposeIntermediateTensorInfo(D)),T}},Mce={kernelName:Tv,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o,bias:A,preluActivationWeights:u}=e,{strides:h,pad:l,dilations:c,dimRoundingMode:d,activation:m,leakyreluAlpha:y}=r,b=[];let v=c;v==null&&(v=[1,1]),J(oa(h,v),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${h} and dilations '${v}'`);const w=Vs(s.shape,o.shape,h,v,l,d,!0),I=st().getBool("WEBGL_PACK_DEPTHWISECONV")&&w.strideWidth<=2&&w.outChannels/w.inChannels==1,S=m?n1(m,I):null,T=[s,o],D=A!=null,L=u!=null,W=m==="leakyrelu";if(D&&T.push(A),L&&T.push(u),W){const ee=t.makeTensorInfo([],"float32",tu(y,"float32"));T.push(ee),b.push(ee)}let K;K=I?new AR(w,D,S,L,W):new iR(w,D,S,L,W);const U=[[w.padInfo.top,w.padInfo.left],[w.strideHeight,w.strideWidth],[w.dilationHeight,w.dilationWidth],[w.inHeight,w.inWidth]],_=t.runWebGLProgram(K,T,"float32",U);return b.forEach(ee=>t.disposeIntermediateTensorInfo(ee)),_}};class Ece{constructor(e,t,r){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=r;const s=kr(t.length),o=kr(r.length),A=this.sliceDim>1?"strides[j]":"strides";this.userCode=`
        ${s} strides = ${s}(${this.strides});
         void main() {
          ${o} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${A};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `}}const Dce={kernelName:FC,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t}=n,{params:r,indices:s}=e,o=s.shape,A=o[o.length-1],u=Ye(r.shape),[h,l,c,d]=CS(r,s),m=Gt({inputs:{x:s},backend:t,attrs:{shape:[l,A]}}),y=Gt({inputs:{x:r},backend:t,attrs:{shape:[Ye(r.shape)/c,c]}});if(t.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const I=t.readSync(s.dataId),S=t.bufferSync(r),T=DAe(I,S,r.dtype,l,A,c,d,r.shape,u);return t.makeTensorInfo(h,r.dtype,T.values)}const b=new Ece(A,d,[l,c]),v=t.runWebGLProgram(b,[y,m],y.dtype),w=Gt({inputs:{x:v},backend:t,attrs:{shape:h}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(v),w}};class zce{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const r=kr(this.rank),s=function(o){const A=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[];for(let h=0;h<o.length;h++)h===2?u.push("int(getIndices(resRC.x, resRC.z))"):u.push(`${A[h]}`);return u.join()}(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}}function fR(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,indices:o}=e,{axis:A,batchDims:u}=r,h=WS(s,o,pt(A,s.shape)[0],u),l=Ye(o.shape),c=[],d=Gt({inputs:{x:s},backend:t,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),m=Gt({inputs:{x:o},backend:t,attrs:{shape:[h.batchSize,l/h.batchSize]}});c.push(d),c.push(m);const y=[h.batchSize,h.outerSize,l/h.batchSize,h.sliceSize];if(t.shouldExecuteOnCPU([s,o])||s.dtype==="string"){const I=t.bufferSync(m),S=t.bufferSync(d),T=zAe(S,I,y);return c.forEach(D=>t.disposeIntermediateTensorInfo(D)),t.makeTensorInfo(h.outputShape,T.dtype,T.values)}const b=new zce(d.shape,y),v=t.runWebGLProgram(b,[d,m],d.dtype);c.push(v);const w=Gt({inputs:{x:v},backend:t,attrs:{shape:h.outputShape}});return c.forEach(I=>t.disposeIntermediateTensorInfo(I)),w}const Oce={kernelName:X0,backendName:"webgl",kernelFunc:fR},Pce=la({opSnippet:"return float(a > b);",packedOpSnippet:`
  return vec4(greaterThan(a, b));
`,cpuKernelImpl:OAe,dtype:"bool"}),Bce={kernelName:Z0,backendName:"webgl",kernelFunc:Pce},Fce=la({opSnippet:"return float(a >= b);",packedOpSnippet:`
  return vec4(greaterThanEqual(a, b));
`,dtype:"bool",cpuKernelImpl:PAe}),Lce={kernelName:Yf,backendName:"webgl",kernelFunc:Fce},Rce={kernelName:LC,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t}=n,{input:r}=e;return pR(r,!0,t)}},Wce=Qn({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),jce={kernelName:Qf,backendName:"webgl",kernelFunc:Wce},Hce=Qn({opSnippet:"return float(isinf(x));",dtype:"bool"}),Gce={kernelName:Kf,backendName:"webgl",kernelFunc:Hce},Vce=Qn({opSnippet:"return float(isnan(x));",dtype:"bool"}),Xce={kernelName:qf,backendName:"webgl",kernelFunc:Vce},Zce=la({opSnippet:"return float(a < b);",packedOpSnippet:`
  return vec4(lessThan(a, b));
`,cpuKernelImpl:BAe,dtype:"bool"}),Yce={kernelName:U0,backendName:"webgl",kernelFunc:Zce},Uce=la({opSnippet:"return float(a <= b);",packedOpSnippet:`
  return vec4(lessThanEqual(a, b));
`,cpuKernelImpl:FAe,dtype:"bool"}),Qce={kernelName:Q0,backendName:"webgl",kernelFunc:Uce},Kce={kernelName:WC,backendName:"webgl",kernelFunc:function(n){const{backend:e,attrs:t}=n,{start:r,stop:s,num:o}=t,A=LAe(r,s,o);return e.makeTensorInfo([A.length],"float32",A)}},qce=Qn({opSnippet:`if (x < 0.0) return NAN;
  return log(x);`,packedOpSnippet:`
  vec4 result = log(x);
  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));
  result.r = isNaN.r == 1.0 ? NAN : result.r;
  result.g = isNaN.g == 1.0 ? NAN : result.g;
  result.b = isNaN.b == 1.0 ? NAN : result.b;
  result.a = isNaN.a == 1.0 ? NAN : result.a;

  return result;
`,cpuKernelImpl:RAe}),Jce={kernelName:Jf,backendName:"webgl",kernelFunc:qce},$ce=Qn({opSnippet:"return log(1.0 + x);"}),_ce={kernelName:$f,backendName:"webgl",kernelFunc:$ce},ede=la({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,dtype:"bool"}),tde={kernelName:K0,backendName:"webgl",kernelFunc:ede},nde=Qn({opSnippet:"return float(!(x >= 1.0));"}),rde={kernelName:q0,backendName:"webgl",kernelFunc:nde},sde=la({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,dtype:"bool"}),ade={kernelName:J0,backendName:"webgl",kernelFunc:sde};class ode{constructor(e,t,r,s,o){this.variableNames=["x"],this.outputShape=[];const A=t,u=e[3]-1;let h;this.outputShape=e;const l=`float(${r}) + float(${s}) * sum`;h=o===.5?`inversesqrt(${l})`:o===1?`1.0/(${l})`:`exp(log(${l}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${A}; j <= ${A}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${u}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${h};
        setOutput(val);
      }
    `}}class ide{constructor(e,t,r,s,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const A=t,u=e[3]-1;let h;this.outputShape=e;const l=`float(${r}) + float(${s}) * sum`;h=o===.5?`inversesqrt(${l})`:o===1?`1.0/(${l})`:`exp(log(${l}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${A};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${A}; j <= ${A}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${u}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${h};
        setOutput(result);
      }
    `}}const Ade={kernelName:$0,backendName:"webgl",kernelFunc:n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{depthRadius:o,bias:A,alpha:u,beta:h}=r,l=st().getBool("WEBGL_PACK_NORMALIZATION")?new ide(s.shape,o,A,u,h):new ode(s.shape,o,A,u,h);return t.runWebGLProgram(l,[s],s.dtype)}};class lde{constructor(e,t,r,s,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=r,this.alpha=s,this.beta=o,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${s}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${s})
                * float(${o})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${o});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}const ude={kernelName:jC,backendName:"webgl",kernelFunc:n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s,y:o,dy:A}=e,{depthRadius:u,bias:h,alpha:l,beta:c}=r,d=new lde(s.shape,u,h,l,c);return t.runWebGLProgram(d,[s,o,A],s.dtype)}};function mR(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reductionIndices:o,keepDims:A}=r,u=s.shape.length,h=pt(o,s.shape);let l=h;const c=cs(l,u),d=c!=null,m=t.shouldExecuteOnCPU([s]);let y=s;if(d){if(m){const S=t.texData.get(y.dataId).values,T=new Array(u);for(let L=0;L<T.length;L++)T[L]=s.shape[c[L]];const D=mN(S,s.shape,s.dtype,c,T);y=t.makeTensorInfo(T,s.dtype),t.texData.get(y.dataId).values=D}else y=r1(s,c,t);l=bs(l.length,u)}ia("max",l,u);const[b,v]=Xs(y.shape,l);let w,I=b;if(A&&(I=us(b,h)),m){const S=t.texData.get(y.dataId).values,T=WAe(S,Ye(v),I,s.dtype);w=t.makeTensorInfo(I,s.dtype),t.texData.get(w.dataId).values=T}else w=function(S,T,D,L){const W=Ye(T),K=Gt({inputs:{x:S},attrs:{shape:[Ye(S.shape)/W,W]},backend:L}),U=Jc(K,S.dtype,"max",L),_=Gt({inputs:{x:U},attrs:{shape:D},backend:L});return L.disposeIntermediateTensorInfo(K),L.disposeIntermediateTensorInfo(U),_}(y,v,I,t);return d&&t.disposeIntermediateTensorInfo(y),w}const cde={kernelName:_0,backendName:"webgl",kernelFunc:mR},dde=la({opSnippet:F6+`
  return max(a, b);
`,packedOpSnippet:`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+t1+`
  return result;
`,cpuKernelImpl:jAe}),pde={kernelName:_f,backendName:"webgl",kernelFunc:dde},hde={kernelName:ev,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;cg(s,"maxPool");const{filterSize:o,strides:A,pad:u,dimRoundingMode:h}=r;J(oa(A,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${A} and dilations '1'`);const l=bi(s.shape,o,A,1,u,h);if(l.filterWidth===1&&l.filterHeight===1&&ht(l.inShape,l.outShape))return No({inputs:{x:s},backend:t});const c=new hg(l,"max",!1);return t.runWebGLProgram(c,[s],s.dtype)}},fde={kernelName:tv,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:o,strides:A,pad:u,dataFormat:h,dimRoundingMode:l}=r,c=ul(s.shape,o,A,[1,1,1],u,l,h),d=new bN(c,"max",!1);return t.runWebGLProgram(d,[s],s.dtype)}};class mde{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,r=e.strideWidth,s=e.dilationHeight,o=e.effectiveFilterHeight,A=e.effectiveFilterWidth,u=o-1-e.padInfo.top,h=A-1-e.padInfo.left,l=o*A-1;this.userCode=`
      const ivec2 pads = ivec2(${u}, ${h});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
          wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${A}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${A} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class gde{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,r=e.strideHeight,s=e.strideWidth,o=e.dilationDepth,A=e.dilationHeight,u=e.dilationWidth,h=e.effectiveFilterDepth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,d=h-1-e.padInfo.front,m=l-1-e.padInfo.top,y=c-1-e.padInfo.left,b=h*l*c-1;this.userCode=`
      const ivec3 pads = ivec3(${d}, ${m}, ${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
           wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${A}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${s}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${b} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}const yde={kernelName:GC,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:o}=e,A=o,{filterSize:u,strides:h,pad:l,dimRoundingMode:c}=r,d=ul(A.shape,u,h,[1,1,1],l,c),m=new bN(d,"max",!0),y=t.runWebGLProgram(m,[A],A.dtype),b=new gde(d),v=t.runWebGLProgram(b,[s,y],A.dtype);return t.disposeIntermediateTensorInfo(y),v}},bde={kernelName:HC,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:o,output:A}=e,u=o;cg([o,A],"maxPoolGrad");const{filterSize:h,strides:l,pad:c,dimRoundingMode:d}=r,m=bi(u.shape,h,l,1,c,d),y=new hg(m,"max",!0),b=t.runWebGLProgram(y,[u],u.dtype),v=new mde(m),w=t.runWebGLProgram(v,[s,b],u.dtype);return t.disposeIntermediateTensorInfo(b),w}},vde={kernelName:VC,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{filterSize:s,strides:o,pad:A,includeBatchInIndex:u}=e,h=t;J(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const l=[1,1];J(oa(o,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const c=bi(r.shape,s,o,l,A),[d,m]=function(y,b,v,w){let I=new hg(v,"max",!1);const S=w.runWebGLProgram(I,[y],"float32");return I=new hg(v,"max",!0,!0,b),[S,w.runWebGLProgram(I,[y],"float32")]}(r,u,c,h);return[d,m]}},xde={kernelName:nv,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{keepDims:s,axis:o}=e,A=t,u=r.shape.length,h=pt(o,r.shape);let l=h;const c=cs(l,u),d=c!=null,m=A.shouldExecuteOnCPU([r]),y=[];let b=r;if(d){if(m){const T=A.texData.get(b.dataId).values,D=new Array(u);for(let W=0;W<D.length;W++)D[W]=r.shape[c[W]];const L=mN(T,r.shape,r.dtype,c,D);b=A.makeTensorInfo(D,r.dtype),A.texData.get(b.dataId).values=L}else b=r1(r,c,A);y.push(b),l=bs(l.length,u)}ia("sum",l,u);const[v,w]=Xs(b.shape,l);let I=v;s&&(I=us(v,h));const S=function(T,D,L,W){const K=Ye(D),U=Gt({inputs:{x:T},attrs:{shape:[Ye(T.shape)/K,K]},backend:W}),_=Jc(U,"float32","mean",W),ee=Gt({inputs:{x:_},attrs:{shape:L},backend:W});return W.disposeIntermediateTensorInfo(U),W.disposeIntermediateTensorInfo(_),ee}(b,w,I,A);for(const T of y)A.disposeIntermediateTensorInfo(T);return S}},wde={kernelName:rv,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:A}=r,u=s.shape.length,h=pt(o,s.shape);let l=h;const c=cs(l,u);let d=s;c!=null&&(d=Ga({inputs:{x:s},backend:t,attrs:{perm:c}}),l=bs(l.length,s.shape.length)),ia("min",l,u);const[m,y]=Xs(d.shape,l),b=Gt({inputs:{x:d},backend:t,attrs:{shape:[-1,Ye(y)]}}),v=Jc(b,b.dtype,"min",t);let w;return w=Gt(A?{inputs:{x:v},backend:t,attrs:{shape:us(m,h)}}:{inputs:{x:v},backend:t,attrs:{shape:m}}),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(v),c!=null&&t.disposeIntermediateTensorInfo(d),w}},kde=la({opSnippet:F6+`
  return min(a, b);
`,packedOpSnippet:`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+t1+`
  return result;
`,cpuKernelImpl:HAe}),Cde={kernelName:em,backendName:"webgl",kernelFunc:kde};class Ide{constructor(e,t,r){this.variableNames=["x"],this.outputShape=t.map((c,d)=>c[0]+e[d]+c[1]);const s=e.length,o=kr(s),A=t.map(c=>c[0]).join(","),u=t.map((c,d)=>c[0]+e[d]).join(","),h=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),l=r==="reflect"?0:1;this.userCode=s!==1?`
      ${o} start = ${o}(${A});
      ${o} end = ${o}(${u});

      void main() {
        ${o} outC = getOutputCoords();
        for (int i = 0; i < ${s}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${o} coords = outC - start;
        setOutput(getX(${h}));
      }
    `:`
        int start = ${A};
        int end = ${u};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `}}class Sde{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((b,v)=>b[0]+e[v]+b[1]);const s=e.length,o=kr(s),A=t.map(b=>b[0]).join(","),u=t.map((b,v)=>b[0]+e[v]).join(","),h=Ha("rc",s),l=Ha("source",s),c=`${h[s-1]} < ${this.outputShape[s-1]}`,d=s===1?"source":`vec2(${l.slice(-2).join()})`,m=r==="reflect"?0:1;let y="";if(s===1){const b=`
        ${o} source = rc;
        if (source < start) {
          source = start * 2 - source - ${m};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${m};
        }
        source -= start;
      `;y=`
        ${o} rc = outputLoc;
        ${b}
        result[0] = getChannel(getX(${l.join()}), ${d});
        ${h[s-1]} += 1;
        if(${c}) {
          ${b}
          result[1] = getChannel(getX(${l.join()}), ${d});
        }
      `}else{const b=`
        ${o} source = rc;
        ${o} lt = ${o}(lessThan(source, start));
        ${o} gte = ${o}(greaterThanEqual(source, end));
        ${o} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${m}) +
                gte * ((end - 1) * 2 - source + ${m});
        source -= start;
      `;y=`
        ${o} rc = outputLoc;
        ${b}
        result[0] = getChannel(getX(${l.join()}), ${d});
        ${h[s-1]} += 1;
        if(${c}) {
          ${b}
          result[1] = getChannel(getX(${l.join()}), ${d});
        }
        rc = outputLoc;
        ${h[s-2]} += 1;
        if(${h[s-2]} < ${this.outputShape[s-2]}) {
          ${b}
          result[2] = getChannel(getX(${l.join()}), ${d});
          ${h[s-1]} += 1;
          if(${c}) {
            ${b}
            result[3] = getChannel(getX(${l.join()}), ${d});
          }
        }
      `}this.userCode=`
      const ${o} start = ${o}(${A});
      const ${o} end = ${o}(${u});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${y}
        setOutput(result);
      }
    `}}const Nde={kernelName:sv,backendName:"webgl",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:r}=n,{paddings:s,mode:o}=t,A=st().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Sde(r.shape,s,o):new Ide(r.shape,s,o);return e.runWebGLProgram(A,[r],r.dtype)}},Tde=la({opSnippet:`if (b == 0.0) return NAN;
  return mod(a, b);`,packedOpSnippet:`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  `+t1+`
  return result;
`}),Mde={kernelName:tm,backendName:"webgl",kernelFunc:Tde};class Ede{constructor(e,t,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}const gR=la({opSnippet:`
if (a == b) {
  return 1.0;
};
return a / b;`,packedOpSnippet:`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,checkOutOfBounds:!0}),Dde={kernelName:ol,backendName:"webgl",kernelFunc:gR},yR="return a - b;",bR=la({opSnippet:yR,packedOpSnippet:yR,supportsComplex:!0,cpuKernelImpl:rle}),zde={kernelName:gm,backendName:"webgl",kernelFunc:bR};function vR(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{dim:o}=r,A=pt([o],s.shape),u=mR({inputs:{x:s},backend:t,attrs:{reductionIndices:A,keepDims:!1}}),h=us(u.shape,A),l=Gt({inputs:{x:u},backend:t,attrs:{shape:h}}),c=bR({inputs:{a:s,b:l},backend:t}),d=uR({inputs:{x:c},backend:t}),m=s1({inputs:{x:d},backend:t,attrs:{axis:A,keepDims:!1}}),y=Gt({inputs:{x:m},backend:t,attrs:{shape:h}}),b=gR({inputs:{a:d,b:y},backend:t});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),b}const Ode={kernelName:xv,backendName:"webgl",kernelFunc:vR},Pde={kernelName:XC,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{numSamples:o,seed:A,normalized:u}=r,h=u?s:vR({inputs:{logits:s},backend:t,attrs:{dim:s.shape.length-1}}),l=h.shape[0],c=h.shape[1],d=new Ede(l,c,o),m=[[A]],y=t.runWebGLProgram(d,[h],"int32",m);return u||t.disposeIntermediateTensorInfo(h),y}},xR="return -x;",Bde={kernelName:av,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])){const o=t.texData.get(r.dataId),[A,u]=VAe(o.values,r.shape,r.dtype);return t.makeTensorInfo(u,r.dtype,A)}let s;return s=st().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Kp(r.shape,xR):new Su(r.shape,xR),t.runWebGLProgram(s,[r],r.dtype)}},Fde=sS,Lde={kernelName:ZC,backendName:"webgl",kernelFunc:function(n){Zr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:o}=e,{maxOutputSize:A,iouThreshold:u,scoreThreshold:h}=r,l=t.readSync(s.dataId),c=t.readSync(o.dataId),{selectedIndices:d}=Fde(l,c,A,u,h);return t.makeTensorInfo([d.length],"int32",new Int32Array(d))}},Rde=aS,Wde={kernelName:YC,backendName:"webgl",kernelFunc:function(n){Zr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:o}=e,{maxOutputSize:A,iouThreshold:u,scoreThreshold:h,padToMaxOutputSize:l}=r,c=t.readSync(s.dataId),d=t.readSync(o.dataId),{selectedIndices:m,validOutputs:y}=Rde(c,d,A,u,h,l);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([],"int32",new Int32Array([y]))]}},jde=oS,Hde={kernelName:UC,backendName:"webgl",kernelFunc:function(n){Zr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:o}=e,{maxOutputSize:A,iouThreshold:u,scoreThreshold:h,softNmsSigma:l}=r,c=t.readSync(s.dataId),d=t.readSync(o.dataId),m=A,y=u,b=h,v=l,{selectedIndices:w,selectedScores:I}=jde(c,d,m,y,b,v);return[t.makeTensorInfo([w.length],"int32",new Int32Array(w)),t.makeTensorInfo([I.length],"float32",new Float32Array(I))]}};class Gde{constructor(e,t,r,s){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${s}), float(${r}),
                      float(index == coords.y)));
      }
    `}}const Vde={kernelName:Av,backendName:"webgl",kernelFunc:n=>{const{inputs:e,backend:t,attrs:r}=n,{indices:s}=e,{depth:o,onValue:A,offValue:u}=r,h=Ye(s.shape),l=new Gde(h,o,A,u),c=Gt({inputs:{x:s},backend:t,attrs:{shape:[h]}}),d=t.runWebGLProgram(l,[c],s.dtype);t.disposeIntermediateTensorInfo(c);const m=Gt({inputs:{x:d},backend:t,attrs:{shape:[...s.shape,o]}});return t.disposeIntermediateTensorInfo(d),m}};function A1(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="complex64"){const s=fg({inputs:{input:r},backend:t}),o=A1({inputs:{x:s},backend:t}),A=i1({inputs:{input:r},backend:t}),u=A1({inputs:{x:A},backend:t}),h=Nu({inputs:{real:o,imag:u},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(A),t.disposeIntermediateTensorInfo(u),h}return mg({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:t})}const Xde={kernelName:Iv,backendName:"webgl",kernelFunc:A1},Zde={kernelName:iv,backendName:"webgl",kernelFunc:function n(e){const{inputs:t,backend:r}=e,{x:s}=t;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const o=fg({inputs:{input:s},backend:r}),A=n({inputs:{x:o},backend:r}),u=i1({inputs:{input:s},backend:r}),h=A1({inputs:{x:u},backend:r}),l=Nu({inputs:{real:A,imag:h},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(A),r.disposeIntermediateTensorInfo(u),r.disposeIntermediateTensorInfo(h),l}return mg({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:r})}},Yde={kernelName:lv,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r;if(e.length===1)return xN({inputs:{input:e[0]},backend:t,attrs:{dim:s}});const o=e[0].shape,A=e[0].dtype;e.forEach(l=>{gn(o,l.shape,"All tensors passed to stack must have matching shapes"),J(A===l.dtype,()=>"All tensors passed to stack must have matching dtypes")});const u=[],h=eR({inputs:e.map(l=>{const c=xN({inputs:{input:l},backend:t,attrs:{dim:s}});return u.push(c),c}),backend:t,attrs:{axis:s}});return u.forEach(l=>t.disposeIntermediateTensorInfo(l)),h}};class Ude{constructor(e,t,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((l,c)=>l[0]+e[c]+l[1]);const s=e.length,o=kr(s),A=t.map(l=>l[0]).join(","),u=t.map((l,c)=>l[0]+e[c]).join(","),h=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);this.userCode=s!==1?`
      ${o} start = ${o}(${A});
      ${o} end = ${o}(${u});

      void main() {
        ${o} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${o} coords = outC - start;
          setOutput(getX(${h}));
        }
      }
    `:`
        int start = ${A};
        int end = ${u};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `}}class Qde{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((v,w)=>v[0]+e[w]+v[1]);const s=e.length,o=kr(s),A=t.map(v=>v[0]).join(","),u=t.map((v,w)=>v[0]+e[w]).join(","),h=Ha("rc",s),l=Ha("source",s),c=`${h[s-1]} < ${this.outputShape[s-1]}`,d=s===1?"source":`vec2(${l.slice(-2).join()})`,m=[`${o} rc = outputLoc;`,`${h[s-1]} += 1;
       if(${c}) {
      `,s===1?"":`}
       rc = outputLoc;
       ${h[s-2]} += 1;
       if(${h[s-2]} < ${this.outputShape[s-2]}) {`,s===1?"":`  ${h[s-1]} += 1;
         if(${c}) {`],y=s===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let b="";for(let v=0,w=s===1?2:4;v<w;v++)b+=`
        ${m[v]}
        if (${y}) {
          result[${v}] = float(value);
        } else {
          ${o} source = rc - start;
          result[${v}] = getChannel(getX(${l.join()}), ${d});
        }
      `;b+=s===1?"} ":"}}",this.userCode=`
      const ${o} start = ${o}(${A});
      const ${o} end = ${o}(${u});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${b}
        setOutput(result);
      }
    `}}const wR=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{paddings:o,constantValue:A}=r;if(Ye(s.shape)===0)return mg({backend:t,attrs:{shape:o.map((l,c)=>l[0]+s.shape[c]+l[1]),value:A,dtype:s.dtype}});const u=st().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Qde(s.shape,o,A):new Ude(s.shape,o,A),h=[[A]];return t.runWebGLProgram(u,[s],s.dtype,h)},Kde={kernelName:uv,backendName:"webgl",kernelFunc:wR},qde=la({opSnippet:`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,packedOpSnippet:`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  `+t1+`
  return result;
`}),Jde={kernelName:rm,backendName:"webgl",kernelFunc:qde},$de={kernelName:QC,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:A}=r,u=s.shape.length,h=[],l=pt(o,s.shape);let c=l;const d=cs(c,u);let m,y=s;if(d!=null&&(y=Ga({inputs:{x:s},backend:t,attrs:{perm:d}}),c=bs(c.length,u),h.push(y)),ia("prod",c,u),t.shouldExecuteOnCPU([y])){const b=t.texData.get(y.dataId).values,{outVals:v,outShape:w,outDtype:I}=ZAe(y.shape,y.dtype,b,c);m=t.makeTensorInfo(w,I,v)}else{const[b,v]=Xs(y.shape,c),w=Ye(v),I=Gt({inputs:{x:y},backend:t,attrs:{shape:[-1,w]}}),S=Jc(I,kI(s.dtype),"prod",t);m=Gt({inputs:{x:S},backend:t,attrs:{shape:b}}),h.push(I),h.push(S)}if(A){h.push(m);const b=us(m.shape,l);m=Gt({inputs:{x:m},backend:t,attrs:{shape:b}})}return h.forEach(b=>t.disposeIntermediateTensorInfo(b)),m}},kR=n=>{const{backend:e,attrs:t}=n,{start:r,stop:s,step:o,dtype:A}=t,u=YAe(r,s,o,A);return e.makeTensorInfo([u.length],A,u)},_de={kernelName:KC,backendName:"webgl",kernelFunc:kR},epe=Qn({opSnippet:"return 1.0 / x;"}),tpe={kernelName:sm,backendName:"webgl",kernelFunc:epe},npe=Qn({opSnippet:eA+`
  return (x < 0.0) ? 0.0 : x;
`,packedOpSnippet:`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`}),rpe={kernelName:am,backendName:"webgl",kernelFunc:npe},spe=Qn({opSnippet:eA+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,packedOpSnippet:`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`}),ape={kernelName:om,backendName:"webgl",kernelFunc:spe};class ope{constructor(e,t,r,s,o){this.variableNames=["A"],this.outputShape=[];const[A,u,h,l]=e;this.outputShape=[A,t,r,l];const c=[s&&t>1?u-1:u,s&&r>1?h-1:h],d=[s&&t>1?t-1:t,s&&r>1?r-1:r];let m;m=o?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/d[0]},
          ${c[1]/d[1]});
      const vec2 inputShapeRC = vec2(${u}.0, ${h}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class ipe{constructor(e,t,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[A,u,h,l]=e;this.outputShape=[A,t,r,l];const c=[s&&t>1?u-1:u,s&&r>1?h-1:h],d=[s&&t>1?t-1:t,s&&r>1?r-1:r];let m;m=o?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/d[0]},
          ${c[1]/d[1]},
          ${c[1]/d[1]});
      const vec3 inputShapeRC = vec3(${u}.0, ${h}.0,
                                     ${h}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}const Ape={kernelName:hv,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:o,halfPixelCenters:A,size:u}=r,[h,l]=u,c=st().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ipe(s.shape,h,l,o,A):new ope(s.shape,h,l,o,A);return t.runWebGLProgram(c,[s],"float32")}};class lpe{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,s,o]=t,[,A,u]=e,h=[r&&A>1?s-1:s,r&&u>1?o-1:o],l=[r&&A>1?A-1:A,r&&u>1?u-1:u],c=h[0]/l[0],d=h[1]/l[1],m=1/c,y=1/d,b=2*Math.ceil(m)+2,v=2*Math.ceil(y)+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${d});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${y});

        const int winHeight = int(${b});
        const int winWidth = int(${v});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${A}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${u}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}const upe={kernelName:$C,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:o}=e,{alignCorners:A}=r,u=new lpe(o.shape,s.shape,A);return t.runWebGLProgram(u,[o],o.dtype)}};class cpe{constructor(e,t,r,s,o){this.variableNames=["A"],this.outputShape=[];const[A,u,h,l]=e;this.outputShape=[A,t,r,l];const c=[s&&t>1?u-1:u,s&&r>1?h-1:h],d=[s&&t>1?t-1:t,s&&r>1?r-1:r],m=s?"0.5":"0.0";let y;y=o?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/d[0]},
          ${c[1]/d[1]});
      const vec2 inputShapeRC = vec2(${u}.0, ${h}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${y};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}class dpe{constructor(e,t,r,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[A,u,h,l]=e;this.outputShape=[A,t,r,l];const c=[s&&t>1?u-1:u,s&&r>1?h-1:h],d=[s&&t>1?t-1:t,s&&r>1?r-1:r],m=s?"0.5":"0.0";let y;y=o?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/d[0]},
          ${c[1]/d[1]},
          ${c[1]/d[1]});
      const vec3 inputShapeRC = vec3(${u}.0, ${h}.0,
                                     ${h}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${y};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}const ppe={kernelName:pv,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:o,halfPixelCenters:A,size:u}=r,[h,l]=u,c=st().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new dpe(s.shape,h,l,o,A):new cpe(s.shape,h,l,o,A);return t.runWebGLProgram(c,[s],s.dtype)}};class hpe{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,s,o]=t,[,A,u]=e,h=[r&&A>1?s-1:s,r&&u>1?o-1:o],l=[r&&A>1?A-1:A,r&&u>1?u-1:u],c=h[0]/l[0],d=h[1]/l[1],m=1/c,y=1/d,b=2*Math.ceil(m)+2,v=2*Math.ceil(y)+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${d});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${y});

        const int winHeight = int(${b});
        const int winWidth = int(${v});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${A}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${u}) {
              continue;
            }

            float sourceFracRow =
              float(${h[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${h[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${o}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}const fpe={kernelName:JC,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:o}=e,{alignCorners:A}=r,u=new hpe(o.shape,s.shape,A);return t.runWebGLProgram(u,[o],o.dtype)}};class mpe{constructor(e,t){this.variableNames=["x"];const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=e,r===1)return void(this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `);const s=e.map((A,u)=>(h=>t.indexOf(h)!==-1&&e[h]!==1?`${e[h]} - coords[${h}] - 1`:`coords[${h}]`)(u)).join(","),o=kr(r);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}}class gpe{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=e;const s=Ha("rc",r),o=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,A=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,u=kr(r);function h(l){const c=e.map((d,m)=>function(y,b){return t.indexOf(y)!==-1&&e[y]!==1?`${e[y]} - ${b[y]} - 1`:`${b[y]}`}(m,l));return`getChannel(getX(${c.join(",")}), vec2(${c.slice(-2).join(",")}))`}this.userCode=r===1?`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${o}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:`
        void main() {
          ${u} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${function(l){return h(l)}(s.slice())};
          if(${o}){
            result.g = ${function(l){return l[r-1]="("+l[r-1]+" + 1)",h(l)}(s.slice())};
          }
          if(${A}) {
            result.b = ${function(l){return l[r-2]="("+l[r-2]+" + 1)",h(l)}(s.slice())};
            if(${o}) {
              result.a = ${function(l){return l[r-1]="("+l[r-1]+" + 1)",l[r-2]="("+l[r-2]+" + 1)",h(l)}(s.slice())};
            }
          }
          setOutput(result);
        }
    `}}const ype={kernelName:fv,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dims:o}=r,A=s.shape.length,u=pt(o,s.shape);if(A===0)return No({inputs:{x:s},backend:t});const h=st().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new gpe(s.shape,u):new mpe(s.shape,u);return t.runWebGLProgram(h,[s],s.dtype)}};class bpe{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=e[1],s=e[2];this.outputShape=e;let o="";o=typeof t=="number"?`float outputValue = ${t.toFixed(2)};`:`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${o}
          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const vpe={kernelName:hI,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,{radians:s,fillValue:o,center:A}=e,u=t,h=new bpe(r.shape,o),[l,c]=xS(A,r.shape[1],r.shape[2]),d=[[l,c,Math.sin(s),Math.cos(s)]];return u.runWebGLProgram(h,[r],r.dtype,d)}},xpe=Qn({opSnippet:`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`}),wpe={kernelName:im,backendName:"webgl",kernelFunc:xpe},kpe=Qn({opSnippet:"return inversesqrt(x);",cpuKernelImpl:UAe}),Cpe={kernelName:Am,backendName:"webgl",kernelFunc:kpe};class CR{constructor(e,t,r,s,o,A,u=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=A;const h=kr(o.length),l=kr(A.length);let c="";r===1?c="i":r===2&&(c="i, j");const d=`getIndices(${c})`;let m="";s===1?m="i":s===2&&(m="i, coords[1]");const y=`getUpdates(${m})`,b=t>1?"strides[j]":"strides";this.userCode=`
        ${h} strides = ${h}(${o});

        void main() {
          ${l} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${b};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${y};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}}const Ipe={kernelName:_C,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s,updates:o}=e,{shape:A}=r,{sliceRank:u,numUpdates:h,sliceSize:l,strides:c,outputSize:d}=Hm(0,s,A),m=[d/l,l];if(d===0)return t.makeTensorInfo(A,s.dtype);const y=Gt({inputs:{x:s},backend:t,attrs:{shape:[h,u]}}),b=Gt({inputs:{x:o},backend:t,attrs:{shape:[h,l]}}),v=t.makeTensorInfo([],"float32",new Float32Array([0])),w=new CR(h,u,y.shape.length,b.shape.length,c,m),I=t.runWebGLProgram(w,[b,y,v],b.dtype),S=Gt({inputs:{x:I},backend:t,attrs:{shape:A}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(I),t.disposeIntermediateTensorInfo(v),S}};class Spe{constructor(e,t,r){let s,o;if(this.variableNames=["c","a","b"],this.outputShape=t,r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)o="resRC",s="resRC";else{const u=["resRC.x","resRC.y","resRC.z","resRC.w"],h=[],l=[];for(let c=0;c<t.length;c++)l.push(`${u[c]}`),c<e&&h.push(`${u[c]}`);s=h.join(),o=l.join()}const A=kr(r);this.userCode=`
      void main() {
        ${A} resRC = getOutputCoords();
        float cVal = getC(${s});
        if (cVal >= 1.0) {
          setOutput(getA(${o}));
        } else {
          setOutput(getB(${o}));
        }
      }
    `}}const Npe={kernelName:mv,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t}=n,{condition:r,t:s,e:o}=e,A=new Spe(r.shape.length,s.shape,s.shape.length);return t.runWebGLProgram(A,[r,s,o],Uo(s.dtype,o.dtype))}},Tpe=Qn({opSnippet:`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${lx};
  float scale = ${ux};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`}),Mpe={kernelName:lm,backendName:"webgl",kernelFunc:Tpe},IR="return 1.0 / (1.0 + exp(-1.0 * x));",Epe=Qn({opSnippet:IR,packedOpSnippet:IR,cpuKernelImpl:QAe}),Dpe={kernelName:pm,backendName:"webgl",kernelFunc:Epe},zpe=Qn({opSnippet:`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`}),Ope={kernelName:dm,backendName:"webgl",kernelFunc:zpe},Ppe=Qn({opSnippet:H6+`
  return sin(x);
`}),Bpe={kernelName:um,backendName:"webgl",kernelFunc:Ppe},Fpe=Qn({opSnippet:`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`}),Lpe={kernelName:cm,backendName:"webgl",kernelFunc:Fpe},Rpe=Qn({opSnippet:`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`}),Wpe={kernelName:hm,backendName:"webgl",kernelFunc:Rpe},jpe={kernelName:bv,backendName:"webgl",kernelFunc:n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:o,paddings:A}=r;J(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const u=o.reduce((I,S)=>I*S),h=[[0,0]];h.push(...A);for(let I=1+o.length;I<s.shape.length;++I)h.push([0,0]);const l=[],c=wR({inputs:{x:s},backend:t,attrs:{paddings:h,constantValue:0}}),d=Rm(c.shape,o,u,!1),m=Wm(d.length,o.length,!1),y=jm(c.shape,o,u,!1),b=Gt({inputs:{x:c},backend:t,attrs:{shape:d}}),v=Ga({inputs:{x:b},backend:t,attrs:{perm:m}}),w=Gt({inputs:{x:v},backend:t,attrs:{shape:y}});return l.push(c),l.push(b),l.push(v),l.forEach(I=>t.disposeIntermediateTensorInfo(I)),w}},Hpe={kernelName:eI,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t}=n,{indices:r,values:s,denseShape:o,defaultValue:A}=e;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${o.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(A.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${A.shape}`);const u=t.readSync(r.dataId),h=t.readSync(s.dataId),l=t.readSync(o.dataId),c=t.readSync(A.dataId)[0],[d,m,y,b,v]=qAe(u,r.shape,r.dtype,h,s.dtype,l,c);return[t.makeTensorInfo(m,r.dtype,d),t.makeTensorInfo([m[0]],s.dtype,y),t.makeTensorInfo([b.length],"bool",new Uint8Array(b.map(w=>Number(w)))),t.makeTensorInfo([v.length],r.dtype,new Int32Array(v))]}},Gpe={kernelName:tI,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t}=n,{inputIndices:r,inputShape:s,newShape:o}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const A=Array.from(t.readSync(s.dataId)),u=t.readSync(r.dataId),h=Array.from(t.readSync(o.dataId)),[l,c,d]=JAe(u,r.shape,r.dtype,A,h);return[t.makeTensorInfo(c,r.dtype,l),t.makeTensorInfo([d.length],o.dtype,new Int32Array(d))]}},Vpe={kernelName:nI,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:o}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${o.shape}`);const A=t.readSync(r.dataId),u=t.readSync(s.dataId),h=t.readSync(o.dataId),[l,c]=M6(A,r.shape,r.dtype,u,h,!0);return t.makeTensorInfo(c,r.dtype,l)}},Xpe={kernelName:rI,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:o}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${o.shape}`);const A=t.readSync(r.dataId),u=t.readSync(s.dataId),h=t.readSync(o.dataId),[l,c]=M6(A,r.shape,r.dtype,u,h);return t.makeTensorInfo(c,r.dtype,l)}},Zpe={kernelName:sI,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{sparseIndices:s,sparseValues:o,defaultValue:A}=e,{outputShape:u}=r,{sliceRank:h,numUpdates:l,strides:c,outputSize:d}=Hm(0,s,u),m=new CR(l,h,s.shape.length,o.shape.length,c,[d,1],!1),y=t.runWebGLProgram(m,[o,s,A],o.dtype),b=Gt({inputs:{x:y},backend:t,attrs:{shape:u}});return t.disposeIntermediateTensorInfo(y),b}},Ype={kernelName:vv,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{numOrSizeSplits:o,axis:A}=r,u=pt(A,s.shape)[0],h=RS(s,o,u),l=s.shape.length,c=new Array(l).fill(0),d=s.shape.slice();return h.map(m=>{const y=[...d];y[u]=m;const b=Jp({inputs:{x:s},backend:t,attrs:{begin:c,size:y}});return c[u]+=m,b})}},SR="return sqrt(x);",Upe=Qn({opSnippet:SR,packedOpSnippet:SR,cpuKernelImpl:$Ae}),Qpe={kernelName:fm,backendName:"webgl",kernelFunc:Upe},Kpe={kernelName:aI,backendName:"webgl",kernelFunc:Qn({opSnippet:"return x * x;"})},NR="return (a - b) * (a - b);",qpe=la({opSnippet:NR,packedOpSnippet:NR}),Jpe={kernelName:mm,backendName:"webgl",kernelFunc:qpe},$pe={kernelName:xm,backendName:"webgl",kernelFunc:function({inputs:n,attrs:e,backend:t}){const{x:r}=n,s=eA+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,o=new Su(r.shape,s);return t.runWebGLProgram(o,[r],r.dtype)}};class _pe{constructor(e,t,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,o=kr(r.length),A=kr(r.length);let u="";if(s===1)u="coords * strides + begin";else{let h=0;u=r.map((l,c)=>(h++,r.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${h-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${o} begin = ${o}(${e});
      ${o} strides = ${o}(${t});

      void main() {
        ${A} coords = getOutputCoords();
        setOutput(getX(${u}));
      }
    `}}const ehe={kernelName:oI,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:o,end:A,strides:u,beginMask:h,endMask:l,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:m}=r,{nonStrided:y,$begin:b,$strides:v,size:w,newShape:I,outShape:S}=PI(s.shape,o,A,u,h,l,c,d,m),T=Gt({inputs:{x:s},backend:t,attrs:{shape:I}});let D;if(y){const W=Jp({inputs:{x:T},backend:t,attrs:{begin:b,size:w}});D=Gt({inputs:{x:W},backend:t,attrs:{shape:S}}),t.disposeIntermediateTensorInfo(W)}else if(S.some(W=>W===0))D=t.makeTensorInfo(S,s.dtype,[]);else if(t.shouldExecuteOnCPU([T])){const W=t.texData.get(T.dataId).values,K=Wn(T.shape,T.dtype,W),U=_Ae(S,K,v,b);D=t.makeTensorInfo(S,T.dtype,U.values)}else{const W=new _pe(b,v,S);D=t.runWebGLProgram(W,[T],T.dtype)}const L=Gt({inputs:{x:D},backend:t,attrs:{shape:S}});return t.disposeIntermediateTensorInfo(T),t.disposeIntermediateTensorInfo(D),L}},the={kernelName:iI,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{separator:s,nGramWidths:o,leftPad:A,rightPad:u,padWidth:h,preserveShortSequences:l}=r,{data:c,dataSplits:d}=e,m=t.readSync(c.dataId),y=t.readSync(d.dataId),[b,v]=ele(m,y,s,o,A,u,h,l);return[t.makeTensorInfo([b.length],"string",b),t.makeTensorInfo(d.shape,"int32",v)]}},nhe={kernelName:AI,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{skipEmpty:s}=r,{input:o,delimiter:A}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(A.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${A.shape}`);const u=t.readSync(o.dataId),h=t.readSync(A.dataId)[0],[l,c,d]=tle(u,h,s),m=c.length;return[t.makeTensorInfo([m,2],"int32",l),t.makeTensorInfo([m],"string",c),t.makeTensorInfo([2],"int32",new Int32Array(d))]}},rhe={kernelName:lI,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{numBuckets:s}=r,{input:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const A=t.readSync(o.dataId),u=nle(A,s);return t.makeTensorInfo(o.shape,"int32",u)}},she=Qn({opSnippet:"return tan(x);"}),ahe={kernelName:ym,backendName:"webgl",kernelFunc:she},ohe=Qn({opSnippet:`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`}),ihe={kernelName:bm,backendName:"webgl",kernelFunc:ohe};class Ahe{constructor(e,t){this.variableNames=["A"];const r=new Array(e.length);for(let A=0;A<r.length;A++)r[A]=e[A]*t[A];this.outputShape=r,this.rank=r.length;const s=kr(this.rank),o=function(A){const u=A.length;if(u>5)throw Error(`Tile for rank ${u} is not yet supported`);if(u===1)return`imod(resRC, ${A[0]})`;const h=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],l=[];for(let c=0;c<A.length;c++)l.push(`imod(${h[c]}, ${A[c]})`);return l.join()}(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        setOutput(getA(${o}));
      }
    `}}function TR(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reps:o}=r;if(s.dtype==="string"||s.shape.length>5){const u=t.readSync(s.dataId),h=s.dtype==="string"?u.map(d=>yp(d)):u,l=Wn(s.shape,s.dtype,h),c=sle(l,o);return t.makeTensorInfo(c.shape,c.dtype,c.values)}const A=new Ahe(s.shape,o);return t.runWebGLProgram(A,[s],s.dtype)}const lhe={kernelName:vm,backendName:"webgl",kernelFunc:TR};class uhe{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class che{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}function $c(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function MR(n){let e=1;for(;e<n;)e*=2;return e}const dhe={kernelName:uI,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{k:o,sorted:A}=r,u=st().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),h=st().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=s.shape,c=l[l.length-1];if(t.shouldExecuteOnCPU([s])||c<u||o>h){const _=t.readSync(s.dataId),[ee,re]=ale(_,l,s.dtype,o,A);return[t.makeTensorInfo(ee.shape,ee.dtype,ee.values),t.makeTensorInfo(re.shape,re.dtype,re.values)]}if(o===0)return l[l.length-1]=0,[t.makeTensorInfo(l,s.dtype,[]),t.makeTensorInfo(l,"int32",[])];if(c===1)return[s,mg({attrs:{shape:l,dtype:"int32",value:0},backend:t})];const d=t.texData.get(s.dataId),m=d!==null&&d.isPacked,y=m?t.unpackTensor(s):s,b=Ye(l)/c,v=Gt({inputs:{x:y},attrs:{shape:[b,c]},backend:t});m&&$c(t,y);const w=MR(o),I=MR(c);let S=null;const T=()=>S===null?[v,v]:[v,S],D=(_,ee,re)=>{const ce=T(),we=new uhe(re),Ee=[[c],[S===null?1:0],[Number.NEGATIVE_INFINITY],[_],[ee]],Pe=S;S=t.runWebGLProgram(we,ce,"int32",Ee),$c(t,Pe)};for(let _=1;_<w;_*=2){const ee=2*_;for(let re=_;re>=1;re/=2)D(ee,re,[b,I])}for(let _=I;_>w;_/=2){const ee=T(),re=new che([b,_/2]),ce=[[c],[S===null?1:0],[w]],we=S;S=t.runWebGLProgram(re,ee,"int32",ce),$c(t,we);const Ee=w/2,Pe=2*Ee;for(let he=Ee;he>=1;he/=2)D(Pe,he,S.shape)}let L=S;S=Jp({inputs:{x:S},backend:t,attrs:{begin:0,size:[b,o]}}),$c(t,L);let W=fR({inputs:{x:v,indices:S},backend:t,attrs:{axis:1,batchDims:1}});$c(t,v);const K=l.slice(0,-1);K.push(o),L=S,S=Gt({inputs:{x:S},attrs:{shape:K},backend:t}),$c(t,L);const U=W;return W=Gt({inputs:{x:W},attrs:{shape:K},backend:t}),$c(t,U),[W,S]}};class phe{constructor(e,t,r,s,o,A){this.variableNames=["Image","Transforms"],this.outputShape=A;const u=r==="nearest"?1:2;let h;switch(s){case"constant":default:h=1;break;case"reflect":h=2;break;case"wrap":h=3;break;case"nearest":h=4}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${h} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${h} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${h} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${o});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${o});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${u} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}const hhe={kernelName:cI,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{image:s,transforms:o}=e,{interpolation:A,fillMode:u,fillValue:h,outputShape:l}=r,[c,d,m,y]=s.shape,[b,v]=l??[d,m],w=new phe(d,m,A,u,h,[c,b,v,y]);return t.runWebGLProgram(w,[s,o],"float32")}},fhe={kernelName:dI,backendName:"webgl",kernelFunc:function(n){const{inputs:e,attrs:t,backend:r}=n,{axis:s}=t,{x:o}=e;cg(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const A=r.readSync(o.dataId),{outputValues:u,outputShape:h,indices:l}=ole(A,s,o.shape,o.dtype);return[r.makeTensorInfo(h,o.dtype,u),r.makeTensorInfo([l.length],"int32",l)]}},mhe={kernelName:kv,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{value:s}=e;let{axis:o}=r;o<0&&(o+=s.shape.length);const A=s,u=A.shape.length,h=s.shape[o],l=new Array(u-1);let c=0;for(let v=0;v<u;v++)v!==o&&(l[c++]=A.shape[v]);const d=[],m=new Array(u).fill(0),y=A.shape.slice();y[o]=1;const b=new Array(h);for(let v=0;v<b.length;v++){m[o]=v;const w=Jp({inputs:{x:A},backend:t,attrs:{begin:m,size:y}}),I=Gt({inputs:{x:w},backend:t,attrs:{shape:l}});b[v]=I,d.push(w)}return d.forEach(v=>t.disposeIntermediateTensorInfo(v)),b}};class ghe{constructor(e,t){this.variableNames=["x","segmentIds"];const r=e.windowSize,s=e.batchSize,o=e.inSize,A=e.numSegments,u=A*Math.ceil(o/r);this.outputShape=[s,u];const h=4*Math.floor(r/4),l=r%4,c=`
        sumValue += dot(values, segFilter);
    `;let d="";o%r>0&&(d=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `);let m="";o%r>0&&(m=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = 0.0;

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${m}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${A})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${A})));

        float sumValue = 0.0;

        for (int i = 0; i < ${h}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${c}
        }

        int inIdx = inOffset + ${h};
        if (${l===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${c}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${c}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${c}
        }
        setOutput(sumValue);
      }
    `}}const yhe=[Ade,ude,Ile,Sle,Tle,Ele,zle,Ble,Fle,Lle,jle,Hle,Vle,Zle,Kle,Ule,Jle,_le,$le,nue,rue,sue,iue,cue,due,fue,gue,vue,wue,fle,Sue,Pue,Bue,Mue,Lue,Rue,Fue,jue,Gue,Xue,Zue,Yue,Que,$ue,_ue,Kue,tce,rce,sce,oce,ice,lce,cce,dce,pce,fce,mce,yce,vce,wce,Cce,Nce,Tce,Mce,Dce,Oce,Bce,Lce,hle,Rce,Iue,jce,Gce,Xce,mle,Yce,Qce,Kce,_ce,Jce,tde,rde,ade,cde,fde,hde,yde,bde,vde,pde,xde,wde,Cde,Nde,Mde,Pde,yle,Bde,Lde,Wde,Hde,pue,Vde,Zde,Yde,Kde,Jde,gle,$de,_de,hue,Dde,tpe,ape,rpe,ble,Ape,upe,ppe,fpe,ype,vpe,wpe,Cpe,Ipe,Npe,Mpe,Dpe,Ope,Bpe,Lpe,uue,Ode,Wpe,jpe,Hpe,Gpe,Vpe,Xpe,Zpe,Ype,Qpe,Kpe,Jpe,$pe,ehe,the,nhe,rhe,zde,kle,ahe,ihe,lhe,dhe,hhe,Cle,fhe,mhe,{kernelName:Cv,backendName:"webgl",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,segmentIds:o}=e,{numSegments:A}=r,u=s.shape.length,h=[];let l=0;const c=cs([l],u);let d=s;c!=null&&(d=Ga({inputs:{x:s},backend:t,attrs:{perm:c}}),h.push(d),l=bs(1,u)[0]);const m=U4(d.shape,l,A),y=Ye([d.shape[l]]),b=Gt({inputs:{x:d},backend:t,attrs:{shape:[-1,y]}});h.push(b);const v=kI(s.dtype),w=(T,D,L,W,K)=>{const U=T.shape[0],_=T.shape[1],ee=Y4(_,K),re=new ghe({windowSize:ee,inSize:_,batchSize:U,numSegments:K},D),ce=t.compileAndRun(re,[T,L],W);if(h.push(ce),ce.shape[1]===K)return ce;const we=kR({backend:t,attrs:{start:0,stop:K,step:1,dtype:"float32"}}),Ee=TR({inputs:{x:we},backend:t,attrs:{reps:[_/ee]}});return h.push(we),h.push(Ee),w(ce,D,Ee,W,K)},I=Gt({inputs:{x:w(b,"unsortedSegmentSum",o,v,A)},backend:t,attrs:{shape:m}});let S=I;if(c!=null){h.push(I);const T=Np(c);S=Ga({inputs:{x:S},backend:t,attrs:{perm:T}})}return h.forEach(T=>t.disposeIntermediateTensorInfo(T)),S}},Xde];for(const n of yhe)w7(n);class bhe{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class ER{refCount(e){return Ti("refCount")}incRef(e){return Ti("incRef")}timerAvailable(){return!0}time(e){return Ti("time")}read(e){return Ti("read")}readSync(e){return Ti("readSync")}numDataIds(){return Ti("numDataIds")}disposeData(e,t){return Ti("disposeData")}write(e,t,r){return Ti("write")}move(e,t,r,s,o){return Ti("move")}memory(){return Ti("memory")}floatPrecision(){return Ti("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return Ti("dispose")}}function Ti(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function ze(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function tA(n,e,t=""){ze(_c(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function wN(n){ze(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function l1(n,e=[],t=!1){if(e==null&&(e=[]),Array.isArray(n)||PA(n)&&!t)for(let r=0;r<n.length;++r)l1(n[r],e,t);else e.push(n);return e}function Jt(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function _c(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function ri(n){return n%1==0}function u1(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function Tu(n,e){const t=e.length;return ze((n=n==null?e.map((r,s)=>s):[].concat(n)).every(r=>r>=-t&&r<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),ze(n.every(r=>ri(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?t+r:r)}function DR(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else{if(n!=="string")throw new Error(`Unknown data type ${n}`);t=new Array(e)}return t}function PA(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}function c1(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function kN(n){return typeof n=="string"||n instanceof String}function CN(n){return Array.isArray(n)?CN(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":typeof n=="number"?"float32":kN(n)?"string":typeof n=="boolean"?"bool":"float32"}function zR(n){return!!(n&&n.constructor&&n.call&&n.apply)}function ka(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let r=e-3;r>=0;--r)t[r]=t[r+1]*n[r+1];return t}function OR(n,e,t,r=!1){const s=new Array;if(e.length===1){const o=e[0]*(r?2:1);for(let A=0;A<o;A++)s[A]=t[n+A]}else{const o=e[0],A=e.slice(1),u=A.reduce((h,l)=>h*l)*(r?2:1);for(let h=0;h<o;h++)s[h]=OR(n+h*u,A,t,r)}return s}function IN(n,e,t=!1){if(n.length===0)return e[0];const r=n.reduce((s,o)=>s*o)*(t?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return OR(0,n,e,t)}function PR(n,e){const t=gg(n,e);for(let r=0;r<t.length;r++)t[r]=1;return t}function gg(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function BR(n){n.forEach(e=>{ze(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function yg(n){return n&&n.then&&typeof n.then=="function"}function Mu(...n){yr().getBool("IS_TEST")||yr().getBool("PROD")||console.warn(...n)}const FR="tfjsflags";class vhe{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=xhe,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&Mu(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`),this.platformName=e,this.platform=t}registerFlag(e,t,r){if(this.flagRegistry[e]={evaluationFn:t,setHook:r},this.urlFlags[e]!=null){const s=this.urlFlags[e];Mu(`Setting feature override from URL ${e}: ${s}.`),this.set(e,s)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(yg(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(this.global===void 0||this.global.location===void 0||this.global.location.search===void 0)return;const e=this.getQueryParams(this.global.location.search);FR in e&&e[FR].split(",").forEach(t=>{const[r,s]=t.split(":");this.urlFlags[r]=function(o,A){if((A=A.toLowerCase())==="true"||A==="false")return A==="true";if(""+ +A===A)return+A;throw new Error(`Could not parse value flag value ${A} for flag ${o}.`)}(r,s)})}}function xhe(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...r)=>(function(s,o,A){s[decodeURIComponent(o)]=decodeURIComponent(A||"")}(e,r[0],r[1]),r.join("="))),e}function yr(){return LR}let SN,LR=null;function RR(){if(SN==null){let n;if(typeof window<"u")n=window;else if(p.g!==void 0)n=p.g;else if(typeof process<"u")n=process;else{if(typeof self>"u")throw new Error("Could not find a global object");n=self}SN=n}return SN}function NN(n,e){const t=function(){const r=RR();return r._tfGlobals==null&&(r._tfGlobals=new Map),r._tfGlobals}();if(t.has(n))return t.get(n);{const r=e();return t.set(n,r),t.get(n)}}const TN="Add",MN="AddN",EN="All",DN="Any",zN="ArgMax",ON="AvgPool",PN="BatchMatMul",WR="BatchToSpaceND",BN="Cast",jR="Ceil",FN="ClipByValue",HR="Concat",LN="Conv2D",RN="Conv2DBackpropInput",GR="Cosh",WN="Cumsum",jN="CropAndResize",HN="DepthToSpace",GN="DepthwiseConv2dNative",VR="RealDiv",XR="Equal",ZR="ExpandDims",YR="Fill",VN="FlipLeftRight",UR="Floor",QR="FloorDiv",XN="FusedBatchNorm",KR="GatherV2",ZN="GatherNd",qR="Greater",JR="GreaterEqual",YN="Identity",UN="LeakyRelu",$R="Less",_R="LessEqual",e8="LogicalAnd",QN="Max",t8="Maximum",KN="MaxPool",qN="Mean",JN="Min",n8="Minimum",$N="MirrorPad",r8="Multiply",s8="NotEqual",_N="NonMaxSuppressionV3",eT="NonMaxSuppressionV4",tT="NonMaxSuppressionV5",a8="OnesLike",nT="OneHot",o8="Pack",rT="PadV2",sT="Prelu",aT="Prod",i8="Range",A8="Relu",l8="Reshape",oT="ResizeBilinear",u8="Relu6",iT="Reverse",c8="Round",d8="Rsqrt",AT="ScatterNd",p8="Select",h8="Slice",f8="Sigmoid",m8="Sqrt",lT="Sum",g8="SpaceToBatchND",y8="SplitV",uT="Softmax",b8="SquaredDifference",cT="StridedSlice",v8="Tanh",d1="Tile",dT="TopK",pT="Transform",hT="Transpose",x8="Unpack",w8="ZerosLike",fT="Step",k8="FromPixels",mT="RotateWithOffset",p1="_FusedMatMul",h1="FusedConv2D",f1="FusedDepthwiseConv2D",m1=NN("kernelRegistry",()=>new Map),whe=NN("gradRegistry",()=>new Map);function gT(n,e){const t=S8(n,e);return m1.get(t)}function C8(n){return whe.get(n)}function I8(n){const e=m1.entries(),t=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[o,A]=s,[u]=o.split("_");u===n&&t.push(A)}return t}function khe(n){const{kernelName:e,backendName:t}=n,r=S8(e,t);m1.has(r)&&Mu(`The kernel '${e}' for backend '${t}' is already registered`),m1.set(r,n)}function S8(n,e){return`${e}_${n}`}const Che=C7()||gI;function yT(n){return Che.fromString(n,!0,16)}function N8(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=l1(n)),yr().getBool("DEBUG")&&function(t,r){for(let s=0;s<t.length;s++){const o=t[s];if(isNaN(o)||!isFinite(o))throw Error(`A tensor of type ${r} being uploaded contains ${o}.`)}}(n,e),function(t,r){return t instanceof Float32Array&&r==="float32"||t instanceof Int32Array&&r==="int32"||t instanceof Uint8Array&&r==="bool"}(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let r=0;r<t.length;++r)Math.round(n[r])!==0&&(t[r]=1);return t}throw new Error(`Unknown data type ${e}`)}function eh(){return yr().platform.now()}function T8(n,e="utf-8"){return e=e||"utf-8",yr().platform.encode(n,e)}function bT(n,e="utf-8"){return e=e||"utf-8",yr().platform.decode(n,e)}yT("c3a5c85c97cb3127"),yT("b492b66fbe98f273"),yT("9ae16a3b2f90404f");class Ihe{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new Nhe)}profileKernel(e,t,r){let s;const o=()=>{s=r()};let A;const u=eh();if(this.backendTimer.timerAvailable())A=this.backendTimer.time(o);else{o();for(const h of s)h.dataSync();A=Promise.resolve({kernelMs:eh()-u})}if(yr().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let h=0;h<s.length;h++){const l=s[h];l.data().then(c=>{She(c,l.dtype,e)})}return{kernelName:e,outputs:s,inputs:t,timeMs:A.then(h=>h.kernelMs),extraInfo:A.then(h=>h.getExtraProfileInfo!=null?h.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:r,timeMs:s,inputs:o,extraInfo:A}=e;r.forEach(u=>{Promise.all([u.data(),s,A]).then(h=>{this.logger.logKernelProfile(t,u,h[0],h[1],o,h[2])})})}}function She(n,e,t){if(e!=="float32")return!1;for(let r=0;r<n.length;r++){const s=n[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${t}'`),!0}return!1}class Nhe{logKernelProfile(e,t,r,s,o,A){const u=typeof s=="number"?u1(`${s}ms`,9):s.error,h=u1(e,25),l=t.rank,c=t.size,d=u1(t.shape.toString(),14);let m="";for(const y in o){const b=o[y];if(b!=null){const v=b.shape||t.shape,w=v.length;m+=`${y}: ${w}D ${w>0?v:""} `}}console.log(`%c${h}	%c${u}	%c${l}D ${d}	%c${c}	%c${m}	%c${A}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function The(n,e,t,r){const s=ka(e),o=function(l,c,d,m){const y=Jt(c),b=m[m.length-1],v=new Array(b).fill(0),w=c.length,I=d==="complex64"?vg(l):l;if(w>1)for(let S=0;S<y/b;S++){const T=S*b;for(let D=0;D<b;D++)v[D]=Math.max(v[D],bg(I[T+D],0,d).length)}return v}(n,e,t,s),A=e.length,u=g1(n,e,t,s,o),h=["Tensor"];return r&&(h.push(`  dtype: ${t}`),h.push(`  rank: ${A}`),h.push(`  shape: [${e}]`),h.push("  values:")),h.push(u.map(l=>"    "+l).join(`
`)),h.join(`
`)}function bg(n,e,t){let r;return r=Array.isArray(n)?`${parseFloat(n[0].toFixed(7))} + ${parseFloat(n[1].toFixed(7))}j`:kN(n)?`'${n}'`:t==="bool"?M8(n):parseFloat(n.toFixed(7)).toString(),u1(r,e)}function M8(n){return n===0?"false":"true"}function g1(n,e,t,r,s,o=!0){const A=t==="complex64"?2:1,u=e[0],h=e.length;if(h===0)return t==="complex64"?[bg(vg(n)[0],0,t)]:t==="bool"?[M8(n[0])]:[n[0].toString()];if(h===1){if(u>20){const v=3*A;let w=Array.from(n.slice(0,v)),I=Array.from(n.slice((u-3)*A,u*A));return t==="complex64"&&(w=vg(w),I=vg(I)),["["+w.map((S,T)=>bg(S,s[T],t)).join(", ")+", ..., "+I.map((S,T)=>bg(S,s[u-3+T],t)).join(", ")+"]"]}return["["+(t==="complex64"?vg(n):Array.from(n)).map((v,w)=>bg(v,s[w],t)).join(", ")+"]"]}const l=e.slice(1),c=r.slice(1),d=r[0]*A,m=[];if(u>20){for(let v=0;v<3;v++){const w=v*d,I=w+d;m.push(...g1(n.slice(w,I),l,t,c,s,!1))}m.push("...");for(let v=u-3;v<u;v++){const w=v*d,I=w+d;m.push(...g1(n.slice(w,I),l,t,c,s,v===u-1))}}else for(let v=0;v<u;v++){const w=v*d,I=w+d;m.push(...g1(n.slice(w,I),l,t,c,s,v===u-1))}const y=h===2?",":"";m[0]="["+m[0]+y;for(let v=1;v<m.length-1;v++)m[v]=" "+m[v]+y;let b=`,
`;for(let v=2;v<h;v++)b+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(o?"":b),m}function vg(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}class vT{constructor(e,t,r){if(this.dtype=t,this.shape=e.slice(),this.size=Jt(e),r!=null){const s=r.length;ze(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||DR(t,this.size),this.strides=ka(e)}set(e,...t){t.length===0&&(t=[0]),ze(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const r=this.locToIndex(t);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const s of e){if(s<0||s>=this.shape[t]){const o=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(o)}t++}let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=this.strides[s]*e[s];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let r=0;r<e.length-1;++r)t+=this.strides[r]*e[r];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let r=0;r<t.length-1;++r)t[r]=Math.floor(e/this.strides[r]),e-=t[r]*this.strides[r];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return BA().makeTensor(this.values,this.shape,this.dtype)}}let BA=null,th=null;class Us{constructor(e,t,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Jt(e),this.strides=ka(e),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return th.buffer(this.shape,this.dtype,e)}bufferSync(){return th.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return IN(this.shape,e,this.dtype==="complex64")}arraySync(){return IN(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=BA().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(r=>bT(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataSync(){this.throwIfDisposed();const e=BA().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>bT(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await BA().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(BA().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return th.print(this,e)}clone(){return this.throwIfDisposed(),th.clone(this)}toString(e=!1){return The(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),th.cast(this,e)}variable(e=!0,t,r){return this.throwIfDisposed(),BA().makeVariable(this,e,t,r)}}Object.defineProperty(Us,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null}),NN("Tensor",()=>Us);class xT extends Us{constructor(e,t,r,s){super(e.shape,e.dtype,e.dataId,s),this.trainable=t,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!_c(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);BA().disposeTensor(this),this.dataId=e.dataId,BA().incRef(this,null)}dispose(){BA().disposeVariable(this),this.isDisposedInternal=!0}}var E8,wT,kT,CT,IT;Object.defineProperty(xT,Symbol.hasInstance,{value:n=>n instanceof Us&&n.assign!=null&&n.assign instanceof Function}),function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"}(E8||(E8={})),function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"}(wT||(wT={})),function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"}(kT||(kT={})),function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"}(CT||(CT={})),function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"}(IT||(IT={}));const Mhe={float32:CT,int32:wT,bool:kT,complex64:IT};function ts(n,e){if(n.dtype===e.dtype)return[n,e];const t=function(r,s){if(r==="string"||s==="string"){if(r==="string"&&s==="string")return"string";throw new Error(`Can not upcast ${r} with ${s}`)}return Mhe[r][s]}(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function D8(n){const e=[];return z8(n,e,new Set),e}function z8(n,e,t){if(n==null)return;if(n instanceof Us)return void e.push(n);if(r=n,!Array.isArray(r)&&typeof r!="object")return;var r;const s=n;for(const o in s){const A=s[o];t.has(A)||(t.add(A),z8(A,e,t))}}function ST(n){return n.kernelName!=null}class O8{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class nh{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new O8}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t];if(await this.initializeBackend(r).success)return void await this.setBackend(r)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,r=1){return e in this.registryFactory?(Mu(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:r}=this.initializeBackend(e);if(!(r?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Ihe(this.backendInstance),!0}setupRegisteredKernels(){I8(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){I8(e).forEach(t=>{t.disposeFunc!=null&&t.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=t.factory();if(!r||r instanceof ER||typeof r.then!="function")return this.registry[e]=r,{success:!0,asyncInit:!1};{const s=++this.pendingBackendInitId,o=r.then(A=>!(s<this.pendingBackendInitId||(this.registry[e]=A,this.pendingBackendInit=null,0))).catch(A=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,Mu(`Initialization of backend ${e} failed`),Mu(A.stack||A.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}}catch(r){return Mu(`Initialization of backend ${e} failed`),Mu(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t],{success:s,asyncInit:o}=this.initializeBackend(r);if(o||s)return{name:r,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const r=this.state.tensorInfo.get(t),s=r.backend,o=this.readSync(t),A=s.refCount(t);s.disposeData(t,!0),r.backend=e,e.move(t,o,r.shape,r.dtype,A),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let r,s=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,r){e();try{const s=r();return t(),s}catch(s){throw t(),s}}nextTensorId(){return nh.nextTensorId++}nextVariableId(){return nh.nextVariableId++}clone(e){const t=Xe.runKernel(YN,{x:e}),r={x:e};return this.addTapeNode(this.state.activeScope.name,r,[t],s=>({x:()=>{const o={x:s};return Xe.runKernel(BN,o,{dtype:"float32"})}}),[],{}),t}runKernel(e,t,r){if(this.backendName==null&&this.backend,gT(e,this.backendName)==null)throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,r){const s=this.backend.numDataIds();let o=0;r.forEach(h=>{o+=h.dtype==="complex64"?3:1});const A=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],u=s-t-o-A;if(u>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${u} data ids) after running '${e}'`)}runKernelFunc(e){let t,r=[];const s=this.isTapeOn(),o=this.state.numBytes,A=this.state.numTensors;let u,h;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),this.backendName==null&&this.backend;const l=ST(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(ST(e)){const{kernelName:b,inputs:v,attrs:w}=e;this.backendName==null&&this.backend;const I=gT(b,this.backendName);ze(I!=null,()=>`Cannot find registered kernel '${b}' for backend '${this.backendName}'`),u=()=>{const S=this.backend.numDataIds();h=I.kernelFunc({inputs:v,attrs:w,backend:this.backend});const T=Array.isArray(h)?h:[h];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(b,S,T);const D=T.map(L=>{if(L.rank!=null)return L;const{dataId:W,shape:K,dtype:U}=L;return this.makeTensorFromDataId(W,K,U)});if(s){const L=this.getTensorsForGradient(b,v,D);r=this.saveTensorsForBackwardMode(L)}return D}}else{const{forwardFunc:b}=e,v=w=>{s&&(r=w.map(I=>this.keep(this.clone(I))))};u=()=>{const w=this.backend.numDataIds();h=this.tidy(()=>b(this.backend,v));const I=Array.isArray(h)?h:[h];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,w,I),I}}const{inputs:c,attrs:d}=e,m=ST(e)?null:e.backwardsFunc;let y;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(y=this.profiler.profileKernel(l,c,()=>u()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(y),t=y.outputs):t=u()}),s&&this.addTapeNode(l,c,t,m,r,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-A,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(b=>c[b]!=null?c[b].shape:null),outputShapes:t.map(b=>b.shape),kernelTimeMs:y.timeMs,extraInfo:y.extraInfo}),Array.isArray(h)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(t=>this.keep(this.clone(t)))}getTensorsForGradient(e,t,r){const s=C8(e);if(s!=null){const o=s.inputsToSave||[],A=s.outputsToSave||[];let u;s.saveAllInputs?(ze(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),u=Object.keys(t).map(l=>t[l])):u=o.map(l=>t[l]);const h=r.filter((l,c)=>A[c]);return u.concat(h)}return[]}makeTensor(e,t,r,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let o=e;r==="string"&&kN(e[0])&&(o=e.map(h=>T8(h)));const A=s.write(o,t,r),u=new Us(t,r,A,this.nextTensorId());if(this.trackTensor(u,s),r==="string"){const h=this.state.tensorInfo.get(A),l=function(c){if(c==null)return 0;let d=0;return c.forEach(m=>d+=m.length),d}(o);this.state.numBytes+=l-h.bytes,h.bytes=l}return u}makeTensorFromDataId(e,t,r,s){const o=new Us(t,r=r||"float32",e,this.nextTensorId());return this.trackTensor(o,s),o}makeVariable(e,t=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));const o=new xT(e,t,r,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null)throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*c1(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof xT||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*c1(e.dtype);this.state.numBytes-=r}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,r,s,o,A){const u={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:r,saved:o},h=C8(e);h!=null&&(s=h.gradFunc),s!=null&&(u.gradient=l=>(l=l.map((c,d)=>{if(c==null){const m=r[d],y=gg(m.size,m.dtype);return this.makeTensor(y,m.shape,m.dtype)}return c}),s(l.length>1?l:l[0],o,A))),this.state.activeTape.push(u)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=D8(e),r=new Set(t.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const A=this.state.activeScope.track[o];A.kept||r.has(A.id)||A.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(o=>{o.kept||o.scopeId!==s.id||this.track(o)})}gradients(e,t,r,s=!1){if(ze(t.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));ze(o instanceof Us,()=>"The result y returned by f() must be a tensor.");const A=function(u,h,l){const c={},d={};for(let v=0;v<h.length;v++)c[h[v].id]=!0;for(let v=0;v<u.length;v++){const w=u[v],I=w.inputs;for(const S in I){const T=I[S];let D=!1;for(let L=0;L<h.length;L++)if(c[T.id]){w.outputs.forEach(W=>c[W.id]=!0),D=!0,d[w.id]=!0;break}if(D)break}}const m={};m[l.id]=!0;const y={};for(let v=u.length-1;v>=0;v--){const w=u[v],I=w.inputs;for(let S=0;S<w.outputs.length;S++)if(m[w.outputs[S].id]){for(const T in I)m[I[T].id]=!0,y[w.id]=!0;break}}const b=[];for(let v=0;v<u.length;v++){const w=u[v];if(d[w.id]&&y[w.id]){const I={};for(const T in w.inputs){const D=w.inputs[T];c[D.id]&&(I[T]=D)}const S=Object.assign({},w);S.inputs=I,S.outputs=w.outputs,b.push(S)}}return b}(this.state.activeTape,t,o);if(!s&&A.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const u={};u[o.id]=r??function(l){const c=PR(Jt(l),"float32");return Xe.makeTensor(c,l,"float32")}(o.shape),function(l,c,d,m){for(let y=c.length-1;y>=0;y--){const b=c[y],v=[];if(b.outputs.forEach(I=>{const S=l[I.id];S!=null?v.push(S):v.push(null)}),b.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${b.kernelName}.`);const w=b.gradient(v);for(const I in b.inputs){if(!(I in w))throw new Error(`Cannot backprop through input ${I}. Available gradients found: ${Object.keys(w)}.`);const S=d(()=>w[I]());if(S.dtype!=="float32")throw new Error(`Error in gradient for op ${b.kernelName}. The gradient of input ${I} must have 'float32' dtype, but has '${S.dtype}'`);const T=b.inputs[I];if(!_c(S.shape,T.shape))throw new Error(`Error in gradient for op ${b.kernelName}. The gradient of input '${I}' has shape '${S.shape}', which does not match the shape of the input '${T.shape}'`);if(l[T.id]==null)l[T.id]=S;else{const D=l[T.id];l[T.id]=m(D,S),D.dispose()}}}}(u,A,l=>this.tidy(l),Ehe);const h=t.map(l=>u[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(const c of l.saved)c.dispose()}),this.state.activeTape=null),{value:o,grads:h}})}customGrad(e){return ze(zR(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{let r;ze(t.every(o=>o instanceof Us),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const s={};return t.forEach((o,A)=>{s[A]=o}),this.runKernelFunc({forwardFunc:(o,A)=>(r=e(...t,A),ze(r.value instanceof Us,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),ze(zR(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),backwardsFunc:(o,A)=>{const u=r.gradFunc(o,A),h=Array.isArray(u)?u:[u];ze(h.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),ze(h.every(c=>c instanceof Us),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const l={};return h.forEach((c,d)=>{l[d]=()=>c}),l},inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}async time(e){const t=eh(),r=await this.backend.time(e);return r.wallMs=eh()-t,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new O8;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function P8(){const n=RR();if(n._tfengine==null){const t=new vhe(n);n._tfengine=new nh(t)}var e;return e=n._tfengine.ENV,LR=e,BA=()=>n._tfengine,n._tfengine}nh.nextTensorId=0,nh.nextVariableId=0;const Xe=P8();function Ehe(n,e){const t={a:n,b:e};return Xe.runKernel(TN,t)}const nA=yr();function xg(n,e){let t=n;if(PA(n))return e==="string"?[]:[n.length];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(t)||PA(t)&&e!=="string";)r.push(t.length),t=t[0];return Array.isArray(n)&&yr().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&B8(n,r,[]),r}function B8(n,e,t){if(t=t||[],!Array.isArray(n)&&!PA(n))return void ze(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);ze(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),ze(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const r=e.slice(1);for(let s=0;s<n.length;++s)B8(n[s],r,t.concat(s))}function F8(n,e,t,r){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${r}' must be ${n} tensor, but got ${e} tensor`)}}function me(n,e,t,r="numeric"){if(n instanceof Us)return F8(r,n.dtype,e,t),n;let s=CN(n);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),F8(r,s,e,t),n==null||!PA(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const u=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${u}'`)}const o=xg(n,s);PA(n)||Array.isArray(n)||(n=[n]);const A=s!=="string"?N8(n,s):l1(n,[],!0);return Xe.makeTensor(A,o,s)}function L8(n,e,t,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((s,o)=>me(s,`${e}[${o}]`,t,r))}function Ge(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const r=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t+="__op";const s=(...o)=>{Xe.startScope(t);try{const A=r(...o);return yg(A)&&console.error("Cannot return a Promise inside of tidy."),Xe.endScope(A),A}catch(A){throw Xe.endScope(null),A}};return Object.defineProperty(s,"name",{value:t,configurable:!0}),s}nA.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),nA.registerFlag("IS_BROWSER",()=>typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"),nA.registerFlag("IS_NODE",()=>typeof process<"u"&&process.versions!==void 0&&process.versions.node!==void 0),nA.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),nA.registerFlag("PROD",()=>!1),nA.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>nA.getBool("DEBUG")),nA.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),nA.registerFlag("IS_TEST",()=>!1),nA.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),nA.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);const ed=Ge({complex_:function(n,e){const t=me(n,"real","complex"),r=me(e,"imag","complex");tA(t.shape,r.shape,`real and imag shapes, ${t.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:t,imag:r};return Xe.runKernel("Complex",s)}});function wg(n,e,t,r){if(r==null&&(r=CN(n)),r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!PA(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){BR(e);const s=Jt(e),o=Jt(t);ze(s===o,()=>`Based on the provided shape, [${e}], the tensor should have ${s} values but has ${o}`);for(let A=0;A<t.length;++A){const u=t[A],h=A!==t.length-1||u!==Jt(e.slice(A));ze(t[A]===e[A]||!h,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return PA(n)||Array.isArray(n)||(n=[n]),e=e||t,n=r!=="string"?N8(n,r):l1(n,[],!0),Xe.makeTensor(n,e,r)}function Eu(n,e,t){return wg(n,e,xg(n,t),t)}const R8={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},NT=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function W8(n){return NT?Buffer.byteLength(n):new Blob([n]).size}function Dhe(n){if(n.length===1)return n[0];let e=0;n.forEach(s=>{e+=s.byteLength});const t=new Uint8Array(e);let r=0;return n.forEach(s=>{t.set(new Uint8Array(s),r),r+=s.byteLength}),t.buffer}function j8(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function y1(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:W8(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:W8(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:n.weightData.byteLength}}function zhe(){const n=function(){const r=o=>{let A=o<<13,u=0;for(;!(8388608&A);)u-=8388608,A<<=1;return A&=-8388609,u+=947912704,A|u},s=new Uint32Array(2048);s[0]=0;for(let o=1;o<1024;o++)s[o]=r(o);for(let o=1024;o<2048;o++)s[o]=939524096+(o-1024<<13);return s}(),e=function(){const r=new Uint32Array(64);r[0]=0,r[31]=1199570944,r[32]=2147483648,r[63]=3347054592;for(let s=1;s<31;s++)r[s]=s<<23;for(let s=33;s<63;s++)r[s]=2147483648+(s-32<<23);return r}(),t=function(){const r=new Uint32Array(64);for(let s=0;s<64;s++)r[s]=1024;return r[0]=r[32]=0,r}();return r=>{const s=new ArrayBuffer(4*r.length),o=new Uint32Array(s);for(let A=0;A<r.length;A++){const u=r[A],h=n[t[u>>10]+(1023&u)]+e[u>>10];o[A]=h}return new Float32Array(s)}}class Bs{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Bs.instance==null&&(Bs.instance=new Bs),Bs.instance}static registerSaveRouter(e){Bs.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Bs.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Bs.getHandlers(e,"save")}static getLoadHandlers(e,t){return Bs.getHandlers(e,"load",t)}static getHandlers(e,t,r){const s=[];return(t==="load"?Bs.getInstance().loadRouters:Bs.getInstance().saveRouters).forEach(o=>{const A=o(e,r);A!==null&&s.push(A)}),s}}const TT="tensorflowjs",td="models_store",Du="model_info_store";function H8(){if(!yr().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function MT(n){const e=n.result;e.createObjectStore(td,{keyPath:"modelPath"}),e.createObjectStore(Du,{keyPath:"modelPath"})}class nd{constructor(e){if(this.indexedDB=H8(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((r,s)=>{const o=this.indexedDB.open(TT,1);o.onupgradeneeded=()=>MT(o),o.onsuccess=()=>{const A=o.result;if(t==null){const u=A.transaction(td,"readonly"),h=u.objectStore(td).get(this.modelPath);h.onsuccess=()=>{if(h.result==null)return A.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(h.result.modelArtifacts)},h.onerror=l=>(A.close(),s(h.error)),u.oncomplete=()=>A.close()}else{const u=y1(t),h=A.transaction(Du,"readwrite");let l=h.objectStore(Du);const c=l.put({modelPath:this.modelPath,modelArtifactsInfo:u});let d;c.onsuccess=()=>{d=A.transaction(td,"readwrite");const m=d.objectStore(td).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:u});m.onsuccess=()=>r({modelArtifactsInfo:u}),m.onerror=y=>{l=h.objectStore(Du);const b=l.delete(this.modelPath);b.onsuccess=()=>(A.close(),s(m.error)),b.onerror=v=>(A.close(),s(m.error))}},c.onerror=m=>(A.close(),s(c.error)),h.oncomplete=()=>{d==null?A.close():d.oncomplete=()=>A.close()}}},o.onerror=A=>s(o.error)})}}nd.URL_SCHEME="indexeddb://";const G8=n=>{return yr().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(nd.URL_SCHEME)?(e=n.slice(nd.URL_SCHEME.length),new nd(e)):null;var e};Bs.registerSaveRouter(G8),Bs.registerLoadRouter(G8);class Ohe{constructor(){this.indexedDB=H8()}async listModels(){return new Promise((e,t)=>{const r=this.indexedDB.open(TT,1);r.onupgradeneeded=()=>MT(r),r.onsuccess=()=>{const s=r.result,o=s.transaction(Du,"readonly"),A=o.objectStore(Du).getAll();A.onsuccess=()=>{const u={};for(const h of A.result)u[h.modelPath]=h.modelArtifactsInfo;e(u)},A.onerror=u=>(s.close(),t(A.error)),o.oncomplete=()=>s.close()},r.onerror=s=>t(r.error)})}async removeModel(e){var t;return e=(t=e).startsWith(nd.URL_SCHEME)?t.slice(nd.URL_SCHEME.length):t,new Promise((r,s)=>{const o=this.indexedDB.open(TT,1);o.onupgradeneeded=()=>MT(o),o.onsuccess=()=>{const A=o.result,u=A.transaction(Du,"readwrite"),h=u.objectStore(Du),l=h.get(e);let c;l.onsuccess=()=>{if(l.result==null)return A.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const d=h.delete(e),m=()=>{c=A.transaction(td,"readwrite");const y=c.objectStore(td).delete(e);y.onsuccess=()=>r(l.result.modelArtifactsInfo),y.onerror=b=>s(l.error)};d.onsuccess=m,d.onerror=y=>(m(),A.close(),s(l.error))}},l.onerror=d=>(A.close(),s(l.error)),u.oncomplete=()=>{c==null?A.close():c.oncomplete=()=>A.close()}},o.onerror=A=>s(o.error)})}}const xl="/",rh="tensorflowjs_models",V8="info",Phe="model_topology",Bhe="weight_specs",Fhe="weight_data",Lhe="model_metadata";function X8(n){return{info:[rh,n,V8].join(xl),topology:[rh,n,Phe].join(xl),weightSpecs:[rh,n,Bhe].join(xl),weightData:[rh,n,Fhe].join(xl),modelMetadata:[rh,n,Lhe].join(xl)}}function Z8(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function Rhe(n){const e=n.split(xl);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(xl)}class rd{constructor(e){if(!yr().getBool("IS_BROWSER")||typeof window>"u"||window.localStorage===void 0)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=X8(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=y1(e);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,function(A){if(NT)return Buffer.from(A).toString("base64");const u=new Uint8Array(A);let h="";for(let l=0,c=u.length;l<c;l++)h+=String.fromCharCode(u[l]);return btoa(h)}(e.weightData));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:s}}catch{throw Z8(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=r;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=s;const o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){const u=JSON.parse(o);t.format=u.format,t.generatedBy=u.generatedBy,t.convertedBy=u.convertedBy,u.signature!=null&&(t.signature=u.signature),u.userDefinedMetadata!=null&&(t.userDefinedMetadata=u.userDefinedMetadata),u.modelInitializer!=null&&(t.modelInitializer=u.modelInitializer),u.trainingConfig!=null&&(t.trainingConfig=u.trainingConfig)}const A=this.LS.getItem(this.keys.weightData);if(A==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(u){if(NT){const c=Buffer.from(u,"base64");return c.buffer.slice(c.byteOffset,c.byteOffset+c.byteLength)}const h=atob(u),l=new Uint8Array(h.length);for(let c=0;c<h.length;++c)l.set([h.charCodeAt(c)],c);return l.buffer}(A),t}}rd.URL_SCHEME="localstorage://";const Y8=n=>{return yr().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(rd.URL_SCHEME)?(e=n.slice(rd.URL_SCHEME.length),new rd(e)):null;var e};Bs.registerSaveRouter(Y8),Bs.registerLoadRouter(Y8);class Whe{constructor(){ze(yr().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),ze(typeof window>"u"||window.localStorage!==void 0,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=rh+xl,r=xl+V8;for(let s=0;s<this.LS.length;++s){const o=this.LS.key(s);o.startsWith(t)&&o.endsWith(r)&&(e[Rhe(o)]=JSON.parse(this.LS.getItem(o)))}return e}async removeModel(e){var t;const r=X8(e=(t=e).startsWith(rd.URL_SCHEME)?t.slice(rd.URL_SCHEME.length):t);if(this.LS.getItem(r.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(r.info));return Z8(r),s}}class zu{constructor(){this.managers={}}static getInstance(){return zu.instance==null&&(zu.instance=new zu),zu.instance}static registerManager(e,t){ze(e!=null,()=>"scheme must not be undefined or null."),e.endsWith("://")&&(e=e.slice(0,e.indexOf("://"))),ze(e.length>0,()=>"scheme must not be an empty string.");const r=zu.getInstance();ze(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=t}static getManager(e){const t=this.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}}class jhe{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}}if(yr().get("IS_BROWSER")){yr().setPlatform("browser",new jhe);try{zu.registerManager(rd.URL_SCHEME,new Whe)}catch{}try{zu.registerManager(nd.URL_SCHEME,new Ohe)}catch{}}let ET;function Ou(n,e="float32",t){return e=e||"float32",BR(n),new vT(n,e,t)}yr().get("IS_NODE")&&yr().setPlatform("node",new class{constructor(){this.util=p(590),this.textEncoder=new this.util.TextEncoder}fetch(n,e){return yr().global.fetch!=null?yr().global.fetch(n,e):(ET==null&&(ET=p(817)),ET(n,e))}now(){const n=process.hrtime();return 1e3*n[0]+n[1]/1e6}encode(n,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(n)}decode(n,e){return n.length===0?"":new this.util.TextDecoder(e).decode(n)}});const ns=Ge({cast_:function(n,e){const t=me(n,"x","cast");if(!function(o){return o==="bool"||o==="complex64"||o==="float32"||o==="int32"||o==="string"}(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:t},s={dtype:e};return Xe.runKernel(BN,r,s)}}),sd=Ge({clone_:function(n){const e={x:me(n,"x","clone","string_or_numeric")};return Xe.runKernel(YN,e)}});function U8(n){return new Promise(e=>setTimeout(e)).then(n)}P8(),th={buffer:Ou,cast:ns,clone:sd,print:function(n,e=!1){console.log(n.toString(e))}};class ad{constructor(e){if(!yr().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(ad.URL_SCHEME)&&(e=e.slice(ad.URL_SCHEME.length)),e!=null&&e.length!==0||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=j8(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),s=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=s,await U8(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const A=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;A.download=this.weightDataFileName,A.href=t,await U8(()=>A.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:y1(e)}}}}function Q8(n,e,t,r){(function(o){ze(o!=null&&Array.isArray(o)&&o.length>0,()=>"promises must be a none empty array")})(n),function(o,A){ze(o>=0&&o<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${o}`),ze(A>=0&&A<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${A}`),ze(A>=o,()=>`startFraction must be no more than endFraction, but got startFraction ${o} and endFraction ${A}`)}(t=t??0,r=r??1);let s=0;return Promise.all(n.map(o=>(o.then(A=>{const u=t+ ++s/n.length*(r-t);return e(u),A}),o)))}async function Hhe(n,e){e==null&&(e={});const t=e.fetchFunc==null?yr().platform.fetch:e.fetchFunc,r=n.map(o=>t(o,e.requestInit,{isBinary:!0})),s=(e.onProgress==null?await Promise.all(r):await Q8(r,e.onProgress,0,.5)).map(o=>o.arrayBuffer());return e.onProgress==null?await Promise.all(s):await Q8(s,e.onProgress,.5,1)}ad.URL_SCHEME="downloads://",Bs.registerSaveRouter(n=>yr().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ad.URL_SCHEME)?function(e="model"){return new ad(e)}(n.slice(ad.URL_SCHEME.length)):null);class DT{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(ze(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=yr().platform.fetch,ze(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&ze(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const r=j8(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);t.body.append("model.json",new Blob([JSON.stringify(r)],{type:"application/json"}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const s=await this.fetch(this.path,t);if(s.ok)return{modelArtifactsInfo:y1(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let A=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?A+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":A+=" Please make sure the server is serving valid JSON for this request.",new Error(A)}const r=t.modelTopology,s=t.weightsManifest;if(r==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return async function(o,A){const u={modelTopology:o.modelTopology,format:o.format,generatedBy:o.generatedBy,convertedBy:o.convertedBy};if(o.trainingConfig!=null&&(u.trainingConfig=o.trainingConfig),o.weightsManifest!=null){const[h,l]=await A(o.weightsManifest);u.weightSpecs=h,u.weightData=l}return o.signature!=null&&(u.signature=o.signature),o.userDefinedMetadata!=null&&(u.userDefinedMetadata=o.userDefinedMetadata),o.modelInitializer!=null&&(u.modelInitializer=o.modelInitializer),u}(t,o=>this.loadWeights(o))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[r,s]=function(l){const c=l.lastIndexOf("/"),d=l.lastIndexOf("?");return[l.substring(0,c)+"/",d>c?l.substring(d):""]}(t),o=this.weightPathPrefix||r,A=[];for(const l of e)A.push(...l.weights);const u=[],h=[];for(const l of e)for(const c of l.paths)this.weightUrlConverter!=null?h.push(this.weightUrlConverter(c)):u.push(o+c+s);return this.weightUrlConverter&&u.push(...await Promise.all(h)),[A,Dhe(await Hhe(u,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function K8(n){return n.match(DT.URL_SCHEME_REGEX)!=null}DT.URL_SCHEME_REGEX=/^https?:\/\//;const q8=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(t=Array.isArray(n)?n.every(r=>K8(r)):K8(n),t)return J8(n,e)}return null};function J8(n,e){return new DT(n,e)}function $8(n,e){return J8(n,e)}let od;Bs.registerSaveRouter(q8),Bs.registerLoadRouter(q8);const Ghe=Ge({fromPixels_:function(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,r=!1,s=!1,o=!1,A=!1,u=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)o=!0;else if(n.getContext!=null)A=!0;else{if(!(typeof ImageBitmap<"u"&&n instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);u=!0}if(s&&s&&n.readyState<2)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");if(gT(k8,Xe.backendName)!=null){const m={pixels:n},y={numChannels:e};return Xe.runKernel(k8,m,y)}const[h,l]=s?[n.videoWidth,n.videoHeight]:[n.width,n.height];let c,d;if(A)c=n.getContext("2d").getImageData(0,0,h,l).data;else if(r||t)c=n.data;else if(o||s||u){if(od==null)if(typeof document>"u"){if(typeof OffscreenCanvas>"u"||typeof OffscreenCanvasRenderingContext2D>"u")throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");od=new OffscreenCanvas(1,1).getContext("2d")}else od=document.createElement("canvas").getContext("2d");od.canvas.width=h,od.canvas.height=l,od.drawImage(n,0,0,h,l),c=od.getImageData(0,0,h,l).data}if(e===4)d=new Int32Array(c);else{const m=h*l;d=new Int32Array(m*e);for(let y=0;y<m;y++)for(let b=0;b<e;++b)d[y*e+b]=c[4*y+b]}return function(m,y,b){if(wN(m),y!=null&&y.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const v=xg(m,b);if(v.length!==3&&v.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(v.length===1&&y==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return wg(m,y,v,b)}(d,[l,h,e],"int32")}});function _8(n,e,t){let r=t.length;for(let s=0;s<t.length;s++)if(t[s]>1){r=s;break}for(let s=r+1;s<t.length;s++)if(e[s]>0||t[s]!==n[s])return!1;return!0}function eW(n,e){let t=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)t+=n[r]*e[r];return t}function tW(n,e,t,r,s,o){if(s[e])return t>0?o[e]:o[e+1&1];{const A=n<0?r+n:n;return A<o[0]?o[0]:A>o[1]?o[1]:A}}const Ca=Ge({add_:function(n,e){let t=me(n,"a","add"),r=me(e,"b","add");[t,r]=ts(t,r);const s={a:t,b:r};return Xe.runKernel(TN,s)}}),To=Ge({concat_:function(n,e=0){ze(n.length>=1,()=>"Pass at least one tensor to concat");const t=L8(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(o=>{if(o.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${o.dtype}. `)}),t.length===1)return sd(t[0]);const r=t,s={axis:e};return Xe.runKernel(HR,r,s)}}),nW=Ge({concat2d_:function(n,e){return To(n,e)}}),rW=Ge({floorDiv_:function(n,e){let t=me(n,"a","floorDiv"),r=me(e,"b","floorDiv");[t,r]=ts(t,r);const s={a:t,b:r};return Xe.runKernel(QR,s)}}),Qs=Ge({div_:function(n,e){let t=me(n,"a","div"),r=me(e,"b","div");if([t,r]=ts(t,r),t.dtype==="int32"&&r.dtype==="int32")return rW(t,r);const s={a:t,b:r};return Xe.runKernel(VR,s,{})}}),Pu=Ge({expandDims_:function(n,e=0){const t=me(n,"x","expandDims","string_or_numeric");ze(e<=t.rank,()=>"Axis must be <= rank of the tensor");const r={input:t},s={dim:e};return Xe.runKernel(ZR,r,s)}}),Dn=Ge({mul_:function(n,e){let t=me(n,"a","mul"),r=me(e,"b","mul");[t,r]=ts(t,r);const s={a:t,b:r};return Xe.runKernel(r8,s)}}),Nt=Ge({reshape_:function(n,e){const t={x:me(n,"x","reshape","string_or_numeric")},r={shape:e};return Xe.runKernel(l8,t,r)}});function fr(n,e){if((PA(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&PA(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return wg(n,[],[],e)}const zT=Ge({sigmoid_:function(n){const e={x:me(n,"x","sigmoid","float32")};return Xe.runKernel(f8,e)}}),$n=Ge({slice_:function(n,e,t){const r=me(n,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const s={x:r},o={begin:e,size:t};return Xe.runKernel(h8,s,o)}}),Bu=Ge({squeeze_:function(n,e){const t=me(n,"x","squeeze");return Nt(t,function(r,s){const o=[],A=[],u=s!=null&&Array.isArray(s)&&s.length===0,h=s==null||u?null:Tu(s,r).sort();let l=0;for(let c=0;c<r.length;++c){if(h!=null){if(h[l]===c&&r[c]!==1)throw new Error(`Can't squeeze axis ${c} since its dim '${r[c]}' is not 1`);(h[l]==null||h[l]>c)&&r[c]===1&&(o.push(r[c]),A.push(c)),h[l]<=c&&l++}r[c]!==1&&(o.push(r[c]),A.push(c))}return{newShape:o,keptDims:A}}(t.shape,e).newShape)}}),wl=Ge({stack_:function(n,e=0){const t=L8(n,"tensors","stack","string_or_numeric");ze(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&ze(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const r=t,s={axis:e};return Xe.runKernel(o8,r,s)}}),_n=Ge({sub_:function(n,e){let t=me(n,"a","sub"),r=me(e,"b","sub");[t,r]=ts(t,r);const s={a:t,b:r};return Xe.runKernel("Sub",s)}});function so(n,e){wN(n);const t=xg(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return wg(n,null,t,e)}function sh(n,e,t){if(wN(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=xg(n,t);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return wg(n,e,r,t)}const id=Ge({unstack_:function(n,e=0){const t=me(n,"x","unstack","string_or_numeric");ze(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const r={value:t},s={axis:e};return Xe.runKernel(x8,r,s)}}),OT=Ge({imag_:function(n){const e={input:me(n,"input","imag")};return Xe.runKernel("Imag",e)}}),b1=Ge({real_:function(n){const e={input:me(n,"input","real")};return Xe.runKernel("Real",e)}}),kg=Ge({split_:function(n,e,t=0){const r={x:me(n,"x","split")},s={numOrSizeSplits:e,axis:t};return Xe.runKernel(y8,r,s)}});function ah(n,e="float32"){if(e==="complex64"){const r=ah(n,"float32"),s=ah(n,"float32");return ed(r,s)}const t=gg(Jt(n),e);return Xe.makeTensor(t,n,e)}const PT=Ge({zerosLike_:function(n){const e={x:me(n,"x","zerosLike")};return Xe.runKernel(w8,e)}}),sW=Ge({fft_:function(n){ze(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return Xe.runKernel("FFT",e)}}),aW=Ge({rfft_:function(n,e){ze(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const r=n.size/t;let s;if(e!=null&&e<t){const b=n.shape.map(w=>0),v=n.shape.map(w=>w);v[n.shape.length-1]=e,s=$n(n,b,v),t=e}else if(e!=null&&e>t){const b=n.shape.map(v=>v);b[n.shape.length-1]=e-t,s=To([n,ah(b)],n.shape.length-1),t=e}else s=n;const o=PT(s),A=Nt(ed(s,o),[r,t]),u=sW(A),h=Math.floor(t/2)+1,l=b1(u),c=OT(u),d=kg(l,[h,t-h],l.shape.length-1),m=kg(c,[h,t-h],c.shape.length-1),y=s.shape.slice();return y[s.shape.length-1]=h,Nt(ed(d[0],m[0]),y)}}),BT=Ge({ifft_:function(n){ze(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return Xe.runKernel("IFFT",e)}}),v1=Ge({reverse_:function(n,e){const t={x:me(n,"x","reverse")},r={dims:e};return Xe.runKernel(iT,t,r)}}),Vhe=Ge({irfft_:function(n){const e=n.shape[n.shape.length-1],t=n.size/e;let r;if(e<=2){const s=Nt(n,[t,e]);r=BT(s)}else{const s=[t,2*(e-1)],o=Nt(b1(n),[t,e]),A=Nt(OT(n),[t,e]),u=v1($n(o,[0,1],[t,e-2]),1),h=Dn(v1($n(A,[0,1],[t,e-2]),1),fr(-1)),l=To([o,u],1),c=To([A,h],1),d=Nt(ed(l,c),[s[0],s[1]]);r=BT(d)}if(r=b1(r),n.rank===3&&n.shape[0]!==0){const s=r,o=n.shape[0];r=Nt(r,[o,r.shape[0]/o,r.shape[1]]),s.dispose()}return r}});function oW(n,e,t){const r=1-n%2,s=new Float32Array(n);for(let o=0;o<n;++o){const A=2*Math.PI*o/(n+r-1);s[o]=e-t*Math.cos(A)}return so(s,"float32")}Ge({hammingWindow_:function(n){return oW(n,.54,.46)}});const Xhe=Ge({hannWindow_:function(n){return oW(n,.5,.5)}});function FT(n,e,t){const r={shape:n,value:e,dtype:t};return Xe.runKernel(YR,{},r)}const Zhe=Ge({frame_:function(n,e,t,r=!1,s=0){let o=0;const A=[];for(;o+e<=n.size;)A.push($n(n,o,e)),o+=t;if(r)for(;o<n.size;){const u=o+e-n.size,h=To([$n(n,o,e-u),FT([u],s)]);A.push(h),o+=t}return A.length===0?sh([],[0,e]):Nt(To(A),[A.length,e])}});Ge({stft_:function(n,e,t,r,s=Xhe){var o;r==null&&(o=e,r=Math.floor(Math.pow(2,Math.ceil(Math.log(o)/Math.log(2)))));const A=Zhe(n,e,t),u=Dn(A,s(e));return aW(u,r)}});const Yhe=Ge({cropAndResize_:function(n,e,t,r,s="bilinear",o=0){const A=me(n,"image","cropAndResize"),u=me(e,"boxes","cropAndResize","float32"),h=me(t,"boxInd","cropAndResize","int32"),l=u.shape[0];ze(A.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${A.rank}.`),ze(u.rank===2&&u.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${u.shape}.`),ze(h.rank===1&&h.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${u.shape}.`),ze(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),ze(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),ze(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const c={image:A,boxes:u,boxInd:h},d={method:s,extrapolationValue:o,cropSize:r};return Xe.runKernel(jN,c,d)}}),Uhe=Ge({flipLeftRight_:function(n){const e=me(n,"image","flipLeftRight","float32");ze(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return Xe.runKernel(VN,t,{})}}),Cg=Ge({tile_:function(n,e){const t=me(n,"x","tile","string_or_numeric");ze(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const r={x:t},s={reps:e};return Xe.runKernel(d1,r,s)}}),Qhe=Ge({grayscaleToRGB_:function(n){const e=me(n,"image","grayscaleToRGB"),t=e.rank-1,r=e.shape[t];ze(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),ze(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(e.rank);return s.fill(1,0,t),s[t]=3,Cg(e,s)}}),Khe=Ge({rotateWithOffset_:function(n,e,t=0,r=.5){const s=me(n,"image","rotateWithOffset","float32");ze(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const o={image:s},A={radians:e,fillValue:t,center:r};return Xe.runKernel(mT,o,A)}});function oh(n,e,t,r,s,o){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),o==null&&(o=0);const A=n.shape[0];return t=Math.min(t,A),ze(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),ze(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),ze(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),ze(e.rank===1,()=>"scores must be a 1D tensor"),ze(e.shape[0]===A,()=>`scores has incompatible shape with boxes. Expected ${A}, but was ${e.shape[0]}`),ze(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:t,iouThreshold:r,scoreThreshold:s,softNmsSigma:o}}const qhe=Ge({nonMaxSuppression_:function(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY){const o=me(n,"boxes","nonMaxSuppression","float32"),A=me(e,"scores","nonMaxSuppression","float32"),u=oh(o,A,t,r,s),h={maxOutputSize:t=u.maxOutputSize,iouThreshold:r=u.iouThreshold,scoreThreshold:s=u.scoreThreshold};return Xe.runKernel(_N,{boxes:o,scores:A},h)}});function Jhe(n,e,t){const r=function(o,A,u){return function(h,l,c){let d=0,m=h.length,y=0,b=!1;for(;d<m;){y=d+(m-d>>>1);const v=c(l,h[y]);v>0?d=y+1:(m=y,b=!v)}return b?d:-d-1}(o,A,u||$he)}(n,e,t),s=r<0?-(r+1):r;n.splice(s,0,e)}function $he(n,e){return n>e?1:n<e?-1:0}function LT(n,e,t,r,s,o,A=!1,u=!1,h=!1){const l=[];for(let w=0;w<e.length;w++)e[w]>s&&l.push({score:e[w],boxIndex:w,suppressBeginIndex:0});l.sort(iW);const c=o>0?-.5/o:0,d=[],m=[];for(;d.length<t&&l.length>0;){const w=l.pop(),{score:I,boxIndex:S,suppressBeginIndex:T}=w;if(I<s)break;let D=!1;for(let L=d.length-1;L>=T;--L){const W=_he(n,S,d[L]);if(W>=r){D=!0;break}if(w.score=w.score*efe(r,c,W),w.score<=s)break}w.suppressBeginIndex=d.length,D||(w.score===I?(d.push(S),m.push(w.score)):w.score>s&&Jhe(l,w,iW))}const y=d.length,b=t-y;u&&b>0&&(d.push(...new Array(b).fill(0)),m.push(...new Array(b).fill(0)));const v={selectedIndices:d};return A&&(v.selectedScores=m),h&&(v.validOutputs=y),v}function _he(n,e,t){const r=n.subarray(4*e,4*e+4),s=n.subarray(4*t,4*t+4),o=Math.min(r[0],r[2]),A=Math.min(r[1],r[3]),u=Math.max(r[0],r[2]),h=Math.max(r[1],r[3]),l=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),m=Math.max(s[1],s[3]),y=(u-o)*(h-A),b=(d-l)*(m-c);if(y<=0||b<=0)return 0;const v=Math.max(o,l),w=Math.max(A,c),I=Math.min(u,d),S=Math.min(h,m),T=Math.max(I-v,0)*Math.max(S-w,0);return T/(y+b-T)}function efe(n,e,t){const r=Math.exp(e*t*t);return t<=n?r:0}function iW(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}const tfe=Ge({nonMaxSuppressionWithScore_:function(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const A=me(n,"boxes","nonMaxSuppression"),u=me(e,"scores","nonMaxSuppression"),h=oh(A,u,t,r,s,o),l={boxes:A,scores:u},c={maxOutputSize:t=h.maxOutputSize,iouThreshold:r=h.iouThreshold,scoreThreshold:s=h.scoreThreshold,softNmsSigma:o=h.softNmsSigma},d=Xe.runKernel(tT,l,c);return{selectedIndices:d[0],selectedScores:d[1]}}}),nfe=Ge({nonMaxSuppressionPadded_:function(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const A=me(n,"boxes","nonMaxSuppression"),u=me(e,"scores","nonMaxSuppression"),h=oh(A,u,t,r,s,null),l={boxes:A,scores:u},c={maxOutputSize:h.maxOutputSize,iouThreshold:h.iouThreshold,scoreThreshold:h.scoreThreshold,padToMaxOutputSize:o},d=Xe.runKernel(eT,l,c);return{selectedIndices:d[0],validOutputs:d[1]}}}),rfe=Ge({resizeBilinear_:function(n,e,t=!1,r=!1){const s=me(n,"images","resizeBilinear");ze(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),ze(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),ze(r===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=s,A=!1;s.rank===3&&(A=!0,o=Nt(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const u={images:o},h={alignCorners:t,halfPixelCenters:r,size:e},l=Xe.runKernel(oT,u,h);return A?Nt(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),sfe=Ge({resizeNearestNeighbor_:function(n,e,t=!1,r=!1){const s=me(n,"images","resizeNearestNeighbor");ze(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),ze(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),ze(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),ze(r===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=s,A=!1;s.rank===3&&(A=!0,o=Nt(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const u={images:o},h={alignCorners:t,halfPixelCenters:r,size:e},l=Xe.runKernel("ResizeNearestNeighbor",u,h);return A?Nt(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),AW=Ge({bincount_:function(n,e,t){const r=me(n,"x","bincount"),s=me(e,"weights","bincount");ze(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),ze(t>=0,()=>`size must be non-negative, but got ${t}.`),ze(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const o={x:r,weights:s},A={size:t};return Xe.runKernel("Bincount",o,A)}});function lW(n,e){const t=n.length,r=[];for(let s=0;s<t;s++){const o=t-1-s,A=n[o]||1;(e[e.length-1-s]||1)>1&&A===1&&r.unshift(o)}return r}function Ia(n,e){const t=[],r=Math.max(n.length,e.length);for(let s=0;s<r;s++){let o=n[n.length-s-1];o==null&&(o=1);let A=e[e.length-s-1];if(A==null&&(A=1),o===1)t.unshift(A);else if(A===1)t.unshift(o);else{if(o!==A)throw Error(`Operands could not be broadcast together with shapes ${n} and ${e}.`);t.unshift(o)}}return t}const RT=Ge({lessEqual_:function(n,e){let t=me(n,"a","lessEqual","string_or_numeric"),r=me(e,"b","lessEqual","string_or_numeric");[t,r]=ts(t,r),Ia(t.shape,r.shape);const s={a:t,b:r};return Xe.runKernel(_R,s)}}),x1=Ge({greater_:function(n,e){let t=me(n,"a","greater","string_or_numeric"),r=me(e,"b","greater","string_or_numeric");[t,r]=ts(t,r),Ia(t.shape,r.shape);const s={a:t,b:r};return Xe.runKernel(qR,s)}}),Or=Ge({sum_:function(n,e=null,t=!1){let r=me(n,"x","sum");r.dtype==="bool"&&(r=ns(r,"int32"));const s={x:r},o={axis:e,keepDims:t};return Xe.runKernel(lT,s,o)}}),uW=Ge({round_:function(n){const e={x:me(n,"x","round")};return Xe.runKernel(c8,e)}}),w1=Ge({broadcastTo_:function(n,e){let t=me(n,"broadcastTo","x");const r=t.shape;if(e.some(h=>!(h>0)||h%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const h=t.shape.slice();for(;h.length<e.length;)h.unshift(1);t=Nt(t,h)}const s=t.shape,o=Array.from(e);for(let h=e.length-1;h>=0;h--)if(s[h]===e[h])o[h]=1;else if(t.shape[h]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(o.map((h,l)=>h>1?l:-1).filter(h=>h>=0).length===0)return sd(t);const A={x:t},u={reps:o};return Xe.runKernel(d1,A,u)}}),ih=Ge({where_:function(n,e,t){const r=me(e,"a","where"),s=me(t,"b","where"),o=me(n,"condition","where","bool"),A=Ia(Ia(o.shape,r.shape),s.shape),u={condition:w1(o,A),t:w1(r,A),e:w1(s,A)};return Xe.runKernel(p8,u)}});function Ig(n,e,t=1,r="float32"){if(t===0)throw new Error("Cannot have a step of zero");const s={start:n,stop:e,step:t,dtype:r};return Xe.runKernel(i8,{},s)}const afe=Ge({threshold_:function(n,e="binary",t=!1,r=.5){const s=me(n,"image","threshold"),o=s.shape[0]*s.shape[1];let A,u,h,l,c=Dn(so([r]),255);if(ze(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),ze(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),ze(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),ze(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),s.shape[2]===3){[A,u,h]=kg(s,[1,1,1],-1);const m=Dn(A,.2989),y=Dn(u,.587),b=Dn(h,.114);l=Ca(Ca(m,y),b)}else l=n;e==="otsu"&&(c=function(m,y){let b,v,w,I,S,T,D=so([-1]),L=so([0]),W=so([0]);for(let K=0;K<m.size-1;K++){b=$n(m,0,K+1),v=$n(m,K+1),S=Qs(Or(b),y),T=Qs(Or(v),y);const U=Or(Dn(b,Ig(0,b.size)));w=Qs(U,Or(b));const _=FT(v.shape,b.size),ee=Ca(Ig(0,v.size),_),re=Dn(v,ee);I=Qs(Or(re),Or(v));const ce=_n(w,I),we=_n(w,I),Ee=Dn(S,T);W=Dn(Dn(Ee,ce),we);const Pe=x1(W,L);L=ih(Pe,W,L),D=ih(Pe,so([K]),D)}return D}(AW(ns(uW(l),"int32"),Eu([]),256),o));const d=t?RT(l,c):x1(l,c);return ns(Dn(d,255),"int32")}}),ofe=Ge({transform_:function(n,e,t="nearest",r="constant",s=0,o){const A=me(n,"image","transform","float32"),u=me(e,"transforms","transform","float32");ze(A.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${A.rank}.`),ze(u.rank===2&&(u.shape[0]===A.shape[0]||u.shape[0]===1)&&u.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),ze(o==null||o.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`);const h={image:A,transforms:u},l={interpolation:t,fillMode:r,fillValue:s,outputShape:o};return Xe.runKernel(pT,h,l)}}),cW=Ge({greaterEqual_:function(n,e){let t=me(n,"a","greaterEqual","string_or_numeric"),r=me(e,"b","greaterEqual","string_or_numeric");[t,r]=ts(t,r),Ia(t.shape,r.shape);const s={a:t,b:r};return Xe.runKernel(JR,s)}}),dW=Ge({logicalAnd_:function(n,e){const t=me(n,"a","logicalAnd","bool"),r=me(e,"b","logicalAnd","bool");Ia(t.shape,r.shape);const s={a:t,b:r};return Xe.runKernel(e8,s)}});Ge({bandPart_:function(n,e,t){ze(e%1==0,()=>`bandPart(): numLower must be an integer, got ${e}.`),ze(t%1==0,()=>`bandPart(): numUpper must be an integer, got ${t}.`);const r=me(n,"a","bandPart");ze(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[o,A]=r.shape.slice(-2);if(!(e<=o))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${o}).`);if(!(t<=A))throw new Error(`bandPart(): numUpper (${t}) must not be greater than the number of columns (${A}).`);e<0&&(e=o),t<0&&(t=A);const u=Nt(Ig(0,o,1,"int32"),[-1,1]),h=Ig(0,A,1,"int32"),l=_n(u,h),c=dW(RT(l,fr(+e,"int32")),cW(l,fr(-t,"int32"))),d=ah([o,A],r.dtype);return Nt(wl(id(Nt(r,[-1,o,A])).map(m=>ih(c,m,d))),s)}});const Mi=Ge({abs_:function(n){const e=me(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return Xe.runKernel("ComplexAbs",t)}{const t={x:e};return Xe.runKernel("Abs",t)}}});function pW(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function Ad(n,e){const t=[],r=n.length;for(let s=0;s<r;s++)e.indexOf(s)===-1&&t.push(n[s]);return[t,e.map(s=>n[s])]}function FA(n,e){return function(t,r,s){const o=t.length+r.length,A=[];let u=0,h=0;for(let l=0;l<o;l++)s.indexOf(l)===-1?A.push(t[u++]):A.push(r[h++]);return A}(n,e.map(t=>1),e)}function Fu(n,e,t){ze(pW(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function hW(n,e){if(pW(n,e))return null;const t=[];for(let r=0;r<e;++r)n.indexOf(r)===-1&&t.push(r);return n.forEach(r=>t.push(r)),t}function Sg(n,e){const t=[];for(let r=e-n;r<e;++r)t.push(r);return t}const Ah=Ge({max_:function(n,e=null,t=!1){const r={x:me(n,"x","max")},s={reductionIndices:e,keepDims:t};return Xe.runKernel(QN,r,s)}}),WT=Ge({min_:function(n,e=null,t=!1){const r={x:me(n,"x","min")},s={axis:e,keepDims:t};return Xe.runKernel(JN,r,s)}}),fW=Ge({pow_:function(n,e){let t=me(n,"base","pow"),r=me(e,"exp","pow");[t,r]=ts(t,r);const s={a:t,b:r};return Xe.runKernel("Pow",s)}}),jT=Ge({sqrt_:function(n){const e={x:me(n,"x","sqrt","float32")};return Xe.runKernel(m8,e)}}),HT=Ge({square_:function(n){const e=me(n,"x","square");return Xe.runKernel("Square",{x:e},{})}});function mW(n,e,t=null){if(n.rank===0)return Mi(n);if(n.rank!==1&&t===null)return mW(Nt(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return Or(Mi(n),t);if(e===1/0)return Ah(Mi(n),t);if(e===-1/0)return WT(Mi(n),t);if(e==="euclidean"||e===2)return jT(Or(fW(Mi(n),fr(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return Ah(Or(Mi(n),t[0]),t[1]-1);if(e===1/0)return Ah(Or(Mi(n),t[1]),t[0]);if(e===-1/0)return WT(Or(Mi(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return jT(Or(HT(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const gW=Ge({norm_:function(n,e="euclidean",t=null,r=!1){const s=mW(n=me(n,"x","norm"),e,t);let o=s.shape;if(r){const A=Tu(t,n.shape);o=FA(s.shape,A)}return Nt(s,o)}});function ur(n,e){return Xe.tidy(n,e)}function Lu(n){return Xe.keep(n)}Ge({gramSchmidt_:function(n){let e;if(Array.isArray(n)){e=!1,ze(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=n[0].shape[0];for(let o=1;o<n.length;++o)ze(n[o].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[o].shape[0]} vs. ${s})`)}else e=!0,n=kg(n,n.shape[0],0).map(s=>Bu(s,[0]));ze(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],r=n;for(let s=0;s<n.length;++s)t.push(Xe.tidy(()=>{let o=r[s];if(s>0)for(let A=0;A<s;++A){const u=Dn(Or(Dn(t[A],o)),t[A]);o=_n(o,u)}return Qs(o,gW(o,"euclidean"))}));return e?wl(t,0):t}});const ife=Ge({eye_:function(n,e,t,r="float32"){e==null&&(e=n);const s=Ou([n,e],r),o=n<=e?n:e;for(let u=0;u<o;++u)s.set(1,u,u);const A=Nt(s.toTensor(),[n,e]);if(t==null)return A;if(t.length===1)return Cg(Pu(A,0),[t[0],1,1]);if(t.length===2)return Cg(Pu(Pu(A,0),0),[t[0],t[1],1,1]);if(t.length===3)return Cg(Pu(Pu(Pu(A,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}}),Ks=Ge({matMul_:function(n,e,t=!1,r=!1){let s=me(n,"a","matMul"),o=me(e,"b","matMul");[s,o]=ts(s,o);const A={a:s,b:o},u={transposeA:t,transposeB:r};return Xe.runKernel(PN,A,u)}}),Ng=Ge({neg_:function(n){const e={x:me(n,"x","neg")};return Xe.runKernel("Neg",e)}}),GT=Ge({transpose_:function(n,e){const t=me(n,"x","transpose");if(e==null&&(e=t.shape.map((o,A)=>A).reverse()),ze(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of perm ${e}.`),e.forEach(o=>{ze(o>=0&&o<t.rank,()=>"All entries in 'perm' must be between 0 and "+(t.rank-1)+` but got ${e}`)}),t.rank<=1)return t.clone();const r={x:t},s={perm:e};return Xe.runKernel(hT,r,s)}});function yW(n,e=!1){return Xe.tidy(()=>{ze(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],r=n.shape[1];let s=ife(t),o=sd(n);const A=sh([[1]],[1,1]);let u=sd(A);const h=t>=r?r:t;for(let l=0;l<h;++l){const c=o,d=u,m=s;[u,o,s]=Xe.tidy(()=>{const y=$n(o,[l,l],[t-l,1]),b=gW(y),v=$n(o,[l,l],[1,1]),w=ih(x1(v,0),sh([[-1]]),sh([[1]])),I=_n(v,Dn(w,b)),S=Qs(y,I);u=S.shape[0]===1?sd(A):To([A,$n(S,[1,0],[S.shape[0]-1,S.shape[1]])],0);const T=Ng(Qs(Ks(w,I),b)),D=$n(o,[l,0],[t-l,r]),L=Dn(T,u),W=GT(u);if(l===0)o=_n(D,Ks(L,Ks(W,D)));else{const _=_n(D,Ks(L,Ks(W,D)));o=To([$n(o,[0,0],[l,r]),_],0)}const K=GT(L),U=$n(s,[0,l],[t,s.shape[1]-l]);if(l===0)s=_n(U,Ks(Ks(U,u),K));else{const _=_n(U,Ks(Ks(U,u),K));s=To([$n(s,[0,0],[t,l]),_],1)}return[u,o,s]}),D8([c,d,m]).forEach(y=>y.dispose())}return!e&&t>r&&(s=$n(s,[0,0],[t,r]),o=$n(o,[0,0],[r,r])),[s,o]})}var ao;Ge({qr_:function(n,e=!1){if(ze(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return yW(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((A,u)=>A*u),r=id(Nt(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),s=[],o=[];return r.forEach(A=>{const[u,h]=yW(A,e);s.push(u),o.push(h)}),[Nt(wl(s,0),n.shape),Nt(wl(o,0),n.shape)]}}}),function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(ao||(ao={}));const bW=Ge({mean_:function(n,e=null,t=!1){const r={x:me(n,"x","mean")},s={axis:e,keepDims:t};return Xe.runKernel(qN,r,s)}}),vW=Ge({notEqual_:function(n,e){let t=me(n,"a","notEqual","string_or_numeric"),r=me(e,"b","notEqual","string_or_numeric");[t,r]=ts(t,r),Ia(t.shape,r.shape);const s={a:t,b:r};return Xe.runKernel(s8,s)}});function VT(n,e="float32"){if(e==="complex64"){const r=VT(n,"float32"),s=ah(n,"float32");return ed(r,s)}const t=PR(Jt(n),e);return Xe.makeTensor(t,n,e)}const Ru=Ge({computeWeightedLoss_:function(n,e,t=ao.SUM_BY_NONZERO_WEIGHTS){const r=me(n,"losses","computeWeightedLoss");let s=null;e!=null&&(s=me(e,"weights","computeWeightedLoss"));const o=s==null?r:Dn(r,s);if(t===ao.NONE)return o;if(t===ao.SUM)return Or(o);if(t===ao.MEAN){if(s==null)return bW(o);{const A=r.size/s.size,u=Qs(Or(o),Or(s));return A>1?Qs(u,fr(A)):u}}if(t===ao.SUM_BY_NONZERO_WEIGHTS){if(s==null)return Qs(Or(o),fr(r.size));{const A=Dn(s,VT(r.shape)),u=ns(Or(vW(A,fr(0))),"float32");return Qs(Or(o),u)}}throw Error(`Unknown reduction: ${t}`)}});Ge({absoluteDifference_:function(n,e,t,r=ao.SUM_BY_NONZERO_WEIGHTS){const s=me(n,"labels","absoluteDifference"),o=me(e,"predictions","absoluteDifference");let A=null;t!=null&&(A=me(t,"weights","absoluteDifference")),tA(s.shape,o.shape,"Error in absoluteDifference: ");const u=Mi(_n(s,o));return Ru(u,A,r)}}),Ge({cosineDistance_:function(n,e,t,r,s=ao.SUM_BY_NONZERO_WEIGHTS){const o=me(n,"labels","cosineDistance"),A=me(e,"predictions","cosineDistance");let u=null;r!=null&&(u=me(r,"weights","cosineDistance")),tA(o.shape,A.shape,"Error in cosineDistance: ");const h=fr(1),l=_n(h,Or(Dn(o,A),t,!0));return Ru(l,u,s)}});const k1=Ge({relu_:function(n){const e={x:me(n,"x","relu")};return Xe.runKernel(A8,e)}});Ge({hingeLoss_:function(n,e,t,r=ao.SUM_BY_NONZERO_WEIGHTS){let s=me(n,"labels","hingeLoss");const o=me(e,"predictions","hingeLoss");let A=null;t!=null&&(A=me(t,"weights","hingeLoss")),tA(s.shape,o.shape,"Error in hingeLoss: ");const u=fr(1);s=_n(Dn(fr(2),s),u);const h=k1(_n(u,Dn(s,o)));return Ru(h,A,r)}});const xW=Ge({minimum_:function(n,e){let t=me(n,"a","minimum"),r=me(e,"b","minimum");[t,r]=ts(t,r),t.dtype==="bool"&&(t=ns(t,"int32"),r=ns(r,"int32")),Ia(t.shape,r.shape);const s={a:t,b:r};return Xe.runKernel(n8,s)}});Ge({huberLoss_:function(n,e,t,r=1,s=ao.SUM_BY_NONZERO_WEIGHTS){const o=me(n,"labels","huberLoss"),A=me(e,"predictions","huberLoss");let u=null;t!=null&&(u=me(t,"weights","huberLoss")),tA(o.shape,A.shape,"Error in huberLoss: ");const h=fr(r),l=Mi(_n(A,o)),c=xW(l,h),d=_n(l,c),m=Ca(Dn(fr(.5),HT(c)),Dn(h,d));return Ru(m,u,s)}});const Tg=Ge({log_:function(n){const e={x:me(n,"x","log","float32")};return Xe.runKernel("Log",e)}});Ge({logLoss_:function(n,e,t,r=1e-7,s=ao.SUM_BY_NONZERO_WEIGHTS){const o=me(n,"labels","logLoss"),A=me(e,"predictions","logLoss");let u=null;t!=null&&(u=me(t,"weights","logLoss")),tA(o.shape,A.shape,"Error in logLoss: ");const h=fr(1),l=fr(r),c=Ng(Dn(o,Tg(Ca(A,l)))),d=Dn(_n(h,o),Tg(Ca(_n(h,A),l))),m=_n(c,d);return Ru(m,u,s)}});const wW=Ge({squaredDifference_:function(n,e){let t=me(n,"a","squaredDifference"),r=me(e,"b","squaredDifference");[t,r]=ts(t,r),Ia(t.shape,r.shape);const s={a:t,b:r};return Xe.runKernel(b8,s,{})}});Ge({meanSquaredError_:function(n,e,t,r=ao.SUM_BY_NONZERO_WEIGHTS){const s=me(n,"labels","meanSquaredError"),o=me(e,"predictions","meanSquaredError");let A=null;t!=null&&(A=me(t,"weights","meanSquaredError")),tA(s.shape,o.shape,"Error in meanSquaredError: ");const u=wW(s,o);return Ru(u,A,r)}});const ld=Ge({exp_:function(n){const e={x:me(n,"x","exp")};return Xe.runKernel("Exp",e)}}),kW=Ge({log1p_:function(n){const e={x:me(n,"x","log1p")};return Xe.runKernel("Log1p",e)}});function Wu(n){return Xe.customGrad(n)}Ge({sigmoidCrossEntropy_:function(n,e,t,r=0,s=ao.SUM_BY_NONZERO_WEIGHTS){let o=me(n,"multiClassLabels","sigmoidCrossEntropy");const A=me(e,"logits","sigmoidCrossEntropy");let u=null;if(t!=null&&(u=me(t,"weights","sigmoidCrossEntropy")),tA(o.shape,A.shape,"Error in sigmoidCrossEntropy: "),r>0){const l=fr(r),c=fr(1),d=fr(.5);o=Ca(Dn(o,_n(c,l)),Dn(d,l))}const h=function(l,c){const d=me(l,"labels","sigmoidCrossEntropyWithLogits"),m=me(c,"logits","sigmoidCrossEntropyWithLogits");tA(d.shape,m.shape,"Error in sigmoidCrossEntropyWithLogits: ");const y=k1(m),b=Dn(m,d),v=kW(ld(Ng(Mi(m))));return Ca(_n(y,b),v)}(o,A);return Ru(h,u,s)}});const Afe=Ge({logSumExp_:function(n,e=null,t=!1){const r=me(n,"x","logSumExp"),s=Tu(e,r.shape),o=Ah(r,s,!0),A=_n(r,o),u=ld(A),h=Or(u,s),l=Tg(h),c=Ca(Nt(o,l.shape),l);if(t){const d=FA(c.shape,s);return Nt(c,d)}return c}});Ge({softmaxCrossEntropy_:function(n,e,t,r=0,s=ao.SUM_BY_NONZERO_WEIGHTS){let o=me(n,"onehotLabels","softmaxCrossEntropy");const A=me(e,"logits","softmaxCrossEntropy");let u=null;if(t!=null&&(u=me(t,"weights","softmaxCrossEntropy")),tA(o.shape,A.shape,"Error in softmaxCrossEntropy: "),r>0){const l=fr(r),c=fr(1),d=fr(o.shape[1]);o=Ca(Dn(o,_n(c,l)),Qs(l,d))}const h=function(l,c,d=-1){if(d===-1&&(d=c.rank-1),d!==c.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${c.rank} and dim was ${d}`);return Wu((y,b,v)=>{const w=Afe(b,[d],!0),I=_n(ns(b,"float32"),w);v([y,I]);const S=Ng(Dn(I,y));return{value:Or(S,[d]),gradFunc:(T,D)=>{const[L,W]=D,K=FA(T.shape,[d]);return[Dn(Nt(T,K),_n(ns(L,"float32"),ld(W))),Dn(Nt(T,K),_n(ld(W),ns(L,"float32")))]}}})(l,c)}(o,A);return Ru(h,u,s)}});const lfe=Ge({sparseFillEmptyRows_:function(n,e,t,r){const s=me(n,"indices","sparseFillEmptyRows"),o=me(e,"values","sparseFillEmptyRows"),A=me(t,"denseShape","sparseFillEmptyRows"),u=me(r,"defaultValue","sparseFillEmptyRows",o.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(o.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(A.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${A.shape}`);if(u.rank!==0)throw new Error(`Default value should be a scalar but received shape ${u.shape}`);const h={indices:s,values:o,denseShape:A,defaultValue:u},l=Xe.runKernel("SparseFillEmptyRows",h);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}}),ufe=Ge({sparseReshape_:function(n,e,t){const r=me(n,"inputIndices","sparseReshape"),s=me(e,"inputShape","sparseReshape"),o=me(t,"newShape","sparseReshape");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(o.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const A={inputIndices:r,inputShape:s,newShape:o},u=Xe.runKernel("SparseReshape",A);return{outputIndices:u[0],outputShape:u[1]}}}),cfe=Ge({sparseSegmentMean_:function(n,e,t){const r=me(n,"data","sparseSegmentMean"),s=me(e,"indices","sparseSegmentMean"),o=me(t,"segmentIds","sparseSegmentMean");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${o.shape}`);const A={data:r,indices:s,segmentIds:o};return Xe.runKernel("SparseSegmentMean",A)}}),dfe=Ge({sparseSegmentSum_:function(n,e,t){const r=me(n,"data","sparseSegmentSum"),s=me(e,"indices","sparseSegmentSum"),o=me(t,"segmentIds","sparseSegmentSum");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${o.shape}`);const A={data:r,indices:s,segmentIds:o};return Xe.runKernel("SparseSegmentSum",A)}}),pfe=Ge({stringNGrams_:function(n,e,t,r,s,o,A,u){const h=me(n,"data","stringNGrams","string");if(h.dtype!=="string")throw new Error("Data must be of datatype string");if(h.shape.length!==1)throw new Error(`Data must be a vector, saw: ${h.shape}`);const l=me(e,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const c={separator:t,nGramWidths:r,leftPad:s,rightPad:o,padWidth:A,preserveShortSequences:u},d={data:h,dataSplits:l},m=Xe.runKernel("StringNGrams",d,c);return{nGrams:m[0],nGramsSplits:m[1]}}}),hfe=Ge({stringSplit_:function(n,e,t=!0){const r=me(n,"input","stringSplit","string"),s=me(e,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const o={skipEmpty:t},A={input:r,delimiter:s},u=Xe.runKernel("StringSplit",A,o);return{indices:u[0],values:u[1],shape:u[2]}}}),ffe=Ge({stringToHashBucketFast_:function(n,e){const t=me(n,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const s={input:t};return Xe.runKernel("StringToHashBucketFast",s,r)}}),ju={flipLeftRight:Uhe,grayscaleToRGB:Qhe,resizeNearestNeighbor:sfe,resizeBilinear:rfe,rotateWithOffset:Khe,cropAndResize:Yhe,nonMaxSuppression:qhe,nonMaxSuppressionAsync:async function(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY){const o=me(n,"boxes","nonMaxSuppressionAsync"),A=me(e,"scores","nonMaxSuppressionAsync"),u=oh(o,A,t,r,s);t=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold;const h=await Promise.all([o.data(),A.data()]),l=h[0],c=h[1],{selectedIndices:d}=function(m,y,b,v,w){return LT(m,y,b,v,w,0)}(l,c,t,r,s);return o!==n&&o.dispose(),A!==e&&A.dispose(),so(d,"int32")},nonMaxSuppressionWithScore:tfe,nonMaxSuppressionWithScoreAsync:async function(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const A=me(n,"boxes","nonMaxSuppressionAsync"),u=me(e,"scores","nonMaxSuppressionAsync"),h=oh(A,u,t,r,s,o);t=h.maxOutputSize,r=h.iouThreshold,s=h.scoreThreshold,o=h.softNmsSigma;const l=await Promise.all([A.data(),u.data()]),c=l[0],d=l[1],{selectedIndices:m,selectedScores:y}=function(b,v,w,I,S,T){return LT(b,v,w,I,S,T,!0)}(c,d,t,r,s,o);return A!==n&&A.dispose(),u!==e&&u.dispose(),{selectedIndices:so(m,"int32"),selectedScores:so(y)}},nonMaxSuppressionPadded:nfe,nonMaxSuppressionPaddedAsync:async function(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const A=me(n,"boxes","nonMaxSuppressionAsync"),u=me(e,"scores","nonMaxSuppressionAsync"),h=oh(A,u,t,r,s,null),l=h.maxOutputSize,c=h.iouThreshold,d=h.scoreThreshold,[m,y]=await Promise.all([A.data(),u.data()]),{selectedIndices:b,validOutputs:v}=function(w,I,S,T,D,L){return LT(w,I,S,T,D,0,!1,L,!0)}(m,y,l,c,d,o);return A!==n&&A.dispose(),u!==e&&u.dispose(),{selectedIndices:so(b,"int32"),validOutputs:fr(v,"int32")}},threshold:afe,transform:ofe},C1={sparseFillEmptyRows:lfe,sparseReshape:ufe,sparseSegmentMean:cfe,sparseSegmentSum:dfe},XT={stringNGrams:pfe,stringSplit:hfe,stringToHashBucketFast:ffe};function ZT(n,e){const t=n[0].slice();for(let r=1;r<n.length;r++)t[e]+=n[r][e];return t}function CW(n,e,t,r,s,o,A="channelsLast"){const[u,h]=I1(e);let l;if(A==="channelsLast")l=[u,h,n[3],n[3]];else{if(A!=="channelsFirst")throw new Error(`Unknown dataFormat ${A}`);l=[u,h,n[1],n[1]]}return Hu(n,l,t,r,s,o,!1,A)}function Hu(n,e,t,r,s,o,A=!1,u="channelsLast"){let[h,l,c,d]=[-1,-1,-1,-1];if(u==="channelsLast")[h,l,c,d]=n;else{if(u!=="channelsFirst")throw new Error(`Unknown dataFormat ${u}`);[h,d,l,c]=n}const[m,y,,b]=e,[v,w]=I1(t),[I,S]=I1(r),T=YT(m,I),D=YT(y,S),{padInfo:L,outHeight:W,outWidth:K}=function(ee,re,ce,we,Ee,Pe,he,de,Ae){let Se,Te,Ze;if(typeof ee=="number"){Se={top:ee,bottom:ee,left:ee,right:ee,type:ee===0?"VALID":"NUMBER"};const et=function(qe,Re,Ue,ot,yt){ot==null&&(ot=function(ln,en,Xt,hn=1){const wn=YT(en,hn);return Math.floor((ln[0]*(Xt-1)-Xt+wn)/2)}(qe,Re,Ue));const Vt=qe[1];return[S1((qe[0]-Re+2*ot)/Ue+1,yt),S1((Vt-Re+2*ot)/Ue+1,yt)]}([re,ce],Pe,we,ee,de);Te=et[0],Ze=et[1]}else if(ee==="same"){Te=Math.ceil(re/we),Ze=Math.ceil(ce/Ee);const et=Math.max(0,(Te-1)*we+Pe-re),qe=Math.max(0,(Ze-1)*Ee+he-ce),Re=Math.floor(et/2),Ue=et-Re,ot=Math.floor(qe/2);Se={top:Re,bottom:Ue,left:ot,right:qe-ot,type:"SAME"}}else if(ee==="valid")Se={top:0,bottom:0,left:0,right:0,type:"VALID"},Te=Math.ceil((re-Pe+1)/we),Ze=Math.ceil((ce-he+1)/Ee);else{if(typeof ee!="object")throw Error(`Unknown padding parameter: ${ee}`);{const et=Ae==="channelsLast"?ee[1][0]:ee[2][0],qe=Ae==="channelsLast"?ee[1][1]:ee[2][1],Re=Ae==="channelsLast"?ee[2][0]:ee[3][0],Ue=Ae==="channelsLast"?ee[2][1]:ee[3][1];Se={top:et,bottom:qe,left:Re,right:Ue,type:et===0&&qe===0&&Re===0&&Ue===0?"VALID":"EXPLICIT"},Te=S1((re-Pe+et+qe)/we+1,de),Ze=S1((ce-he+Re+Ue)/Ee+1,de)}}return{padInfo:Se,outHeight:Te,outWidth:Ze}}(s,l,c,v,w,T,D,o,u),U=A?b*d:b;let _;return u==="channelsFirst"?_=[h,U,W,K]:u==="channelsLast"&&(_=[h,W,K,U]),{batchSize:h,dataFormat:u,inHeight:l,inWidth:c,inChannels:d,outHeight:W,outWidth:K,outChannels:U,padInfo:L,strideHeight:v,strideWidth:w,filterHeight:m,filterWidth:y,effectiveFilterHeight:T,effectiveFilterWidth:D,dilationHeight:I,dilationWidth:S,inShape:n,outShape:_,filterShape:e}}function I1(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function YT(n,e){return e<=1?n:n+(n-1)*(e-1)}function S1(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function N1(n){const[e,t,r]=I1(n);return e===1&&t===1&&r===1}function ud(n,e){return N1(n)||N1(e)}function IW(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}const SW=Ge({elu_:function(n){const e={x:me(n,"x","elu","float32")};return Xe.runKernel("Elu",e)}}),NW=Ge({leakyRelu_:function(n,e=.2){const t={x:me(n,"x","leakyRelu")},r={alpha:e};return Xe.runKernel(UN,t,r)}}),TW=Ge({prelu_:function(n,e){const t={x:me(n,"x","prelu"),alpha:me(e,"alpha","prelu")};return Xe.runKernel(sT,t)}}),MW=Ge({relu6_:function(n){const e={x:me(n,"x","relu6")};return Xe.runKernel(u8,e)}}),mfe=Ge({step_:function(n,e=0){const t={x:me(n,"x","step")},r={alpha:e};return Xe.runKernel(fT,t,r)}});function UT(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return Dn(n,mfe(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function QT(n,e){let t=e;const r=function(s,o){const A=[];for(let u=0;u<o.length;u++){const h=s[s.length-u-1],l=o.length-u-1,c=o[l];(h==null||h===1&&c>1)&&A.unshift(l)}return A}(n.shape,e.shape);return r.length>0&&(t=Or(t,r)),Nt(t,n.shape)}function KT(n,e,t,r){if(e==="linear")return n;if(e==="relu")return k1(n);if(e==="elu")return SW(n);if(e==="relu6")return MW(n);if(e==="prelu")return TW(n,t);if(e==="leakyrelu")return NW(n,r);if(e==="sigmoid")return zT(n);throw new Error(`Unknown fused activation ${e}.`)}const qT=(n,e)=>!(n>0)||e==="linear";function EW(n,e,t,r=!0){let s=[];if(r)s=s.concat(e.slice(0)),s.push(n[0]/t),s=s.concat(n.slice(1));else{s=s.concat(n[0]);const o=e.length;for(let A=0;A<o;++A)s=s.concat([n[A+1]/e[A],e[A]]);s=s.concat(n.slice(o+1))}return s}function DW(n,e,t=!0){const r=[];if(t){r.push(e);for(let s=e+1;s<n;++s)s<=2*e?(r.push(s),r.push(s-(e+1))):r.push(s)}else{const s=[],o=[];for(let A=1;A<n;++A)A>=2*e+1||A%2==1?o.push(A):s.push(A);r.push(...s),r.push(0),r.push(...o)}return r}function zW(n,e,t,r=!0){const s=[];r?s.push(n[0]/t):s.push(n[0]*t);for(let o=1;o<n.length;++o)o<=e.length?r?s.push(e[o-1]*n[o]):s.push(n[o]/e[o-1]):s.push(n[o]);return s}function OW(n){try{return n.map(e=>bT(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function PW(n){return n.map(e=>T8(e))}var xs,LA,Mg,Mo;let BW;(LA=xs||(xs={}))[LA.float32=0]="float32",LA[LA.int32=1]="int32",LA[LA.bool=2]="bool",LA[LA.string=3]="string",LA[LA.complex64=4]="complex64",(Mo=Mg||(Mg={}))[Mo.linear=0]="linear",Mo[Mo.relu=1]="relu",Mo[Mo.relu6=2]="relu6",Mo[Mo.prelu=3]="prelu",Mo[Mo.leakyrelu=4]="leakyrelu",Mo[Mo.sigmoid=5]="sigmoid",Mo[Mo.elu=6]="elu";const gfe={kernelName:p1,backendName:"wasm",setupFunc:function(n){BW=n.wasm.cwrap(p1,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])},kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:o,bias:A,preluActivationWeights:u}=e;if(s.dtype!=="float32"||o.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");const{transposeA:h,transposeB:l,activation:c,leakyreluAlpha:d}=r,m=t.dataIdMap.get(s.dataId).id,y=t.dataIdMap.get(o.dataId).id;let b=0;if(A!=null){const U=t.dataIdMap.get(A.dataId);if(U.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${U.shape.length}.`);b=U.id}const v=u==null?0:t.dataIdMap.get(u.dataId).id,w=Mg[c];if(w==null)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);const I=h?s.shape[2]:s.shape[1],S=l?o.shape[1]:o.shape[2],T=s.shape[0],D=t.makeOutput([T,I,S],s.dtype),L=t.dataIdMap.get(D.dataId).id,W=new Uint8Array(new Int32Array(s.shape).buffer),K=new Uint8Array(new Int32Array(o.shape).buffer);return BW(m,W,s.shape.length,y,K,o.shape.length,h,l,w,b,v,d||0,L),D}};function ua(n,e){let t;return{kernelName:n,backendName:"wasm",setupFunc:function(r){t=r.wasm.cwrap(n,null,["number","number","number"])},kernelFunc:function(r){const{backend:s,inputs:{x:o}}=r,A=s.dataIdMap.get(o.dataId).id,u=s.makeOutput(o.shape,e||o.dtype),h=s.dataIdMap.get(u.dataId).id;return Jt(u.shape)===0||t(A,xs[o.dtype],h),u}}}const yfe=ua("Abs");function Va(n,e,t){let r;return{kernelName:n,backendName:"wasm",setupFunc:function(s){r=s.wasm.cwrap(n,null,["number","array","number","number","array","number","number","number"])},kernelFunc:function(s){const{backend:o,inputs:A}=s,{a:u,b:h}=A,l=o.dataIdMap.get(u.dataId).id,c=o.dataIdMap.get(h.dataId).id,d=t??u.dtype,m=Ia(u.shape,h.shape),y=o.makeOutput(m,d);if(Jt(m)===0)return y;const b=new Uint8Array(new Int32Array(u.shape).buffer),v=new Uint8Array(new Int32Array(h.shape).buffer),w=o.dataIdMap.get(y.dataId).id,I=()=>r(l,b,u.shape.length,c,v,h.shape.length,xs[u.dtype],w);if(e&&u.dtype==="float32")return I(),y;const S=lW(u.shape,m),T=lW(h.shape,m),D=S.every((W,K)=>W===K),L=T.every((W,K)=>W===K);if(D&&L)return I(),y;throw new Error(`Broadcasting along outer dims is not yet supported for ${u.dtype} ${n}.`)}}}const bfe=Va(TN,!0);let FW;const vfe={kernelName:MN,backendName:"wasm",setupFunc:function(n){FW=n.wasm.cwrap(MN,null,["array","number","number","number"])},kernelFunc:function(n){const{inputs:e,backend:t}=n,r=t.makeOutput(e[0].shape,e[0].dtype);if(Jt(r.shape)===0)return r;const s=e.map(u=>t.dataIdMap.get(u.dataId).id),o=new Uint8Array(new Int32Array(s).buffer),A=t.dataIdMap.get(r.dataId).id;return FW(o,s.length,xs[r.dtype],A),r}};function T1(n){const{inputs:{x:e},backend:t}=n,r=t.makeOutput(e.shape,e.dtype),s=t.typedArrayFromHeap(e);return t.typedArrayFromHeap(r).set(s),r}const xfe={kernelName:YN,backendName:"wasm",kernelFunc:T1};let LW;function lh(n){const{inputs:e,backend:t,attrs:r}=n,[s,o]=function(b,v){const w=[],I=[];for(let S=0;S<b.length;++S)b[S]!==1&&w.push(b[S]),b[v[S]]!==1&&I.push(v[S]);for(let S=0;S<I.length;++S){let T=-1;for(let D=0;D<I.length;++D)I[D]>=S&&(T===-1||I[T]>I[D])&&(T=D);I[T]=S}return[w,I]}(e.x.shape,r.perm);let A=!0;for(let b=0;b<o.length;b++)o[b]!==b&&(A=!1);const u=function(b,v){const w=new Array(b.length);for(let I=0;I<w.length;I++)w[I]=b[v[I]];return w}(e.x.shape,r.perm),h={dataId:e.x.dataId,shape:s,dtype:e.x.dtype};if(A){const b=T1({inputs:e,backend:t});return b.shape=u,b}const l=t.makeOutput(u,h.dtype),c=t.dataIdMap.get(h.dataId).id,d=t.dataIdMap.get(l.dataId).id,m=new Uint8Array(new Int32Array(o).buffer),y=new Uint8Array(new Int32Array(h.shape).buffer);return LW(c,y,h.shape.length,xs[h.dtype],d,m,o.length),l}const wfe={kernelName:hT,backendName:"wasm",kernelFunc:lh,setupFunc:function(n){LW=n.wasm.cwrap(hT,null,["number","array","number","number","number","array","number"])}};function Gu(n,e,t){const r=n.shape,s=n.shape.length,o=Tu(e,r);let A=o;const u=hW(A,s);let h=null,l=!1;if(u!=null){const c=new Array(s);for(let m=0;m<c.length;m++)c[m]=r[u[m]];A=Sg(A.length,s),h=lh({inputs:{x:n},attrs:{perm:u},backend:t});const d=t.dataIdMap.get(n.dataId).id;t.dataIdMap.get(h.dataId).id!==d&&(l=!0)}return{transposed:h,originalAxes:o,axes:A,inputWasTransposed:l}}let RW;const kfe={kernelName:EN,backendName:"wasm",setupFunc:function(n){RW=n.wasm.cwrap(EN,null,["number, number, number"])},kernelFunc:function(n){const{backend:e,inputs:t,attrs:r}=n,{axis:s,keepDims:o}=r,{x:A}=t;let u=e.dataIdMap.get(A.dataId).id,h=A;const{transposed:l,axes:c,originalAxes:d,inputWasTransposed:m}=Gu(A,s,e);m&&(h=l,u=e.dataIdMap.get(l.dataId).id),Fu("all",c,h.shape.length);const[y,b]=Ad(h.shape,c),v=Jt(b),w=e.makeOutput(y,A.dtype);if(Jt(h.shape)!==0){const I=e.dataIdMap.get(w.dataId).id;RW(u,v,I)}if(m&&e.disposeData(l.dataId),o){const I=FA(w.shape,d);w.shape=I}return w}};let WW;const Cfe={kernelName:DN,backendName:"wasm",setupFunc:function(n){WW=n.wasm.cwrap(DN,null,["number, number, number"])},kernelFunc:function(n){const{backend:e,inputs:t,attrs:r}=n,{axis:s,keepDims:o}=r,{x:A}=t;let u=e.dataIdMap.get(A.dataId).id,h=A;const{transposed:l,axes:c,originalAxes:d,inputWasTransposed:m}=Gu(A,s,e);m&&(h=l,u=e.dataIdMap.get(l.dataId).id),Fu("any",c,h.shape.length);const[y,b]=Ad(h.shape,c),v=Jt(b),w=e.makeOutput(y,A.dtype);if(Jt(h.shape)!==0){const I=e.dataIdMap.get(w.dataId).id;WW(u,v,I)}if(m&&e.disposeData(l.dataId),o){const I=FA(w.shape,d);w.shape=I}return w}};let jW;const Ife={kernelName:zN,backendName:"wasm",kernelFunc:function(n){const{backend:e,inputs:t,attrs:r}=n,{axis:s}=r,{x:o}=t,A=e.dataIdMap.get(o.dataId).id;let u=A,h=o;const{transposed:l,axes:c,inputWasTransposed:d}=Gu(o,s,e);if(d){const I=e.dataIdMap.get(l.dataId).id;I!==A&&(h=l,u=I)}const m=h.shape.slice(0,-1),y=e.makeOutput(m,"int32"),b=e.dataIdMap.get(y.dataId).id,v=Jt(y.shape),w=h.shape[c[0]];return jW(u,xs[h.dtype],v,w,b),d&&e.disposeData(l.dataId),y},setupFunc:function(n){jW=n.wasm.cwrap(zN,null,["number","number","number","number","number"])}};let HW;const Sfe={kernelName:ON,backendName:"wasm",setupFunc:function(n){HW=n.wasm.cwrap(ON,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(n){const{inputs:e,attrs:t,backend:r}=n,s=e.x,o=r.dataIdMap.get(s.dataId).id,{filterSize:A,strides:u,pad:h,dimRoundingMode:l}=t,c=CW(s.shape,A,u,1,h,l),d=c.filterHeight,m=c.filterWidth,y=c.padInfo.top,b=c.padInfo.right,v=c.padInfo.bottom,w=c.padInfo.left,I=c.strideHeight,S=c.strideWidth,T=c.inChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(c.dilationWidth!==1||c.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);const D=r.makeOutput(c.outShape,"float32"),L=r.dataIdMap.get(D.dataId).id;return HW(o,s.shape[0],s.shape[1],s.shape[2],d,m,y,b,v,w,I,S,T,L),D}};function oo(n){const{inputs:e,attrs:t}=n,{x:r}=e,{shape:s}=t,o=Jt(r.shape),A=function(u,h){let l=1,c=-1;for(let m=0;m<u.length;++m)if(u[m]>=0)l*=u[m];else if(u[m]===-1){if(c!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${c} and dim ${m}`);c=m}else if(u[m]<0)throw Error(`Shapes can not be < 0. Found ${u[m]} at dim ${m}`);if(c===-1){if(h>0&&h!==l)throw Error(`Size(${h}) must match the product of shape ${u}`);return u}if(l===0)throw Error(`Cannot infer the missing size in [${u}] when there are 0 elements`);if(h%l!=0)throw Error(`The implicit shape can't be a fractional number. Got ${h} / ${l}`);const d=u.slice();return d[c]=h/l,d}(s,o);return ze(o===Jt(A),()=>`new shape: ${A}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`),n.backend.incRef(r.dataId),{dataId:r.dataId,shape:A,dtype:r.dtype}}const Nfe={kernelName:l8,backendName:"wasm",kernelFunc:oo};let GW;const Tfe={kernelName:PN,backendName:"wasm",setupFunc:function(n){GW=n.wasm.cwrap(PN,null,["number","array","number","number","array","number","number","number","number"])},kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:o}=e,{transposeA:A,transposeB:u}=r;if(s.dtype!=="float32"||o.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");const h=s.shape.length,l=o.shape.length,c=A?s.shape[h-2]:s.shape[h-1],d=u?o.shape[l-1]:o.shape[l-2],m=A?s.shape[h-1]:s.shape[h-2],y=u?o.shape[l-2]:o.shape[l-1],b=s.shape.slice(0,-2),v=o.shape.slice(0,-2),w=Jt(b),I=Jt(v);ze(h>=2&&l>=2&&(w===I||w===1||I===1),()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${b}) and (${v}).`);const S=(w>I?s.shape.slice(0,-2):o.shape.slice(0,-2)).concat([m,y]);ze(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${s.shape} and ${o.shape} and transposeA=${A} and transposeB=${u} must match.`);const T=u?[I,y,d]:[I,d,y],D=oo({inputs:{x:s},backend:t,attrs:{shape:A?[w,c,m]:[w,m,c]}}),L=oo({inputs:{x:o},backend:t,attrs:{shape:T}}),W=t.dataIdMap.get(D.dataId).id,K=t.dataIdMap.get(L.dataId).id,U=A?D.shape[2]:D.shape[1],_=u?L.shape[1]:L.shape[2],ee=Math.max(w,I),re=t.makeOutput([ee,U,_],D.dtype),ce=t.dataIdMap.get(re.dataId).id,we=new Uint8Array(new Int32Array(D.shape).buffer),Ee=new Uint8Array(new Int32Array(L.shape).buffer);return GW(W,we,D.shape.length,K,Ee,L.shape.length,A,u,ce),t.disposeData(D.dataId),t.disposeData(L.dataId),re.shape=S,re}};function VW(n,e,t,r,s){const o=_8(r,e,t),A=Jt(t),u=ka(r);if(o){const c=eW(e,u);return s==="string"?n.slice(c,c+A):n.subarray(c,c+A)}const h=Ou(r,s,s==="string"?OW(n):n),l=Ou(t,s);for(let c=0;c<l.size;++c){const d=l.indexToLoc(c),m=d.map((y,b)=>y+e[b]);l.set(h.get(...m),...d)}return s==="string"?PW(l.values):l.values}function Eg(n){const{inputs:{x:e},attrs:{begin:t,size:r},backend:s}=n,[o,A]=function(b,v,w){let I;const S=b.shape.length;let T;return I=typeof v=="number"?[v,...new Array(S-1).fill(0)]:v.length<S?v.concat(new Array(S-v.length).fill(0)):v.slice(),I.forEach(D=>{ze(D!==-1,()=>"slice() does not support negative begin indexing.")}),T=w==null?new Array(S).fill(-1):typeof w=="number"?[w,...new Array(S-1).fill(-1)]:w.length<S?w.concat(new Array(S-w.length).fill(-1)):w,T=T.map((D,L)=>D>=0?D:(ze(D===-1,()=>`Negative size values should be exactly -1 but got ${D} for the slice() size at index ${L}.`),b.shape[L]-I[L])),[I,T]}(e,t,r),u=_8(e.shape,o,A),h=s.readSync(e.dataId),l=s.makeOutput(A,e.dtype),c=ka(e.shape),d=s.dataIdMap.get(l.dataId);if(u){const b=eW(o,c);return e.dtype==="string"?d.stringBytes=h.slice(b,b+Jt(A)):s.typedArrayFromHeap(l).set(h.subarray(b,b+Jt(A))),l}if(e.dtype==="string"){const b=VW(h,o,A,e.shape,e.dtype);return d.stringBytes=b,l}const m=s.typedArrayFromHeap(l),y=e.shape.length;if(y===2)(function(b,v,w,I,S){let T=0;const D=I[0],L=I[1],W=D+S[0];for(let K=D;K<W;K++){const U=K*v+L;w.set(b.subarray(U,U+S[1]),T),T+=S[1]}})(h,c[0],m,o,A);else if(y===3)(function(b,v,w,I,S,T){let D=0;const L=S[0],W=S[1],K=S[2],U=L+T[0],_=W+T[1];for(let ee=L;ee<U;ee++)for(let re=W;re<_;re++){const ce=ee*v+re*w+K;I.set(b.subarray(ce,ce+T[2]),D),D+=T[2]}})(h,c[0],c[1],m,o,A);else if(y===4)(function(b,v,w,I,S,T,D){let L=0;const W=T[0],K=T[1],U=T[2],_=W+D[0],ee=K+D[1],re=U+D[2],ce=T[3];for(let we=W;we<_;we++)for(let Ee=K;Ee<ee;Ee++)for(let Pe=U;Pe<re;Pe++){const he=we*v+Ee*w+Pe*I+ce;S.set(b.subarray(he,he+D[3]),L),L+=D[3]}})(h,c[0],c[1],c[2],m,o,A);else{const b=VW(h,o,A,e.shape,e.dtype);m.set(b)}return l}const Mfe={kernelName:h8,backendName:"wasm",kernelFunc:Eg},Efe={kernelName:WR,backendName:"wasm",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:o,crops:A}=r,u=o.reduce((w,I)=>w*I),h=EW(s.shape,o,u),l=DW(h.length,o.length),c=zW(s.shape,o,u),d=function(w,I){const S=[0];for(let T=0;T<I;++T)S.push(w[T][0]);return S}(A,o.length),m=function(w,I,S){const T=w.slice(0,1);for(let D=0;D<S;++D)T.push(w[D+1]-I[D][0]-I[D][1]);return T}(c,A,o.length),y=oo({inputs:{x:s},backend:t,attrs:{shape:h}}),b=lh({inputs:{x:y},backend:t,attrs:{perm:l}}),v=Eg({inputs:{x:oo({inputs:{x:b},backend:t,attrs:{shape:c}})},backend:t,attrs:{begin:d,size:m}});return t.disposeData(y.dataId),t.disposeData(b.dataId),t.disposeData(y.dataId),v}};function Dg(n){const{inputs:{x:e},attrs:{dtype:t},backend:r}=n,s=r.makeOutput(e.shape,t),o=r.typedArrayFromHeap(e);return r.typedArrayFromHeap(s).set(o),s}const Dfe={kernelName:BN,backendName:"wasm",kernelFunc:Dg},zfe=ua(jR);let XW;const Ofe={kernelName:FN,backendName:"wasm",setupFunc:function(n){XW=n.wasm.cwrap(FN,null,["number","number","number","number"])},kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{clipValueMin:o,clipValueMax:A}=r,u=t.dataIdMap.get(s.dataId).id,h=t.makeOutput(s.shape,s.dtype),l=t.dataIdMap.get(h.dataId).id;return XW(u,o,A,l),h}};function ZW(n){const{inputs:e,backend:t}=n,r=Tu(n.attrs.axis,e[0].shape)[0];let s=ZT(e.map(m=>m.shape),r);const o=e.filter(m=>Jt(m.shape)>0);if(o.length===1)return T1({inputs:{x:o[0]},backend:t});const A=t.makeOutput(s,e[0].dtype);if(Jt(s)===0)return A;if(function(m,y){const b=m[0].length;m.forEach((w,I)=>{ze(w.length===b,()=>`Error in concat${b}D: rank of tensors[${I}] must be the same as the rank of the rest (${b})`)}),ze(y>=0&&y<b,()=>`Error in concat${b}D: axis must be between 0 and ${b-1}.`);const v=m[0];m.forEach((w,I)=>{for(let S=0;S<b;S++)ze(S===y||w[S]===v[S],()=>`Error in concat${b}D: Shape of tensors[${I}] (${w}) does not match the shape of the rest (${v}) along the non-concatenated axis ${I}.`)})}(o.map(m=>m.shape),r),o[0].dtype==="string"){const m=o.map(I=>{const S=Jt(I.shape.slice(r));return oo({inputs:{x:I},backend:t,attrs:{shape:[-1,S]}})}),y=m.map(I=>({vals:t.readSync(I.dataId),shape:I.shape}));s=ZT(m.map(I=>I.shape),1);const b=m[0].shape[0]===1,v=function(I,S,T,D){const L=DR(T,Jt(S));if(D&&T!=="string"){let W=0;I.forEach(K=>{const U=Jt(K.shape);L.set(K.vals,W),W+=U})}else{let W=0;I.forEach(K=>{const U=T==="string"?OW(K.vals):K.vals;let _=0;for(let ee=0;ee<K.shape[0];++ee){const re=ee*S[1]+W;for(let ce=0;ce<K.shape[1];++ce)L[re+ce]=U[_++]}W+=K.shape[1]})}return L}(y,s,e[0].dtype,b),w=ZT(o.map(I=>I.shape),r);return A.shape=w,t.dataIdMap.get(A.dataId).stringBytes=PW(v),m.forEach(I=>t.disposeData(I.dataId)),A}const u=Jt(o[0].shape.slice(0,r));let h=0;const l=o.map(m=>{const y=Jt(m.shape.slice(r));return h+=y,y}),c=o.map(m=>t.typedArrayFromHeap(m)),d=t.typedArrayFromHeap(A);for(let m=0;m<u;m++){let y=m*h;for(let b=0;b<c.length;b++){const v=l[b],w=m*v,I=c[b].subarray(w,w+v);d.set(I,y),y+=v}}return A}const Pfe={kernelName:HR,backendName:"wasm",kernelFunc:ZW};let YW;const Bfe={kernelName:LN,backendName:"wasm",setupFunc:function(n){YW=n.wasm.cwrap(LN,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(n){const{inputs:e,attrs:t,backend:r}=n,{x:s,filter:o}=e,A=r.dataIdMap.get(s.dataId).id,u=r.dataIdMap.get(o.dataId).id,{strides:h,dilations:l,pad:c,dimRoundingMode:d,dataFormat:m}=t,y=IW(m),b=Hu(s.shape,o.shape,h,l,c,d,!1,y),v=b.filterHeight,w=b.filterWidth,I=b.padInfo.top,S=b.padInfo.right,T=b.padInfo.bottom,D=b.padInfo.left,L=b.dilationHeight,W=b.dilationWidth,K=b.strideHeight,U=b.strideWidth,_=b.inChannels,ee=b.outChannels,re=b.padInfo.type==="SAME"?1:0;if(b.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${b.dataFormat}'. Please use 'channelsLast'.`);const ce=r.makeOutput(b.outShape,"float32"),we=r.dataIdMap.get(ce.dataId).id;return YW(A,s.shape[0],s.shape[1],s.shape[2],u,v,w,I,S,T,D,re,L,W,K,U,_,ee,we),ce}};let UW;const Ffe={kernelName:RN,backendName:"wasm",setupFunc:function(n){UW=n.wasm.cwrap(RN,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(n){const{backend:e,inputs:t,attrs:r}=n,{dy:s,filter:o}=t,{strides:A,pad:u,dataFormat:h,dimRoundingMode:l,inputShape:c}=r,d=IW(h),m=Hu(c,o.shape,A,1,u,l,!1,d),{batchSize:y,filterHeight:b,filterWidth:v,inChannels:w,inHeight:I,inWidth:S,outChannels:T,outHeight:D,outWidth:L,strideHeight:W,strideWidth:K}=m,U=b-1-m.padInfo.top,_=v-1-m.padInfo.left,ee=m.dataFormat==="channelsLast",re=ka(m.inShape),ce=ka(s.shape),[we,Ee,Pe]=ka(o.shape),he=re[0],de=ee?re[1]:re[2],Ae=ee?re[2]:1,Se=ee?1:re[1],Te=ce[0],Ze=ee?ce[1]:ce[2],et=ee?ce[2]:1,qe=ee?1:ce[1],Re=e.makeOutput(m.inShape,"float32"),Ue=e.dataIdMap.get(Re.dataId).id,ot=e.dataIdMap.get(s.dataId).id,yt=e.dataIdMap.get(o.dataId).id;return UW(ot,yt,y,b,v,I,S,w,D,L,T,W,K,U,_,we,Ee,Pe,he,de,Ae,Se,Te,Ze,et,qe,Ue),Re}},Lfe=ua("Cos"),Rfe=ua(GR);var JT,M1;let QW;(M1=JT||(JT={}))[M1.bilinear=0]="bilinear",M1[M1.nearest=1]="nearest";const Wfe={kernelName:jN,backendName:"wasm",setupFunc:function(n){QW=n.wasm.cwrap(jN,null,["number","number","number","number","array","number","number","number","number","number"])},kernelFunc:function(n){const{backend:e,inputs:t,attrs:r}=n,{method:s,extrapolationValue:o,cropSize:A}=r,{image:u,boxes:h,boxInd:l}=t,c=h.shape[0],[d,m]=A,y=[c,d,m,u.shape[3]];let b,v=e.dataIdMap.get(u.dataId);u.dtype!=="float32"&&(b=Dg({backend:e,inputs:{x:u},attrs:{dtype:"float32"}}),v=e.dataIdMap.get(b.dataId));const w=v.id,I=e.dataIdMap.get(h.dataId).id,S=e.dataIdMap.get(l.dataId).id,T=e.makeOutput(y,"float32"),D=e.dataIdMap.get(T.dataId).id,L=new Uint8Array(new Int32Array(u.shape).buffer);return QW(w,I,S,c,L,d,m,JT[s],o,D),b!=null&&e.disposeData(b.dataId),T}};let KW;const jfe={kernelName:WN,backendName:"wasm",setupFunc:function(n){KW=n.wasm.cwrap(WN,null,["number","number","number","number","number","number"])},kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,exclusive:A,reverse:u}=r,h=s.shape.length;ze(s.dtype==="float32"||s.dtype==="int32",()=>`cumsum does not support ${s.dtype} tensors in the WASM backend`);const l=hW([o],h);let c=s;l!==null&&(c=lh({inputs:{x:s},attrs:{perm:l},backend:t}));const d=Sg(1,h)[0];Fu("cumsum",[d],h);const m=t.makeOutput(c.shape,c.dtype),y=c.shape[d],b=t.dataIdMap.get(c.dataId).id,v=t.dataIdMap.get(m.dataId).id;KW(b,A?1:0,u?1:0,y,v,xs[s.dtype]);let w=m;if(l!==null){const I=l.map((S,T)=>[T,S]).sort((S,T)=>S[1]-T[1]).map(S=>S[0]);w=lh({inputs:{x:m},attrs:{perm:I},backend:t}),t.disposeData(c.dataId),t.disposeData(m.dataId)}return w}};let qW;const Hfe={kernelName:HN,backendName:"wasm",setupFunc:function(n){qW=n.wasm.cwrap(HN,null,["number","number","number","array","number","array","array","number","number"])},kernelFunc:function(n){const{backend:e,inputs:t,attrs:r}=n,{x:s}=t,{blockSize:o,dataFormat:A}=r,u=s.shape[0],h=(A==="NHWC"?s.shape[1]:s.shape[2])*o,l=(A==="NHWC"?s.shape[2]:s.shape[3])*o,c=(A==="NHWC"?s.shape[3]:s.shape[1])/(o*o),d=A==="NHWC"?[u,h,l,c]:[u,c,h,l],m=e.makeOutput(d,"float32"),y=e.dataIdMap.get(s.dataId).id,b=new Uint8Array(new Int32Array(ka(s.shape)).buffer),v=new Uint8Array(new Int32Array(d).buffer),w=new Uint8Array(new Int32Array(ka(d)).buffer),I=e.dataIdMap.get(m.dataId).id;return qW(y,o,A==="NHWC"?1:0,b,s.shape.length-1,v,w,d.length,I),m}};let JW;const Gfe={kernelName:GN,backendName:"wasm",setupFunc:function(n){JW=n.wasm.cwrap(GN,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(n){const{inputs:e,attrs:t,backend:r}=n,{x:s,filter:o}=e,A=r.dataIdMap.get(s.dataId).id,u=r.dataIdMap.get(o.dataId).id,{strides:h,dilations:l,pad:c,dimRoundingMode:d}=t,m=l??[1,1],y=Hu(s.shape,o.shape,h,m,c,d,!0),b=y.filterHeight,v=y.filterWidth,w=y.padInfo.top,I=y.padInfo.right,S=y.padInfo.bottom,T=y.padInfo.left,D=y.dilationHeight,L=y.dilationWidth,W=y.strideHeight,K=y.strideWidth,U=y.inChannels,_=y.outChannels,ee=y.padInfo.type==="SAME"?1:0;if(y.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${y.dataFormat}'. Please use 'channelsLast'.`);const re=r.makeOutput(y.outShape,"float32"),ce=r.dataIdMap.get(re.dataId).id;return JW(A,s.shape[0],s.shape[1],s.shape[2],u,b,v,w,I,S,T,ee,D,L,W,K,U,_,ce),re}},Vfe=ua("Elu"),Xfe=Va(XR,!1,"bool"),Zfe=ua("Exp","float32");function $T(n){const{inputs:e,attrs:t,backend:r}=n,{input:s}=e,{dim:o}=t,A=s.shape.length,u=s.shape.slice();let h=o;return o<0&&(ze(-(A+1)<=o,()=>`Axis must be in the interval [${-(A+1)}, ${A}]`),h=A+o+1),u.splice(h,0,1),oo({inputs:{x:s},backend:r,attrs:{shape:u}})}const Yfe={kernelName:ZR,backendName:"wasm",kernelFunc:$T};function $W(n){const{attrs:{shape:e,value:t,dtype:r},backend:s}=n,o=s.makeOutput(e,r);return s.typedArrayFromHeap(o).fill(t),o}const Ufe={kernelName:YR,backendName:"wasm",kernelFunc:$W};let _W;const Qfe={kernelName:VN,backendName:"wasm",kernelFunc:function(n){const{inputs:e,backend:t}=n,{image:r}=e,s=t.makeOutput(r.shape,r.dtype),o=t.dataIdMap.get(r.dataId).id,A=t.dataIdMap.get(s.dataId).id,[u,h,l,c]=r.shape;return _W(o,u,h,l,c,A),s},setupFunc:function(n){_W=n.wasm.cwrap(VN,null,["number","number","number","number","number","number"])}},Kfe=ua(UR),qfe=Va(QR,!1);let ej;const Jfe={kernelName:XN,backendName:"wasm",setupFunc:function(n){ej=n.wasm.cwrap(XN,null,["number","number","number","number","number","number","number"])},kernelFunc:function(n){const{backend:e,inputs:t,attrs:r}=n,{varianceEpsilon:s}=r,{x:o,mean:A,variance:u,offset:h,scale:l}=t,c=e.dataIdMap.get(o.dataId).id,d=e.dataIdMap.get(A.dataId).id,m=e.dataIdMap.get(u.dataId).id,y=h!=null?e.dataIdMap.get(h.dataId).id:0,b=l!=null?e.dataIdMap.get(l.dataId).id:0,v=e.makeOutput(o.shape,o.dtype);if(Jt(o.shape)===0)return v;const w=e.dataIdMap.get(v.dataId).id;return ej(c,d,m,y,b,s,w),v}};let tj;const $fe={kernelName:h1,backendName:"wasm",setupFunc:function(n){tj=n.wasm.cwrap(h1,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(n){const{inputs:e,attrs:t,backend:r}=n,{x:s,filter:o,bias:A,preluActivationWeights:u}=e,{strides:h,pad:l,dilations:c,dataFormat:d,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=t,v=Hu(s.shape,o.shape,h,c,l,m),w=Mg[y];if(w==null)throw new Error(`${y} activation not yet supported for FusedConv2D in the wasm backend.`);const I=r.dataIdMap.get(s.dataId).id,S=r.dataIdMap.get(o.dataId).id,T=v.outChannels;let D=0;if(A!=null){const qe=r.dataIdMap.get(A.dataId);if(qe.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${qe.shape.length}.`);if(qe.shape[0]!==T)throw new Error(`FusedConv2D bias shape (${qe.shape}) does not match the number of output channels (${T})`);D=qe.id}const L=v.filterHeight,W=v.filterWidth,K=v.padInfo.top,U=v.padInfo.right,_=v.padInfo.bottom,ee=v.padInfo.left,re=v.dilationHeight,ce=v.dilationWidth,we=v.strideHeight,Ee=v.strideWidth,Pe=v.inChannels,he=v.padInfo.type==="SAME"?1:0,de=v.batchSize,Ae=v.inHeight,Se=v.inWidth;if(d!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);const Te=r.makeOutput(v.outShape,"float32"),Ze=r.dataIdMap.get(Te.dataId).id,et=u==null?0:r.dataIdMap.get(u.dataId).id;return tj(I,de,Ae,Se,S,L,W,D,K,U,_,ee,he,re,ce,we,Ee,Pe,T,w,et,b||0,Ze),Te}};let nj;const _fe={kernelName:f1,backendName:"wasm",setupFunc:function(n){nj=n.wasm.cwrap(f1,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(n){const{inputs:e,attrs:t,backend:r}=n,{x:s,filter:o,bias:A,preluActivationWeights:u}=e,{strides:h,pad:l,dilations:c,dataFormat:d,dimRoundingMode:m,activation:y,leakyreluAlpha:b}=t,v=Hu(s.shape,o.shape,h,c,l,m,!0),w=Mg[y];if(w==null)throw new Error(`${y} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);const I=r.dataIdMap.get(s.dataId).id,S=r.dataIdMap.get(o.dataId).id,T=v.outChannels;let D=0;if(A!=null){const qe=r.dataIdMap.get(A.dataId);if(qe.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${qe.shape.length}.`);if(qe.shape[0]!==T)throw new Error(`FusedDepthwiseConv2D bias shape (${qe.shape}) does not match the number of output channels (${T})`);D=qe.id}const L=v.filterHeight,W=v.filterWidth,K=v.padInfo.top,U=v.padInfo.right,_=v.padInfo.bottom,ee=v.padInfo.left,re=v.dilationHeight,ce=v.dilationWidth,we=v.strideHeight,Ee=v.strideWidth,Pe=v.inChannels,he=v.padInfo.type==="SAME"?1:0,de=v.batchSize,Ae=v.inHeight,Se=v.inWidth;if(d!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);const Te=r.makeOutput(v.outShape,"float32"),Ze=r.dataIdMap.get(Te.dataId).id,et=u==null?0:r.dataIdMap.get(u.dataId).id;return nj(I,de,Ae,Se,S,L,W,D,K,U,_,ee,he,re,ce,we,Ee,Pe,T,w,et,b||0,Ze),Te}};let rj;const eme={kernelName:ZN,backendName:"wasm",setupFunc:function(n){rj=n.wasm.cwrap(ZN,null,["number","number","number","number","number","number","array","number"])},kernelFunc:function(n){const{backend:e,inputs:t}=n,{params:r,indices:s}=t,[o,A,u,h]=function(w,I){const S=w.shape.length,T=I.shape.length;if(S<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${S}.`);if(T<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${T}.`);if(I.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${I.dtype}.`);if(I.shape[T-1]>S)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${I.shape[T-1]} vs. ${S}`);if(Jt(w.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${w.shape}.`);const D=I.shape,L=D[D.length-1];let W=1;for(let re=0;re<D.length-1;++re)W*=D[re];const K=w.shape,U=D.slice();U.pop();let _=1;for(let re=L;re<S;++re)_*=K[re],U.push(K[re]);const ee=[...ka(w.shape).map(re=>re/_),1].slice(0,L);return[U,W,_,ee]}(r,s),l=e.makeOutput(o,r.dtype);if(A===0)return l;const c=s.shape,d=c[c.length-1],m=e.dataIdMap.get(r.dataId).id,y=e.dataIdMap.get(s.dataId).id,b=new Uint8Array(new Int32Array(h).buffer),v=e.dataIdMap.get(l.dataId).id;return rj(m,xs[r.dtype],y,A,d,u,b,v),l}};let sj;const tme={kernelName:KR,backendName:"wasm",setupFunc:function(n){sj=n.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])},kernelFunc:function(n){const{backend:e,inputs:t,attrs:r}=n,{x:s,indices:o}=t,{axis:A,batchDims:u}=r,h=Tu(A,s.shape)[0],l=e.readSync(o.dataId),c=s.shape[h];for(let K=0;K<l.length;++K){const U=l[K];ze(U<=c-1&&U>=0,()=>`GatherV2: the index value ${U} is not in [0, ${c-1}]`)}const d=function(K,U,_,ee){const re=U.shape.length,ce=K.shape.length;if(ee!==0&&(ee<-re||ee>re))throw new Error(`Expect batchDims in the range of [-${re}, ${re}], but got ${ee}`);if(ee<0&&(ee+=re),ee>ce)throw new Error(`batchDims (${ee}) must be less than rank(x) (
    ${ce}).`);if(_<ee)throw new Error(`batchDims (${ee}) must be less than or equal to axis (${_}).`);for(let Ae=0;Ae<ee;++Ae)if(K.shape[Ae]!==U.shape[Ae])throw new Error(`x.shape[${Ae}]: ${K.shape[Ae]} should be equal to indices.shape[${Ae}]: ${U.shape[Ae]}.`);const we=K.shape[_],Ee=[];let Pe=1,he=1,de=1;for(let Ae=0;Ae<ee;++Ae)Ee.push(K.shape[Ae]),Pe*=K.shape[Ae];for(let Ae=ee;Ae<_;Ae++)Ee.push(K.shape[Ae]),he*=K.shape[Ae];for(let Ae=ee;Ae<re;Ae++)Ee.push(U.shape[Ae]);for(let Ae=_+1;Ae<ce;Ae++)Ee.push(K.shape[Ae]),de*=K.shape[Ae];return{batchSize:Pe,sliceSize:de,outerSize:he,dimSize:we,outputShape:Ee}}(s,o,h,u),m=oo({inputs:{x:s},attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]},backend:e}),y=Jt(o.shape),b=oo({inputs:{x:o},attrs:{shape:[d.batchSize,y/d.batchSize]},backend:e}),v=[d.batchSize,d.outerSize,y/d.batchSize,d.sliceSize],w=e.makeOutput(v,s.dtype);if(Jt(s.shape)===0)return w;const I=m.shape.length-1,S=e.dataIdMap.get(m.dataId).id,T=e.dataIdMap.get(b.dataId).id,D=e.dataIdMap.get(w.dataId).id,L=new Uint8Array(new Int32Array(ka(m.shape)).buffer),W=new Uint8Array(new Int32Array(ka(v)).buffer);return sj(S,xs[s.dtype],L,I,T,d.batchSize,W,D),e.disposeData(m.dataId),e.disposeData(b.dataId),w.shape=d.outputShape,w}},nme=Va(qR,!1,"bool"),rme=Va(JR,!1,"bool");let aj;const sme={kernelName:UN,backendName:"wasm",setupFunc:function(n){aj=n.wasm.cwrap(UN,null,["number","number","number","number"])},kernelFunc:function(n){const{inputs:{x:e},attrs:{alpha:t},backend:r}=n,s=r.dataIdMap.get(e.dataId).id,o=r.makeOutput(e.shape,"float32");if(Jt(e.shape)!==0){const A=r.dataIdMap.get(o.dataId).id;aj(s,xs[e.dtype],t,A)}return o}},ame=Va($R,!1,"bool"),ome=Va(_R,!1,"bool"),ime=ua("Log"),Ame=Va(e8,!1,"bool");let oj;const lme={kernelName:QN,backendName:"wasm",setupFunc:function(n){oj=n.wasm.cwrap(QN,null,["number","number","number","number"])},kernelFunc:function(n){const{backend:e,inputs:t,attrs:r}=n,{reductionIndices:s,keepDims:o}=r,{x:A}=t;let u=e.dataIdMap.get(A.dataId).id,h=A;const{transposed:l,axes:c,originalAxes:d,inputWasTransposed:m}=Gu(A,s,e);m&&(h=l,u=e.dataIdMap.get(l.dataId).id),Fu("max",c,h.shape.length);const[y,b]=Ad(h.shape,c),v=Jt(b),w=e.makeOutput(y,A.dtype);if(Jt(h.shape)!==0){const I=e.dataIdMap.get(w.dataId).id;oj(u,xs[A.dtype],v,I)}if(m&&e.disposeData(l.dataId),o){const I=FA(w.shape,d);w.shape=I}return w}},ume=Va(t8,!1);let ij;const cme={kernelName:KN,backendName:"wasm",setupFunc:function(n){ij=n.wasm.cwrap(KN,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(n){const{inputs:e,attrs:t,backend:r}=n,s=e.x,o=r.dataIdMap.get(s.dataId).id;ze(s.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${s.dtype}.`);const{filterSize:A,strides:u,pad:h,dimRoundingMode:l}=t,c=CW(s.shape,A,u,1,h,l),d=c.filterHeight,m=c.filterWidth,y=c.padInfo.top,b=c.padInfo.right,v=c.padInfo.bottom,w=c.padInfo.left,I=c.dilationHeight,S=c.dilationWidth,T=c.strideHeight,D=c.strideWidth,L=c.inChannels,W=c.outChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);const K=r.makeOutput(c.outShape,"float32"),U=r.dataIdMap.get(K.dataId).id;return ij(o,s.shape[0],s.shape[1],s.shape[2],d,m,y,b,v,w,I,S,T,D,L,W,U),K}};let Aj;const dme={kernelName:qN,backendName:"wasm",setupFunc:function(n){Aj=n.wasm.cwrap(qN,null,["number, number, number"])},kernelFunc:function(n){const{backend:e,inputs:t,attrs:r}=n,{axis:s,keepDims:o}=r,{x:A}=t,u=e.dataIdMap.get(A.dataId).id;let h=u,l=A;const{transposed:c,axes:d,originalAxes:m,inputWasTransposed:y}=Gu(A,s,e);let b=d;if(y){const D=e.dataIdMap.get(c.dataId).id;D!==u&&(l=c,h=D,b=Sg(b.length,l.shape.length))}Fu("mean",b,l.shape.length);const[v,w]=Ad(l.shape,b),I=Jt(w);let S=l;l.dtype!=="float32"&&(S=Dg({backend:e,inputs:{x:l},attrs:{dtype:"float32"}}),h=e.dataIdMap.get(S.dataId).id);const T=e.makeOutput(v,"float32");if(Jt(l.shape)!==0){const D=e.dataIdMap.get(T.dataId).id;Aj(h,I,D)}if(y&&e.disposeData(c.dataId),o){const D=FA(T.shape,m);T.shape=D}return l.dtype!=="float32"&&e.disposeData(S.dataId),T}};let lj;const pme={kernelName:JN,backendName:"wasm",setupFunc:function(n){lj=n.wasm.cwrap(JN,null,["number","number","number","number"])},kernelFunc:function(n){const{backend:e,inputs:t,attrs:r}=n,{axis:s,keepDims:o}=r,{x:A}=t,u=e.dataIdMap.get(A.dataId).id;let h=u,l=A;const{transposed:c,axes:d,originalAxes:m,inputWasTransposed:y}=Gu(A,s,e);if(y){const S=e.dataIdMap.get(c.dataId).id;S!==u&&(l=c,h=S)}Fu("min",d,l.shape.length);const[b,v]=Ad(l.shape,d),w=Jt(v),I=e.makeOutput(b,l.dtype);if(Jt(l.shape)!==0){const S=e.dataIdMap.get(I.dataId).id;lj(h,xs[A.dtype],w,S)}if(y&&e.disposeData(c.dataId),o){const S=FA(I.shape,m);I.shape=S}return I}},hme=Va(n8,!1);var _T,E1;let uj;(E1=_T||(_T={}))[E1.reflect=0]="reflect",E1[E1.symmetric=1]="symmetric";const fme={kernelName:$N,backendName:"wasm",kernelFunc:function(n){const{inputs:{x:e},backend:t,attrs:{paddings:r,mode:s}}=n,o=r.map((b,v)=>b[0]+e.shape[v]+b[1]),A=t.dataIdMap.get(e.dataId).id,u=t.makeOutput(o,e.dtype),h=t.dataIdMap.get(u.dataId).id,l=new Uint8Array(new Int32Array(e.shape).buffer),c=r.map(b=>b[0]),d=r.map(b=>b[1]),m=new Uint8Array(new Int32Array(c).buffer),y=new Uint8Array(new Int32Array(d).buffer);return uj(A,l,e.shape.length,xs[e.dtype],m,y,_T[s],h),u},setupFunc:function(n){uj=n.wasm.cwrap($N,null,["number","array","number","number","array","array","number","number"])}},mme=Va(r8,!0),gme=ua("Neg");function eM(n,e){const t=new Int32Array(n.wasm.HEAPU8.buffer,e,4),r=t[0],s=t[1],o=t[2],A=t[3];return n.wasm._free(e),{pSelectedIndices:r,selectedSize:s,pSelectedScores:o,pValidOutputs:A}}let cj;const yme={kernelName:_N,backendName:"wasm",setupFunc:function(n){cj=n.wasm.cwrap(_N,"number",["number","number","number","number","number"])},kernelFunc:function(n){const{backend:e,inputs:t,attrs:r}=n,{iouThreshold:s,maxOutputSize:o,scoreThreshold:A}=r,{boxes:u,scores:h}=t,l=e.dataIdMap.get(u.dataId).id,c=e.dataIdMap.get(h.dataId).id,d=cj(l,c,o,s,A),{pSelectedIndices:m,selectedSize:y,pSelectedScores:b,pValidOutputs:v}=eM(e,d);return e.wasm._free(b),e.wasm._free(v),e.makeOutput([y],"int32",m)}};let dj;const bme={kernelName:eT,backendName:"wasm",setupFunc:function(n){dj=n.wasm.cwrap(eT,"number",["number","number","number","number","number","bool"])},kernelFunc:function(n){const{backend:e,inputs:t,attrs:r}=n,{iouThreshold:s,maxOutputSize:o,scoreThreshold:A,padToMaxOutputSize:u}=r,{boxes:h,scores:l}=t,c=e.dataIdMap.get(h.dataId).id,d=e.dataIdMap.get(l.dataId).id,m=dj(c,d,o,s,A,u),{pSelectedIndices:y,selectedSize:b,pSelectedScores:v,pValidOutputs:w}=eM(e,m);return e.wasm._free(v),[e.makeOutput([b],"int32",y),e.makeOutput([],"int32",w)]}};let pj;const vme={kernelName:tT,backendName:"wasm",setupFunc:function(n){pj=n.wasm.cwrap(tT,"number",["number","number","number","number","number","number"])},kernelFunc:function(n){const{backend:e,inputs:t,attrs:r}=n,{iouThreshold:s,maxOutputSize:o,scoreThreshold:A,softNmsSigma:u}=r,{boxes:h,scores:l}=t,c=e.dataIdMap.get(h.dataId).id,d=e.dataIdMap.get(l.dataId).id,m=pj(c,d,o,s,A,u),{pSelectedIndices:y,selectedSize:b,pSelectedScores:v,pValidOutputs:w}=eM(e,m);return e.wasm._free(w),[e.makeOutput([b],"int32",y),e.makeOutput([b],"float32",v)]}},xme=Va(s8,!1,"bool");let hj;const wme={kernelName:nT,backendName:"wasm",setupFunc:function(n){hj=n.wasm.cwrap(nT,null,["number","number","number","number","number"])},kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s}=e,{depth:o,onValue:A,offValue:u}=r,h=t.makeOutput([...s.shape,o],"int32"),l=t.dataIdMap.get(h.dataId).id,c=t.dataIdMap.get(s.dataId).id;return hj(c,o,A,u,l),h}},kme={kernelName:a8,backendName:"wasm",kernelFunc:function(n){const{inputs:{x:e},backend:t}=n,r=t.makeOutput(e.shape,e.dtype);return t.typedArrayFromHeap(r).fill(1),r}},Cme={kernelName:o8,backendName:"wasm",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r;if(e.length===1)return $T({inputs:{input:e[0]},backend:t,attrs:{dim:s}});const o=e[0].shape,A=e[0].dtype;e.forEach(l=>{tA(o,l.shape,"All tensors passed to stack must have matching shapes"),ze(A===l.dtype,()=>"All tensors passed to stack must have matching dtypes")});const u=[],h=ZW({inputs:e.map(l=>{const c=$T({inputs:{input:l},backend:t,attrs:{dim:s}});return u.push(c),c}),backend:t,attrs:{axis:s}});return u.forEach(l=>t.disposeData(l.dataId)),h}};let fj;const mj={kernelName:rT,backendName:"wasm",kernelFunc:function(n){const{inputs:{x:e},backend:t,attrs:{paddings:r,constantValue:s}}=n,o=r.map((b,v)=>b[0]+e.shape[v]+b[1]);if(Jt(e.shape)===0)return $W({backend:t,attrs:{shape:o,value:s,dtype:e.dtype}});const A=t.dataIdMap.get(e.dataId).id,u=t.makeOutput(o,e.dtype),h=t.dataIdMap.get(u.dataId).id,l=new Uint8Array(new Int32Array(e.shape).buffer),c=r.map(b=>b[0]),d=r.map(b=>b[1]),m=new Uint8Array(new Int32Array(c).buffer),y=new Uint8Array(new Int32Array(d).buffer);return fj(A,l,e.shape.length,xs[e.dtype],m,y,s,h),u},setupFunc:function(n){fj=n.wasm.cwrap(rT,null,["number","array","number","number","array","array","number","number"])}},Ime=Va("Pow",!1);let gj;const Sme={kernelName:sT,backendName:"wasm",setupFunc:function(n){gj=n.wasm.cwrap(sT,null,["number","number","number"])},kernelFunc:function(n){const{inputs:e,backend:t}=n,{x:r,alpha:s}=e,o=t.dataIdMap.get(r.dataId).id,A=t.dataIdMap.get(s.dataId).id;let u=o;const h=r;let l=h;h.dtype!=="float32"&&(l=Dg({backend:t,inputs:{x:r},attrs:{dtype:"float32"}}),u=t.dataIdMap.get(l.dataId).id);const c=t.makeOutput(r.shape,"float32"),d=t.dataIdMap.get(c.dataId).id;return gj(u,A,d),h.dtype!=="float32"&&t.disposeData(l.dataId),c}};let yj;const Nme={kernelName:aT,backendName:"wasm",setupFunc:function(n){yj=n.wasm.cwrap(aT,null,["number","number","number","number"])},kernelFunc:function(n){const{backend:e,inputs:t,attrs:r}=n,{axis:s,keepDims:o}=r,{x:A}=t,u=e.dataIdMap.get(A.dataId).id;let h=u,l=A;const{transposed:c,axes:d,originalAxes:m,inputWasTransposed:y}=Gu(A,s,e);let b=d;if(y){const T=e.dataIdMap.get(c.dataId).id;T!==u&&(l=c,h=T,b=Sg(b.length,l.shape.length))}Fu("prod",b,l.shape.length);const[v,w]=Ad(l.shape,b),I=Jt(w),S=e.makeOutput(v,l.dtype);if(Jt(l.shape)!==0){const T=e.dataIdMap.get(S.dataId).id;yj(h,I,xs[S.dtype],T)}if(y&&e.disposeData(c.dataId),o){const T=FA(S.shape,m);S.shape=T}return S}},Tme={kernelName:i8,backendName:"wasm",kernelFunc:n=>{const{backend:e,attrs:t}=n,{start:r,stop:s,step:o,dtype:A}=t,u=function(l,c,d,m){if(l===c||l<c&&d<0||c<l&&d>1)return gg(0,m);const y=gg(Math.abs(Math.ceil((c-l)/d)),m);c<l&&d===1&&(d=-1),y[0]=l;for(let b=1;b<y.length;b++)y[b]=y[b-1]+d;return y}(r,s,o,A),h=e.makeOutput([u.length],A);return e.typedArrayFromHeap(h).set(u),h}},Mme=Va(VR,!0),Eme=ua(A8),Dme=ua(u8);let bj;const zme={kernelName:oT,backendName:"wasm",setupFunc:function(n){bj=n.wasm.cwrap(oT,null,["number","number","number","number","number","number","number","number","number","number"])},kernelFunc:function(n){const{backend:e,inputs:t,attrs:r}=n,{images:s}=t,{alignCorners:o,halfPixelCenters:A,size:u}=r,[h,l]=u,[c,d,m,y]=s.shape,b=[c,h,l,y];let v,w=e.dataIdMap.get(s.dataId);w.dtype!=="float32"&&(v=Dg({backend:e,inputs:{x:s},attrs:{dtype:"float32"}}),w=e.dataIdMap.get(v.dataId));const I=w.id,S=e.makeOutput(b,"float32");if(Jt(s.shape)===0)return S;const T=e.dataIdMap.get(S.dataId).id;return bj(I,c,d,m,y,h,l,o?1:0,A?1:0,T),v!=null&&e.disposeData(v.dataId),S}};let vj;const Ome={kernelName:iT,backendName:"wasm",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dims:o}=r,A=Tu(o,s.shape);if(s.shape.length===0)return T1({inputs:{x:s},backend:t});const u=t.makeOutput(s.shape,s.dtype),h=t.dataIdMap.get(s.dataId).id,l=t.dataIdMap.get(u.dataId).id,c=new Uint8Array(new Int32Array(A).buffer),d=new Uint8Array(new Int32Array(s.shape).buffer);vj(h,c,A.length,d,s.shape.length,l);const m=oo({inputs:{x:u},attrs:{shape:s.shape},backend:t});return t.disposeData(u.dataId),m},setupFunc:function(n){vj=n.wasm.cwrap(iT,null,["number","array","number","array","number","number"])}};let xj;const Pme={kernelName:mT,backendName:"wasm",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{image:s}=e,{radians:o,fillValue:A,center:u}=r,h=t.makeOutput(s.shape,s.dtype),l=t.dataIdMap.get(s.dataId).id,c=t.dataIdMap.get(h.dataId).id,[d,m,y,b]=s.shape,[v,w]=function(T,D,L){return[L*(typeof T=="number"?T:T[0]),D*(typeof T=="number"?T:T[1])]}(u,m,y),I=typeof A=="number"?[A,A,A,A===0?0:255]:[...A,255],S=new Uint8Array(new Int32Array(I).buffer);return xj(l,d,m,y,b,o,v,w,S,I.length,c),h},setupFunc:function(n){xj=n.wasm.cwrap(mT,null,["number","number","number","number","number","number","number","number","array","number","number"])}},Bme=ua(c8),Fme=ua(d8);let wj;const Lme={kernelName:AT,backendName:"wasm",setupFunc:function(n){wj=n.wasm.cwrap(AT,null,["number","number","number","number","number","number","array","number","number"])},kernelFunc:function(n){const{backend:e,inputs:t,attrs:r}=n,{indices:s,updates:o}=t,{shape:A}=r,u=e.makeOutput(A,o.dtype);if(Jt(A)===0)return u;const{sliceRank:h,numUpdates:l,sliceSize:c,strides:d,outputSize:m}=function(I,S,T){const D=S.shape.length,L=D>1?S.shape[D-1]:1,W=T.length;let K=1;for(let _=L;_<W;++_)K*=T[_];const U=L<1?1:L;return{sliceRank:L,numUpdates:Jt(S.shape)/U,sliceSize:K,strides:[...ka(T.slice(0,L)),1],outputSize:Jt(T)}}(0,s,A),y=e.dataIdMap.get(s.dataId).id,b=e.dataIdMap.get(o.dataId).id,v=new Uint8Array(new Int32Array(d).buffer),w=e.dataIdMap.get(u.dataId).id;return wj(y,b,xs[o.dtype],h,l,c,v,m,w),u}};let kj;const Rme={kernelName:p8,backendName:"wasm",kernelFunc:function(n){const{inputs:e,backend:t}=n,{condition:r,t:s,e:o}=e,A=t.dataIdMap.get(r.dataId).id,u=t.dataIdMap.get(s.dataId).id,h=t.dataIdMap.get(o.dataId).id,l=t.makeOutput(s.shape,s.dtype),c=t.dataIdMap.get(l.dataId).id,d=r.shape.length,m=s.shape.length,y=d===0||d>1||m===1?1:Jt(s.shape.slice(1));return kj(A,u,h,y,c),l},setupFunc:function(n){kj=n.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}};let Cj;const Wme={kernelName:"Sigmoid",backendName:"wasm",setupFunc:function(n){Cj=n.wasm.cwrap(f8,null,["number","number"])},kernelFunc:function(n){const{backend:e,inputs:{x:t}}=n,r=e.dataIdMap.get(t.dataId).id,s=e.makeOutput(t.shape,t.dtype),o=e.dataIdMap.get(s.dataId).id;return Jt(s.shape)===0||Cj(r,o),s}},jme=ua("Sin");let Ij;const Hme={kernelName:uT,backendName:"wasm",setupFunc:function(n){Ij=n.wasm.cwrap(uT,null,["number","number","number","number"])},kernelFunc:function(n){const{backend:e,inputs:{logits:t},attrs:{dim:r}}=n,s=e.dataIdMap.get(t.dataId).id,o=e.makeOutput(t.shape,t.dtype),A=e.dataIdMap.get(o.dataId).id,u=t.shape[r],h=Jt(t.shape)/u;return Jt(o.shape)===0||Ij(s,A,u,h),o}},Gme={kernelName:g8,backendName:"wasm",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:o,paddings:A}=r,u=Jt(o),h=[[0,0]];h.push(...A);for(let w=1+o.length;w<s.shape.length;++w)h.push([0,0]);const l=mj.kernelFunc({inputs:{x:s},backend:t,attrs:{paddings:h,constantValue:0}}),c=EW(l.shape,o,u,!1),d=DW(c.length,o.length,!1),m=zW(l.shape,o,u,!1),y=oo({inputs:{x:l},backend:t,attrs:{shape:c}}),b=lh({inputs:{x:y},backend:t,attrs:{perm:d}}),v=oo({inputs:{x:b},backend:t,attrs:{shape:m}});return t.disposeData(l.dataId),t.disposeData(y.dataId),t.disposeData(b.dataId),v}},Vme={kernelName:y8,backendName:"wasm",kernelFunc:function(n){const{inputs:e,attrs:t,backend:r}=n,{x:s}=e,{numOrSizeSplits:o,axis:A}=t,u=Tu(A,s.shape)[0],h=function(d,m,y=0){let b=[];if(typeof m=="number")ze(d.shape[y]%m==0,()=>"Number of splits must evenly divide the axis."),b=new Array(m).fill(d.shape[y]/m);else{ze(m.reduce((w,I)=>(I===-1&&(w+=1),w),0)<=1,()=>"There should be only one negative value in split array.");const v=m.indexOf(-1);if(v!==-1){const w=m.reduce((I,S)=>S>0?I+S:I);m[v]=d.shape[y]-w}ze(d.shape[y]===m.reduce((w,I)=>w+I),()=>"The sum of sizes must match the size of the axis dimension."),b=m}return b}(s,o,u),l=new Array(s.shape.length).fill(0),c=s.shape.slice();return h.map(d=>{const m=[...c];m[u]=d;const y=Eg({inputs:{x:s},attrs:{begin:l,size:m},backend:r});return l[u]+=d,y})}},Xme=ua(m8),Zme=ua("Square"),Yme=Va(b8,!0);let Sj;const Ume={kernelName:fT,backendName:"wasm",setupFunc:function(n){Sj=n.wasm.cwrap(fT,null,["number","number","number","number"])},kernelFunc:function(n){const{backend:e,inputs:t,attrs:r}=n,{alpha:s}=r,{x:o}=t,A=e.dataIdMap.get(o.dataId).id,u=e.makeOutput(o.shape,o.dtype),h=e.dataIdMap.get(u.dataId).id;return Sj(A,s,xs[o.dtype],h),u}};let Nj;const Qme={kernelName:cT,backendName:"wasm",setupFunc:function(n){Nj=n.wasm.cwrap(cT,null,["number","array","number","array","array","array","array","array","number","number"])},kernelFunc:function(n){const{backend:e,inputs:t,attrs:r}=n,{x:s}=t,{begin:o,end:A,strides:u,beginMask:h,endMask:l,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:m}=r,{finalShapeSparse:y,finalShape:b,isIdentity:v,sliceDim0:w,isSimpleSlice:I,begin:S,end:T,strides:D}=function(W,K,U,_,ee,re,ce,we,Ee){let Pe;if(_==null?(Pe=new Array(K.length),Pe.fill(1)):Pe=_,ce!=null&&ce&ce-1)throw new Error("Multiple ellipses in slice is not allowed.");let he=!1;const de={dims:Pe.length,numAddAxisAfterEllipsis:0,begin:K.slice(),end:U.slice(),strides:Pe.slice(),beginMask:ee,endMask:re,ellipsisMask:ce,newAxisMask:we,shrinkAxisMask:Ee};for(let Re=0;Re<de.dims;Re++)he&&1<<Re&we&&de.numAddAxisAfterEllipsis++,1<<Re&ce&&(he=!0);he||(de.ellipsisMask|=1<<de.dims,de.dims++);const Ae={dims:W.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};(function(Re,Ue){Ue.beginMask=0,Ue.endMask=0,Ue.shrinkAxisMask=0;let ot=0;Ue.beginValid=Re.begin!=null,Ue.endValid=Re.end!=null,Ue.begin=new Array(Ue.dims),Ue.end=new Array(Ue.dims),Ue.strides=new Array(Ue.dims),Ue.finalShapeGatherIndices=[],Ue.finalShapeGatherIndicesSparse=[],Ue.inputShapeGatherIndicesSparse=new Array(Ue.dims);for(let yt=0;yt<Re.dims;yt++)if(1<<yt&Re.ellipsisMask){const Vt=Math.min(Ue.dims-(Re.dims-yt)+1+Re.numAddAxisAfterEllipsis,Ue.dims);for(;ot<Vt;ot++)Ue.begin[ot]=0,Ue.end[ot]=0,Ue.strides[ot]=1,Ue.beginMask|=1<<ot,Ue.endMask|=1<<ot,Ue.finalShapeGatherIndices.push(ot),Ue.finalShapeGatherIndicesSparse.push(-1),Ue.inputShapeGatherIndicesSparse[ot]=yt}else if(1<<yt&Re.newAxisMask)Ue.finalShapeGatherIndices.push(-2),Ue.finalShapeGatherIndicesSparse.push(-1);else{if(ot===Ue.begin.length)throw Error(`Index out of range using input dim ${ot}; input has only ${Ue.dims} dims, ${Ue.begin.length}.`);Re.begin!=null&&(Ue.begin[ot]=Re.begin[yt]),Re.end!=null&&(Ue.end[ot]=Re.end[yt]),Ue.strides[ot]=Re.strides[yt],Re.beginMask&1<<yt&&(Ue.beginMask|=1<<ot),Re.endMask&1<<yt&&(Ue.endMask|=1<<ot),Re.shrinkAxisMask&1<<yt?(Ue.finalShapeGatherIndices.push(-1),Ue.finalShapeGatherIndicesSparse.push(-1),Ue.shrinkAxisMask|=1<<ot):(Ue.finalShapeGatherIndices.push(ot),Ue.finalShapeGatherIndicesSparse.push(yt)),Ue.inputShapeGatherIndicesSparse[ot]=yt,ot++}})(de,Ae);let Se=!0,Te=!0,Ze=!0;const et=[],qe=[];for(let Re=0;Re<W.length;++Re){if(Ae.strides[Re]===0)throw Error(`strides[${Re}] must be non-zero`);const Ue=!!(Ae.shrinkAxisMask&1<<Re),ot=W[Re];if(ot===-1){et.push(Ue?1:-1);continue}const yt=[Ae.beginMask&1<<Re,Ae.endMask&1<<Re],Vt=[Ae.strides[Re]>0?0:-1,Ae.strides[Re]>0?ot:ot-1];if(Ue&&Ae.strides[Re]<=0)throw Error("only stride 1 allowed on non-range indexing.");Ze=Ze&&Ae.strides[Re]===1;const ln=!!(Ae.beginMask&1<<Re&&Ae.endMask&1<<Re);if(Ae.beginValid&&Ae.endValid){if(Ue){const wn=Ae.begin[Re]<0?ot+Ae.begin[Re]:Ae.begin[Re];if(Ae.begin[Re]=wn,Ae.end[Re]=Ae.begin[Re]+1,wn<0||wn>=ot)throw Error(`slice index ${Ae.begin[Re]} of dimension ${Re} out of bounds.`)}else Ae.begin[Re]=tW(Ae.begin[Re],0,Ae.strides[Re],ot,yt,Vt),Ae.end[Re]=tW(Ae.end[Re],1,Ae.strides[Re],ot,yt,Vt);const hn=Ae.strides[Re]===1&&Ae.begin[Re]===0&&Ae.end[Re]===ot;Se=Se&&hn,Te=Te&&(Re===0&&Ae.strides[Re]===1||hn)}else Se=Se&&Ae.strides[Re]===1&&ln,Te=Te&&(Re===0&&Ae.strides[Re]===1||ln);let en,Xt=!1;if(Ae.beginValid&&Ae.endValid?(en=Ae.end[Re]-Ae.begin[Re],Xt=!0):Ue?(en=1,Xt=!0):ln&&ot>=0&&(en=Ae.strides[Re]<0?-ot:ot,Xt=!0),Xt){let hn;hn=en===0||en<0!=Ae.strides[Re]<0?0:Math.trunc(en/Ae.strides[Re])+(en%Ae.strides[Re]!=0?1:0),et.push(hn)}else et.push(-1)}for(let Re=0;Re<Ae.finalShapeGatherIndices.length;++Re){const Ue=Ae.finalShapeGatherIndices[Re];Ue>=0?qe.push(et[Ue]):Ue===-2&&qe.push(1)}return{finalShapeSparse:qe.filter((Re,Ue)=>Ae.finalShapeGatherIndices[Ue]!==-2),finalShape:qe,isIdentity:Se,sliceDim0:Te,isSimpleSlice:Ze,begin:Ae.begin,end:Ae.end,strides:Ae.strides}}(s.shape,o,A,u,h,l,c,d,m);let L;if(v)L=oo({inputs:{x:s},backend:e,attrs:{shape:b}});else if(w||I){ze(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const W=function(U,_,ee){const re=[];for(let ce=0;ce<U.length;ce++)re[ce]=Math.ceil((_[ce]-U[ce])/ee[ce]);return re}(S,T,D),K=Eg({inputs:{x:s},backend:e,attrs:{begin:S,size:W}});L=oo({inputs:{x:K},backend:e,attrs:{shape:b}}),e.disposeData(K.dataId)}else{const W=e.makeOutput(y,"float32"),K=e.dataIdMap.get(s.dataId).id,U=new Uint8Array(new Int32Array(ka(s.shape)).buffer),_=new Uint8Array(new Int32Array(S).buffer),ee=new Uint8Array(new Int32Array(T).buffer),re=new Uint8Array(new Int32Array(D).buffer),ce=new Uint8Array(new Int32Array(y).buffer),we=new Uint8Array(new Int32Array(ka(y)).buffer),Ee=e.dataIdMap.get(W.dataId).id;Nj(K,U,s.shape.length,_,ee,re,ce,we,y.length,Ee),L=oo({inputs:{x:W},backend:e,attrs:{shape:b}}),e.disposeData(W.dataId)}return L}},Kme=Va("Sub",!0);let Tj;const qme={kernelName:lT,backendName:"wasm",setupFunc:function(n){Tj=n.wasm.cwrap(lT,null,["number","number","number","number"])},kernelFunc:function(n){const{backend:e,inputs:t,attrs:r}=n,{axis:s,keepDims:o}=r,{x:A}=t,u=e.dataIdMap.get(A.dataId).id;let h=u,l=A;const{transposed:c,axes:d,originalAxes:m,inputWasTransposed:y}=Gu(A,s,e);let b=d;if(y){const T=e.dataIdMap.get(c.dataId).id;T!==u&&(l=c,h=T,b=Sg(b.length,l.shape.length))}Fu("sum",b,l.shape.length);const[v,w]=Ad(l.shape,b),I=Jt(w),S=e.makeOutput(v,l.dtype);if(Jt(l.shape)!==0){const T=e.dataIdMap.get(S.dataId).id;Tj(h,I,xs[S.dtype],T)}if(y&&e.disposeData(c.dataId),o){const T=FA(S.shape,m);S.shape=T}return S}},Jme=ua("Tan"),$me=ua(v8);let Mj,Ej,Dj;const _me=[yfe,bfe,vfe,kfe,Cfe,Ife,Sfe,Tfe,Efe,Dfe,zfe,Ofe,Pfe,Bfe,Ffe,Lfe,Rfe,Wfe,jfe,Hfe,Gfe,Vfe,Xfe,Zfe,Yfe,Ufe,Qfe,Kfe,qfe,gfe,Jfe,$fe,_fe,eme,tme,nme,rme,xfe,sme,ame,ome,ime,Ame,lme,ume,cme,dme,pme,hme,fme,mme,gme,yme,bme,vme,xme,wme,kme,Cme,mj,Ime,Sme,Nme,Tme,Mme,Eme,Dme,Nfe,zme,Ome,Pme,Fme,Bme,Lme,Rme,Wme,jme,Mfe,Hme,Gme,Vme,Xme,Zme,Yme,Ume,Qme,Kme,qme,Jme,$me,{kernelName:d1,backendName:"wasm",setupFunc:function(n){Mj=n.wasm.cwrap(d1,null,["number","array","number","array","number","number"])},kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,o=t.dataIdMap.get(s.dataId).id,{reps:A}=r,u=new Array(s.shape.length);for(let m=0;m<u.length;m++)u[m]=s.shape[m]*A[m];const h=new Uint8Array(new Int32Array(s.shape).buffer),l=new Uint8Array(new Int32Array(u).buffer),c=t.makeOutput(u,s.dtype),d=t.dataIdMap.get(c.dataId).id;return Mj(o,h,s.shape.length,l,u.length,xs[c.dtype],d),c}},{kernelName:dT,backendName:"wasm",setupFunc:function(n){Ej=n.wasm.cwrap(dT,null,["number","array","number","number","number","bool","number","number"])},kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:r}=n,{k:s,sorted:o}=t,A=e.dataIdMap.get(r.dataId).id,u=new Uint8Array(new Int32Array(r.shape).buffer),h=r.shape.slice();h[h.length-1]=s;const l=e.makeOutput(h,r.dtype),c=e.dataIdMap.get(l.dataId).id,d=e.makeOutput(h,"int32"),m=e.dataIdMap.get(d.dataId).id;return Ej(A,u,r.shape.length,xs[r.dtype],s,o,c,m),[l,d]}},{kernelName:pT,backendName:"wasm",setupFunc:function(n){Dj=n.wasm.cwrap(pT,null,["number","number","bool","number","number","number","number","number","number","array","number","number","number","number","number"])},kernelFunc:function(n){const{backend:e,inputs:t,attrs:r}=n,{image:s,transforms:o}=t,{interpolation:A,fillMode:u,fillValue:h,outputShape:l}=r,[c,d,m,y]=s.shape,[b,v]=l??[d,m],w=[c,b,v,y],I=new Uint8Array(new Int32Array(ka(s.shape)).buffer),S=e.makeOutput(w,s.dtype),T=e.dataIdMap.get(S.dataId).id,D=e.dataIdMap.get(s.dataId).id,L=e.dataIdMap.get(o.dataId).id,W=A==="nearest"?1:2;let K;switch(u){case"constant":default:K=1;break;case"reflect":K=2;break;case"wrap":K=3;break;case"nearest":K=4}return Dj(D,L,o.shape[0]>1,c,b,v,y,m,d,I,s.shape.length-1,W,K,h,T),S}},wfe,{kernelName:x8,backendName:"wasm",kernelFunc:function(n){const{inputs:e,backend:t,attrs:r}=n,{value:s}=e;let{axis:o}=r;o<0&&(o+=s.shape.length);const A=s.shape[o],u=s.shape.length,h=new Array(u-1);let l=0;for(let y=0;y<u;y++)y!==o&&(h[l++]=s.shape[y]);const c=new Array(A),d=new Array(u).fill(0),m=s.shape.slice();m[o]=1;for(let y=0;y<c.length;y++)d[o]=y,c[y]=Eg({inputs:{x:s},attrs:{begin:d,size:m},backend:t});return c.map(({dataId:y,dtype:b})=>({dataId:y,dtype:b,shape:h}))}},{kernelName:w8,backendName:"wasm",kernelFunc:function(n){const{inputs:{x:e},backend:t}=n,r=t.makeOutput(e.shape,e.dtype);return t.typedArrayFromHeap(r).fill(0),r}}];for(const n of _me)khe(n);const tM=yr();tM.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))),tM.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(tM.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}});var ege=p(417),zj=p.n(ege),tge=p(805),nge=p.n(tge);class rge extends ER{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(oge),this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new bhe(this,Xe)}write(e,t,r){const s={id:this.dataIdNextNumber++};return this.move(s,e,t,r,1),s}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){const t=eh();return e(),{kernelMs:eh()-t}}move(e,t,r,s,o){const A=this.dataIdNextNumber++;if(s==="string"){const c=t;return void this.dataIdMap.set(e,{id:A,stringBytes:c,shape:r,dtype:s,memoryOffset:null,refCount:o})}const u=Jt(r),h=u*c1(s),l=this.wasm._malloc(h);this.dataIdMap.set(e,{id:A,memoryOffset:l,shape:r,dtype:s,refCount:o}),this.wasm.tfjs.registerTensor(A,u,l),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,h),l)}async read(e){return this.readSync(e)}readSync(e){const{memoryOffset:t,dtype:r,shape:s,stringBytes:o}=this.dataIdMap.get(e);return r==="string"?o:function(A,u){switch(u){case"float32":return new Float32Array(A);case"int32":return new Int32Array(A);case"bool":return new Uint8Array(A);default:throw new Error(`Unknown dtype ${u}`)}}(this.wasm.HEAPU8.slice(t,t+Jt(s)*c1(r)).buffer,r)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){const r=this.dataIdMap.get(e);if(r.refCount--,!t&&r.refCount>0)return!1;this.wasm._free(r.memoryOffset),this.wasm.tfjs.disposeData(r.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){const t=this.dataIdMap.get(e);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,r){let s;if(r==null)s=this.write(null,e,t);else{const o=this.dataIdNextNumber++;s={id:o},this.dataIdMap.set(s,{id:o,memoryOffset:r,shape:e,dtype:t,refCount:1});const A=Jt(e);this.wasm.tfjs.registerTensor(o,A,r)}return{dataId:s,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:r}){const s=this.wasm.HEAPU8.buffer,{memoryOffset:o}=this.dataIdMap.get(r),A=Jt(e);switch(t){case"float32":return new Float32Array(s,o,A);case"int32":return new Int32Array(s,o,A);case"bool":return new Uint8Array(s,o,A);default:throw new Error(`Unknown dtype ${t}`)}}}function Oj(n,e,t){let r="tfjs-backend-wasm.wasm";return n&&e?r="tfjs-backend-wasm-threaded-simd.wasm":n&&(r="tfjs-backend-wasm-simd.wasm"),Og!=null&&Og[r]!=null?Og[r]:t+r}const sge=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"];let age=null,zg=null,Og={},D1=!1,Pj=!1,oge=-1;var rA,Bj;(function(n,e,t=1){Xe.registerBackend(n,e,t)})("wasm",async()=>{const{wasm:n}=await async function(){const[e,t]=await Promise.all([yr().getAsync("WASM_HAS_SIMD_SUPPORT"),yr().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((r,s)=>{const o={locateFile:(l,c)=>{if(l.endsWith(".worker.js")){const d=new Blob(['var Module={};function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;this.alert=threadAlert;Module["instantiateWasm"]=function(info,receiveInstance){var instance=new WebAssembly.Instance(Module["wasmModule"],info);Module["wasmModule"]=null;receiveInstance(instance);return instance.exports};function moduleLoaded(){}this.onmessage=function(e){try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob==="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module).then(function(instance){Module=instance;moduleLoaded()})}else if(e.data.cmd==="objectTransfer"){Module["PThread"].receiveObjectTransfer(e.data)}else if(e.data.cmd==="run"){Module["__performance_now_clock_drift"]=performance.now()-e.data.time;Module["__emscripten_thread_init"](e.data.threadInfoStruct,0,0);var max=e.data.stackBase;var top=e.data.stackBase+e.data.stackSize;Module["establishStackSpace"](top,max);Module["_emscripten_tls_init"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].setThreadStatus(Module["_pthread_self"](),1);try{var result=Module["invokeEntryPoint"](e.data.start_routine,e.data.arg);if(!Module["getNoExitRuntime"]())Module["PThread"].threadExit(result)}catch(ex){if(ex==="Canceled!"){Module["PThread"].threadCancel()}else if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["getNoExitRuntime"]()){}else{Module["PThread"].threadExit(ex.status)}}else{Module["PThread"].threadExit(-2);throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["PThread"].threadCancel()}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processThreadQueue"){if(Module["_pthread_self"]()){Module["_emscripten_current_thread_process_queued_calls"]()}}else{err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){err("worker.js onmessage() captured an uncaught exception: "+ex);if(ex&&ex.stack)err(ex.stack);throw ex}};if(typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string"){self={location:{href:__filename}};var onmessage=this.onmessage;var nodeWorkerThreads=require("worker_threads");global.Worker=nodeWorkerThreads.Worker;var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",function(data){onmessage({data:data})});var nodeFS=require("fs");var nodeRead=function(filename){return nodeFS.readFileSync(filename,"utf8")};function globalEval(x){global.require=require;global.Module=Module;eval.call(null,x)}importScripts=function(f){globalEval(nodeRead(f))};postMessage=function(msg){parentPort.postMessage(msg)};if(typeof performance==="undefined"){performance={now:function(){return Date.now()}}}}'],{type:"application/javascript"});return URL.createObjectURL(d)}return l.endsWith(".wasm")?Oj(e,t,zg??c):c+l}};var A;Pj&&(o.instantiateWasm=(A=Oj(e,t,zg??""),(l,c)=>(function(d){return yr().platform.fetch(d,{credentials:"same-origin"})}(A).then(d=>{d.ok||l.env.a(`failed to load wasm binary file at '${A}'`),d.arrayBuffer().then(m=>{WebAssembly.instantiate(m,l).then(y=>{c(y.instance,y.module)})})}),{})));let u,h=!1;o.onAbort=()=>{h||D1||(D1=!0,s({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))},t&&e&&age==null?(o.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+zj().toString()],{type:"text/javascript"}),u=zj()(o)):u=nge()(o),u.then(l=>{h=!0,D1=!1,l.tfjs={init:l.cwrap("init",null,[]),initWithThreadsCount:l.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:l.cwrap("get_threads_count","number",[]),registerTensor:l.cwrap("register_tensor",null,["number","number","number"]),disposeData:l.cwrap("dispose_data",null,["number"]),dispose:l.cwrap("dispose",null,[])},r({wasm:l})})})}();return new rge(n)},2),function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(rA||(rA={})),function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))}(Bj||(Bj={}));const ige={};function Fj(n){return ige[n]}function X(n,e,t,r,s){const o=e.inputParams[n];if(o&&o.inputIndexStart!==void 0){const u=o.inputIndexStart,h=o.inputIndexEnd===0?void 0:o.inputIndexEnd===void 0?u+1:o.inputIndexEnd;if(o.type==="tensor")return Xa(e.inputNames[o.inputIndexStart],t,r,s);if(o.type==="tensors")return e.inputNames.slice(u,h).map(d=>Xa(d,t,r,s));const l=Xa(e.inputNames.slice(u)[0],t,r,s),c=l.dataSync();return o.type==="number"?c[0]:IN(l.shape,c)}const A=e.attrParams[n];return A&&A.value}function Xa(n,e,t,r){const[s,o]=Eo(n);if(r!=null){const u=r.getHashTableHandleByName(s);if(u!=null)return u}const A=t.currentContextIds.find(u=>!!e[z1(s,u)]);return A!==void 0?e[z1(s,A)][o]:void 0}function kl(n,e){const[t,r,s]=Eo(n);return[z1(t,e&&e.currentContextId),r,s]}function z1(n,e){return e?`${n}-${e}`:n}function Eo(n){const e=n.split(":");if(e.length===1)return[n,0,void 0];const t=e[0],r=e.length===3?e[1]:void 0;return[t,Number(e[e.length-1]),r]}function O1(n,e,t){let r=X("pad",n,e,t);if(r==="explicit"){r=X("explicitPaddings",n,e,t);const s=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)s[o][0]=r[2*o],s[o][1]=r[2*o+1];return s}return r}function Vu(n){return n.kept?n:sd(n)}const Age=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],lge=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],uge=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}],cge=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],dge=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],pge=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],hge=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],fge=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],mge=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],gge=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],yge=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],bge=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],vge=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],xge=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],wge=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],kge=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Cge=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Ige=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Sge=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class Lj{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[ye,pe,Q,ke,ie,Ie,je,xe,We,Ke,ut,ge,Qe,At,dt,It,Ft,pn,Yt].map(t=>t.json));this.opMappers=e.reduce((t,r)=>(t[r.tfOpName]=r,t),{})}transformGraph(e,t={}){const r=e.node,s=[],o=[],A=[],u=r.reduce((v,w)=>(v[w.name]=this.mapNode(w),w.op.startsWith("Placeholder")?s.push(v[w.name]):w.op==="Const"?o.push(v[w.name]):w.input!=null&&w.input.length!==0||A.push(v[w.name]),v),{});let h=[];const l=[];let c={},d={};t!=null&&(c=this.mapSignatureEntries(t.inputs),d=this.mapSignatureEntries(t.outputs));const m=Object.keys(u);m.forEach(v=>{const w=u[v];w.inputNames.forEach((I,S)=>{const[T,,D]=kl(I),L=u[T];if(L.outputs!=null){const W=L.outputs.indexOf(D);if(W!==-1){const K=`${T}:${W}`;w.inputNames[S]=K}}w.inputs.push(L),L.children.push(w)})}),Object.keys(d).length===0?m.forEach(v=>{const w=u[v];w.children.length===0&&l.push(w)}):Object.keys(d).forEach(v=>{const[w]=kl(v),I=u[w];I!=null&&(I.signatureKey=d[v],l.push(I))}),Object.keys(c).length>0?Object.keys(c).forEach(v=>{const[w]=kl(v),I=u[w];I&&(I.signatureKey=c[v],h.push(I))}):h=s;let y={};e.library!=null&&e.library.function!=null&&(y=e.library.function.reduce((v,w)=>(v[w.signature.name]=this.mapFunction(w),v),{}));const b={nodes:u,inputs:h,outputs:l,weights:o,placeholders:s,signature:t,functions:y};return A.length>0&&(b.initNodes=A),b}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,r)=>(t[e[r].name]=r,t),{})}mapNode(e){const t=Fj(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const r={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(s=>s.startsWith("^")?s.substr(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(r.inputParams=t.inputs.reduce((s,o)=>(s[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},s),{})),t.attrs!=null&&(r.attrParams=t.attrs.reduce((s,o)=>{const A=o.type;let u;switch(o.type){case"string":u=nM(e.attr,o.tfName,o.defaultValue),u===void 0&&o.tfDeprecatedName&&(u=nM(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":u=uM(e.attr,o.tfName,o.defaultValue),u===void 0&&o.tfDeprecatedName&&(u=uM(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":u=sM(e.attr,o.tfName,o.defaultValue||0),u===void 0&&o.tfDeprecatedName&&(u=sM(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":u=lM(e.attr,o.tfName,o.defaultValue),u===void 0&&o.tfDeprecatedName&&(u=lM(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":u=rM(e.attr,o.tfName,o.defaultValue),u===void 0&&o.tfDeprecatedName&&(u=rM(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":u=dM(e.attr,o.tfName,o.defaultValue),u===void 0&&o.tfDeprecatedName&&(u=dM(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":u=AM(e.attr,o.tfName,o.defaultValue),u===void 0&&o.tfDeprecatedName&&(u=AM(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":u=cM(e.attr,o.tfName,o.defaultValue),u===void 0&&o.tfDeprecatedName&&(u=cM(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":u=oM(e.attr,o.tfName,o.defaultValue),u===void 0&&o.tfDeprecatedName&&(u=oM(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":u=iM(e.attr,o.tfName,o.defaultValue),u===void 0&&o.tfDeprecatedName&&(u=iM(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":u=Wj(e.attr,o.tfName,o.defaultValue),u===void 0&&o.tfDeprecatedName&&(u=Wj(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${e.op}`)}return s[o.name]={value:u,type:A},s},{})),r}mapFunction(e){const t=e.nodeDef,r=[];let s={};t!=null&&(s=t.reduce((l,c)=>(l[c.name]=this.mapNode(c),c.op==="Const"&&r.push(l[c.name]),l),{}));const o=[],A=[];e.signature.inputArg.forEach(l=>{const[c]=kl(l.name),d={name:c,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:aM(l.type),type:"dtype"}},children:[]};d.signatureKey=l.name,o.push(d),s[c]=d}),Object.keys(s).forEach(l=>{const c=s[l];c.inputNames.forEach((d,m)=>{const[y,,b]=kl(d),v=s[y];if(v.outputs!=null){const w=v.outputs.indexOf(b);if(w!==-1){const I=`${y}:${w}`;c.inputNames[m]=I}}c.inputs.push(v),v.children.push(c)})});const u=e.ret;e.signature.outputArg.forEach(l=>{const[c,d]=kl(u[l.name]),m=s[c];m!=null&&(m.defaultOutput=d,A.push(m))});const h=this.mapArgsToSignature(e);return{nodes:s,inputs:o,outputs:A,weights:r,placeholders:[],signature:h}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r),t),{}),outputs:e.signature.outputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r,e.ret),t),{})}}mapArgToTensorInfo(e,t){let r=e.name;return t!=null&&(r=t[r]),{name:r,dtype:e.type}}}function Rj(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):function(r){const s=yr().global;if(s.atob!==void 0)return s.atob(r);if(typeof Buffer<"u")return new Buffer(r,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(n);return e?t:t.toLowerCase()}function nM(n,e,t,r=!1){const s=n[e];return s!=null?Rj(s.s,r):t}function rM(n,e,t){const r=n[e];return r?r.b:t}function sM(n,e,t){const r=n[e]||{},s=r.i!=null?r.i:r.f!=null?r.f:t;return typeof s=="number"?s:parseInt(s,10)}function aM(n){switch(typeof n=="string"&&(n=rA[n]),n){case rA.DT_FLOAT:return"float32";case rA.DT_INT32:case rA.DT_INT64:case rA.DT_INT8:case rA.DT_UINT8:return"int32";case rA.DT_BOOL:return"bool";case rA.DT_DOUBLE:return"float32";case rA.DT_STRING:return"string";default:return null}}function Wj(n,e,t){const r=n[e];return r&&r.func?r.func.name:t}function oM(n,e,t){const r=n[e];return r&&r.type?aM(r.type):t}function iM(n,e,t){const r=n[e];return r&&r.list&&r.list.type?r.list.type.map(s=>aM(s)):t}function jj(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function AM(n,e,t){const r=n[e];return r&&r.shape?jj(r.shape):t}function lM(n,e,t){const r=n[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):t}function uM(n,e,t,r=!1){const s=n[e];return s&&s.list&&s.list.s?s.list.s.map(o=>Rj(o,r)):t}function cM(n,e,t){const r=n[e];return r&&r.list&&r.list.shape?r.list.shape.map(s=>jj(s)):t}function dM(n,e,t){const r=n[e];return r&&r.list&&r.list.b?r.list.b:t}class Nge{constructor(e,t,r){this.node=e,this.tensorMap=t,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(s=>this.getInput(s)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((s,o)=>(s[o]=this.getAttr(o),s),{}))}getInput(e){return Xa(e,this.tensorMap,this.context)}getAttr(e,t){const r=this.node.rawAttrs[e];if(r.tensor!=null)return Xa(e,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return sM(this.node.rawAttrs,e,t);if(r.s!=null)return nM(this.node.rawAttrs,e,t);if(r.b!=null)return rM(this.node.rawAttrs,e,t);if(r.shape!=null)return AM(this.node.rawAttrs,e,t);if(r.type!=null)return oM(this.node.rawAttrs,e,t);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return lM(this.node.rawAttrs,e,t);if(r.list.s!=null)return uM(this.node.rawAttrs,e,t);if(r.list.shape!=null)return cM(this.node.rawAttrs,e,t);if(r.list.b!=null)return dM(this.node.rawAttrs,e,t);if(r.list.type!=null)return iM(this.node.rawAttrs,e,t)}return t}}const Tge=Ge({addN_:function(n){ze(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),ze(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((s,o)=>me(s,`tensors${o}`,"addN")),t=e[0];e.forEach(s=>{if(s.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(s=>{if(!_c(s.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=e;return Xe.runKernel(MN,r)}}),Mge=Ge({mod_:function(n,e){let t=me(n,"a","mod"),r=me(e,"b","mod");[t,r]=ts(t,r);const s={a:t,b:r};return Xe.runKernel("Mod",s)}}),Hj=Ge({equal_:function(n,e){let t=me(n,"a","equal","string_or_numeric"),r=me(e,"b","equal","string_or_numeric");[t,r]=ts(t,r),Ia(t.shape,r.shape);const s={a:t,b:r};return Xe.runKernel(XR,s)}}),Ege=Ge({divNoNan_:function(n,e){let t=me(n,"a","div"),r=me(e,"b","div");[t,r]=ts(t,r);const s=Qs(t,r),o=PT(s),A=Hj(r,o);return ih(A,o,s)}}),Dge=Ge({maximum_:function(n,e){let t=me(n,"a","maximum"),r=me(e,"b","maximum");[t,r]=ts(t,r),t.dtype==="bool"&&(t=ns(t,"int32"),r=ns(r,"int32")),Ia(t.shape,r.shape);const s={a:t,b:r};return Xe.runKernel(t8,s)}}),zge=Ge({acos_:function(n){const e={x:me(n,"x","acos")};return Xe.runKernel("Acos",e)}}),Oge=Ge({acosh_:function(n){const e={x:me(n,"x","acosh")};return Xe.runKernel("Acosh",e)}}),Pge=Ge({asin_:function(n){const e={x:me(n,"x","asin")};return Xe.runKernel("Asin",e)}}),Bge=Ge({asinh_:function(n){const e={x:me(n,"x","asinh")};return Xe.runKernel("Asinh",e)}}),Fge=Ge({atan_:function(n){const e={x:me(n,"x","atan")};return Xe.runKernel("Atan",e)}}),Lge=Ge({atan2_:function(n,e){let t=me(n,"a","atan2"),r=me(e,"b","atan2");[t,r]=ts(t,r);const s={a:t,b:r};return Xe.runKernel("Atan2",s)}}),Rge=Ge({atanh_:function(n){const e={x:me(n,"x","atanh")};return Xe.runKernel("Atanh",e)}}),Wge=Ge({ceil_:function(n){const e={x:me(n,"x","ceil","float32")};return Xe.runKernel(jR,e)}}),jge=Ge({cos_:function(n){const e={x:me(n,"x","cos","float32")};return Xe.runKernel("Cos",e)}}),Hge=Ge({cosh_:function(n){const e={x:me(n,"x","cosh","float32")};return Xe.runKernel(GR,e)}}),Gge=Ge({erf_:function(n){let e=me(n,"x","erf");ze(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=ns(e,"float32"));const t={x:e};return Xe.runKernel("Erf",t)}}),Vge=Ge({expm1_:function(n){const e={x:me(n,"x","expm1")};return Xe.runKernel("Expm1",e)}}),Xge=Ge({floor_:function(n){const e={x:me(n,"x","floor","float32")};return Xe.runKernel(UR,e)}}),Zge=Ge({reciprocal_:function(n){const e={x:me(n,"x","reciprocal")};return Xe.runKernel("Reciprocal",e)}}),Yge=Ge({selu_:function(n){const e={x:me(n,"x","selu")};return Xe.runKernel("Selu",e)}}),Uge=Ge({sin_:function(n){const e={x:me(n,"x","sin","float32")};return Xe.runKernel("Sin",e)}}),Qge=Ge({sign_:function(n){const e={x:me(n,"x","sign")};return Xe.runKernel("Sign",e)}}),Kge=Ge({sinh_:function(n){const e={x:me(n,"x","sinh")};return Xe.runKernel("Sinh",e)}}),qge=Ge({softplus_:function(n){const e={x:me(n,"x","softplus")};return Xe.runKernel("Softplus",e)}}),Jge=Ge({tanh_:function(n){const e={x:me(n,"x","tanh","float32")};return Xe.runKernel(v8,e)}}),$ge=Ge({tan_:function(n){const e={x:me(n,"x","tan","float32")};return Xe.runKernel("Tan",e)}}),_ge=Ge({clipByValue_:function(n,e,t){const r=me(n,"x","clipByValue");ze(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`);const s={x:r},o={clipValueMin:e,clipValueMax:t};return Xe.runKernel(FN,s,o)}}),eye=Ge({rsqrt_:function(n){const e={x:me(n,"x","rsqrt","float32")};return Xe.runKernel(d8,e)}}),Gj=Ge({prod_:function(n,e=null,t=!1){let r=me(n,"x","prod");r.dtype==="bool"&&(r=ns(r,"int32"));const s={x:r},o={axis:e,keepDims:t};return Xe.runKernel(aT,s,o)}}),tye=Ge({isNaN_:function(n){const e={x:me(n,"x","isNaN")};return Xe.runKernel("IsNan",e)}});function Ei(n,e,t=""){if(typeof n!="number"&&typeof e!="number"){ze(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let r=0;r<n.length;r++){const s=n[r],o=e[r];ze(s<0||o<0||s===o,()=>t+` Shapes ${n} and ${e} must match`)}}}function Vj(n){return typeof n!="number"&&!n.some(e=>e<0)}function Pg(n,e,t){let r=pM(n,t);const s=!Vj(r);if(s&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&e.forEach(o=>{r=pM(o.shape,r)}),!Vj(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function pM(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let r=0;r<n.length;++r){const s=n[r],o=e[r];if(s>=0&&o>=0&&s!==o)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[r]=s>=0?s:o}return t}class nye{constructor(e,t,r,s,o,A,u){this.name=e,this.dtype=t,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=o,this.dynamicSize=A,this.clearAfterRead=u,this.tensors=[],this.closed_=!1,this.idTensor=fr(0),Lu(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{e!=null&&e.has(t.tensor.id)||t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()!==0||this.elementShape!=null&&this.elementShape.length!==0||(this.elementShape=t.shape),Ei(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);r.tensor=t,Lu(t),r.written=!0,this.tensors[e]=r}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((r,s)=>this.write(r,t[s]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let s=0;s<this.size();s++)e.push(s)}if(e.length===0)return Eu([],[0].concat(this.elementShape));const r=this.readMany(e);return Ei(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),wl(r,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Eu([],[0].concat(this.elementShape));const t=[];for(let s=0;s<this.size();s++)t.push(s);const r=this.readMany(t);return Ei(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),To(r,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const r=Math.max(...e);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(e,id(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let r=0;const s=e.map(h=>(r+=h,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const o=r===0?0:t.size/r,A=[];ur(()=>{t=Nt(t,[1,r,o]);for(let h=0;h<e.length;++h){const l=[0,h===0?0:s[h-1],0],c=[1,e[h],o];A[h]=Nt($n(t,l,c),this.elementShape)}return A});const u=[];for(let h=0;h<e.length;h++)u[h]=h;this.writeMany(u,A)}}class uh{constructor(e,t,r,s=-1){this.tensors=e,this.elementShape=t,this.elementDtype=r,e!=null&&e.forEach(o=>{if(r!==o.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${o.dtype}`);Ei(t,o.shape,"TensorList shape mismatch: "),Lu(o)}),this.idTensor=fr(0),this.maxNumElements=s,Lu(this.idTensor)}get id(){return this.idTensor.id}copy(){return new uh([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{e!=null&&e.has(t.id)||t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,r=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);Ei(e,this.elementShape,"TensorList shape mismatch: ");const s=Pg(this.elementShape,this.tensors,e);return ur(()=>{const o=this.tensors.map(A=>Nt(A,s));return wl(o,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const r=Pg(this.elementShape,this.tensors,e),s=this.tensors.pop();return Ei(s.shape,e,"TensorList shape mismatch: "),Nt(s,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Ei(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Lu(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Ei(this.tensors[e].shape,t,"TensorList shape mismatch: ");const s=Pg(this.elementShape,this.tensors,t);return Nt(this.tensors[e],s)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Ei(this.elementShape,t.shape,"TensorList shape mismatch: "),Lu(t),this.tensors[e]=t}gather(e,t,r){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Ei(this.elementShape,r,"TensorList shape mismatch: "),e=e.slice(0,this.size());const s=Pg(this.elementShape,this.tensors,r);return e.length===0?Eu([],[0].concat(s)):ur(()=>{const o=e.map(A=>Nt(this.tensors[A],s));return wl(o,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Ei(this.elementShape,t,"TensorList shape mismatch: ");const r=Pg(this.elementShape,this.tensors,t);return this.size()===0?Eu([],[0].concat(r)):ur(()=>{const s=this.tensors.map(o=>Nt(o,r));return To(s,0)})}}const hM=Ge({conv2d_:function(n,e,t,r,s="NHWC",o=[1,1],A){const u=me(n,"x","conv2d","float32"),h=me(e,"filter","conv2d","float32");let l=u,c=!1;u.rank===3&&(c=!0,l=Nt(u,[1,u.shape[0],u.shape[1],u.shape[2]])),ze(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),ze(h.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${h.rank}.`),A!=null&&ze(ri(r),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${A} but got pad ${r}.`);const d=s==="NHWC"?l.shape[3]:l.shape[1];ze(d===h.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${h.shape[2]}.`),ze(ud(t,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);const m={x:l,filter:h},y={strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:A},b=Xe.runKernel(LN,m,y);return c?Nt(b,[b.shape[1],b.shape[2],b.shape[3]]):b}}),rye=Ge({conv1d_:function(n,e,t,r,s="NWC",o=1,A){const u=me(n,"x","conv1d"),h=me(e,"filter","conv1d");let l=u,c=!1;u.rank===2&&(c=!0,l=Nt(u,[1,u.shape[0],u.shape[1]])),ze(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),ze(h.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${h.rank}.`),A!=null&&ze(ri(r),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${A} but got pad ${r}.`),ze(l.shape[2]===h.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${h.shape[1]}.`),ze(ud(t,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${o}'`),ze(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const d=Nt(h,[1,h.shape[0],h.shape[1],h.shape[2]]),m=Nt(l,[l.shape[0],1,l.shape[1],l.shape[2]]),y=hM(m,d,[1,t],r,"NHWC",[1,o],A);return Nt(y,c?[y.shape[2],y.shape[3]]:[y.shape[0],y.shape[2],y.shape[3]])}}),sye=Ge({conv2DBackpropFilter_:function(n,e,t,r,s,o="NHWC",A){let u=n;n.rank===3&&(u=Nt(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let h=e;h.rank===3&&(h=Nt(e,[1,e.shape[0],e.shape[1],e.shape[2]])),ze(u.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${u.shape}.`),ze(h.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${h.shape}.`),ze(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const l=o==="NHWC"?u.shape[3]:u.shape[1],c=o==="NHWC"?h.shape[3]:h.shape[1];ze(l===t[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${t[2]}.`),ze(c===t[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${t[3]}).`),A!=null&&ze(ri(s),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${A} but got pad ${s}.`);const d={x:u,dy:h},m={strides:r,pad:s,dataFormat:o,dimRoundingMode:A,filterShape:t};return Xe.runKernel("Conv2DBackpropFilter",d,m)}}),Xj=Ge({conv2DBackpropInput_:function(n,e,t,r,s,o="NHWC",A){ze(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let u=n,h=e,l=!1;e.rank===3&&(l=!0,h=Nt(e,[1,e.shape[0],e.shape[1],e.shape[2]]),u=[1,n[0],n[1],n[2]]),ze(u.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${u.length}.`),ze(h.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${h.rank}`),ze(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const c=o==="NHWC"?u[3]:u[1],d=o==="NHWC"?h.shape[3]:h.shape[1];ze(c===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${t.shape[2]}.`),ze(d===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${t.shape[3]}.`),A!=null&&ze(ri(s),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${A} but got pad ${s}.`);const m={dy:h,filter:t},y={strides:r,pad:s,dataFormat:o,dimRoundingMode:A,inputShape:u},b=Xe.runKernel(RN,m,y);return l?Nt(b,[b.shape[1],b.shape[2],b.shape[3]]):b}}),aye=Ge({fusedConv2d_:function({x:n,filter:e,strides:t,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:A,bias:u,activation:h="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(h=h||"linear",qT(Xe.state.gradientDepth,h)===!1){let L=hM(n,e,t,r,s,o,A);return u!=null&&(L=Ca(L,u)),KT(L,h,l,c)}const d=me(n,"x","conv2d","float32"),m=me(e,"filter","conv2d","float32");let y=d,b=!1;d.rank===3&&(b=!0,y=Nt(d,[1,d.shape[0],d.shape[1],d.shape[2]])),ze(y.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${y.rank}.`),ze(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),A!=null&&ze(ri(r),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${A} but got pad ${r}.`),ze(y.shape[3]===m.shape[2],()=>`Error in conv2d: depth of input (${y.shape[3]}) must match input depth for filter ${m.shape[2]}.`),ze(ud(t,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),ze(s==="NHWC",()=>`Error in conv2d: got dataFormat of ${s} but only NHWC is currently supported.`);const v=Hu(y.shape,m.shape,t,o,r,A);let w,I;u!=null&&(w=me(u,"bias","fused conv2d"),[w]=ts(w,d),Ia(v.outShape,w.shape)),l!=null&&(I=me(l,"prelu weights","fused conv2d"));const S=(L,W)=>{const[K,U,_,ee]=W,re=UT(L,_,h);ze(N1(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const ce=[Xj(U.shape,re,K,t,r),sye(U,re,K.shape,t,r)];if(ee!=null){const we=QT(ee,re);ce.push(we)}return ce},T={x:y,filter:m,bias:w,preluActivationWeights:I},D={strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:A,activation:h,leakyreluAlpha:c};return u==null?Wu((W,K,U)=>{let _=Xe.runKernel(h1,T,D);return U([K,W,_]),b&&(_=Nt(_,[_.shape[1],_.shape[2],_.shape[3]])),{value:_,gradFunc:S}})(y,m):Wu((W,K,U,_)=>{let ee=Xe.runKernel(h1,T,D);return _([K,W,ee,U]),b&&(ee=Nt(ee,[ee.shape[1],ee.shape[2],ee.shape[3]])),{value:ee,gradFunc:S}})(y,m,w)}}),Zj=Ge({depthwiseConv2d_:function(n,e,t,r,s="NHWC",o=[1,1],A){const u=me(n,"x","depthwiseConv2d","float32"),h=me(e,"filter","depthwiseConv2d","float32");let l=u,c=!1;u.rank===3&&(c=!0,l=Nt(u,[1,u.shape[0],u.shape[1],u.shape[2]])),ze(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),ze(h.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`),ze(l.shape[3]===h.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),A!=null&&ze(ri(r),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${A} but got pad ${r}.`);const d={x:l,filter:h},m={strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:A},y=Xe.runKernel(GN,d,m);return c?Nt(y,[y.shape[1],y.shape[2],y.shape[3]]):y}}),oye=Ge({depthwiseConv2dNativeBackpropFilter_:function(n,e,t,r,s,o=[1,1],A){let u=n;n.rank===3&&(u=Nt(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let h=e;h.rank===3&&(h=Nt(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={x:u,dy:h},c={strides:r,pad:s,dimRoundingMode:A,dilations:o,filterShape:t};return Xe.runKernel("DepthwiseConv2dNativeBackpropFilter",l,c)}}),iye=Ge({depthwiseConv2dNativeBackpropInput_:function(n,e,t,r,s,o=[1,1],A){let u=e,h=!1;e.rank===3&&(h=!0,u=Nt(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={dy:u,filter:t},c={strides:r,pad:s,dimRoundingMode:A,dilations:o,inputShape:n},d=Xe.runKernel("DepthwiseConv2dNativeBackpropInput",l,c);return h?Nt(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),Aye=Ge({fusedDepthwiseConv2d_:function({x:n,filter:e,strides:t,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:A,bias:u,activation:h="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(qT(Xe.state.gradientDepth,h)===!1){let L=Zj(n,e,t,r,s,o,A);return u!=null&&(L=Ca(L,u)),KT(L,h,l,c)}const d=me(n,"x","depthwiseConv2d","float32"),m=me(e,"filter","depthwiseConv2d","float32");let y=d,b=!1;d.rank===3&&(b=!0,y=Nt(d,[1,d.shape[0],d.shape[1],d.shape[2]])),ze(y.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${y.rank}.`),ze(m.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${m.rank}.`),ze(y.shape[3]===m.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${y.shape[3]}) must match the inChannels dimension in filter ${m.shape[2]}.`),o==null&&(o=[1,1]),ze(ud(t,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),A!=null&&ze(ri(r),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${A} but got pad ${r}.`);const v=Hu(y.shape,m.shape,t,o,r,A,!0);let w,I;u!=null&&(w=me(u,"bias","fused conv2d"),[w]=ts(w,d),Ia(v.outShape,w.shape)),l!=null&&(I=me(l,"prelu weights","fused depthwiseConv2d"));const S=(L,W)=>{ze(N1(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[K,U,_,ee]=W,re=UT(L,_,h),ce=iye(U.shape,re,K,t,r,o,A),we=oye(U,re,K.shape,t,r,o,A);return ee!=null?[ce,we,QT(w,re)]:[ce,we]},T={x:y,filter:m,bias:w,preluActivationWeights:I},D={strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:A,activation:h,leakyreluAlpha:c};return u==null?Wu((W,K,U)=>{let _=Xe.runKernel(f1,T,D);return U([K,W,_]),b&&(_=Nt(_,[_.shape[1],_.shape[2],_.shape[3]])),{value:_,gradFunc:S}})(y,m):Wu((W,K,U,_)=>{let ee=Xe.runKernel(f1,T,D);return _([K,W,ee,U]),b&&(ee=Nt(ee,[ee.shape[1],ee.shape[2],ee.shape[3]])),{value:ee,gradFunc:S}})(y,m,w)}}),lye=Ge({conv2dTranspose_:function(n,e,t,r,s,o){const A=me(n,"x","conv2dTranspose"),u=me(e,"filter","conv2dTranspose");return Xj(t,A,u,r,s,"NHWC",o)}}),uye=Ge({conv3d_:function(n,e,t,r,s="NDHWC",o=[1,1,1]){const A=me(n,"x","conv3d"),u=me(e,"filter","conv3d");let h=A,l=!1;A.rank===4&&(l=!0,h=Nt(A,[1,A.shape[0],A.shape[1],A.shape[2],A.shape[3]])),ze(h.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${h.rank}.`),ze(u.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${u.rank}.`),ze(h.shape[4]===u.shape[3],()=>`Error in conv3d: depth of input (${h.shape[4]}) must match input depth for filter ${u.shape[3]}.`),ze(ud(t,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),ze(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);const c={x:h,filter:u},d={strides:t,pad:r,dataFormat:s,dilations:o},m=Xe.runKernel("Conv3D",c,d);return l?Nt(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),cye=Ge({avgPool_:function(n,e,t,r,s){const o=me(n,"x","avgPool","float32");ze(ud(t,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '1'`);let A=o,u=!1;o.rank===3&&(u=!0,A=Nt(o,[1,o.shape[0],o.shape[1],o.shape[2]])),ze(A.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${A.rank}.`),s!=null&&ze(ri(r),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const h={x:A},l={filterSize:e,strides:t,pad:r,dimRoundingMode:s};let c=Xe.runKernel(ON,h,l);return c=ns(c,o.dtype),u?Nt(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),dye=Ge({maxPool_:function(n,e,t,r,s){const o=me(n,"x","maxPool");let A=o,u=!1;o.rank===3&&(u=!0,A=Nt(o,[1,o.shape[0],o.shape[1],o.shape[2]])),ze(A.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${A.rank}.`),ze(ud(t,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '1'`),s!=null&&ze(ri(r),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const h={x:A},l={filterSize:e,strides:t,pad:r,dimRoundingMode:s},c=Xe.runKernel(KN,h,l);return u?Nt(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),pye=Ge({maxPoolWithArgmax_:function(n,e,t,r,s=!1){const o={x:me(n,"x","maxPoolWithArgmax")},A={filterSize:e,strides:t,pad:r,includeBatchInIndex:s},u=Xe.runKernel("MaxPoolWithArgmax",o,A);return{result:u[0],indexes:u[1]}}}),hye=Ge({avgPool3d_:function(n,e,t,r,s,o="NDHWC"){const A=me(n,"x","avgPool3d","float32");let u=A,h=!1;A.rank===4&&(h=!0,u=Nt(A,[1,A.shape[0],A.shape[1],A.shape[2],A.shape[3]])),ze(u.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${u.rank}.`),ze(o==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),s!=null&&ze(ri(r),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const l={x:u},c={filterSize:e,strides:t,pad:r,dimRoundingMode:s,dataFormat:o};let d=Xe.runKernel("AvgPool3D",l,c);return d=ns(d,u.dtype),h?Nt(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),fye=Ge({maxPool3d_:function(n,e=[1,1,1],t,r,s,o="NDHWC"){const A=me(n,"x","maxPool3d");let u=A,h=!1;A.rank===4&&(h=!0,u=Nt(A,[1,A.shape[0],A.shape[1],A.shape[2],A.shape[3]])),ze(u.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${u.rank}.`),ze(o==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),s!=null&&ze(ri(r),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const l={x:u},c={filterSize:e,strides:t,pad:r,dimRoundingMode:s,dataFormat:o},d=Xe.runKernel("MaxPool3D",l,c);return h?Nt(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),mye=Ge({dilation2d_:function(n,e,t,r,s=[1,1],o="NHWC"){const A=me(n,"x","dilation2d"),u=me(e,"filter","dilation2d");ze(A.rank===3||A.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${A.rank}.`),ze(u.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${u.rank}.`),ze(o==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let h=A,l=!1;A.rank===3&&(h=Nt(A,[1,A.shape[0],A.shape[1],A.shape[2]]),l=!0);const c={x:h,filter:u},d={strides:t,pad:r,dilations:s},m=Xe.runKernel("Dilation2D",c,d);return l?Nt(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});function Yj(n,e,t){const[r,s]=X("fusedOps",n,e,t),o=r==="biasadd",A=!o,u=s==="prelu",h=r==="fusedbatchnorm",l=X("numArgs",n,e,t);if(o){if(u&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!u&&o&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(h)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=X("strides",n,e,t),d=O1(n,e,t),m=X("dataFormat",n,e,t).toUpperCase(),y=X("dilations",n,e,t);let[b,v]=X("args",n,e,t);return A&&(v=b,b=void 0),{stride:c,pad:d,dataFormat:m,dilations:y,biasArg:b,preluArg:v,activationFunc:s,leakyreluAlpha:X("leakyreluAlpha",n,e,t)}}function gye(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const r={start:n,stop:e,num:t};return Xe.runKernel("LinSpace",{},r)}const yye=Ge({multinomial_:function(n,e,t,r=!1){const s=me(n,"logits","multinomial"),o=s.size,A=s.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(A>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${A}`);t=t||Math.random();const u={logits:A===1?Nt(s,[1,-1]):s},h={numSamples:e,seed:t,normalized:r},l=Xe.runKernel("Multinomial",u,h);return A===1?Nt(l,[l.size]):l}}),bye=Ge({oneHot_:function(n,e,t=1,r=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const s={indices:me(n,"indices","oneHot","int32")},o={depth:e,onValue:t,offValue:r};return Xe.runKernel(nT,s,o)}}),vye=Ge({onesLike_:function(n){const e={x:me(n,"x","onesLike")};return Xe.runKernel(a8,e)}});var Uj=p(264);class xye{constructor(e,t,r,s,o){this.mean=e,this.stdDev=t,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const A=o||Math.random();this.random=Uj.alea(A.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let e,t,r=!1;for(;!r;){let s,o,A;do s=2*this.random()-1,o=2*this.random()-1,A=s*s+o*o;while(A>=1||A===0);const u=Math.sqrt(-2*Math.log(A)/A);e=this.mean+this.stdDev*s*u,t=this.mean+this.stdDev*o*u,this.truncated&&!this.isValidTruncated(e)||(r=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class wye{constructor(e=0,t=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Uj.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const kye=Ge({randomUniform_:function(n,e=0,t=1,r="float32",s){const o=Ou(n,r),A=new wye(e,t,null,s);for(let u=0;u<o.values.length;u++)o.values[u]=A.nextValue();return o.toTensor()}}),Cye=Ge({truncatedNormal_:function(n,e=0,t=1,r,s){if(r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const o=new xye(e,t,r,!0,s),A=Ou(n,r);for(let u=0;u<A.values.length;u++)A.values[u]=o.nextValue();return A.toTensor()}}),Iye=async function(n){const e=me(n,"condition","whereAsync","bool"),t=await e.data(),r=function(s,o){const A=[];for(let l=0;l<o.length;l++)o[l]&&A.push(l);const u=Ou(s,"int32"),h=Ou([A.length,s.length],"int32");for(let l=0;l<A.length;l++){const c=u.indexToLoc(A[l]),d=l*s.length;h.values.set(c,d)}return h.toTensor()}(e.shape,t);return n!==e&&e.dispose(),r};function fM(n,e,t){return{boxes:X("boxes",n,e,t),scores:X("scores",n,e,t),maxOutputSize:X("maxOutputSize",n,e,t),iouThreshold:X("iouThreshold",n,e,t),scoreThreshold:X("scoreThreshold",n,e,t),softNmsSigma:X("softNmsSigma",n,e,t)}}const Sye=Ge({topk_:function(n,e=1,t=!0){const r=me(n,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${e}`);const o={x:r},A={k:e,sorted:t},[u,h]=Xe.runKernel(dT,o,A);return{values:u,indices:h}}}),Qj=Ge({unique_:function(n,e=0){const t=me(n,"x","unique","string_or_numeric");ze(t.rank>0,()=>"The input tensor must be at least 1D");const r={x:t},s={axis:e},[o,A]=Xe.runKernel("Unique",r,s);return{values:o,indices:A}}});class Nye{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=fr(0),this.tensorMap=new Map,Lu(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return fr(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const r=await e.data();return this.tensorMap.forEach(s=>s.dispose()),this.tensorMap.clear(),ur(()=>{const s=id(t),o=r.length,A=s.length;ze(o===A,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${A} elements.`);for(let u=0;u<o;u++){const h=r[u],l=s[u];Lu(l),this.tensorMap.set(h,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const r=await e.data();return ur(()=>{const s=[];for(let o=0;o<r.length;o++){const A=r[o],u=this.findWithDefault(A,t);s.push(u)}return wl(s)})}findWithDefault(e,t){const r=this.tensorMap.get(e);return r??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}const Tye=Ge({less_:function(n,e){let t=me(n,"a","less","string_or_numeric"),r=me(e,"b","less","string_or_numeric");[t,r]=ts(t,r),Ia(t.shape,r.shape);const s={a:t,b:r};return Xe.runKernel($R,s)}}),Mye=Ge({logicalNot_:function(n){const e={x:me(n,"x","logicalNot","bool")};return Xe.runKernel("LogicalNot",e)}}),Eye=Ge({logicalOr_:function(n,e){const t=me(n,"a","logicalOr","bool"),r=me(e,"b","logicalOr","bool");Ia(t.shape,r.shape);const s={a:t,b:r};return Xe.runKernel("LogicalOr",s)}}),Dye=Ge({einsum_:function(n,...e){const t=e.map((s,o)=>me(s,`tensors${o}`,"einsum")),r={equation:n};return Xe.runKernel("Einsum",t,r)}}),zye=Ge({fusedMatMul_:function({a:n,b:e,transposeA:t=!1,transposeB:r=!1,bias:s,activation:o="linear",preluActivationWeights:A,leakyreluAlpha:u}){if(qT(Xe.state.gradientDepth,o)===!1){let ee=Ks(n,e,t,r);return s!=null&&(ee=Ca(ee,s)),KT(ee,o,A,u)}let h=me(n,"a","fused matMul"),l=me(e,"b","fused matMul");[h,l]=ts(h,l);const c=t?h.shape[h.rank-2]:h.shape[h.rank-1],d=r?l.shape[l.rank-1]:l.shape[l.rank-2],m=t?h.shape[h.rank-1]:h.shape[h.rank-2],y=r?l.shape[l.rank-2]:l.shape[l.rank-1],b=h.shape.slice(0,-2),v=l.shape.slice(0,-2),w=Jt(b),I=Jt(v);ze(h.rank>=2&&l.rank>=2&&h.rank===l.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${h.rank} and ${l.rank}.`),ze(_c(b,v),()=>`Error in fused matMul: outer dimensions (${b}) and (${v}) of Tensors with shapes ${h.shape} and ${l.shape} must match.`),ze(c===d,()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${h.shape} and ${l.shape} and transposeA=${t} and transposeB=${r} must match.`);const S=h.shape.slice(0,-2).concat([m,y]),T=Nt(h,t?[w,c,m]:[w,m,c]),D=Nt(l,r?[I,y,d]:[I,d,y]);let L,W;s!=null&&(L=me(s,"bias","fused matMul"),[L]=ts(L,h),Ia(S,L.shape)),A!=null&&(W=me(A,"prelu weights","fused matMul"));const K=(ee,re)=>{const[ce,we,Ee,Pe]=re,he=UT(Nt(ee,Ee.shape),Ee,o);let de,Ae;return t||r?!t&&r?(de=Ks(he,we,!1,!1),Ae=Ks(he,ce,!0,!1)):t&&!r?(de=Ks(we,he,!1,!0),Ae=Ks(ce,he,!1,!1)):(de=Ks(we,he,!0,!0),Ae=Ks(he,ce,!0,!0)):(de=Ks(he,we,!1,!0),Ae=Ks(ce,he,!0,!1)),s!=null?[de,Ae,QT(Pe,he)]:[de,Ae]},U={a:T,b:D,bias:L,preluActivationWeights:W},_={transposeA:t,transposeB:r,activation:o,leakyreluAlpha:u};return s==null?Wu((re,ce,we)=>{const Ee=Xe.runKernel(p1,U,_);return we([re,ce,Ee]),{value:Nt(Ee,S),gradFunc:K}})(T,D):Wu((re,ce,we,Ee)=>{const Pe=Xe.runKernel(p1,U,_);return Ee([re,ce,Pe,we]),{value:Nt(Pe,S),gradFunc:K}})(T,D,L)}}),Oye=Ge({batchNorm_:function(n,e,t,r,s,o){o==null&&(o=.001);const A=me(n,"x","batchNorm"),u=me(e,"mean","batchNorm"),h=me(t,"variance","batchNorm");let l,c;s!=null&&(l=me(s,"scale","batchNorm")),r!=null&&(c=me(r,"offset","batchNorm")),ze(u.rank===h.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),ze(c==null||u.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),ze(l==null||u.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const d={x:function(b){let v;return v=b.rank===0||b.rank===1?Nt(b,[1,1,1,b.size]):b.rank===2?Nt(b,[1,1,b.shape[0],b.shape[1]]):b.rank===3?Nt(b,[1,b.shape[0],b.shape[1],b.shape[2]]):b,v}(A),scale:l,offset:c,mean:u,variance:h},m={varianceEpsilon:o},y=Xe.runKernel(XN,d,m);return Nt(y,A.shape)}}),Pye=Ge({localResponseNormalization_:function(n,e=5,t=1,r=1,s=.5){const o=me(n,"x","localResponseNormalization");ze(o.rank===4||o.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${o.rank}.`),ze(ri(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let A=o,u=!1;o.rank===3&&(u=!0,A=Nt(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const h={x:A},l={depthRadius:e,bias:t,alpha:r,beta:s},c=Xe.runKernel("LRN",h,l);return u?Nt(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),Bye=Ge({softmax_:function(n,e=-1){const t=me(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const r={logits:t},s={dim:e};return Xe.runKernel(uT,r,s)}}),Fye=Ge({logSoftmax_:function(n,e=-1){const t=me(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return Wu((r,s)=>{const o=Ah(r,e,!0),A=_n(r,o),u=_n(ns(A,"float32"),Tg(Or(ld(A),e,!0)));return s([u]),{value:u,gradFunc:(h,l)=>{const[c]=l,d=ld(c);return _n(h,Dn(Or(h,e,!0),d))}}})(t)}}),Kj=Ge({sparseToDense_:function(n,e,t,r=0){const s=me(n,"sparseIndices","sparseToDense","int32"),o=me(e,"sparseValues","sparseToDense"),A=me(r,"defaultValue","sparseToDense",o.dtype);(function(l,c,d,m){if(l.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${l.dtype}.`);if(l.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${l.shape}.`);const y=l.rank>0?l.shape[0]:1,b=l.rank>1?l.shape[1]:1;if(d.length!==b)throw new Error(`outputShape has incorrect number of elements:, ${d.length}, should be: ${b}.`);const v=c.size;if(c.rank!==0&&(c.rank!==1||v!==y))throw new Error(`sparseValues has incorrect shape ${c.shape}, should be [] or [${y}]`);if(c.dtype!==m.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")})(s,o,t,A);const u={sparseIndices:s,sparseValues:o,defaultValue:A},h={outputShape:t};return Xe.runKernel("SparseToDense",u,h)}}),Lye=Ge({all_:function(n,e=null,t=!1){const r={x:me(n,"x","all","bool")},s={axis:e,keepDims:t};return Xe.runKernel(EN,r,s)}}),Rye=Ge({any_:function(n,e=null,t=!1){const r={x:me(n,"x","any","bool")},s={axis:e,keepDims:t};return Xe.runKernel(DN,r,s)}}),Wye=Ge({argMax_:function(n,e=0){const t={x:me(n,"x","argMax")},r={axis:e};return Xe.runKernel(zN,t,r)}}),jye=Ge({argMin_:function(n,e=0){const t={x:me(n,"x","argMin")},r={axis:e};return Xe.runKernel("ArgMin",t,r)}}),Hye=Ge({cumsum_:function(n,e=0,t=!1,r=!1){const s={x:me(n,"x","cumsum")},o={axis:e,exclusive:t,reverse:r};return Xe.runKernel(WN,s,o)}}),Gye=Ge({denseBincount_:function(n,e,t,r=!1){const s=me(n,"x","denseBincount"),o=me(e,"weights","denseBincount");ze(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),ze(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),ze(t>=0,()=>`size must be non-negative, but got ${t}.`),ze(o.size===s.size||o.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${o.shape}.`);const A={x:s,weights:o},u={size:t,binaryOutput:r};return Xe.runKernel("DenseBincount",A,u)}}),qj=Ge({gather_:function(n,e,t=0,r=0){const s={x:me(n,"x","gather"),indices:me(e,"indices","gather","int32")},o={axis:t,batchDims:r};return Xe.runKernel(KR,s,o)}}),Vye=Ge({stridedSlice_:function(n,e,t,r,s=0,o=0,A=0,u=0,h=0){const l={x:me(n,"x","stridedSlice","string_or_numeric")},c={begin:e,end:t,strides:r,beginMask:s,endMask:o,ellipsisMask:A,newAxisMask:u,shrinkAxisMask:h};return Xe.runKernel(cT,l,c)}}),Xye=Ge({scatterND_:function(n,e,t){const r=me(n,"indices","scatterND","int32"),s=me(e,"updates","scatterND");(function(u,h,l){if(h.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${h.rank}.`);if(u.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${u.rank}.`);if(h.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${h.dtype}`);if(l.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${l}`);if(l.length===0){if(h.size===0)throw new Error(`Indices specified for empty output. indices shape: ${h.shape}`);if(u.size===0)throw new Error(`Updates specified for empty output. updates shape: ${u.shape}`)}(function(c,d,m){const y=d.rank>1?d.shape[d.rank-1]:1,b=d.rank>1?d.rank-1:1,v=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${m.shape}, indices.shape: ${d.shape}, shape: ${c}, sliceDim: ${y}, and batchDim: ${b}.`;if(m.rank<b)throw new Error(v+` update.rank < ${b}. `);if(c.length<y+(m.rank-b))throw new Error(v+` Output shape length < ${y+(m.rank-b)}`);if(m.rank!==b+c.length-y)throw new Error(v+" update.rank != "+(b+c.length-y));for(let w=0;w<b;++w)if(m.shape[w]!==d.shape[w])throw new Error(v+` updates.shape[${w}] (${m.shape[w]}) != indices.shape[${w}] (${d.shape[w]}).`);for(let w=0;w<m.rank-b;++w)if(m.shape[w+b]!==c[w+y])throw new Error(v+` updates.shape[${w+b}] (${m.shape[w+b]}) != shape[${w+b}] (${c[w+b]})`)})(l,h,u)})(s,r,t);const o={indices:r,updates:s},A={shape:t};return Xe.runKernel(AT,o,A)}}),Zye=Ge({gatherND_:function(n,e){const t=me(e,"indices","gatherND","int32"),r={params:me(n,"x","gatherND","string_or_numeric"),indices:t};return Xe.runKernel(ZN,r)}}),Yye=Ge({mirrorPad_:function(n,e,t){ze(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const r=me(n,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");ze(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);const s=t==="reflect"?1:0;for(let u=0;u<r.rank;u++)ze(e[u].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ze(e[u][0]>=0&&e[u][0]<=r.shape[u]-s&&e[u][1]>=0&&e[u][1]<=r.shape[u]-s,()=>`Padding in dimension ${u} cannot be greater than or equal to ${r.shape[u]-s} or less than 0 for input of shape ${r.shape}`);const o={paddings:e,mode:t},A={x:r};return Xe.runKernel($N,A,o)}}),Uye=Ge({pad_:function(n,e,t=0){const r=me(n,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:e,constantValue:t},o={x:r};return Xe.runKernel(rT,o,s)}}),Qye=Ge({spaceToBatchND_:function(n,e,t){const r=me(n,"x","spaceToBatchND");ze(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),ze(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),ze(r.shape.reduce((A,u,h)=>h>0&&h<=e.length?A&&(u+t[h-1][0]+t[h-1][1])%e[h-1]==0:A,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const s={x:r},o={blockShape:e,paddings:t};return Xe.runKernel(g8,s,o)}}),Kye=Ge({batchToSpaceND_:function(n,e,t){const r=me(n,"x","batchToSpaceND"),s=e.reduce((u,h)=>u*h);ze(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),ze(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),ze(r.shape[0]%s==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${s}`);const o={x:r},A={blockShape:e,crops:t};return Xe.runKernel(WR,o,A)}}),qye=Ge({depthToSpace_:function(n,e,t="NHWC"){const r=me(n,"x","depthToSpace","float32"),s=t==="NHWC"?r.shape[1]:r.shape[2],o=t==="NHWC"?r.shape[2]:r.shape[3],A=t==="NHWC"?r.shape[3]:r.shape[1];ze(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),ze(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e}  for depthToSpace with input shape
    ${r.shape}`),ze(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e} for depthToSpace with input shape
        ${r.shape}`),ze(A%(e*e)==0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${A} for depthToSpace with input shape ${r.shape}`);const u={x:r},h={blockSize:e,dataFormat:t};return Xe.runKernel(HN,u,h)}}),Jye=Ge({broadcastArgs_:function(n,e){const t=me(n,"s0","broadcastArgs","int32"),r=me(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:t,s1:r};return Xe.runKernel("BroadcastArgs",s)}});function Jj(n,e,t,r){const s=((o,A,u)=>{switch(o.category){case"arithmetic":return ur(()=>((l,c,d)=>{switch(l.op){case"BiasAdd":case"AddV2":case"Add":return[Ca(X("a",l,c,d),X("b",l,c,d))];case"AddN":return[Tge(X("tensors",l,c,d))];case"FloorMod":case"Mod":return[Mge(X("a",l,c,d),X("b",l,c,d))];case"Mul":return[Dn(X("a",l,c,d),X("b",l,c,d))];case"RealDiv":case"Div":return[Qs(X("a",l,c,d),X("b",l,c,d))];case"DivNoNan":return[Ege(X("a",l,c,d),X("b",l,c,d))];case"FloorDiv":return[rW(X("a",l,c,d),X("b",l,c,d))];case"Sub":return[_n(X("a",l,c,d),X("b",l,c,d))];case"Minimum":return[xW(X("a",l,c,d),X("b",l,c,d))];case"Maximum":return[Dge(X("a",l,c,d),X("b",l,c,d))];case"Pow":return[fW(X("a",l,c,d),X("b",l,c,d))];case"SquaredDifference":return[wW(X("a",l,c,d),X("b",l,c,d))];default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"basic_math":return ur(()=>((l,c,d)=>{switch(l.op){case"Abs":case"ComplexAbs":return[Mi(X("x",l,c,d))];case"Acos":return[zge(X("x",l,c,d))];case"Acosh":return[Oge(X("x",l,c,d))];case"Asin":return[Pge(X("x",l,c,d))];case"Asinh":return[Bge(X("x",l,c,d))];case"Atan":return[Fge(X("x",l,c,d))];case"Atan2":return[Lge(X("x",l,c,d),X("y",l,c,d))];case"Atanh":return[Rge(X("x",l,c,d))];case"Ceil":return[Wge(X("x",l,c,d))];case"Complex":return[ed(X("real",l,c,d),X("imag",l,c,d))];case"Cos":return[jge(X("x",l,c,d))];case"Cosh":return[Hge(X("x",l,c,d))];case"Elu":return[SW(X("x",l,c,d))];case"Erf":return[Gge(X("x",l,c,d))];case"Exp":return[ld(X("x",l,c,d))];case"Expm1":return[Vge(X("x",l,c,d))];case"Floor":return[Xge(X("x",l,c,d))];case"Log":return[Tg(X("x",l,c,d))];case"Log1p":return[kW(X("x",l,c,d))];case"Imag":return[OT(X("x",l,c,d))];case"Neg":return[Ng(X("x",l,c,d))];case"Reciprocal":return[Zge(X("x",l,c,d))];case"Real":return[b1(X("x",l,c,d))];case"Relu":return[k1(X("x",l,c,d))];case"Round":return[uW(X("x",l,c,d))];case"Selu":return[Yge(X("x",l,c,d))];case"Sigmoid":return[zT(X("x",l,c,d))];case"Sin":return[Uge(X("x",l,c,d))];case"Sign":return[Qge(X("x",l,c,d))];case"Sinh":return[Kge(X("x",l,c,d))];case"Softplus":return[qge(X("x",l,c,d))];case"Sqrt":return[jT(X("x",l,c,d))];case"Square":return[HT(X("x",l,c,d))];case"Tanh":return[Jge(X("x",l,c,d))];case"Tan":return[$ge(X("x",l,c,d))];case"ClipByValue":return[_ge(X("x",l,c,d),X("clipValueMin",l,c,d),X("clipValueMax",l,c,d))];case"Relu6":return[MW(X("x",l,c,d))];case"Rsqrt":return[eye(Xa(l.inputNames[0],c,d))];case"Prod":return[Gj(X("x",l,c,d),X("axes",l,c,d))];case"LeakyRelu":return[NW(X("x",l,c,d),X("alpha",l,c,d))];case"Prelu":return[TW(X("x",l,c,d),X("alpha",l,c,d))];case"IsNan":return[tye(Xa(l.inputNames[0],c,d))];default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"control":return(async(l,c,d)=>{switch(l.op){case"If":case"StatelessIf":{const m=X("thenBranch",l,c,d),y=X("elseBranch",l,c,d),b=X("cond",l,c,d),v=X("args",l,c,d);return(await b.data())[0]?d.functionMap[m].executeFunctionAsync(v,d.tensorArrayMap,d.tensorListMap):d.functionMap[y].executeFunctionAsync(v,d.tensorArrayMap,d.tensorListMap)}case"While":case"StatelessWhile":{const m=X("body",l,c,d),y=X("cond",l,c,d),b=X("args",l,c,d),v=await d.functionMap[y].executeFunctionAsync(b,d.tensorArrayMap,d.tensorListMap),w=b.map(T=>T.id);let I=await v[0].data();v.forEach(T=>{T.kept||w.indexOf(T.id)!==-1||T.dispose()});let S=b;for(;I[0];){const T=S;S=await d.functionMap[m].executeFunctionAsync(S,d.tensorArrayMap,d.tensorListMap);const D=S.map(W=>W.id);T.forEach(W=>{W.kept||w.indexOf(W.id)!==-1||D.indexOf(W.id)!==-1||W.dispose()});const L=await d.functionMap[y].executeFunctionAsync(S,d.tensorArrayMap,d.tensorListMap);I=await L[0].data(),L.forEach(W=>{W.kept||w.indexOf(W.id)!==-1||D.indexOf(W.id)!==-1||W.dispose()})}return S}case"LoopCond":return[Vu(X("pred",l,c,d))];case"Switch":{const m=X("pred",l,c,d);let y=X("data",l,c,d);return y.kept||(y=Vu(y)),(await m.data())[0]?[void 0,y]:[y,void 0]}case"Merge":{const m=l.inputNames.find(y=>Xa(y,c,d)!==void 0);return m?[Vu(Xa(m,c,d))]:void 0}case"Enter":{const m=X("frameName",l,c,d),y=X("tensor",l,c,d);return d.enterFrame(m),[Vu(y)]}case"Exit":{const m=X("tensor",l,c,d);return d.exitFrame(),[Vu(m)]}case"NextIteration":{const m=X("tensor",l,c,d);return d.nextIteration(),[Vu(m)]}case"TensorArrayV3":{const m=X("size",l,c,d),y=X("dtype",l,c,d),b=X("elementShape",l,c,d),v=X("dynamicSize",l,c,d),w=X("clearAfterRead",l,c,d),I=X("identicalElementShapes",l,c,d),S=X("name",l,c,d),T=new nye(S,y,m,b,I,v,w);return d.addTensorArray(T),[T.idTensor,fr(1)]}case"TensorArrayWriteV3":{const m=X("tensorArrayId",l,c,d),y=X("index",l,c,d),b=X("tensor",l,c,d),v=d.getTensorArray(m.id);return v.write(y,b),[v.idTensor]}case"TensorArrayReadV3":{const m=X("tensorArrayId",l,c,d),y=X("index",l,c,d);return[d.getTensorArray(m.id).read(y)]}case"TensorArrayGatherV3":{const m=X("tensorArrayId",l,c,d),y=X("indices",l,c,d),b=X("dtype",l,c,d);return[d.getTensorArray(m.id).gather(y,b)]}case"TensorArrayScatterV3":{const m=X("tensorArrayId",l,c,d),y=X("indices",l,c,d),b=X("tensor",l,c,d),v=d.getTensorArray(m.id);return v.scatter(y,b),[v.idTensor]}case"TensorArrayConcatV3":{const m=X("tensorArrayId",l,c,d),y=d.getTensorArray(m.id),b=X("dtype",l,c,d);return[y.concat(b)]}case"TensorArraySplitV3":{const m=X("tensorArrayId",l,c,d),y=X("tensor",l,c,d),b=X("lengths",l,c,d),v=d.getTensorArray(m.id);return v.split(b,y),[v.idTensor]}case"TensorArraySizeV3":{const m=X("tensorArrayId",l,c,d);return[fr(d.getTensorArray(m.id).size(),"int32")]}case"TensorArrayCloseV3":{const m=X("tensorArrayId",l,c,d),y=d.getTensorArray(m.id);return y.clearAndClose(),[y.idTensor]}case"TensorListSetItem":{const m=X("tensorListId",l,c,d),y=X("index",l,c,d),b=X("tensor",l,c,d),v=d.getTensorList(m.id);return v.setItem(y,b),[v.idTensor]}case"TensorListGetItem":{const m=X("tensorListId",l,c,d),y=X("index",l,c,d),b=X("elementShape",l,c,d),v=X("elementDType",l,c,d);return[d.getTensorList(m.id).getItem(y,b,v)]}case"TensorListScatterV2":case"TensorListScatter":{const m=X("indices",l,c,d),y=function(b,v,w,I){if(v.length!==b.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${v.length} vs. ${b.shape[0]}`);const S=Math.max(...v);if(I!=null&&I!==-1&&S>=I)throw new Error(`Max index must be < array size (${S}  vs. ${I})`);const T=new uh([],w,b.dtype,I),D=id(b,0);return v.forEach((L,W)=>{T.setItem(L,D[W])}),T}(X("tensor",l,c,d),m,X("elementShape",l,c,d),X("numElements",l,c,d));return d.addTensorList(y),[y.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const m=X("elementShape",l,c,d),y=X("elementDType",l,c,d);let b;b=l.op==="TensorListReserve"?"numElements":"maxNumElements";const v=function(w,I,S){return new uh([],w,I,S)}(m,y,X(b,l,c,d));return d.addTensorList(v),[v.idTensor]}case"TensorListGather":{const m=X("tensorListId",l,c,d),y=X("indices",l,c,d),b=X("elementShape",l,c,d),v=X("elementDType",l,c,d);return[d.getTensorList(m.id).gather(y,v,b)]}case"TensorListStack":{const m=X("tensorListId",l,c,d),y=X("elementShape",l,c,d),b=X("elementDType",l,c,d),v=X("numElements",l,c,d);return[d.getTensorList(m.id).stack(y,b,v)]}case"TensorListFromTensor":{const m=function(y,b,v){const w=y.dtype;if(y.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${y.shape}`);if(y.dtype!==v)throw new Error(`Invalid data types; op elements ${y.dtype}, but list elements ${v}`);Ei(y.shape.slice(1),b,"TensorList shape mismatch: ");const I=id(y);return new uh(I,b,w)}(X("tensor",l,c,d),X("elementShape",l,c,d),X("elementDType",l,c,d));return d.addTensorList(m),[m.idTensor]}case"TensorListConcat":{const m=X("tensorListId",l,c,d),y=d.getTensorList(m.id),b=X("dtype",l,c,d),v=X("elementShape",l,c,d);return[y.concat(b,v)]}case"TensorListPushBack":{const m=X("tensorListId",l,c,d),y=X("tensor",l,c,d),b=d.getTensorList(m.id);return b.pushBack(y),[b.idTensor]}case"TensorListPopBack":{const m=X("tensorListId",l,c,d),y=X("elementShape",l,c,d),b=X("elementDType",l,c,d);return[d.getTensorList(m.id).popBack(y,b)]}case"TensorListSplit":{const m=X("tensor",l,c,d),y=X("elementShape",l,c,d),b=function(v,w,I){let S=0;const T=w.map(U=>(S+=U,S));if(S!==v.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${S}, and tensor's shape is: ${v.shape}`);const D=pM(v.shape.slice(1),I),L=S===0?0:v.size/S,W=ur(()=>{const U=[];v=Nt(v,[1,S,L]);for(let _=0;_<w.length;++_){const ee=[0,_===0?0:T[_-1],0],re=[1,w[_],L];U[_]=Nt($n(v,ee,re),D)}return v.dispose(),U}),K=new uh([],I,v.dtype,w.length);for(let U=0;U<W.length;U++)K.setItem(U,W[U]);return K}(m,X("lengths",l,c,d),y);return d.addTensorList(b),[b.idTensor]}default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u);case"convolution":return ur(()=>((l,c,d)=>{switch(l.op){case"Conv1D":{const m=X("stride",l,c,d),y=X("pad",l,c,d),b=X("dataFormat",l,c,d).toUpperCase(),v=X("dilation",l,c,d);return[rye(X("x",l,c,d),X("filter",l,c,d),m,y,b,v)]}case"Conv2D":{const m=X("strides",l,c,d),y=O1(l,c,d),b=X("dataFormat",l,c,d).toUpperCase(),v=X("dilations",l,c,d);return[hM(X("x",l,c,d),X("filter",l,c,d),[m[1],m[2]],y,b,[v[1],v[2]])]}case"_FusedConv2D":{const{stride:m,pad:y,dataFormat:b,dilations:v,biasArg:w,preluArg:I,activationFunc:S,leakyreluAlpha:T}=Yj(l,c,d);return[aye({x:X("x",l,c,d),filter:X("filter",l,c,d),strides:[m[1],m[2]],pad:y,dataFormat:b,dilations:[v[1],v[2]],bias:w,activation:S,preluActivationWeights:I,leakyreluAlpha:T})]}case"FusedDepthwiseConv2dNative":{const{stride:m,pad:y,dataFormat:b,dilations:v,biasArg:w,preluArg:I,activationFunc:S,leakyreluAlpha:T}=Yj(l,c,d);return[Aye({x:X("x",l,c,d),filter:X("filter",l,c,d),strides:[m[1],m[2]],pad:y,dataFormat:b,dilations:[v[1],v[2]],bias:w,activation:S,preluActivationWeights:I,leakyreluAlpha:T})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const m=X("outputShape",l,c,d),y=X("strides",l,c,d),b=O1(l,c,d);return[lye(X("x",l,c,d),X("filter",l,c,d),m,[y[1],y[2]],b)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const m=X("strides",l,c,d),y=O1(l,c,d),b=X("dilations",l,c,d),v=X("dataFormat",l,c,d).toUpperCase();return[Zj(X("input",l,c,d),X("filter",l,c,d),[m[1],m[2]],y,v,[b[1],b[2]])]}case"Conv3D":{const m=X("strides",l,c,d),y=X("pad",l,c,d),b=X("dataFormat",l,c,d).toUpperCase(),v=X("dilations",l,c,d);return[uye(X("x",l,c,d),X("filter",l,c,d),[m[1],m[2],m[3]],y,b,[v[1],v[2],v[3]])]}case"AvgPool":{const m=X("strides",l,c,d),y=X("pad",l,c,d),b=X("kernelSize",l,c,d);return[cye(X("x",l,c,d),[b[1],b[2]],[m[1],m[2]],y)]}case"MaxPool":{const m=X("strides",l,c,d),y=X("pad",l,c,d),b=X("kernelSize",l,c,d);return[dye(X("x",l,c,d),[b[1],b[2]],[m[1],m[2]],y)]}case"MaxPoolWithArgmax":{const m=X("strides",l,c,d),y=X("pad",l,c,d),b=X("kernelSize",l,c,d),v=X("includeBatchInIndex",l,c,d),{result:w,indexes:I}=pye(X("x",l,c,d),[b[1],b[2]],[m[1],m[2]],y,v);return[w,I]}case"AvgPool3D":{const m=X("strides",l,c,d),y=X("pad",l,c,d),b=X("kernelSize",l,c,d);return[hye(X("x",l,c,d),[b[1],b[2],b[3]],[m[1],m[2],m[3]],y)]}case"MaxPool3D":{const m=X("strides",l,c,d),y=X("pad",l,c,d),b=X("kernelSize",l,c,d);return[fye(X("x",l,c,d),[b[1],b[2],b[3]],[m[1],m[2],m[3]],y)]}case"Dilation2D":{const m=X("strides",l,c,d),y=X("pad",l,c,d),b=X("dilations",l,c,d),v=m[1],w=m[2],I=b[1],S=b[2];return[mye(X("x",l,c,d),X("filter",l,c,d),[v,w],y,[I,S],"NHWC")]}default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"creation":return ur(()=>((l,c,d)=>{switch(l.op){case"Fill":{const m=X("shape",l,c,d),y=X("dtype",l,c,d);return[FT(m,X("value",l,c,d),y)]}case"LinSpace":return[gye(X("start",l,c,d),X("stop",l,c,d),X("num",l,c,d))];case"Multinomial":{const m=X("logits",l,c,d),y=X("numSamples",l,c,d),b=X("seed",l,c,d);return[yye(m,y,b)]}case"OneHot":{const m=X("indices",l,c,d),y=X("depth",l,c,d),b=X("onValue",l,c,d),v=X("offValue",l,c,d);return[bye(m,y,b,v)]}case"Ones":return[VT(X("shape",l,c,d),X("dtype",l,c,d))];case"OnesLike":return[vye(X("x",l,c,d))];case"RandomUniform":return[kye(X("shape",l,c,d),X("minval",l,c,d),X("maxval",l,c,d),X("dtype",l,c,d))];case"Range":return[Ig(X("start",l,c,d),X("stop",l,c,d),X("step",l,c,d),X("dtype",l,c,d))];case"TruncatedNormal":{const m=X("shape",l,c,d),y=X("mean",l,c,d),b=X("stdDev",l,c,d),v=X("seed",l,c,d);return[Cye(m,y,b,X("dtype",l,c,d),v)]}case"Zeros":return[ah(X("shape",l,c,d),X("dtype",l,c,d))];case"ZerosLike":return[PT(X("x",l,c,d))];default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"dynamic":return(async(l,c,d)=>{switch(l.op){case"NonMaxSuppressionV5":{const{boxes:m,scores:y,maxOutputSize:b,iouThreshold:v,scoreThreshold:w,softNmsSigma:I}=fM(l,c,d),S=await ju.nonMaxSuppressionWithScoreAsync(m,y,b,v,w,I);return[S.selectedIndices,S.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:m,scores:y,maxOutputSize:b,iouThreshold:v,scoreThreshold:w}=fM(l,c,d),I=X("padToMaxOutputSize",l,c,d),S=await ju.nonMaxSuppressionPaddedAsync(m,y,b,v,w,I);return[S.selectedIndices,S.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:m,scores:y,maxOutputSize:b,iouThreshold:v,scoreThreshold:w}=fM(l,c,d);return[await ju.nonMaxSuppressionAsync(m,y,b,v,w)]}case"Where":{const m=ns(X("condition",l,c,d),"bool"),y=[await Iye(m)];return m.dispose(),y}case"ListDiff":return async function(m,y){const b=me(m,"x","setdiff1d"),v=me(y,"y","setdiff1d");ze(b.dtype===v.dtype,()=>`x and y should have the same dtype, but got x (${b.dtype}) and y (${v.dtype}).`),ze(b.rank===1,()=>`x should be 1D tensor, but got x (${b.shape}).`),ze(v.rank===1,()=>`y should be 1D tensor, but got y (${v.shape}).`);const w=await b.data(),I=await v.data(),S=new Set(I);let T=0;for(let W=0;W<w.length;W++)S.has(w[W])||T++;const D=new vT([T],b.dtype),L=new vT([T],"int32");for(let W=0,K=0;W<w.length;W++)S.has(w[W])||(D.values[K]=w[W],L.values[K]=W,K++);return[D.toTensor(),L.toTensor()]}(X("x",l,c,d),X("y",l,c,d));default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u);case"evaluation":return ur(()=>((l,c,d)=>{switch(l.op){case"TopKV2":{const m=X("x",l,c,d),y=X("k",l,c,d),b=X("sorted",l,c,d),v=Sye(m,y,b);return[v.values,v.indices]}case"Unique":{const m=X("x",l,c,d),y=Qj(m);return[y.values,y.indices]}case"UniqueV2":{const m=X("x",l,c,d),y=X("axis",l,c,d),b=Qj(m,y);return[b.values,b.indices]}default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"image":return ur(()=>((l,c,d)=>{switch(l.op){case"ResizeBilinear":{const m=X("images",l,c,d),y=X("size",l,c,d),b=X("alignCorners",l,c,d),v=X("halfPixelCenters",l,c,d);return[ju.resizeBilinear(m,[y[0],y[1]],b,v)]}case"ResizeNearestNeighbor":{const m=X("images",l,c,d),y=X("size",l,c,d),b=X("alignCorners",l,c,d),v=X("halfPixelCenters",l,c,d);return[ju.resizeNearestNeighbor(m,[y[0],y[1]],b,v)]}case"CropAndResize":{const m=X("image",l,c,d),y=X("boxes",l,c,d),b=X("boxInd",l,c,d),v=X("cropSize",l,c,d),w=X("method",l,c,d),I=X("extrapolationValue",l,c,d);return[ju.cropAndResize(m,y,b,v,w,I)]}default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"graph":return ur(()=>((l,c,d)=>{switch(l.op){case"Const":return c[l.name];case"PlaceholderWithDefault":const m=X("default",l,c,d);return[Xa(l.name,c,d)||m];case"Placeholder":return[Xa(l.name,c,d)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[Vu(X("x",l,c,d))];case"IdentityN":return X("x",l,c,d).map(I=>Vu(I));case"Shape":return[so(X("x",l,c,d).shape,"int32")];case"ShapeN":return X("x",l,c,d).map(I=>so(I.shape));case"Size":return[fr(X("x",l,c,d).size,"int32")];case"Rank":return[fr(X("x",l,c,d).rank,"int32")];case"NoOp":return[fr(1)];case"Print":const y=X("x",l,c,d),b=X("data",l,c,d),v=X("message",l,c,d),w=X("summarize",l,c,d);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(v);for(let I=0;I<b.length;I++)console.log(Array.prototype.slice.call(b[I].dataSync()).slice(0,w));return[y];default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"logical":return ur(()=>((l,c,d)=>{switch(l.op){case"Equal":return[Hj(X("a",l,c,d),X("b",l,c,d))];case"NotEqual":return[vW(X("a",l,c,d),X("b",l,c,d))];case"Greater":return[x1(X("a",l,c,d),X("b",l,c,d))];case"GreaterEqual":return[cW(X("a",l,c,d),X("b",l,c,d))];case"Less":return[Tye(X("a",l,c,d),X("b",l,c,d))];case"LessEqual":return[RT(X("a",l,c,d),X("b",l,c,d))];case"LogicalAnd":return[dW(X("a",l,c,d),X("b",l,c,d))];case"LogicalNot":return[Mye(X("a",l,c,d))];case"LogicalOr":return[Eye(X("a",l,c,d),X("b",l,c,d))];case"Select":case"SelectV2":return[ih(X("condition",l,c,d),X("a",l,c,d),X("b",l,c,d))];default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"matrices":return ur(()=>((l,c,d)=>{switch(l.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[Ks(X("a",l,c,d),X("b",l,c,d),X("transposeA",l,c,d),X("transposeB",l,c,d))];case"Einsum":return[Dye(X("equation",l,c,d),...X("tensors",l,c,d))];case"Transpose":return[GT(X("x",l,c,d),X("perm",l,c,d))];case"_FusedMatMul":const[m,y]=X("fusedOps",l,c,d),b=m==="biasadd",v=y==="prelu",w=X("numArgs",l,c,d),I=X("leakyreluAlpha",l,c,d);if(b){if(v&&w!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!v&&w!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[S,T]=X("args",l,c,d);return[zye({a:X("a",l,c,d),b:X("b",l,c,d),transposeA:X("transposeA",l,c,d),transposeB:X("transposeB",l,c,d),bias:S,activation:y,preluActivationWeights:T,leakyreluAlpha:I})];default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"normalization":return ur(()=>((l,c,d)=>{switch(l.op){case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[Oye(X("x",l,c,d),X("mean",l,c,d),X("variance",l,c,d),X("offset",l,c,d),X("scale",l,c,d),X("epsilon",l,c,d))];case"LRN":return[Pye(X("x",l,c,d),X("radius",l,c,d),X("bias",l,c,d),X("alpha",l,c,d),X("beta",l,c,d))];case"Softmax":return[Bye(X("x",l,c,d))];case"LogSoftmax":return[Fye(X("x",l,c,d))];case"SparseToDense":return[Kj(X("sparseIndices",l,c,d),X("outputShape",l,c,d),X("sparseValues",l,c,d),X("defaultValue",l,c,d))];default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"reduction":return ur(()=>((l,c,d)=>{switch(l.op){case"Max":{const v=X("axis",l,c,d),w=X("keepDims",l,c,d);return[Ah(X("x",l,c,d),v,w)]}case"Mean":{const v=X("axis",l,c,d),w=X("keepDims",l,c,d);return[bW(X("x",l,c,d),v,w)]}case"Min":{const v=X("axis",l,c,d),w=X("keepDims",l,c,d);return[WT(X("x",l,c,d),v,w)]}case"Sum":{const v=X("axis",l,c,d),w=X("keepDims",l,c,d);return[Or(X("x",l,c,d),v,w)]}case"All":{const v=X("axis",l,c,d),w=X("keepDims",l,c,d);return[Lye(X("x",l,c,d),v,w)]}case"Any":{const v=X("axis",l,c,d),w=X("keepDims",l,c,d);return[Rye(X("x",l,c,d),v,w)]}case"ArgMax":{const v=X("axis",l,c,d);return[Wye(X("x",l,c,d),v)]}case"ArgMin":{const v=X("axis",l,c,d);return[jye(X("x",l,c,d),v)]}case"Prod":{const v=X("axis",l,c,d),w=X("keepDims",l,c,d);return[Gj(X("x",l,c,d),v,w)]}case"Cumsum":{const v=X("axis",l,c,d),w=X("exclusive",l,c,d),I=X("reverse",l,c,d);return[Hye(X("x",l,c,d),v,w,I)]}case"Bincount":const m=X("x",l,c,d),y=X("weights",l,c,d),b=X("size",l,c,d);return[AW(m,y,b)];case"DenseBincount":{const v=X("x",l,c,d),w=X("weights",l,c,d),I=X("size",l,c,d),S=X("binaryOutput",l,c,d);return[Gye(v,w,I,S)]}default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"slice_join":return ur(()=>((l,c,d)=>{switch(l.op){case"ConcatV2":case"Concat":{const m=X("n",l,c,d),y=X("axis",l,c,d);let b=X("tensors",l,c,d);return b=b.slice(0,m),[To(b,y)]}case"Gather":{const m=X("x",l,c,d),y=X("indices",l,c,d);return[qj(m,ns(y,"int32"),0)]}case"GatherV2":{const m=X("axis",l,c,d),y=X("batchDims",l,c,d),b=X("x",l,c,d),v=X("indices",l,c,d);return[qj(b,ns(v,"int32"),m,y)]}case"Reverse":{const m=X("dims",l,c,d),y=[];for(let v=0;v<m.length;v++)m[v]&&y.push(v);const b=X("x",l,c,d);return[v1(b,y)]}case"ReverseV2":{const m=X("axis",l,c,d),y=X("x",l,c,d);return[v1(y,m)]}case"Slice":{const m=X("begin",l,c,d),y=X("size",l,c,d);return[$n(X("x",l,c,d),m,y)]}case"StridedSlice":{const m=X("begin",l,c,d),y=X("end",l,c,d),b=X("strides",l,c,d),v=X("beginMask",l,c,d),w=X("endMask",l,c,d),I=X("ellipsisMask",l,c,d),S=X("newAxisMask",l,c,d),T=X("shrinkAxisMask",l,c,d),D=X("x",l,c,d);return[Vye(D,m,y,b,v,w,I,S,T)]}case"Pack":return ur(()=>{const m=X("axis",l,c,d),y=X("tensors",l,c,d),b=y[0].shape,v=Bu(y[0]).shape,w=y.map(I=>{const S=_c(I.shape,b);if(!S&&!_c(Bu(I).shape,v))throw new Error("the input tensors shape does not match");return S?I:Nt(I,b)});return[wl(w,m)]});case"Unpack":{const m=X("axis",l,c,d),y=X("tensor",l,c,d);return id(y,m)}case"Tile":{const m=X("reps",l,c,d);return[Cg(X("x",l,c,d),m)]}case"Split":case"SplitV":{const m=X("axis",l,c,d),y=X("numOrSizeSplits",l,c,d),b=X("x",l,c,d);return kg(b,y,m)}case"ScatterNd":{const m=X("indices",l,c,d),y=X("values",l,c,d),b=X("shape",l,c,d);return[Xye(m,y,b)]}case"GatherNd":{const m=X("x",l,c,d),y=X("indices",l,c,d);return[Zye(m,y)]}case"SparseToDense":{const m=X("sparseIndices",l,c,d),y=X("outputShape",l,c,d),b=X("sparseValues",l,c,d),v=X("defaultValue",l,c,d);return[Kj(m,b,y,b.dtype===v.dtype?v:ns(v,b.dtype))]}default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"sparse":return ur(()=>((l,c,d)=>{switch(l.op){case"SparseFillEmptyRows":{const{outputIndices:m,outputValues:y,emptyRowIndicator:b,reverseIndexMap:v}=C1.sparseFillEmptyRows(X("indices",l,c,d),X("values",l,c,d),X("denseShape",l,c,d),X("defaultValue",l,c,d));return[m,y,b,v]}case"SparseReshape":{const{outputIndices:m,outputShape:y}=C1.sparseReshape(X("inputIndices",l,c,d),X("inputShape",l,c,d),X("newShape",l,c,d));return[m,y]}case"SparseSegmentMean":return[C1.sparseSegmentMean(X("data",l,c,d),X("indices",l,c,d),X("segmentIds",l,c,d))];case"SparseSegmentSum":return[C1.sparseSegmentSum(X("data",l,c,d),X("indices",l,c,d),X("segmentIds",l,c,d))];default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"spectral":return ur(()=>((l,c,d)=>{switch(l.op){case"FFT":return[sW(X("x",l,c,d))];case"IFFT":return[BT(X("x",l,c,d))];case"RFFT":return[aW(X("x",l,c,d))];case"IRFFT":return[Vhe(X("x",l,c,d))];default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"string":return ur(()=>((l,c,d)=>{switch(l.op){case"StringNGrams":{const{nGrams:m,nGramsSplits:y}=XT.stringNGrams(X("data",l,c,d),X("dataSplits",l,c,d),X("separator",l,c,d),X("nGramWidths",l,c,d),X("leftPad",l,c,d),X("rightPad",l,c,d),X("padWidth",l,c,d),X("preserveShortSequences",l,c,d));return[m,y]}case"StringSplit":{const{indices:m,values:y,shape:b}=XT.stringSplit(X("input",l,c,d),X("delimiter",l,c,d),X("skipEmpty",l,c,d));return[m,y,b]}case"StringToHashBucketFast":return[XT.stringToHashBucketFast(X("input",l,c,d),X("numBuckets",l,c,d))];default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"transformation":return ur(()=>((l,c,d)=>{switch(l.op){case"Cast":return[ns(X("x",l,c,d),X("dtype",l,c,d))];case"ExpandDims":{const m=X("axis",l,c,d);return[Pu(X("x",l,c,d),m)]}case"Squeeze":{const m=X("axis",l,c,d);return[Bu(X("x",l,c,d),m)]}case"Reshape":return[Nt(X("x",l,c,d),X("shape",l,c,d))];case"MirrorPad":return[Yye(X("x",l,c,d),X("padding",l,c,d),X("mode",l,c,d))];case"PadV2":case"Pad":return[Uye(X("x",l,c,d),X("padding",l,c,d),X("constantValue",l,c,d))];case"SpaceToBatchND":{const m=X("blockShape",l,c,d),y=X("paddings",l,c,d);return[Qye(X("x",l,c,d),m,y)]}case"BatchToSpaceND":{const m=X("blockShape",l,c,d),y=X("crops",l,c,d);return[Kye(X("x",l,c,d),m,y)]}case"DepthToSpace":{const m=X("blockSize",l,c,d),y=X("dataFormat",l,c,d).toUpperCase();return[qye(X("x",l,c,d),m,y)]}case"BroadcastTo":return[w1(X("x",l,c,d),X("shape",l,c,d))];case"BroadcastArgs":return[Jye(X("s0",l,c,d),X("s1",l,c,d))];default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u));case"hash_table":return(async(l,c,d,m)=>{switch(l.op){case"HashTable":case"HashTableV2":{const y=X("keyDType",l,c,d),b=X("valueDType",l,c,d),v=new Nye(y,b);return m.addHashTable(l.name,v),[v.handle]}case"LookupTableImport":case"LookupTableImportV2":{const y=X("tableHandle",l,c,d,m),b=X("keys",l,c,d),v=X("values",l,c,d);return[await m.getHashTableById(y.id).import(b,v)]}case"LookupTableFind":case"LookupTableFindV2":{const y=X("tableHandle",l,c,d,m),b=X("keys",l,c,d),v=X("defaultValue",l,c,d);return[await m.getHashTableById(y.id).find(b,v)]}case"LookupTableSize":case"LookupTableSizeV2":{const y=X("tableHandle",l,c,d,m);return[m.getHashTableById(y.id).tensorSize()]}default:throw TypeError(`Node type ${l.op} is not implemented`)}})(o,A,u,r);case"custom":const h=Fj(o.op);if(h&&h.customExecutor)return h.customExecutor(new Nge(o,A,u));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return yg(s)?s.then(o=>[].concat(o)):[].concat(s)}class $j{constructor(e={},t={},r={},s={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=r,this.functionMap=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const r=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(r))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function _j(n,e,t,r){const s=new Set,o=[];let A=null,u=null;const h=new Set,l=Object.keys(n).map(m=>Eo(m)[0]);let c=[];r!=null&&(c=r.map(m=>Eo(m.name)[0]));const d=[...e];for(;d.length>0;){const m=d.pop();(eH(m)||tbe(m)||nbe(m))&&A==null&&(A=m,u=A.children.map(y=>y.name).filter(y=>s.has(y))),s.add(m.name),t[m.name]==null&&l.indexOf(m.name)===-1&&c.indexOf(m.name)===-1&&(m.inputs.length!==0?m.inputs.forEach(y=>{h.has(y.name)||(h.add(y.name),d.push(y))}):o.push(m.name))}return{inputs:n,outputs:e,usedNodes:s,missingInputs:o,dynamicNode:A,syncInputs:u}}const $ye=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],_ye=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],ebe=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function eH(n){return $ye.indexOf(n.op)>=0}function tbe(n){return _ye.indexOf(n.op)>=0}function nbe(n){return ebe.indexOf(n.op)>=0}class P1{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(r=>{this._functionExecutorMap[r]=new P1(e.functions[r],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(r=>e[r].map(s=>s.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){const r=e.map(o=>o.name).sort(),s=t.map(o=>o.name).sort();return r.join(this.SEPERATOR)+"--"+s.join(this.SEPERATOR)}compile(e,t){const r=_j(e,t,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:o,syncInputs:A}=r;if(o!=null)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${A}]`);if(s.length>0){const u=t.map(l=>l.name),h=Object.keys(e);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${h}]. Missing the following inputs: [${s}]`)}return function(u,h,l){const{usedNodes:c,inputs:d}=l,m=[],y=Object.keys(d).map(I=>Eo(I)[0]).map(I=>u.nodes[I]),b=u.initNodes;y.forEach(I=>{c.has(I.name)&&m.push(I)}),u.weights.forEach(I=>{c.has(I.name)&&m.push(I)}),b!=null&&b.forEach(I=>{c.has(I.name)&&m.push(I)});const v=new Set,w=[];for(;m.length>0;){const I=m.pop();v.add(I.name),h[I.name]||w.push(I),I.children.forEach(S=>{!v.has(S.name)&&c.has(S.name)&&S.inputs.every(T=>v.has(T.name))&&m.push(S)})}return w}(this.graph,this.weightMap,r)}execute(e,t){e=this.mapInputs(e);const r=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const s=r.map(d=>this.graph.nodes[Eo(d)[0]]),o=t.map(d=>Eo(d)[0]);let A=o.map(d=>this.graph.nodes[d]);A.length===0&&(A=this._outputs);const u=this.getCompilationKey(s,A);let h=this.compiledMap.get(u);h==null&&(h=this.compile(e,A),this.compiledMap.set(u,h));const l={},c={};return ur(()=>{const d=new $j(this.weightMap,l,c,this.functionExecutorMap),m=Object.assign({},this.weightMap);Object.keys(e).forEach(v=>{const[w,I]=Eo(v),S=[];S[I]=e[v],m[w]=S});const y=this.getFrozenTensorIds(m),b={};for(let v=0;v<h.length;v++){const w=h[v];if(!m[w.name]){const I=Jj(w,m,d,this._resourceManager);if(yg(I))throw new Error(`The execution of the op '${w.op}' returned a promise. Please use model.executeAsync() instead.`);m[w.name]=I,this.checkTensorForDisposal(w.name,w,m,d,y,o,b)}}return this.parent==null&&d.dispose(y),t.map(v=>Xa(v,m,d))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(r=>e[r]).map(r=>r.map(s=>s.id)));return new Set(t)}checkTensorForDisposal(e,t,r,s,o,A,u){t.category!=="control"&&A.indexOf(e)===-1&&(r[e].forEach(h=>{h!=null&&(u[h.id]=(u[h.id]||0)+t.children.length)}),t.inputs.forEach(h=>{if(h.category!=="control"){const l=function(c,d,m){return d[z1(c,m.currentContextId)]}(h.name,r,s);l!=null&&l.forEach(c=>{if(c&&!c.kept&&!o.has(c.id)){const d=u[c.id];d===1?(c.dispose(),delete u[c.id]):d!=null&&u[c.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}async _executeAsync(e,t,r=!1,s={},o={}){r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));const A=new $j(this.weightMap,s,o,this.functionExecutorMap),u=await this.executeWithControlFlow(e,A,t,r),h=t.map(m=>Xa(m,u,A)),l=h.map(m=>m.id),c=Object.keys(e).map(m=>e[m].id),d=new Set([...l,...c,...this.weightIds]);return Object.keys(u).forEach(m=>{u[m].forEach(y=>{!y||y.kept||y.isDisposed||d.has(y.id)||y.dispose()})}),this.parent==null&&A.dispose(d),h}async executeFunctionAsync(e,t,r){const s=e.reduce((o,A,u)=>(o[this.inputs[u].name]=A,o),{});return this._executeAsync(s,this.outputNodes,!0,t,r)}async executeWithControlFlow(e,t,r,s){const o=Object.keys(e),A=o.map(T=>this.graph.nodes[Eo(T)[0]]),u=r.map(T=>Eo(T)[0]);let h=u.map(T=>this.graph.nodes[T]);h.length===0&&(h=this._outputs);const{usedNodes:l,missingInputs:c,dynamicNode:d,syncInputs:m}=_j(e,h,this.weightMap,this._initNodes),y=[...A,...this.graph.weights,...this._initNodes||[]].map(T=>({node:T,contexts:t.currentContext})),b=Object.assign({},this.weightMap);Object.keys(e).forEach(T=>{const[D,L]=Eo(T),W=[];W[L]=e[T],b[D]=W});const v={},w=this.getFrozenTensorIds(b),I={};for(;y.length>0;){const T=this.processStack(A,y,t,b,I,w,u,v,l);await Promise.all(T)}d!=null||s||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const S=h.filter(T=>!eH(T)&&!Xa(T.name,b,t)).map(T=>T.name);if(S.length>0){let T="";throw d!=null&&(T=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${m}]`),new Error(`Cannot compute the outputs [${S}] from the provided inputs [${o}]. Consider providing the following inputs: [${c}]. ${T}`)}return b}processStack(e,t,r,s,o,A,u,h,l){const c=[];for(;t.length>0;){const d=t.pop();r.currentContext=d.contexts;let m="";if(d.node.op==="Enter"&&X("isConstant",d.node,s,r)&&([m]=kl(d.node.name,r)),s[d.node.name]==null){const y=Jj(d.node,s,r,this._resourceManager);m||([m]=kl(d.node.name,r));const b=r.currentContext;yg(y)?c.push(y.then(v=>(s[m]=v,r.currentContext=b,this.checkTensorForDisposal(m,d.node,s,r,A,u,h),this.processChildNodes(d.node,t,r,s,o,l),v))):(s[m]=y,this.checkTensorForDisposal(m,d.node,s,r,A,u,h),this.processChildNodes(d.node,t,r,s,o,l))}else this.processChildNodes(d.node,t,r,s,o,l)}return c}processChildNodes(e,t,r,s,o,A){e.children.forEach(u=>{const[h]=kl(u.name,r);!o[h]&&A.has(u.name)&&(u.op==="Merge"?u.inputNames.some(l=>!!Xa(l,s,r))&&(o[h]=!0,t.push({contexts:r.currentContext,node:u})):u.inputNames.every(l=>!!Xa(l,s,r))&&(o[h]=!0,t.push({contexts:r.currentContext,node:u})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const r=e[t],[s]=Eo(t),o=this.graph.nodes[s];if(o.attrParams.shape&&o.attrParams.shape.value){const A=o.attrParams.shape.value;ze(A.length===r.shape.length&&r.shape.every((u,h)=>A[h]===-1||A[h]===u),()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${A}], but was [${r.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&ze(r.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){const t={};for(const r in e)this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[r]!=null?t[this._signature.inputs[r].name]=e[r]:t[r]=e[r];return t}checkInputs(e){const t=Object.keys(e).filter(r=>{const[s]=Eo(r);return this.graph.nodes[s]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[t]!=null?this._signature.outputs[t].name:t,{})}checkOutputs(e){e.forEach(t=>{const[r]=Eo(t);if(!this.graph.nodes[r])throw new Error(`The output '${t}' is not found in the graph`)})}}class rbe{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}class sbe{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",t==null&&(this.loadOptions={}),this.resourceManager=new rbe}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=$8(e,this.loadOptions);else{const s=(t=e,r=this.loadOptions,Bs.getLoadHandlers(t,r));if(s.length===0)s.push($8(e,this.loadOptions));else if(s.length>1)throw new Error(`Found more than one (${s.length}) load handlers for URL '${[e]}'`);this.handler=s[0]}var t,r}async load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=await this.handler.load();return this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let r;r=this.artifacts.userDefinedMetadata!=null&&this.artifacts.userDefinedMetadata.signature!=null?this.artifacts.userDefinedMetadata.signature:this.artifacts.signature,this.signature=r,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const s=function(o,A){const u={};let h,l=0;for(const c of A){const d=c.name,m=c.dtype,y=c.shape,b=Jt(y);let v;if("quantization"in c){const w=c.quantization;if(w.dtype==="uint8"||w.dtype==="uint16"){if(!("min"in w)||!("scale"in w))throw new Error(`Weight ${c.name} with quantization ${w.dtype} doesn't have corresponding metadata min and scale.`)}else{if(w.dtype!=="float16")throw new Error(`Weight ${c.name} has unknown quantization dtype ${w.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if(m!=="float32")throw new Error(`Weight ${c.name} is quantized with ${w.dtype} which only supports weights of type float32 not ${m}.`)}const I=R8[w.dtype],S=o.slice(l,l+b*I),T=w.dtype==="uint8"?new Uint8Array(S):new Uint16Array(S);if(m==="float32")if(w.dtype==="uint8"||w.dtype==="uint16"){v=new Float32Array(T.length);for(let D=0;D<T.length;D++){const L=T[D];v[D]=L*w.scale+w.min}}else{if(w.dtype!=="float16")throw new Error(`Unsupported quantization type ${w.dtype} for weight type float32.`);h===void 0&&(h=zhe()),v=h(T)}else{if(m!=="int32")throw new Error(`Unsupported dtype in weight '${d}': ${m}`);if(w.dtype!=="uint8"&&w.dtype!=="uint16")throw new Error(`Unsupported quantization type ${w.dtype} for weight type int32.`);v=new Int32Array(T.length);for(let D=0;D<T.length;D++){const L=T[D];v[D]=Math.round(L*w.scale+w.min)}}l+=b*I}else if(m==="string"){const w=Jt(c.shape);v=[];for(let I=0;I<w;I++){const S=new Uint32Array(o.slice(l,l+4))[0];l+=4;const T=new Uint8Array(o.slice(l,l+S));v.push(T),l+=S}}else{const w=R8[m],I=o.slice(l,l+b*w);if(m==="float32")v=new Float32Array(I);else if(m==="int32")v=new Int32Array(I);else if(m==="bool")v=new Uint8Array(I);else{if(m!=="complex64")throw new Error(`Unsupported dtype in weight '${d}': ${m}`);{v=new Float32Array(I);const S=new Float32Array(v.length/2),T=new Float32Array(v.length/2);for(let W=0;W<S.length;W++)S[W]=v[2*W],T[W]=v[2*W+1];const D=Eu(S,y,"float32"),L=Eu(T,y,"float32");u[d]=ed(D,L),D.dispose(),L.dispose()}}l+=b*w}m!=="complex64"&&(u[d]=Eu(v,y,m))}return u}(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new P1(Lj.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(s),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const o=Lj.Instance.transformGraph(e.modelInitializer);this.initializer=new P1(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if(typeof e=="string"){const s=(r=e,Bs.getSaveHandlers(r));if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}var r;if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof Us||Array.isArray(e)))return e;if((e=Array.isArray(e)?e:[e]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((t,r,s)=>(t[r]=e[s],t),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=this.executor.execute(e,t);return r.length>1?r:r[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=await this.executor.executeAsync(e,t);return r.length>1?r:r[0]}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,r)=>(t[r]=[e[r]],t),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function tH(n,e={}){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&n.load==null&&(n.endsWith("/")||(n+="/"),n=`${n}model.json?tfjs-format=file`);const t=new sbe(n,e);return await t.load(),t}function ch(n,e,t,r){return new(t||(t=Promise))(function(s,o){function A(l){try{h(r.next(l))}catch(c){o(c)}}function u(l){try{h(r.throw(l))}catch(c){o(c)}}function h(l){var c;l.done?s(l.value):(c=l.value,c instanceof t?c:new t(function(d){d(c)})).then(A,u)}h((r=r.apply(n,[])).next())})}function dh(n,e){var t,r,s,o,A={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return o={next:u(0),throw:u(1),return:u(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function u(h){return function(l){return function(c){if(t)throw new TypeError("Generator is already executing.");for(;A;)try{if(t=1,r&&(s=2&c[0]?r.return:c[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,c[1])).done)return s;switch(r=0,s&&(c=[2&c[0],s.value]),c[0]){case 0:case 1:s=c;break;case 4:return A.label++,{value:c[1],done:!1};case 5:A.label++,r=c[1],c=[0];continue;case 7:c=A.ops.pop(),A.trys.pop();continue;default:if(!(s=(s=A.trys).length>0&&s[s.length-1])&&(c[0]===6||c[0]===2)){A=0;continue}if(c[0]===3&&(!s||c[1]>s[0]&&c[1]<s[3])){A.label=c[1];break}if(c[0]===6&&A.label<s[1]){A.label=s[1],s=c;break}if(s&&A.label<s[2]){A.label=s[2],A.ops.push(c);break}s[2]&&A.ops.pop(),A.trys.pop();continue}c=e.call(n,A)}catch(d){c=[6,d],r=0}finally{t=s=0}if(5&c[0])throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}([h,l])}}}var nH=function(n){return{startEndTensor:n,startPoint:$n(n,[0,0],[-1,2]),endPoint:$n(n,[0,2],[-1,2])}},abe={strides:[8,16],anchors:[2,6]};function rH(n,e){var t,r,s;if(n.topLeft instanceof Us&&n.bottomRight instanceof Us){var o=ur(function(){return[To([$n(_n(e-1,n.topLeft),0,1),$n(n.topLeft,1,1)]),To([_n(e-1,$n(n.bottomRight,0,1)),$n(n.bottomRight,1,1)])]});t=o[0],r=o[1],n.landmarks!=null&&(s=ur(function(){var y=_n(so([e-1,0]),n.landmarks),b=so([1,-1]);return Dn(y,b)}))}else{var A=n.topLeft,u=A[0],h=A[1],l=n.bottomRight,c=l[0],d=l[1];t=[e-1-u,h],r=[e-1-c,d],n.landmarks!=null&&(s=n.landmarks.map(function(y){return[e-1-y[0],y[1]]}))}var m={topLeft:t,bottomRight:r};return s!=null&&(m.landmarks=s),n.probability!=null&&(m.probability=n.probability instanceof Us?n.probability.clone():n.probability),m}function sH(n,e){return ur(function(){var t;return t=n.hasOwnProperty("box")?n.box:n,Bu(function(r,s){var o=Dn(r.startPoint,s),A=Dn(r.endPoint,s),u=nW([o,A],1);return nH(u)}(t,e).startEndTensor)})}var obe=function(){function n(e,t,r,s,o,A){this.blazeFaceModel=e,this.width=t,this.height=r,this.maxFaces=s,this.anchorsData=function(u,h,l){for(var c=[],d=0;d<l.strides.length;d++)for(var m=l.strides[d],y=Math.floor((h+m-1)/m),b=Math.floor((u+m-1)/m),v=l.anchors[d],w=0;w<y;w++)for(var I=m*(w+.5),S=0;S<b;S++)for(var T=m*(S+.5),D=0;D<v;D++)c.push([T,I]);return c}(t,r,abe),this.anchors=sh(this.anchorsData),this.inputSizeData=[t,r],this.inputSize=so([t,r]),this.iouThreshold=o,this.scoreThreshold=A}return n.prototype.getBoundingBoxes=function(e,t,r){return r===void 0&&(r=!0),ch(this,void 0,void 0,function(){var s,o,A,u,h,l,c,d,m,y,b,v,w,I,S=this;return dh(this,function(T){switch(T.label){case 0:return s=ur(function(){var D=ju.resizeBilinear(e,[S.width,S.height]),L=Dn(_n(Qs(D,255),.5),2),W=S.blazeFaceModel.predict(L),K=Bu(W),U=function(ee,re,ce){var we=$n(ee,[0,1],[-1,2]),Ee=Ca(we,re),Pe=$n(ee,[0,3],[-1,2]),he=Qs(Pe,ce),de=Qs(Ee,ce),Ae=Qs(he,2),Se=_n(de,Ae),Te=Ca(de,Ae),Ze=Dn(Se,ce),et=Dn(Te,ce);return nW([Ze,et],1)}(K,S.anchors,S.inputSize),_=$n(K,[0,0],[-1,1]);return[K,U,Bu(zT(_))]}),o=s[0],A=s[1],u=s[2],h=console.warn,console.warn=function(){},l=ju.nonMaxSuppression(A,u,this.maxFaces,this.iouThreshold,this.scoreThreshold),console.warn=h,[4,l.array()];case 1:return c=T.sent(),l.dispose(),d=c.map(function(D){return $n(A,[D,0],[1,-1])}),t?[3,3]:[4,Promise.all(d.map(function(D){return ch(S,void 0,void 0,function(){var L;return dh(this,function(W){switch(W.label){case 0:return[4,D.array()];case 1:return L=W.sent(),D.dispose(),[2,L]}})})}))];case 2:d=T.sent(),T.label=3;case 3:for(m=e.shape[1],y=e.shape[2],b=t?Qs([y,m],this.inputSize):[y/this.inputSizeData[0],m/this.inputSizeData[1]],v=[],w=function(D){var L=d[D],W=ur(function(){var K=nH(L instanceof Us?L:sh(L));if(!r)return K;var U,_=c[D];return U=t?$n(S.anchors,[_,0],[1,2]):S.anchorsData[_],{box:K,landmarks:Nt(Bu($n(o,[_,5],[1,-1])),[6,-1]),probability:$n(u,[_],[1]),anchor:U}});v.push(W)},I=0;I<d.length;I++)w(I);return A.dispose(),u.dispose(),o.dispose(),[2,{boxes:v,scaleFactor:b}]}})})},n.prototype.estimateFaces=function(e,t,r,s){return t===void 0&&(t=!1),r===void 0&&(r=!1),s===void 0&&(s=!0),ch(this,void 0,void 0,function(){var o,A,u,h,l,c,d=this;return dh(this,function(m){switch(m.label){case 0:return o=function(y){return y instanceof Us?[y.shape[0],y.shape[1]]:[y.height,y.width]}(e),A=o[1],u=ur(function(){return e instanceof Us||(e=Ghe(e)),Pu(ns(e,"float32"),0)}),[4,this.getBoundingBoxes(u,t,s)];case 1:return h=m.sent(),l=h.boxes,c=h.scaleFactor,u.dispose(),t?[2,l.map(function(y){var b=sH(y,c),v={topLeft:$n(b,[0],[2]),bottomRight:$n(b,[2],[2])};if(s){var w=y,I=w.landmarks,S=w.probability,T=w.anchor,D=Dn(Ca(I,T),c);v.landmarks=D,v.probability=S}return r&&(v=rH(v,A)),v})]:[2,Promise.all(l.map(function(y){return ch(d,void 0,void 0,function(){var b,v,w,I,S,T,D,L,W,K,U,_=this;return dh(this,function(ee){switch(ee.label){case 0:return b=sH(y,c),s?[3,2]:[4,b.array()];case 1:return S=ee.sent(),v={topLeft:S.slice(0,2),bottomRight:S.slice(2)},[3,4];case 2:return[4,Promise.all([y.landmarks,b,y.probability].map(function(re){return ch(_,void 0,void 0,function(){return dh(this,function(ce){return[2,re.array()]})})}))];case 3:w=ee.sent(),I=w[0],S=w[1],T=w[2],D=y.anchor,W=(L=c)[0],K=L[1],U=I.map(function(re){return[(re[0]+D[0])*W,(re[1]+D[1])*K]}),v={topLeft:S.slice(0,2),bottomRight:S.slice(2),landmarks:U,probability:T},function(re){re.startEndTensor.dispose(),re.startPoint.dispose(),re.endPoint.dispose()}(y.box),y.landmarks.dispose(),y.probability.dispose(),ee.label=4;case 4:return b.dispose(),r&&(v=rH(v,A)),[2,v]}})})}))]}})})},n}(),ibe=p(392),Abe=p.n(ibe),lbe=p(159);let ca,ph,Xu;(function(n,e=!1){if(D1)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof n=="string")zg=n;else{Og=n;const t=sge.filter(r=>Og[r]==null);if(t.length>0)throw new Error(`There were no entries found for the following binaries: ${t.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}Pj=e})({"tfjs-backend-wasm.wasm":`${wt.STATIC_ASSETS_BASE_URL}wasm-store/tf/tfjs-backend-wasm.wasm`,"tfjs-backend-wasm-simd.wasm":`${wt.STATIC_ASSETS_BASE_URL}wasm-store/tf/tfjs-backend-wasm-simd.wasm`,"tfjs-backend-wasm-threaded-simd.wasm":`${wt.STATIC_ASSETS_BASE_URL}wasm-store/tf/tfjs-backend-wasm-threaded-simd.wasm`});let mM,hh,Bg,gM,yM,cd,dd,B1,bM,fh,F1=!0;const aH=async n=>{const e=await Xu.estimateFaces(n,!1,!1,!1);return e&&e.length!==0?e[0]:null},oH=(n,e)=>{const t=parseInt(e.topLeft[0]),r=parseInt(e.topLeft[1]),s=parseInt(e.bottomRight[0]),o=parseInt(e.bottomRight[1]),A=Ve(()=>{const l=an(n,255).slice([r,t],[o-r,s-t]),c=Qi.resizeBilinear(l,[112,112]).expandDims(0);let d=ph.predict(c).squeeze(0).reshape([106,2]),[m,y]=_a(d,2,1);return m=vt(Me(m,l.shape[1]),t).asType("float32"),y=vt(Me(y,l.shape[0]),r).asType("float32"),new Float32Array(ys([m,y],1).reshape([106,2]).dataSync().buffer)}),u=ca._malloc(A.length*A.BYTES_PER_ELEMENT);ca.HEAPF32.set(A,u>>2);const h=new Float32Array(ca.glCalculateExtraFacePoints(u));return ca._free(u),h},iH=(n,e,t,r,s,o)=>{const A=ca._malloc(n.length),u=ca._malloc(e.length*e.BYTES_PER_ELEMENT);try{ca.HEAPU8.set(n,A),ca.HEAPF32.set(e,u>>2);const h=ca.verify_image(A,t,r,u,s.tx,s.ty,s.bx,s.by,lbe.Fr,o);return{faceFound:!0,far:h.too_far,close:h.too_close,noSufficientLite:h.light,misAligned:h.orientation===!0,outsideGuide:h.outsideGuide}}finally{ca._free(A),ca._free(u)}},AH=(n,e,t)=>{const r=parseInt(n.topLeft[0]),s=parseInt(n.topLeft[1]),o=parseInt(n.bottomRight[0]),A=parseInt(n.bottomRight[1]);return!(r<=0||o>=e||s<=0||A>=t)},lH=async n=>{performance.now(),Al().startScope();try{const e=r4(n),t=await aH(e);if(!t)return{faceFound:!1,far:!1,close:!1,noSufficientLite:!1,misAligned:!1,outsideGuide:!1};if(!AH(t,dd,cd))return{faceFound:!1,far:!1,close:!1,noSufficientLite:!1,misAligned:!1,outsideGuide:!1};const r=oH(e,t),s=iH(n.data,r,dd,cd,yM,!1);return performance.now(),s}finally{Al().endScope()}},uH=async()=>{if(F1)return;bM.drawImage(B1,0,0),Bg.drawImage(B1,fh.x,fh.y,fh.width,fh.height,0,0,dd,cd);const n=await lH(Bg.getImageData(0,0,dd,cd));F1||(gM(n),requestAnimationFrame(uH))},vM=function(){return hh||(hh=new Promise((n,e)=>{cbe().then(()=>async function(){await ube()}()).then(()=>{n()}).catch(()=>{hh=null,e()})}),hh)};let ube=async()=>{Xu&&ph||await Promise.all([pbe(),dbe()]).then(([n,e])=>(Xu=n,ph=e,Promise.resolve()))};const cbe=async function(){return new Promise(async(n,e)=>(await Ne.setBackend("wasm"),await Ne.ready(),ca={onRuntimeInitialized:()=>n(),onStatus:t=>{},onExit:()=>{},locateFile:t=>wt.ASSETS_BASE_URL+t},st().set("PROD",!0),Abe()(ca)))},dbe=()=>{let n=ca.getSc(),e=JSON.parse(new TextDecoder("utf-8").decode(n));const t={signature:e.userDefinedMetaData.signature};return async function(r,s={}){if(r==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");s==null&&(s={}),s.fromTFHub&&r.load==null&&(r.endsWith("/")||(r+="/"),r=`${r}model.json?tfjs-format=file`);const o=new Yre(r,s);return await o.load(),o}(function(r,s,o,A){return arguments.length===1?r.modelTopology!=null||r.weightSpecs!=null?new EI(r):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new EI({modelTopology:r})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new EI({modelTopology:r,weightSpecs:s,weightData:o,trainingConfig:A}))}({modelTopology:e.modelTopology,weightSpecs:e.weightsManifest,weightData:function(r){for(var s=window.atob(r),o=s.length,A=new Uint8Array(o),u=0;u<o;u++)A[u]=s.charCodeAt(u);return A.buffer}(new TextDecoder("utf-8").decode(ca.getW())),userDefinedMetadata:t}))},pbe=()=>function(n){var e=n===void 0?{}:n,t=e.maxFaces,r=t===void 0?10:t,s=e.inputWidth,o=s===void 0?128:s,A=e.inputHeight,u=A===void 0?128:A,h=e.iouThreshold,l=h===void 0?.3:h,c=e.scoreThreshold,d=c===void 0?.75:c,m=e.modelUrl;return ch(this,void 0,void 0,function(){var y;return dh(this,function(b){switch(b.label){case 0:return m==null?[3,2]:[4,tH(m)];case 1:return y=b.sent(),[3,4];case 2:return[4,tH("https://tfhub.dev/tensorflow/tfjs-model/blazeface/1/default/1",{fromTFHub:!0})];case 3:y=b.sent(),b.label=4;case 4:return[2,new obe(y,o,u,r,l,d)]}})})}({iouThreshold:.75,scoreThreshold:.95,maxFaces:1,modelUrl:`${wt.STATIC_ASSETS_BASE_URL}wasm-store/blazeface/model.json`}),cH=()=>{F1=!0};class io{}qs(io,"CONTAINER_MISSING",{code:1,message:"Container is missing."}),qs(io,"SDK_NOT_INITIALIZED",{code:2,message:"SDK not initialized."}),qs(io,"IMAGE_NOT_PROVIDED",{code:3,message:"Image not provided."}),qs(io,"API_ERROR",{code:4,message:"API error."}),qs(io,"CAMERA_NOT_FOUND",{code:5,message:"Camera not found."}),qs(io,"APP_INIT_ISSUE",{code:6,message:"App initialization issue."}),qs(io,"REQUEST_CANCELLED",{code:7,message:"Request cancelled."}),qs(io,"IMAGE_FILE_MISSING",{code:8,message:"Image file is missing."}),qs(io,"NO_FACE_DETECTED",{code:9,message:"No face detected in the image."}),qs(io,"IMAGE_PROCESSING_FAILED",{code:10,message:"Failed to process the image."});const L1={equals:(n,e)=>n===e};let hbe=vH;const Cl=1,Fg=2,dH={owned:null,cleanups:null,context:null,owner:null};var ws=null;let $t=null,pH=null,xM=null,ps=null,Sa=null,Di=null,R1=0;function Ao(n,e){const t={value:n,observers:null,observerSlots:null,comparator:(e=e?Object.assign({},L1,e):L1).equals||void 0};return[mH.bind(t),r=>(typeof r=="function"&&(r=$t&&$t.running&&$t.sources.has(t)?r(t.tValue):r(t.value)),gH(t,r))]}function W1(n,e,t){const r=bH(n,e,!1,Cl);j1(r)}function hH(n,e,t){t=t?Object.assign({},L1,t):L1;const r=bH(n,e,!0,0);return r.observers=null,r.observerSlots=null,r.comparator=t.equals||void 0,j1(r),mH.bind(r)}function mh(n){if(ps===null)return n();const e=ps;ps=null;try{return xM?xM.untrack(n):n()}finally{ps=e}}const[$be,fH]=Ao(!1);function mH(){const n=$t&&$t.running;if(this.sources&&(n?this.tState:this.state))if((n?this.tState:this.state)===Cl)j1(this);else{const e=Sa;Sa=null,Zu(()=>H1(this),!1),Sa=e}if(ps){const e=this.observers?this.observers.length:0;ps.sources?(ps.sources.push(this),ps.sourceSlots.push(e)):(ps.sources=[this],ps.sourceSlots=[e]),this.observers?(this.observers.push(ps),this.observerSlots.push(ps.sources.length-1)):(this.observers=[ps],this.observerSlots=[ps.sources.length-1])}return n&&$t.sources.has(this)?this.tValue:this.value}function gH(n,e,t){let r=$t&&$t.running&&$t.sources.has(n)?n.tValue:n.value;if(!n.comparator||!n.comparator(r,e)){if($t){const s=$t.running;(s||!t&&$t.sources.has(n))&&($t.sources.add(n),n.tValue=e),s||(n.value=e)}else n.value=e;n.observers&&n.observers.length&&Zu(()=>{for(let s=0;s<n.observers.length;s+=1){const o=n.observers[s],A=$t&&$t.running;A&&$t.disposed.has(o)||((A?o.tState:o.state)||(o.pure?Sa.push(o):Di.push(o),o.observers&&xH(o)),A?o.tState=Cl:o.state=Cl)}if(Sa.length>1e6)throw Sa=[],new Error},!1)}return e}function j1(n){if(!n.fn)return;Yu(n);const e=R1;yH(n,$t&&$t.running&&$t.sources.has(n)?n.tValue:n.value,e),$t&&!$t.running&&$t.sources.has(n)&&queueMicrotask(()=>{Zu(()=>{$t&&($t.running=!0),ps=ws=n,yH(n,n.tValue,e),ps=ws=null},!1)})}function yH(n,e,t){let r;const s=ws,o=ps;ps=ws=n;try{r=n.fn(e)}catch(A){return n.pure&&($t&&$t.running?(n.tState=Cl,n.tOwned&&n.tOwned.forEach(Yu),n.tOwned=void 0):(n.state=Cl,n.owned&&n.owned.forEach(Yu),n.owned=null)),n.updatedAt=t+1,kH(A)}finally{ps=o,ws=s}(!n.updatedAt||n.updatedAt<=t)&&(n.updatedAt!=null&&"observers"in n?gH(n,r,!0):$t&&$t.running&&n.pure?($t.sources.add(n),n.tValue=r):n.value=r,n.updatedAt=t)}function bH(n,e,t,r=Cl,s){const o={fn:n,state:r,updatedAt:null,owned:null,sources:null,sourceSlots:null,cleanups:null,value:e,owner:ws,context:ws?ws.context:null,pure:t};return $t&&$t.running&&(o.state=0,o.tState=r),ws===null||ws!==dH&&($t&&$t.running&&ws.pure?ws.tOwned?ws.tOwned.push(o):ws.tOwned=[o]:ws.owned?ws.owned.push(o):ws.owned=[o]),o}function wM(n){const e=$t&&$t.running;if((e?n.tState:n.state)===0)return;if((e?n.tState:n.state)===Fg)return H1(n);if(n.suspense&&mh(n.suspense.inFallback))return n.suspense.effects.push(n);const t=[n];for(;(n=n.owner)&&(!n.updatedAt||n.updatedAt<R1);){if(e&&$t.disposed.has(n))return;(e?n.tState:n.state)&&t.push(n)}for(let r=t.length-1;r>=0;r--){if(n=t[r],e){let s=n,o=t[r+1];for(;(s=s.owner)&&s!==o;)if($t.disposed.has(s))return}if((e?n.tState:n.state)===Cl)j1(n);else if((e?n.tState:n.state)===Fg){const s=Sa;Sa=null,Zu(()=>H1(n,t[0]),!1),Sa=s}}}function Zu(n,e){if(Sa)return n();let t=!1;e||(Sa=[]),Di?t=!0:Di=[],R1++;try{const r=n();return function(s){if(Sa&&(pH&&$t&&$t.running?function(u){for(let h=0;h<u.length;h++){const l=u[h],c=$t.queue;c.has(l)||(c.add(l),pH(()=>{c.delete(l),Zu(()=>{$t.running=!0,wM(l)},!1),$t&&($t.running=!1)}))}}(Sa):vH(Sa),Sa=null),s)return;let o;if($t)if($t.promises.size||$t.queue.size){if($t.running)return $t.running=!1,$t.effects.push.apply($t.effects,Di),Di=null,void fH(!0)}else{const u=$t.sources,h=$t.disposed;Di.push.apply(Di,$t.effects),o=$t.resolve;for(const l of Di)"tState"in l&&(l.state=l.tState),delete l.tState;$t=null,Zu(()=>{for(const l of h)Yu(l);for(const l of u){if(l.value=l.tValue,l.owned)for(let c=0,d=l.owned.length;c<d;c++)Yu(l.owned[c]);l.tOwned&&(l.owned=l.tOwned),delete l.tValue,delete l.tOwned,l.tState=0}fH(!1)},!1)}const A=Di;Di=null,A.length&&Zu(()=>hbe(A),!1),o&&o()}(t),r}catch(r){t||(Di=null),Sa=null,kH(r)}}function vH(n){for(let e=0;e<n.length;e++)wM(n[e])}function H1(n,e){const t=$t&&$t.running;t?n.tState=0:n.state=0;for(let r=0;r<n.sources.length;r+=1){const s=n.sources[r];if(s.sources){const o=t?s.tState:s.state;o===Cl?s!==e&&(!s.updatedAt||s.updatedAt<R1)&&wM(s):o===Fg&&H1(s,e)}}}function xH(n){const e=$t&&$t.running;for(let t=0;t<n.observers.length;t+=1){const r=n.observers[t];(e?r.tState:r.state)||(e?r.tState=Fg:r.state=Fg,r.pure?Sa.push(r):Di.push(r),r.observers&&xH(r))}}function Yu(n){let e;if(n.sources)for(;n.sources.length;){const t=n.sources.pop(),r=n.sourceSlots.pop(),s=t.observers;if(s&&s.length){const o=s.pop(),A=t.observerSlots.pop();r<s.length&&(o.sourceSlots[A]=r,s[r]=o,t.observerSlots[r]=A)}}if(n.tOwned){for(e=n.tOwned.length-1;e>=0;e--)Yu(n.tOwned[e]);delete n.tOwned}if($t&&$t.running&&n.pure)wH(n,!0);else if(n.owned){for(e=n.owned.length-1;e>=0;e--)Yu(n.owned[e]);n.owned=null}if(n.cleanups){for(e=n.cleanups.length-1;e>=0;e--)n.cleanups[e]();n.cleanups=null}$t&&$t.running?n.tState=0:n.state=0}function wH(n,e){if(e||(n.tState=0,$t.disposed.add(n)),n.owned)for(let t=0;t<n.owned.length;t++)wH(n.owned[t])}function kH(n,e=ws){throw function(r){return r instanceof Error?r:new Error(typeof r=="string"?r:"Unknown error",{cause:r})}(n)}function fbe(n){const e=n.keyed,t=hH(()=>n.when,void 0,{equals:(r,s)=>e?r===s:!r==!s});return hH(()=>{const r=t();if(r){const s=n.children;return typeof s=="function"&&s.length>0?mh(()=>s(e?r:()=>{if(!mh(t))throw"Stale read from <Show>.";return n.when})):s}return n.fallback},void 0,void 0)}const CH="_$DX_DELEGATE";function mbe(n,e,t,r={}){let s;return function(o,A){const u=ps,h=ws,l=o.length===0,c=A===void 0?h:A,d=l?dH:{owned:null,cleanups:null,context:c?c.context:null,owner:c},m=l?o:()=>o(()=>mh(()=>Yu(d)));ws=d,ps=null;try{return Zu(m,!0)}finally{ps=u,ws=h}}(o=>{s=o,e===document?n():lo(e,n(),e.firstChild?null:void 0,t)},r.owner),()=>{s(),e.textContent=""}}function IH(n,e,t){let r;const s=()=>{const A=document.createElement("template");return A.innerHTML=n,A.content.firstChild},o=()=>(r||(r=s())).cloneNode(!0);return o.cloneNode=o,o}function RA(n,e){e==null?n.removeAttribute("class"):n.className=e}function SH(n,e,t,r){Array.isArray(t)?(n[`$$${e}`]=t[0],n[`$$${e}Data`]=t[1]):n[`$$${e}`]=t}function kM(n,e,t){return mh(()=>n(e,t))}function lo(n,e,t,r){if(t===void 0||r||(r=[]),typeof e!="function")return G1(n,e,r,t);W1(s=>G1(n,e(),s,t),r)}function gbe(n){let e=n.target;const t=`$$${n.type}`,r=n.target,s=n.currentTarget,o=h=>Object.defineProperty(n,"target",{configurable:!0,value:h}),A=()=>{const h=e[t];if(h&&!e.disabled){const l=e[`${t}Data`];if(l!==void 0?h.call(e,l,n):h.call(e,n),n.cancelBubble)return}return e.host&&typeof e.host!="string"&&!e.host._$host&&e.contains(n.target)&&o(e.host),!0},u=()=>{for(;A()&&(e=e._$host||e.parentNode||e.host););};if(Object.defineProperty(n,"currentTarget",{configurable:!0,get:()=>e||document}),n.composedPath){const h=n.composedPath();o(h[0]);for(let l=0;l<h.length-2&&(e=h[l],A());l++){if(e._$host){e=e._$host,u();break}if(e.parentNode===s)break}}else u();o(r)}function G1(n,e,t,r,s){for(;typeof t=="function";)t=t();if(e===t)return t;const o=typeof e,A=r!==void 0;if(n=A&&t[0]&&t[0].parentNode||n,o==="string"||o==="number"){if(o==="number"&&(e=e.toString())===t)return t;if(A){let u=t[0];u&&u.nodeType===3?u.data!==e&&(u.data=e):u=document.createTextNode(e),t=gh(n,t,r,u)}else t=t!==""&&typeof t=="string"?n.firstChild.data=e:n.textContent=e}else if(e==null||o==="boolean")t=gh(n,t,r);else{if(o==="function")return W1(()=>{let u=e();for(;typeof u=="function";)u=u();t=G1(n,u,t,r)}),()=>t;if(Array.isArray(e)){const u=[],h=t&&Array.isArray(t);if(CM(u,e,t,s))return W1(()=>t=G1(n,u,t,r,!0)),()=>t;if(u.length===0){if(t=gh(n,t,r),A)return t}else h?t.length===0?NH(n,u,r):function(l,c,d){let m=d.length,y=c.length,b=m,v=0,w=0,I=c[y-1].nextSibling,S=null;for(;v<y||w<b;)if(c[v]!==d[w]){for(;c[y-1]===d[b-1];)y--,b--;if(y===v){const T=b<m?w?d[w-1].nextSibling:d[b-w]:I;for(;w<b;)l.insertBefore(d[w++],T)}else if(b===w)for(;v<y;)S&&S.has(c[v])||c[v].remove(),v++;else if(c[v]===d[b-1]&&d[w]===c[y-1]){const T=c[--y].nextSibling;l.insertBefore(d[w++],c[v++].nextSibling),l.insertBefore(d[--b],T),c[y]=d[b]}else{if(!S){S=new Map;let D=w;for(;D<b;)S.set(d[D],D++)}const T=S.get(c[v]);if(T!=null)if(w<T&&T<b){let D,L=v,W=1;for(;++L<y&&L<b&&(D=S.get(c[L]))!=null&&D===T+W;)W++;if(W>T-w){const K=c[v];for(;w<T;)l.insertBefore(d[w++],K)}else l.replaceChild(d[w++],c[v++])}else v++;else c[v++].remove()}}else v++,w++}(n,t,u):(t&&gh(n),NH(n,u));t=u}else if(e.nodeType){if(Array.isArray(t)){if(A)return t=gh(n,t,r,e);gh(n,t,null,e)}else t!=null&&t!==""&&n.firstChild?n.replaceChild(e,n.firstChild):n.appendChild(e);t=e}}return t}function CM(n,e,t,r){let s=!1;for(let o=0,A=e.length;o<A;o++){let u,h=e[o],l=t&&t[n.length];if(!(h==null||h===!0||h===!1))if((u=typeof h)=="object"&&h.nodeType)n.push(h);else if(Array.isArray(h))s=CM(n,h,l)||s;else if(u==="function")if(r){for(;typeof h=="function";)h=h();s=CM(n,Array.isArray(h)?h:[h],Array.isArray(l)?l:[l])||s}else n.push(h),s=!0;else{const c=String(h);l&&l.nodeType===3&&l.data===c?n.push(l):n.push(document.createTextNode(c))}}return s}function NH(n,e,t=null){for(let r=0,s=e.length;r<s;r++)n.insertBefore(e[r],t)}function gh(n,e,t,r){if(t===void 0)return n.textContent="";const s=r||document.createTextNode("");if(e.length){let o=!1;for(let A=e.length-1;A>=0;A--){const u=e[A];if(s!==u){const h=u.parentNode===n;o||A?h&&u.remove():h?n.replaceChild(s,u):n.insertBefore(s,t)}else o=!0}}else n.insertBefore(s,t);return[s]}class ybe{static getMaxCenteredRectangle(e,t,r,s,o){let A=r,u=A/o;return u>s&&(u=s,A=u*o),A>e&&(A=e,u=A/o),u>t&&(u=t,A=u*o),{width:A,height:u,x:(e-A)/2,y:(t-u)/2}}}const TH={GUIDELINE1:"Look straight into the camera & keep your face in the circle",GUIDELINE2:"Take off your glasses & don't let your hair cover your face"},bbe="Move a little closer!",vbe="Gently tilt your head back a bit.",xbe="Make sure your face is evenly lit.",wbe="Keep your face straight and centered.",kbe="Lighting",Cbe="Pose",Ibe="Position",Sbe="Align your face inside the oval.",Nbe="PROCEED",Tbe="RETRY",yh=(qH=class{constructor(n=10){Ju(this,vh);Ju(this,Sl);gd(this,vh,n),gd(this,Sl,0)}setStatus(n){n?Js(this,Sl)<Js(this,vh)&&GM(this,Sl)._++:Js(this,Sl)>0&&GM(this,Sl)._--}getCount(){return Js(this,Sl)}getWindowSize(){return Js(this,vh)}},vh=new WeakMap,Sl=new WeakMap,qH);function pd(n){return pd=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(e){return typeof e}:function(e){return e&&typeof Symbol=="function"&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},pd(n)}var bt,Mbe=IH('<div class="osc-abs-center osc-counter"id=autoCapturePendingInterval>'),Ebe=IH('<div><div id=smart-capture-sdk><video class=osc-video autoplay=true id=selfieVideo muted playsinline></video><canvas class=osc-canvas id=previewCanvas></canvas><canvas class=osc-canvas id=validationCanvas style=display:none;></canvas><div class="osc-blur osc-abs-center osc-guidance-ellipse"></div><div class="osc-overlay-border osc-abs-center osc-guidance-ellipse"></div><div class="osc-error-messages osc-abs-center"id=errorMessages><div></div><div></div><div></div><div></div><div></div></div><div class=osc-indicators><label></label><label></label><label></label></div><div class=osc-guidelines><div></div><div></div></div><div class=osc-actions><button class=osc-button type=button></button><button class=osc-button type=button>');function Do(n,e){return function(t){if(Array.isArray(t))return t}(n)||function(t,r){var s=t==null?null:typeof Symbol<"u"&&t[Symbol.iterator]||t["@@iterator"];if(s!=null){var o,A,u,h,l=[],c=!0,d=!1;try{if(u=(s=s.call(t)).next,r!==0)for(;!(c=(o=u.call(s)).done)&&(l.push(o.value),l.length!==r);c=!0);}catch(m){d=!0,A=m}finally{try{if(!c&&s.return!=null&&(h=s.return(),Object(h)!==h))return}finally{if(d)throw A}}return l}}(n,e)||function(t,r){if(t){if(typeof t=="string")return MH(t,r);var s={}.toString.call(t).slice(8,-1);return s==="Object"&&t.constructor&&(s=t.constructor.name),s==="Map"||s==="Set"?Array.from(t):s==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(s)?MH(t,r):void 0}}(n,e)||function(){throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}()}function MH(n,e){(e==null||e>n.length)&&(e=n.length);for(var t=0,r=Array(e);t<e;t++)r[t]=n[t];return r}function Lg(){Lg=function(){return e};var n,e={},t=Object.prototype,r=t.hasOwnProperty,s=Object.defineProperty||function(he,de,Ae){he[de]=Ae.value},o=typeof Symbol=="function"?Symbol:{},A=o.iterator||"@@iterator",u=o.asyncIterator||"@@asyncIterator",h=o.toStringTag||"@@toStringTag";function l(he,de,Ae){return Object.defineProperty(he,de,{value:Ae,enumerable:!0,configurable:!0,writable:!0}),he[de]}try{l({},"")}catch{l=function(de,Ae,Se){return de[Ae]=Se}}function c(he,de,Ae,Se){var Te=de&&de.prototype instanceof I?de:I,Ze=Object.create(Te.prototype),et=new Ee(Se||[]);return s(Ze,"_invoke",{value:ee(he,Ae,et)}),Ze}function d(he,de,Ae){try{return{type:"normal",arg:he.call(de,Ae)}}catch(Se){return{type:"throw",arg:Se}}}e.wrap=c;var m="suspendedStart",y="suspendedYield",b="executing",v="completed",w={};function I(){}function S(){}function T(){}var D={};l(D,A,function(){return this});var L=Object.getPrototypeOf,W=L&&L(L(Pe([])));W&&W!==t&&r.call(W,A)&&(D=W);var K=T.prototype=I.prototype=Object.create(D);function U(he){["next","throw","return"].forEach(function(de){l(he,de,function(Ae){return this._invoke(de,Ae)})})}function _(he,de){function Ae(Te,Ze,et,qe){var Re=d(he[Te],he,Ze);if(Re.type!=="throw"){var Ue=Re.arg,ot=Ue.value;return ot&&pd(ot)=="object"&&r.call(ot,"__await")?de.resolve(ot.__await).then(function(yt){Ae("next",yt,et,qe)},function(yt){Ae("throw",yt,et,qe)}):de.resolve(ot).then(function(yt){Ue.value=yt,et(Ue)},function(yt){return Ae("throw",yt,et,qe)})}qe(Re.arg)}var Se;s(this,"_invoke",{value:function(Te,Ze){function et(){return new de(function(qe,Re){Ae(Te,Ze,qe,Re)})}return Se=Se?Se.then(et,et):et()}})}function ee(he,de,Ae){var Se=m;return function(Te,Ze){if(Se===b)throw Error("Generator is already running");if(Se===v){if(Te==="throw")throw Ze;return{value:n,done:!0}}for(Ae.method=Te,Ae.arg=Ze;;){var et=Ae.delegate;if(et){var qe=re(et,Ae);if(qe){if(qe===w)continue;return qe}}if(Ae.method==="next")Ae.sent=Ae._sent=Ae.arg;else if(Ae.method==="throw"){if(Se===m)throw Se=v,Ae.arg;Ae.dispatchException(Ae.arg)}else Ae.method==="return"&&Ae.abrupt("return",Ae.arg);Se=b;var Re=d(he,de,Ae);if(Re.type==="normal"){if(Se=Ae.done?v:y,Re.arg===w)continue;return{value:Re.arg,done:Ae.done}}Re.type==="throw"&&(Se=v,Ae.method="throw",Ae.arg=Re.arg)}}}function re(he,de){var Ae=de.method,Se=he.iterator[Ae];if(Se===n)return de.delegate=null,Ae==="throw"&&he.iterator.return&&(de.method="return",de.arg=n,re(he,de),de.method==="throw")||Ae!=="return"&&(de.method="throw",de.arg=new TypeError("The iterator does not provide a '"+Ae+"' method")),w;var Te=d(Se,he.iterator,de.arg);if(Te.type==="throw")return de.method="throw",de.arg=Te.arg,de.delegate=null,w;var Ze=Te.arg;return Ze?Ze.done?(de[he.resultName]=Ze.value,de.next=he.nextLoc,de.method!=="return"&&(de.method="next",de.arg=n),de.delegate=null,w):Ze:(de.method="throw",de.arg=new TypeError("iterator result is not an object"),de.delegate=null,w)}function ce(he){var de={tryLoc:he[0]};1 in he&&(de.catchLoc=he[1]),2 in he&&(de.finallyLoc=he[2],de.afterLoc=he[3]),this.tryEntries.push(de)}function we(he){var de=he.completion||{};de.type="normal",delete de.arg,he.completion=de}function Ee(he){this.tryEntries=[{tryLoc:"root"}],he.forEach(ce,this),this.reset(!0)}function Pe(he){if(he||he===""){var de=he[A];if(de)return de.call(he);if(typeof he.next=="function")return he;if(!isNaN(he.length)){var Ae=-1,Se=function Te(){for(;++Ae<he.length;)if(r.call(he,Ae))return Te.value=he[Ae],Te.done=!1,Te;return Te.value=n,Te.done=!0,Te};return Se.next=Se}}throw new TypeError(pd(he)+" is not iterable")}return S.prototype=T,s(K,"constructor",{value:T,configurable:!0}),s(T,"constructor",{value:S,configurable:!0}),S.displayName=l(T,h,"GeneratorFunction"),e.isGeneratorFunction=function(he){var de=typeof he=="function"&&he.constructor;return!!de&&(de===S||(de.displayName||de.name)==="GeneratorFunction")},e.mark=function(he){return Object.setPrototypeOf?Object.setPrototypeOf(he,T):(he.__proto__=T,l(he,h,"GeneratorFunction")),he.prototype=Object.create(K),he},e.awrap=function(he){return{__await:he}},U(_.prototype),l(_.prototype,u,function(){return this}),e.AsyncIterator=_,e.async=function(he,de,Ae,Se,Te){Te===void 0&&(Te=Promise);var Ze=new _(c(he,de,Ae,Se),Te);return e.isGeneratorFunction(de)?Ze:Ze.next().then(function(et){return et.done?et.value:Ze.next()})},U(K),l(K,h,"Generator"),l(K,A,function(){return this}),l(K,"toString",function(){return"[object Generator]"}),e.keys=function(he){var de=Object(he),Ae=[];for(var Se in de)Ae.push(Se);return Ae.reverse(),function Te(){for(;Ae.length;){var Ze=Ae.pop();if(Ze in de)return Te.value=Ze,Te.done=!1,Te}return Te.done=!0,Te}},e.values=Pe,Ee.prototype={constructor:Ee,reset:function(he){if(this.prev=0,this.next=0,this.sent=this._sent=n,this.done=!1,this.delegate=null,this.method="next",this.arg=n,this.tryEntries.forEach(we),!he)for(var de in this)de.charAt(0)==="t"&&r.call(this,de)&&!isNaN(+de.slice(1))&&(this[de]=n)},stop:function(){this.done=!0;var he=this.tryEntries[0].completion;if(he.type==="throw")throw he.arg;return this.rval},dispatchException:function(he){if(this.done)throw he;var de=this;function Ae(Re,Ue){return Ze.type="throw",Ze.arg=he,de.next=Re,Ue&&(de.method="next",de.arg=n),!!Ue}for(var Se=this.tryEntries.length-1;Se>=0;--Se){var Te=this.tryEntries[Se],Ze=Te.completion;if(Te.tryLoc==="root")return Ae("end");if(Te.tryLoc<=this.prev){var et=r.call(Te,"catchLoc"),qe=r.call(Te,"finallyLoc");if(et&&qe){if(this.prev<Te.catchLoc)return Ae(Te.catchLoc,!0);if(this.prev<Te.finallyLoc)return Ae(Te.finallyLoc)}else if(et){if(this.prev<Te.catchLoc)return Ae(Te.catchLoc,!0)}else{if(!qe)throw Error("try statement without catch or finally");if(this.prev<Te.finallyLoc)return Ae(Te.finallyLoc)}}}},abrupt:function(he,de){for(var Ae=this.tryEntries.length-1;Ae>=0;--Ae){var Se=this.tryEntries[Ae];if(Se.tryLoc<=this.prev&&r.call(Se,"finallyLoc")&&this.prev<Se.finallyLoc){var Te=Se;break}}Te&&(he==="break"||he==="continue")&&Te.tryLoc<=de&&de<=Te.finallyLoc&&(Te=null);var Ze=Te?Te.completion:{};return Ze.type=he,Ze.arg=de,Te?(this.method="next",this.next=Te.finallyLoc,w):this.complete(Ze)},complete:function(he,de){if(he.type==="throw")throw he.arg;return he.type==="break"||he.type==="continue"?this.next=he.arg:he.type==="return"?(this.rval=this.arg=he.arg,this.method="return",this.next="end"):he.type==="normal"&&de&&(this.next=de),w},finish:function(he){for(var de=this.tryEntries.length-1;de>=0;--de){var Ae=this.tryEntries[de];if(Ae.finallyLoc===he)return this.complete(Ae.completion,Ae.afterLoc),we(Ae),w}},catch:function(he){for(var de=this.tryEntries.length-1;de>=0;--de){var Ae=this.tryEntries[de];if(Ae.tryLoc===he){var Se=Ae.completion;if(Se.type==="throw"){var Te=Se.arg;we(Ae)}return Te}}throw Error("illegal catch attempt")},delegateYield:function(he,de,Ae){return this.delegate={iterator:Pe(he),resultName:de,nextLoc:Ae},this.method==="next"&&(this.arg=n),w}},e}function EH(n,e,t,r,s,o,A){try{var u=n[o](A),h=u.value}catch(l){return void t(l)}u.done?e(h):Promise.resolve(h).then(r,s)}function DH(n){return function(){var e=this,t=arguments;return new Promise(function(r,s){var o=n.apply(e,t);function A(h){EH(o,r,s,A,u,"next",h)}function u(h){EH(o,r,s,A,u,"throw",h)}A(void 0)})}}function Dbe(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,zH(r.key),r)}}function IM(n,e,t){return(e=zH(e))in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function zH(n){var e=function(t){if(pd(t)!="object"||!t)return t;var r=t[Symbol.toPrimitive];if(r!==void 0){var s=r.call(t,"string");if(pd(s)!="object")return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(n);return pd(e)=="symbol"?e:e+""}function Fs(n,e,t){if(typeof n=="function"?n===e:n.has(e))return arguments.length<3?e:t;throw new TypeError("Private element is not present on this object")}var hd=function(){function n(){(function(s,o){if(!(s instanceof o))throw new TypeError("Cannot call a class as a function")})(this,n)}return e=n,t=[{key:"renderSmartCaptureUI",value:(r=DH(Lg().mark(function s(o){var A;return Lg().wrap(function(u){for(;;)switch(u.prev=u.next){case 0:if(!Rg._){u.next=2;break}return u.abrupt("return");case 2:return OH.call(n),u.prev=4,u.next=7,navigator.mediaDevices.getUserMedia(PH._);case 7:A=u.sent,bh._=A,Rg._=mbe(function(){return zbe._.call(n)},o),QH._.call(n),u.next=19;break;case 13:return u.prev=13,u.t0=u.catch(4),md._.notification(io.CAMERA_NOT_FOUND),u.next=18,Promise.reject(io.CAMERA_NOT_FOUND);case 18:return u.abrupt("return",u.sent);case 19:case"end":return u.stop()}},s,null,[[4,13]])})),function(s){return r.apply(this,arguments)})}],t&&Dbe(e,t),Object.defineProperty(e,"prototype",{writable:!1}),e;var e,t,r}();function OH(){Vg._.call(bt,3),LM._.call(bt,!1),FM._.call(bt,!1),BM._.call(bt,!1),RM._.call(bt,!0),WM._.call(bt,!0),EM._.call(bt,!1),PM._.call(bt,!1),DM._.call(bt,!1),zM._.call(bt,!1),Xg._.call(bt,0),OM._.call(bt,!1),Hg._.call(bt,!1),jM._.call(bt,!1),bt.capturedPic=null}bt=hd;var Rg={_:void 0},PH={_:{audio:!1,video:{facingMode:"user",width:{min:1280},height:{min:720}}}},bh={_:void 0},Uu={_:void 0},SM={_:0},NM={_:0},V1={_:0},TM={_:0},Il={_:void 0},Wg={_:null},WA={_:void 0},Qu={_:void 0},jg={_:null},MM={_:!1},sA={_:0},BH={_:void 0},EM={_:void 0},FH={_:void 0},DM={_:void 0},LH={_:void 0},zM={_:void 0},RH={_:void 0},OM={_:void 0},WH={_:void 0},PM={_:void 0},jH={_:void 0},BM={_:void 0},HH={_:void 0},FM={_:void 0},GH={_:void 0},LM={_:void 0},fd={_:void 0},RM={_:void 0},WM={_:void 0},VH={_:void 0},Hg={_:void 0},Gg={_:void 0},Vg={_:void 0},XH={_:void 0},jM={_:void 0},ZH={_:void 0},Xg={_:void 0};IM(hd,"capturedPic",null),function(){var n=Do(Ao(!0),2);BH._=n[0],EM._=n[1];var e=Do(Ao(!0),2);FH._=e[0],DM._=e[1];var t=Do(Ao(!0),2);LH._=t[0],zM._=t[1];var r=Do(Ao(!1),2);RH._=r[0],OM._=r[1];var s=Do(Ao(!1),2);WH._=s[0],PM._=s[1];var o=Do(Ao(!1),2);jH._=o[0],BM._=o[1];var A=Do(Ao(!1),2);HH._=A[0],FM._=A[1];var u=Do(Ao(!1),2);GH._=u[0],LM._=u[1];var h=Do(Ao(!0),2);fd._=h[0],RM._=h[1];var l=Do(Ao(!1),2);l[0],WM._=l[1];var c=Do(Ao(!1),2);VH._=c[0],Hg._=c[1];var d=Do(Ao(3),2);Gg._=d[0],Vg._=d[1];var m=Do(Ao(0),2);ZH._=m[0],Xg._=m[1];var y=Do(Ao(!1),2);XH._=y[0],jM._=y[1]}();var YH,zbe={_:function(){return function(){var n=Ebe(),e=n.firstChild,t=e.firstChild,r=t.nextSibling,s=r.nextSibling,o=s.nextSibling.nextSibling.nextSibling,A=o.firstChild,u=A.nextSibling,h=u.nextSibling,l=h.nextSibling,c=l.nextSibling,d=o.nextSibling,m=d.firstChild,y=m.nextSibling,b=y.nextSibling,v=d.nextSibling,w=v.firstChild,I=w.nextSibling,S=v.nextSibling.firstChild,T=S.nextSibling,D=Uu._;typeof D=="function"?kM(D,t):Uu._=t;var L=Il._;typeof L=="function"?kM(L,r):Il._=r;var W,K,U=Qu._;return typeof U=="function"?kM(U,s):Qu._=s,lo(A,function(){return bbe}),lo(u,function(){return vbe}),lo(h,function(){return xbe}),lo(l,function(){return wbe}),lo(c,function(){return Sbe}),lo(e,(W=fbe,K={get when(){return VH._.call(bt)},get children(){var _=Mbe();return lo(_,function(){return Gg._.call(bt)||""}),_}},mh(()=>W(K||{}))),d),lo(m,function(){return kbe}),lo(y,function(){return Cbe}),lo(b,function(){return Ibe}),lo(w,function(){return TH.GUIDELINE1}),lo(I,function(){return TH.GUIDELINE2}),SH(S,"click",Obe._),lo(S,function(){return Tbe}),SH(T,"click",Pbe._),lo(T,function(){return Nbe}),W1(function(_){var ee="".concat(XH._.call(bt)?"":"osc-veiled"," osc-smart-capture-container"),re="osc-smart-capture-sdk ".concat(ZH._.call(bt)===0?"osc-capture-mode":"osc-review-mode"),ce="osc-div ".concat(RH._.call(bt)?"osc-active":""),we="osc-div ".concat(WH._.call(bt)?"osc-active":""),Ee="osc-div ".concat(jH._.call(bt)?"osc-active":""),Pe="osc-div ".concat(HH._.call(bt)?"osc-active":""),he="osc-div ".concat(GH._.call(bt)?"osc-active":""),de="osc-label ".concat(BH._.call(bt)?"osc-invalid":""),Ae="osc-label ".concat(FH._.call(bt)?"osc-invalid":""),Se="osc-label ".concat(LH._.call(bt)?"osc-invalid":"");return ee!==_.e&&RA(n,_.e=ee),re!==_.t&&RA(e,_.t=re),ce!==_.a&&RA(A,_.a=ce),we!==_.o&&RA(u,_.o=we),Ee!==_.i&&RA(h,_.i=Ee),Pe!==_.n&&RA(l,_.n=Pe),he!==_.s&&RA(c,_.s=he),de!==_.h&&RA(m,_.h=de),Ae!==_.r&&RA(y,_.r=Ae),Se!==_.d&&RA(b,_.d=Se),_},{e:void 0,t:void 0,a:void 0,o:void 0,i:void 0,n:void 0,s:void 0,h:void 0,r:void 0,d:void 0}),n}()}},Obe={_:(YH=DH(Lg().mark(function n(){var e;return Lg().wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return MM._=!1,Xg._.call(bt,0),t.prev=2,t.next=5,navigator.mediaDevices.getUserMedia(PH._);case 5:e=t.sent,bh._=e,t.next=13;break;case 9:throw t.prev=9,t.t0=t.catch(2),md._.notification(io.CAMERA_NOT_FOUND),new Error(io.CAMERA_NOT_FOUND);case 13:QH._.call(bt);case 14:case"end":return t.stop()}},n,null,[[2,9]])})),function(){return YH.apply(this,arguments)})},Pbe={_:function(){Xg._.call(bt,2);var n=document.createElement("canvas");n.width=WA._.width,n.height=WA._.height,n.getContext("2d").drawImage(Il._,WA._.x,WA._.y,WA._.width,WA._.height,0,0,WA._.width,WA._.height),n.toBlob(function(e){bt.capturedPic=e,md._.autoCaptureCallback(e)})}},UH={_:0},Ku={_:new(JH=class{constructor(n=10,e=6){Ju(this,si);Ju(this,Yg);Ju(this,Ug);gd(this,si,{faceFound:new yh(n),outsideGuide:new yh(n),far:new yh(n),close:new yh(n),misAligned:new yh(n),noSufficientLite:new yh(n)}),gd(this,Yg,["faceFound","outsideGuide","far","close","misAligned","noSufficientLite"]),gd(this,Ug,e)}updateStatus(n){Js(this,si).faceFound.setStatus(!n.faceFound),Js(this,si).outsideGuide.setStatus(n.outsideGuide),Js(this,si).far.setStatus(n.far),Js(this,si).close.setStatus(n.close),Js(this,si).misAligned.setStatus(n.misAligned),Js(this,si).noSufficientLite.setStatus(n.noSufficientLite)}getStatusCount(n){if(Js(this,si)[n])return Js(this,si)[n].getCount();throw new Error(`Invalid status type: ${n}`)}getValidationError(){for(const n of Js(this,Yg))if(Js(this,si)[n].getCount()>=Js(this,Ug))return n;return null}},si=new WeakMap,Yg=new WeakMap,Ug=new WeakMap,JH)},QH={_:function(){Wg._&&Wg._.clearRect(0,0,Il._.width,Il._.height),jg._&&jg._.clearRect(0,0,Qu._.width,Qu._.height),Uu._.srcObject=bh._,Uu._.play();var n=function(){var e=Uu._,t=e.videoWidth,r=e.videoHeight,s=r/.7,o=t/.7;WA._=ybe.getMaxCenteredRectangle(t,r,o,s,.75),V1._=210,TM._=4*V1._/3,SM._=(300-V1._)/2,NM._=(400-TM._)/2,Wg._=Il._.getContext("2d",{alpha:!1,willReadFrequently:!0}),jg._=Qu._.getContext("2d",{alpha:!1,desynchronized:!0,willReadFrequently:!0}),Il._.width=t,Il._.height=r,Wg._.translate(t,0),Wg._.scale(-1,1),jg._.translate(t,0),jg._.scale(-1,1),Qu._.width=300,Qu._.height=400,Uu._.removeEventListener("loadeddata",n),vM().then(function(){var A,u,h,l,c,d;A=Uu._,u=Il._,h=Qu._,l=WA._,c=function(m){var y;UH._=Fs(bt,bt,(y=Fs(bt,bt,UH)._,++y));var b=m.faceFound&&!m.far&&!m.close&&!m.noSufficientLite&&!m.misAligned&&!m.outsideGuide;Fs(bt,bt,WM)._.call(bt,b),Fs(bt,bt,Ku)._.updateStatus(m),Fs(bt,bt,RM)._.call(bt,Fs(bt,bt,Ku)._.getValidationError()===null),MM._!==fd._.call(bt)&&(MM._=fd._.call(bt),fd._.call(bt)?setTimeout(function(){fd._.call(bt)&&(Vg._.call(bt,3),Hg._.call(bt,!0),sA._&&(clearInterval(sA._),sA._=0),sA._=setInterval(function(){fd._.call(bt)||(clearInterval(sA._),sA._=0),Gg._.call(bt)>1&&(Vg._.call(bt,Gg._.call(bt)-1),Gg._.call(bt)===1&&setTimeout(function(){fd._.call(bt)&&(async()=>{const K=Bg.getImageData(0,0,dd,cd);return await lH(K)})()&&(KH._.call(bt),Hg._.call(bt,!1),Xg._.call(bt,1)),clearInterval(sA._),sA._=0},250))},1e3))},500):(clearInterval(sA._),sA._=0,Vg._.call(bt,3),Hg._.call(bt,!1)));var v=Fs(bt,bt,Ku)._.getStatusCount("noSufficientLite")>=5,w=Fs(bt,bt,Ku)._.getStatusCount("outsideGuide")>=5||Fs(bt,bt,Ku)._.getStatusCount("far")>=5||Fs(bt,bt,Ku)._.getStatusCount("close")>=5,I=Fs(bt,bt,Ku)._.getStatusCount("misAligned")>=5,S=!1,T=!1,D=!1,L=!1,W=!1;switch(Fs(bt,bt,Ku)._.getValidationError()){case"noSufficientLite":D=!0,v=!0;break;case"outsideGuide":W=!0,w=!0;break;case"far":S=!0,w=!0;break;case"close":T=!0,w=!0;break;case"misAligned":L=!0,I=!0;break;case"faceFound":W=!0,v=!0,I=!0,w=!0}Fs(bt,bt,OM)._.call(bt,S),Fs(bt,bt,PM)._.call(bt,T),Fs(bt,bt,BM)._.call(bt,D),Fs(bt,bt,FM)._.call(bt,L),Fs(bt,bt,LM)._.call(bt,W),Fs(bt,bt,EM)._.call(bt,v),Fs(bt,bt,DM)._.call(bt,I),Fs(bt,bt,zM)._.call(bt,w)},d={tx:SM._,ty:NM._,bx:SM._+V1._,by:NM._+TM._},bM=u.getContext("2d"),B1=A,fh=l,gM=c,yM=d,dd=h.width,cd=h.height,Bg=h.getContext("2d"),F1=!1,requestAnimationFrame(uH),jM._.call(bt,!0)})};Uu._.addEventListener("loadeddata",n)}},md={_:{autoCaptureCallback:function(){},notification:function(){}}},KH={_:function(){cH(),bh._&&bh._.getTracks().forEach(function(n){return n.stop()}),bh._=null,clearInterval(sA._)}};IM(hd,"addEventListener",function(n,e){switch(n){case"autoCapture":md._.autoCaptureCallback=e;break;case"notification":md._.notification=e}});var Bbe={_:function(n){switch(n){case"autoCapture":md._.autoCaptureCallback=function(){};break;case"notification":md._.notification=function(){}}}};IM(hd,"stopSmartCaptureUI",function(){var n;KH._.call(bt),Rg._&&Rg._.call(bt),(n=document.getElementById("otfs-smart-capture-cntr"))===null||n===void 0||n.remove(),Rg._=void 0,OH.call(bt),Bbe._.call(bt)}),function(n,e=window.document){const t=e[CH]||(e[CH]=new Set);for(let r=0,s=n.length;r<s;r++){const o=n[r];t.has(o)||(t.add(o),e.addEventListener(o,gbe))}}(["click"]);var Fbe=p(357);let Zg=null;const Lbe=async n=>Zg||(Zg=new Promise(async(e,t)=>{if(!n)return t(io.CONTAINER_MISSING);try{hd.addEventListener("autoCapture",async r=>{try{X1(),e(r)}catch(s){X1(),t(s)}}),await Promise.all([vM(),hd.renderSmartCaptureUI(n)])}catch(r){Zg=null,console.error(r),X1(),t(r)}}),Zg),X1=()=>{Zg=null,hd.stopSmartCaptureUI(),cH(),mM!==null&&(ca._free(mM),mM=null),ph&&(ph.dispose(),ph=null),Xu&&(Xu.blazeFaceModel.dispose(),Xu.anchors.dispose(),Xu.inputSize.dispose(),Xu=null),ca&&(ca=null),hh&&(hh=null),Ne.disposeVariables(),Bg=void 0,gM=void 0,yM=void 0,cd=void 0,dd=void 0,B1=void 0,bM=void 0,fh=void 0,console.log("Smart Capture stopped "+BI().numTensors)},Rbe=()=>wt.VERSION,Wbe=async n=>{if(!n)return{image:null,validationResult:{faceFound:!1,noSufficientLite:!1,misAligned:!1,outsideGuide:!1,close:!1},isValid:!1};try{await vM();const e=new Image,t=URL.createObjectURL(n);await new Promise((d,m)=>{e.onload=()=>{e.width<500||e.height<500?m(new Error("Image dimensions must be at least 500x500 pixels")):d()},e.onerror=()=>m(new Error("Failed to load image")),e.src=t});const r=r4(e),s=await aH(r);if(!s)return{image:null,validationResult:{faceFound:!1,noSufficientLite:!1,misAligned:!1,outsideGuide:!1,close:!1},isValid:!1};if(!AH(s,e.naturalWidth,e.naturalHeight))return{image:null,validationResult:{faceFound:!1,noSufficientLite:!1,misAligned:!1,outsideGuide:!1,close:!1},isValid:!1};const o=oH(r,s),A=[];for(let d=0;d<o.length;d+=2)A.push([o[d],o[d+1]]);if(URL.revokeObjectURL(t),r.dispose(),function(d,m,y){const b=.9*m,v=.9*y;for(let w=0;w<d.length;w++){const I=d[w][0],S=d[w][1];if(I<=0||I>=b||S<=0||S>=v)return!0}return!1}(A,e.naturalWidth,e.naturalHeight))return{image:null,validationResult:{faceFound:!0,noSufficientLite:!1,misAligned:!1,close:!1,outsideGuide:!0},isValid:!1};const u=await(0,Fbe.resizeImage)(n,A,500,667);if(u.status!==0)return{image:u.image,validationResult:{faceFound:!0,noSufficientLite:!1,misAligned:!1,close:!1,outsideGuide:!0},isValid:!1};const h={tx:0,ty:0,bx:500,by:667},l=new Float32Array(u.landmarks.flat()),c=iH(u.imageData.data,l,500,667,h,!0);return{image:u.image,validationResult:{faceFound:c.faceFound,noSufficientLite:c.noSufficientLite,misAligned:c.misAligned,close:c.close,outsideGuide:c.close||c.outsideGuide},isValid:c.faceFound&&!c.noSufficientLite&&!c.misAligned&&!c.close&&!c.outsideGuide}}catch(e){return console.error("Error in cropFace:",e),{image:null,validationResult:{faceFound:!1,noSufficientLite:!1,misAligned:!1,outsideGuide:!1,close:!1},isValid:!1}}},jbe=n=>{wt.STATIC_ASSETS_BASE_URL=n.STATIC_ASSETS_BASE_URL,wt.ASSETS_BASE_URL=n.ASSETS_BASE_URL}})(),f})());const y7=window.OrboSmartCapture||window.OrboSkinAnalyzer.OrboSmartCapture;y7.withConfig({STATIC_ASSETS_BASE_URL:"https://makeup.sdk.orbo.ai/",ASSETS_BASE_URL:"https://idoxdey.sufydely.com/eQUtAajpcF/smart-capture/"});const O_=()=>{const{setView:a,setCapturedPic:i,setSnackbar:p,sessionId:f,setOutputScore:g,setRecommendations:x,setAnnotations:k,setInputImage:N,userInfo:E}=Jl(),z=se.useRef(!1);return se.useEffect(()=>{(async()=>{if(!z.current)try{z.current=!0;const j=await y7.captureSelfie(document.getElementById("otfs-smart-capture-container"));i(j);const M=new Ff(f);await M.updateSession("",parseInt(E.age),E.skin,E.gender,E.phone,E.email),await M.uploadImage(j);const R=await M.getSkinAnalysis();g(R.output_score),k(R.annotations),N(R.input_image);const B=await M.getProductRecommendations();g(R.output_score),x(B),a("Scores")}catch{p({snackbarOpen:!0,snackbarMessage:"Failed to capture the image. Please try again.",snackbarSeverity:"error"}),a("Questionnaire")}})()},[]),q.jsx(ft,{sx:{display:"flex",flexDirection:"column",gap:{xs:"20px",md:"28px"},alignItems:{xs:"center",md:"flex-start"},justifyContent:{xs:"center",md:"flex-start"},padding:"16px"},children:q.jsx(ft,{sx:Xr.inputContainer,children:q.jsx("div",{id:"otfs-smart-capture-container"})})})},gp=[{id:"dark_circle",heading:"Dark Circle",description:"Dark circles are the darkened areas under the eyes, often caused by thin skin, visible blood vessels, or excess melanin. They can result from factors like lack of sleep, stress, genetics, or allergies, giving the face a tired or fatigued appearance."},{id:"skin_dullness",heading:"Dullness",description:"Dullness refers to a lack of radiance and brightness in the skin, often resulting in a tired or lifeless appearance. It can occur due to factors such as dehydration, dead skin cell buildup, poor circulation, and environmental stressors."},{id:"dark_spots",heading:"Dark Spots",description:"Dark spots, or hyperpigmentation, form when the skin produces too much melaninthe pigment that gives skin its color. These spots can vary in size, shape, and shade, often appearing as noticeable patches across the skin."},{id:"acne",heading:"Acne",description:"A skin condition where red pimples or bumps appear when excess oil, dead skin cells, and bacteria block the pores, leading to inflammation or infection in the sebaceous glands."},{id:"uneven_skin",heading:"Uneven Skin",description:"Uneven skin tone refers to a lack of uniformity in color across your skin, which can be influenced by environmental factors like UV rays, pollution, and other external stressors. This condition may show up as dullness, dark spots, redness, and other inconsistencies in skin appearance."},{id:"face_wrinkles",heading:"Finelines & Wrinkles",description:"Fine lines are the early signs of wrinkles, appearing as small creases close to the skin's surface. Wrinkles, on the other hand, are deeper lines that form over time as skin loses firmness and elasticity. Both fine lines and wrinkles often develop in areas where your face moves the most, like around your eyes and mouth."},{id:"eye_wrinkles",heading:"Eye Wrinkles",description:"Frequent eye movement causes the muscles around the eyes to contract, which over time reduces the skin's flexibility, leading to the formation of wrinkles."},{id:"crows_feet",heading:"Crow's Feet",description:"Crow's feet are fine lines that develop around the outer corners of the eyes due to the contraction of the orbicularis oculi muscle. As this muscle tightens, it can create a crinkled appearance, leading to the formation of these wrinkles. Aging, sun exposure, and repeated facial movements can all contribute to the development of crow's feet."},{id:"redness",heading:"Redness",description:"Redness happens when tiny blood vessels under the skin widen and fill with more blood. This makes the skin look red and flushed."},{id:"pigmentation",heading:"Hyper pigmentation",description:"Hyperpigmentation forms when the skin produces too much melaninthe pigment that gives skin its color. These spots can vary in size, shape, and shade, often appearing as noticeable patches across the skin. It can be caused by factors like sun exposure, hormonal changes, or skin irritation."},{id:"firmness",heading:"Skin Firmness",description:"Firm skin appears smooth and resilient, while a loss of firmness can lead to sagging and the development of fine lines and wrinkles. Factors such as aging, sun damage, and lifestyle choices can impact skin firmness."},{id:"smoothness",heading:"Lack of Smoothness",description:"Smoothness refers to the evenness and texture of your skin's surface. Smooth skin feels soft and appears flawless, while rough, dents or uneven areas can indicate issues like dryness, blemishes, or aging."},{id:"hydration",heading:"Dehydration",description:"It refers to the balance of water in your skin, which is essential for maintaining its elasticity, suppleness, and overall health. Well-hydrated skin appears plump and radiant, while dehydrated skin can look dull, feel tight, and show signs of dryness."},{id:"texture",heading:"Lack of Texture",description:"This refers to skin that feels uneven or rough, with visible bumps, pores, or imperfections. This can be caused by factors like acne scars, dry patches, or an excess buildup of dead skin cells, making the skin appear less smooth and even."},{id:"oxygen",heading:"Oxygen",description:"We detects and measures the oxygen concentration levels from just the face of the user."},{id:"shine",heading:"Shine",description:"Excess sebum production causes shine and can clog pores"}],P_=nl(q.jsx("path",{d:"M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"}),"Close"),B_=[[3,"Need Attention"],[2,"Average"],[1,"Good"]],F_=()=>{const{outputScore:a,recommendations:i,setView:p,setSnackbar:f}=Jl(),[g,x]=se.useState([]),[k,N]=se.useState(0),[E,z]=se.useState(""),[G,j]=se.useState(""),[M,R]=se.useState(!1),B=sp(),P=Qq(B.breakpoints.down("sm")),[H,C]=se.useState([]),[O,F]=se.useState([]),[Y,ae]=se.useState({}),te=async ue=>{try{console.log(ue);const Z={items:[{id:ue,quantity:1}]};try{(await fetch("/cart/add.js",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(Z)})).ok?(ae(pe=>({...pe,[ue]:!0})),document.documentElement.dispatchEvent(new CustomEvent("cart:refresh",{bubbles:!0,detail:{}}))):(console.error("Error: Failed to add product to cart"),f({snackbarOpen:!0,snackbarMessage:"Unable to add product to cart! Do it from product page.",snackbarSeverity:"error"}))}catch(ye){console.error("Error occurred while adding product to cart:",ye),f({snackbarOpen:!0,snackbarMessage:"Unable to add product to cart! Do it from product page.",snackbarSeverity:"error"})}}catch(Z){console.error("Error occurred while adding product to cart:",Z),f({snackbarOpen:!0,snackbarMessage:"Unable to add product to cart! Do it from product page.",snackbarSeverity:"error"})}};se.useEffect(()=>{if(a.length>0){const ue=Math.min(...a.map(ye=>ye.score)),Z=a.find(ye=>ye.score===ue);if(Z){const ye=i.find(pe=>pe.name===Z.concern);ye&&F(ye.products)}}},[a]);const oe=ue=>{switch(ue){case 1:return{borderRadius:{md:"20px",xs:"6px"},border:"2px solid #51A351",backgroundColor:"#77DD77"};case 2:return{borderRadius:{md:"20px",xs:"6px"},border:"2px solid #C6872F",backgroundColor:"#FFB347"};case 3:return{borderRadius:{md:"20px",xs:"6px"},border:"2px solid #C53E37",backgroundColor:"#FF6961"};default:return{}}};se.useEffect(()=>{var ie;const ue=[3,2,1];N(((ie=a.find(Ie=>Ie.concern==="skin_health"))==null?void 0:ie.score)||0);const Z=a.filter(Ie=>Ie.concern!=="skin_health").sort((Ie,je)=>{if(Ie.riskLevel!==je.riskLevel){const xe=ue.indexOf(Ie.riskLevel),We=ue.indexOf(je.riskLevel);return xe-We}return Ie.score-je.score});x(Z);const ye=Z.map(Ie=>Ie.riskLevel),pe=ue.filter(Ie=>!ye.includes(Ie));console.log(pe),C(pe);const Q=Z[0].concern,ke=gp.find(Ie=>Ie.id===Q);z((ke==null?void 0:ke.heading)||""),j((ke==null?void 0:ke.description)||"")},[]);const fe=ue=>{const Z=gp.find(ye=>ye.id===ue);z((Z==null?void 0:Z.heading)||""),j((Z==null?void 0:Z.description)||""),P&&R(!0)};return q.jsxs(ft,{sx:{display:"flex",flexDirection:"column",gap:{xs:"20px",md:"50px"},alignItems:{xs:"center",md:"flex-start"},justifyContent:{xs:"space-around",md:"flex-start"},padding:"16px"},children:[q.jsxs(pq,{open:M,"aria-labelledby":"alert-dialog-title","aria-describedby":"alert-dialog-description",children:[q.jsx(wq,{sx:{m:0,p:2},id:"customized-dialog-title",children:E}),q.jsx(ZP,{"aria-label":"close",sx:ue=>({position:"absolute",right:8,top:8,color:ue.palette.grey[500]}),onClick:()=>R(!1),children:q.jsx(P_,{})}),q.jsx(bq,{dividers:!0,children:G})]}),q.jsx(ft,{sx:Xr.inputContainer,children:q.jsxs(ft,{sx:{display:"flex",flexDirection:"row",alignItems:"flex-start",justifyContent:"space-between",width:"100%"},children:[q.jsxs(ft,{sx:{width:"42%",display:{md:"flex",xs:"none"},flexDirection:"column",justifyContent:"flex-start",alignItems:"left",gap:"10px"},children:[q.jsxs(mn,{sx:{...Xr.subHeading,width:"100%",paddingBottom:"30px",fontWeight:600},children:["Your Skin Health Score - ",k,"%"]}),q.jsx(mn,{sx:{...Xr.subHeading,width:"100%",paddingBottom:"0",borderBottom:"2px dashed #D3D3D3"},children:E}),q.jsx(ft,{sx:{borderTop:"2px dotted #fff",width:"100%"}}),q.jsx(mn,{sx:{color:"rgba(0, 0, 0, 0.90)",fontSize:"22px",fontStyle:"normal",fontWeight:400,lineHeight:"28px",leadingTrim:"both",textEdge:"cap"},children:G}),q.jsxs(ft,{sx:{display:"flex",justifyContent:"flex-start",alignItems:"center",gap:"50px",paddingTop:"50px"},children:[q.jsxs(ft,{sx:{...Xr.rangeBox,border:"2px solid #C53E37",background:"#FF6961"},children:[q.jsx(mn,{sx:{color:"#fff",textAlign:"center",fontSize:"16px",fontStyle:"normal",fontWeight:400,lineHeight:"18px"},children:"Needs attention"}),q.jsx(mn,{sx:{color:"#fff",fontSize:"24px",fontStyle:"normal",fontWeight:500,lineHeight:"42px",leadingTrim:"both",textEdge:"cap"},children:"0-40"})]}),q.jsxs(ft,{sx:{...Xr.rangeBox,border:"2px solid #C6872F",background:"#FFB347"},children:[q.jsx(mn,{sx:{color:"#fff",textAlign:"center",fontSize:"16px",fontStyle:"normal",fontWeight:400,lineHeight:"18px"},children:"Average"}),q.jsx(mn,{sx:{color:"#fff",fontSize:"24px",fontStyle:"normal",fontWeight:500,lineHeight:"42px",leadingTrim:"both",textEdge:"cap"},children:"41-80"})]}),q.jsxs(ft,{sx:{...Xr.rangeBox,border:"2px solid #51A351",background:"#77DD77"},children:[q.jsx(mn,{sx:{color:"#fff",textAlign:"center",fontSize:"16px",fontStyle:"normal",fontWeight:400,lineHeight:"18px"},children:"Good"}),q.jsx(mn,{sx:{color:"#fff",fontSize:"24px",fontStyle:"normal",fontWeight:500,lineHeight:"42px",leadingTrim:"both",textEdge:"cap"},children:"81-100"})]})]})]}),q.jsx(ft,{sx:{width:{xs:"100%",md:"53%"}},children:q.jsxs(ft,{sx:{width:{xs:"100vw",md:"100%"},overflowX:"auto",overflowY:"hidden"},children:[q.jsxs(mn,{sx:{display:{md:"none"},...Xr.subHeading,width:"100%",paddingBottom:"30px",fontWeight:700},children:["Your Skin Health Score - ",k,"%"]}),q.jsxs(ft,{sx:{display:{xs:"flex",md:"none"},justifyContent:"center",alignItems:"center",gap:{xs:"30px",md:"50px"},paddingBottom:"50px"},children:[q.jsxs(ft,{sx:{...Xr.rangeBox,border:"2px solid #C53E37",background:"#FF6961"},children:[q.jsx(mn,{sx:{color:"#fff",textAlign:"center",fontSize:"12px",fontStyle:"normal",fontWeight:400,lineHeight:"18px"},children:"Need attention"}),q.jsx(mn,{sx:{color:"#fff",fontSize:"16px",fontStyle:"normal",fontWeight:500,lineHeight:"20px",leadingTrim:"both",textEdge:"cap"},children:"0-40"})]}),q.jsxs(ft,{sx:{...Xr.rangeBox,border:"2px solid #C6872F",background:"#FFB347"},children:[q.jsx(mn,{sx:{color:"#fff",textAlign:"center",fontSize:"12px",fontStyle:"normal",fontWeight:400,lineHeight:"18px"},children:"Average"}),q.jsx(mn,{sx:{color:"#fff",fontSize:"16px",fontStyle:"normal",fontWeight:500,lineHeight:"20px",leadingTrim:"both",textEdge:"cap"},children:"41-80"})]}),q.jsxs(ft,{sx:{...Xr.rangeBox,border:"2px solid #51A351",background:"#77DD77"},children:[q.jsx(mn,{sx:{color:"#fff",textAlign:"center",fontSize:"12px",fontStyle:"normal",fontWeight:400,lineHeight:"18px"},children:"Good"}),q.jsx(mn,{sx:{color:"#fff",fontSize:"16px",fontStyle:"normal",fontWeight:500,lineHeight:"20px",leadingTrim:"both",textEdge:"cap"},children:"81-100"})]})]}),P?B_.filter(ue=>!H.includes(ue[0])).map((ue,Z)=>q.jsxs(ft,{children:[q.jsxs(ft,{sx:{display:"flex",justifyContent:"center",alignItems:"center",padding:"16px"},children:[q.jsx(ft,{sx:{borderTop:"2px dotted #616161",width:"100%"}}),q.jsx(mn,{sx:{color:"#616161",textAlign:"center",fontSize:"16px",fontStyle:"normal",fontWeight:700,lineHeight:"normal",letterSpacing:"0.32px",paddingX:"8px",whiteSpace:"nowrap"},children:ue[1]}),q.jsx(ft,{sx:{borderTop:"2px dotted #616161",width:"100%"}})]}),q.jsx(ft,{sx:{display:{xs:"grid",md:"grid"},flexDirection:"row",overflowX:"auto",overflowY:"hidden",gridTemplateColumns:{xs:"repeat(3, 1fr)",md:"repeat(2, 1fr)",lg:"repeat(3, 1fr)",xl:"repeat(4, 1fr)"},justifyItems:"center",gap:{xs:"20px",md:"35px"},paddingBottom:"40px","&::-webkit-scrollbar":{display:"none"}},children:g&&g.filter(ye=>ye.riskLevel===ue[0]).map((ye,pe)=>{var Q;return q.jsxs(ft,{sx:{boxSizing:"content-box",width:{xs:"75px",md:"125px"},height:{xs:"63px",md:"105px"},...oe(ye.riskLevel),display:"flex",flexDirection:"column",justifyContent:"space-between",alignItems:"center",padding:{md:"10px",xs:"3px"}},onClick:()=>{fe(ye.concern)},children:[q.jsx(mn,{sx:{color:"#fff",textAlign:"center",fontSize:{xs:"9px",md:"16px"},fontStyle:"normal",fontWeight:400,lineHeight:{md:"20px",xs:"12px"}},children:(Q=gp.find(ke=>ke.id===ye.concern))==null?void 0:Q.heading}),q.jsxs(mn,{sx:{color:"#fff",fontSize:{xs:"18px",md:"28px"},fontStyle:"normal",fontWeight:500,textEdge:"cap",leadingTrim:"both"},children:[ye.score,"%"]}),q.jsx(mn,{sx:{color:"#fff",fontSize:{xs:"7px",md:"10px"},fontStyle:"normal",fontWeight:400,textDecorationStyle:"solid",textDecorationSkipInk:"none",textDecorationThickness:"auto",textUnderlineOffset:"auto",textUnderlinePosition:"from-font",padding:0,cursor:"pointer"},children:ye.riskLevel===3?"needs attention":ye.riskLevel===2?"average":"good"})]},pe)})},Z)]})):q.jsx(ft,{sx:{display:{xs:"grid",md:"grid"},flexDirection:"row",overflowX:"auto",overflowY:"hidden",gridTemplateColumns:{xs:"repeat(3, 1fr)",md:"repeat(2, 1fr)",lg:"repeat(3, 1fr)",xl:"repeat(4, 1fr)"},justifyItems:"center",gap:"34px",paddingX:{xs:"10px",md:"20px"},"&::-webkit-scrollbar":{display:"none"}},children:g&&g.map((ue,Z)=>{var ye;return q.jsxs(ft,{onClick:()=>{fe(ue.concern)},sx:{boxSizing:"content-box",width:{xs:"80px",md:"155px"},height:{xs:"70px",md:"95px"},...oe(ue.riskLevel),display:"flex",flexDirection:"column",justifyContent:"space-between",alignItems:"center",padding:{md:"10px",xs:"3px"},cursor:"pointer"},children:[q.jsx(mn,{sx:{color:"#fff",textAlign:"center",fontSize:{xs:"12px",md:"16px"},fontStyle:"normal",fontWeight:400,lineHeight:{md:"20px",xs:"12px"},textTransform:"lowercase"},children:(ye=gp.find(pe=>pe.id===ue.concern))==null?void 0:ye.heading}),q.jsxs(mn,{sx:{color:"#fff",fontSize:{xs:"18px",md:"40px"},lineHeight:"38px",fontStyle:"normal",fontWeight:400,textEdge:"cap",leadingTrim:"both"},children:[ue.score,"%"]}),q.jsx(mn,{sx:{color:"#fff",fontSize:{xs:"10px",md:"12px"},fontStyle:"normal",fontWeight:400,textDecorationStyle:"solid",textDecorationSkipInk:"none",textDecorationThickness:"auto",textUnderlineOffset:"auto",textUnderlinePosition:"from-font",padding:0},children:ue.riskLevel===3?"needs attention":ue.riskLevel===2?"average":"good"})]},Z)})})]})})]})}),q.jsxs(ft,{sx:Xr.inputContainer,children:[q.jsx(mn,{sx:{...Xr.subHeading,textAlign:"left",width:"100%",paddingX:{xs:"20px",md:"0"}},children:"Recommended products for your skin concern"}),q.jsx(ft,{sx:{width:{xs:"100vw",md:"100%"},overflowX:"auto",overflowY:"hidden"},children:q.jsx(ft,{sx:{display:{xs:"grid",md:"flex"},gridTemplateColumns:"repeat(2, 1fr)",flexDirection:"row",justifyContent:"space-evenly",alignItems:"center",overflowX:"auto",overflowY:"hidden",flexWrap:"wrap",gap:{xs:"18px",md:"35px"},paddingX:{xs:"20px",md:"0"},"&::-webkit-scrollbar":{display:"none"}},children:O.length>0&&O.map((ue,Z)=>q.jsx(ft,{sx:{margin:{xs:"auto",md:0}},children:q.jsxs(ft,{sx:Xr.productContainer,children:[q.jsx(ft,{id:"Sample Image",sx:{backgroundImage:`url('${ue.image_url}')`,width:{xs:"100px",md:"100%"},height:{xs:"100px",md:"320px"},flexShrink:0,backgroundSize:"contain",backgroundPosition:"center",backgroundRepeat:"no-repeat",borderBottom:"0.75px solid #D3D3D3"}}),q.jsx(ft,{sx:{borderBottom:"0.75px solid #D3D3D3",display:"flex",flexDirection:"column",justifyContent:"center",alignItems:"center",width:"100%"},children:q.jsx(mn,{sx:{color:"#464646",textAlign:"center",fontSize:{xs:"12px",md:"26px"},fontStyle:"normal",fontWeight:500,lineHeight:"normal",WebkitLineClamp:3,WebkitBoxOrient:"vertical",overflow:"hidden",display:"-webkit-box"},children:ue.name})}),q.jsx(ft,{sx:{width:"100%"},children:q.jsxs(mn,{sx:{color:"#464646",fontSize:{xs:"12px",md:"22px"},fontStyle:"normal",fontWeight:700,lineHeight:"normal",width:"100%"},children:["",ue.price]})}),q.jsx(vc,{id:"add-to-cart",disabled:Y[ue.variant_id],onClick:()=>{te(ue.variant_id)},children:"ADD TO CART"})]})},Z))})})]}),q.jsx(ft,{sx:{display:"flex",width:"100%",flexDirection:{xs:"column",md:"row"},gap:{xs:"10px",md:"50px"},alignItems:"center",justifyContent:"center"},children:q.jsx(vc,{variant:"contained",onClick:()=>{p("Details")},children:"NEXT"})})]})},L_=()=>{const{view:a,setView:i,sessionId:p,userInfo:f,setUserInfo:g,setSnackbar:x,capturedPic:k}=Jl(),[N,E]=se.useState(""),[z,G]=se.useState(""),[j,M]=se.useState(""),[R,B]=se.useState("+91"),[P,H]=se.useState(""),[C,O]=se.useState(""),[F,Y]=se.useState(""),[ae,te]=se.useState(!1);se.useState(Array(4).fill(""));const[oe,fe]=se.useState(90),ue=()=>{const ie=/^[A-Za-z\s]+$/;return N.trim()?N.trim().length<2?(O("Name must be at least 2 characters"),!0):ie.test(N.trim())?(O(""),!1):(O("Name must contain only alphabets"),!0):(O("Name is required"),!0)},Z=ie=>{B(ie.target.value)},ye=()=>{const ie=/^[0-9]{10}$/;return z?ie.test(z)?(H(""),!1):(H("Phone number must be 10 digits."),!0):(H("Phone number is required."),!0)},pe=()=>{const ie=/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;return j?ie.test(j)?(Y(""),!1):(Y("Please enter a valid email address."),!0):(Y("Email is required."),!0)},Q=async()=>{if(!p||!k){x({snackbarOpen:!0,snackbarMessage:"Oops! Something went wrong. Please try again later.",snackbarSeverity:"error"});return}try{te(!0),await new Ff(p).updateSession(N,parseInt(f.age),f.skin,f.gender,z,j),i("Feedback"),te(!1)}catch(ie){te(!1),console.error("Error occurred while sending details:",ie),x({snackbarOpen:!0,snackbarMessage:ie.message,snackbarSeverity:"error"})}},ke=async()=>{const ie=ue(),Ie=ye(),je=pe();if(fe(90),!ie&&!Ie&&!je&&N&&z&&j){g({name:N,email:j,age:f.age,skin:f.skin,gender:f.gender,phone:z});try{Q()}catch(xe){console.error("Failed to send OTP:",xe.message)}}};return q.jsxs(ft,{sx:{display:"grid",gridTemplateColumns:{xs:"1fr",md:"1fr 1fr"},gap:"100px",width:"100%",height:"100%"},children:[a==="Details"&&q.jsxs(ft,{sx:{display:"flex",flexDirection:"column",gap:{xs:"30px",md:"30px"},alignItems:{xs:"center",md:"center"},justifyContent:{xs:"space-evenly",md:"center"},height:"90vh",padding:"16px",maxWidth:{xs:"100%",md:"525px"},margin:"auto"},children:[q.jsxs(ft,{sx:{display:"flex",alignItems:"center",justifyContent:"space-between"},children:[q.jsx(ft,{sx:{display:"flex",width:{xs:"280px",md:"380px"},height:{xs:"100px",md:"150px"},padding:"4.08px 0px 4.413px 0px",justifyContent:"center",alignItems:"center",flexShrink:0,backgroundImage:`url(${EB})`,backgroundSize:"contain",backgroundPosition:"center",backgroundRepeat:"no-repeat"}}),q.jsx(ft,{})]}),q.jsx(ft,{sx:{color:"#000",textAlign:"center",fontSize:{xs:"18px",md:"24px"},fontStyle:"normal",fontWeight:500,lineHeight:"normal",leadingTrim:"both",textEdge:"cap",paddingX:{xs:"40px",md:0}},children:"Enter your details to receive your detailed skin analysis report"}),q.jsxs(ft,{sx:{display:"flex",flexDirection:"column",gap:{xs:"30px",md:"30px"},alignItems:{xs:"center",md:"center"},justifyContent:{xs:"center",md:"flex-start"},width:"100%"},children:[q.jsxs(ft,{sx:{position:"relative",width:{xs:"100%",md:"fit-content"}},children:[q.jsx(fC,{variant:"outlined",placeholder:"Enter your name *",value:N,onChange:ie=>E(ie.target.value),onBlur:ue,type:"text",sx:{width:{xs:"100%",md:"522.05px"},height:"59.421px",flexShrink:0,borderRadius:"5px",background:"#DAF4F9",border:C?"1px solid #d32f2f":"none","& .MuiInputBase-root":{height:"100%",display:"flex",justifyContent:"center",alignItems:"center"},"& .MuiInputBase-input":{textTransform:"none",textAlign:"left",fontSize:{xs:"16px",md:"18px"},fontWeight:400,lineHeight:"32px",color:"#000"},"& .MuiInputBase-input::placeholder":{color:"#000",fontSize:{xs:"16px",md:"18px"},fontWeight:400,lineHeight:"32px",textAlign:"center"},"& .MuiInput-underline:before":{display:"none"},"& .MuiInput-underline:after":{display:"none"},"& .MuiOutlinedInput-notchedOutline":{border:"none"},"& .MuiInputBase-input:-webkit-autofill,& .MuiInputBase-input:-webkit-autofill:hover, & .MuiInputBase-input:-webkit-autofill:focus, & .MuiInputBase-input:-webkit-autofill:active":{WebkitBackgroundClip:"text",WebkitTextFillColor:"initial",transition:"background-color 5000s ease-in-out 0s",boxShadow:"none"}}}),C&&q.jsx(ft,{sx:{position:"absolute",top:"-20px",left:0,color:"#d32f2f",fontSize:"12px",fontWeight:400},children:C})]}),q.jsxs(ft,{sx:{position:"relative",width:{xs:"100%",md:"fit-content"}},children:[q.jsx(fC,{variant:"outlined",placeholder:"Enter your email id *",value:j,onChange:ie=>M(ie.target.value),onBlur:pe,type:"email",sx:{width:{xs:"100%",md:"522.05px"},height:"59.421px",flexShrink:0,borderRadius:"5px",background:"#DAF4F9",border:F?"1px solid #d32f2f":"none","& .MuiInputBase-root":{height:"100%",display:"flex",justifyContent:"center",alignItems:"center"},"& .MuiInputBase-input":{textTransform:"none",textAlign:"left",fontSize:{xs:"16px",md:"18px"},fontWeight:400,lineHeight:"32px",color:"#000"},"& .MuiInputBase-input::placeholder":{color:"#111",fontSize:{xs:"16px",md:"18px"},fontWeight:400,lineHeight:"32px",textAlign:"center"},"& .MuiInput-underline:before":{display:"none"},"& .MuiInput-underline:after":{display:"none"},"& .MuiOutlinedInput-notchedOutline":{border:"none"},"& .MuiInputBase-input:-webkit-autofill,& .MuiInputBase-input:-webkit-autofill:hover, & .MuiInputBase-input:-webkit-autofill:focus, & .MuiInputBase-input:-webkit-autofill:active":{WebkitBackgroundClip:"text",WebkitTextFillColor:"initial",transition:"background-color 5000s ease-in-out 0s",boxShadow:"none"}}}),F&&q.jsx(ft,{sx:{position:"absolute",top:"-20px",left:0,color:"#d32f2f",fontSize:"12px",fontWeight:400},children:F})]}),q.jsxs(ft,{sx:{position:"relative",width:{xs:"100%",md:"fit-content"}},children:[q.jsxs(ft,{sx:{display:"flex",justifyContent:"center",alignItems:"center",width:{xs:"100%",md:"522.191px"},height:"59.421px",borderRadius:"5px",border:P?"1px solid #d32f2f":"none",borderRight:"none",backgroundColor:"#DAF4F9"},children:[q.jsx(hC,{value:R,onChange:Z,sx:{flexShrink:0,border:"none",backgroundColor:"#DAF4F9",color:"#000",fontSize:{xs:"16px",md:"18px"},fontWeight:700,lineHeight:"26px",textAlign:"center",outline:"none",borderTopLeftRadius:"5px",borderBottomLeftRadius:"5px",".MuiOutlinedInput-notchedOutline":{border:"none"},"& .MuiSvgIcon-root":{color:"#000"}},displayEmpty:!0,children:q.jsx(kJ,{value:"+91",children:"+91"})}),q.jsx(fC,{variant:"outlined",placeholder:"Enter your mobile number *",value:z,onChange:ie=>ie.target.value.length<=10&&G(ie.target.value),onBlur:ye,type:"number",sx:{flexGrow:1,height:"59.421px",borderRadius:"5px",background:"#DAF4F9",border:P?"1px solid #d32f2f":"none",borderLeft:"none","& .MuiInputBase-root":{height:"100%",display:"flex",justifyContent:"center",alignItems:"center"},"& .MuiInputBase-input":{textTransform:"none",textAlign:"left",fontSize:{xs:"16px",md:"18px"},fontWeight:400,lineHeight:"32px",color:"#000"},"& .MuiInputBase-input::placeholder":{color:"#000",fontSize:{xs:"16px",md:"18px"},fontWeight:400,lineHeight:"32px",textAlign:"left",paddingLeft:{xs:"0",md:"12%"}},"& .MuiInput-underline:before":{display:"none"},"& .MuiInput-underline:after":{display:"none"},"& .MuiOutlinedInput-notchedOutline":{border:"none"},"& .MuiInputBase-input:-webkit-autofill,& .MuiInputBase-input:-webkit-autofill:hover, & .MuiInputBase-input:-webkit-autofill:focus, & .MuiInputBase-input:-webkit-autofill:active":{WebkitBackgroundClip:"text",WebkitTextFillColor:"#000",transition:"background-color 5000s ease-in-out 0s",boxShadow:"none"}}})]}),P&&q.jsx(ft,{sx:{position:"absolute",top:"-20px",left:0,color:"#d32f2f",fontSize:"12px",fontWeight:400},children:P})]})]}),q.jsx(ft,{sx:{display:"flex",justifyContent:"center",alignItems:"center",width:"100%"},children:q.jsx(vc,{variant:"contained",onClick:()=>{ke()},children:"Next"})})]}),!1,q.jsx(ft,{sx:{backgroundImage:`url(${DB})`,backgroundSize:"contain",backgroundPosition:"center",backgroundRepeat:"no-repeat",width:"100%",height:"100%",display:{xs:"none",md:"block"}}})]})},R_=()=>{const{outputScore:a,setView:i,annotations:p,inputImage:f}=Jl(),[g,x]=se.useState(0),[k,N]=se.useState(""),[E,z]=se.useState(""),[G,j]=se.useState([]),[M,R]=se.useState("ANNOTATED"),[B,P]=se.useState(""),[H,C]=se.useState("");se.useEffect(()=>{const F=gp.find(Y=>Y.id===k);P((F==null?void 0:F.heading)||""),C((F==null?void 0:F.description)||"")},[k]),se.useEffect(()=>{var F;if(a){x(((F=a.find(ae=>ae.concern==="skin_health"))==null?void 0:F.score)||0);const Y=a.filter(ae=>ae.concern!=="skin_health").sort((ae,te)=>ae.score-te.score);j(Y),O(Y[0].concern)}},[a]);const O=F=>{N(F),z(p[F]||"")};return q.jsxs(ft,{children:[G&&G.length&&q.jsxs(ft,{sx:{maxHeight:"100%",height:"100%",overflow:"hidden",display:"flex",flexDirection:"column",justifyContent:{xs:"center",sm:"space-between"},alignItems:"center"},children:[q.jsxs(mn,{sx:{mb:{xs:1,sm:3},fontWeight:"600",fontSize:"1.25rem",width:"100%",textAlign:"center"},children:["Your Overall Skin Score is ",g,"%"]}),q.jsxs(ft,{className:"skin-scores-container",sx:{flexShrink:1,overflow:"hidden"},children:[q.jsxs(ft,{sx:{width:"100%",overflow:"hidden",gridRow:{xs:2,sm:1}},children:[q.jsx(ft,{className:"skin-scores",children:G&&G.map((F,Y)=>{var ae;return q.jsx(ft,{className:"score-selector",children:q.jsxs(ft,{sx:{display:"flex",justifyContent:"space-between",alignItems:"center",flexDirection:"column"},className:`r${F.riskLevel} score ${F.concern===k?"selected":""}`,onClick:()=>{O(F.concern)},children:[q.jsx(mn,{className:"concern-name",children:(ae=gp.find(te=>te.id===F.concern))==null?void 0:ae.heading}),q.jsxs(mn,{className:"score center",children:[F.score,"%"]}),q.jsx(mn,{sx:{color:"#fff",fontSize:{xs:"10px",md:"12px"},fontStyle:"normal",fontWeight:400,textDecorationStyle:"solid",textDecorationSkipInk:"none",textDecorationThickness:"auto",textUnderlineOffset:"auto",textUnderlinePosition:"from-font",padding:0},children:F.riskLevel===3?"needs attention":F.riskLevel===2?"average":"good"})]})},Y)})}),q.jsx(mn,{sx:{mt:{xs:1,sm:2}},className:"disclaimer",children:"*Skin score may vary depending upon the makeup applied"})]}),q.jsxs(ft,{className:"concern-image",sx:{display:"flex",flexDirection:"column",justifyContent:"flex-start",alignItems:"center",overflow:"hidden",position:"relative"},children:[q.jsx("img",{src:M==="ANNOTATED"?E:f,crossOrigin:"anonymous",style:{maxWidth:"100%",maxHeight:"100%"}}),q.jsxs(ft,{sx:{position:"absolute",bottom:0,left:0,width:"100%",display:"flex",justifyContent:"center",alignItems:"center",backgroundColor:"rgba(255, 255, 255, 0.5)",padding:"10px"},children:[q.jsxs(ft,{sx:{flexGrow:1},children:[q.jsxs(mn,{sx:{display:"inline",fontWeight:"700",fontSize:"18px"},children:[B," -"," "]}),q.jsx(mn,{sx:{display:"inline"},children:H})]}),q.jsx(ft,{className:"center",sx:{flexGrow:0,flexShrink:0,height:"55px",width:"55px",backgroundColor:"#fff",borderRadius:"50%",ml:"1rem",transform:M==="INPUT"?"scaleX(-1)":"scaleX(1)"},onMouseDown:()=>{R(M==="ANNOTATED"?"INPUT":"ANNOTATED")},onMouseUp:()=>{R(M==="ANNOTATED"?"INPUT":"ANNOTATED")},children:q.jsx("svg",{width:"35",height:"35",viewBox:"0 0 35 35",fill:"none",xmlns:"http://www.w3.org/2000/svg",children:q.jsx("path",{d:"M17.9447 34.078H16.3695V1H17.9447V34.078ZM33.6786 5.34253H20.8628V7.08997H32.1041V29.391H20.6366V31.1384H33.6786V5.34253ZM14.2036 30.2643C14.2036 29.7795 13.851 29.391 13.4163 29.391H12.7541C12.3188 29.391 11.9669 29.7795 11.9669 30.2643C11.9669 30.7462 12.3188 31.1377 12.7541 31.1377H13.4163C13.851 31.1384 14.2036 30.7469 14.2036 30.2643ZM10.7244 30.2643C10.7244 29.7795 10.3725 29.391 9.93785 29.391H8.86546C8.43015 29.391 8.07754 29.7795 8.07754 30.2643C8.07754 30.7462 8.43015 31.1377 8.86546 31.1377H9.93785C10.3725 31.1384 10.7244 30.7469 10.7244 30.2643ZM6.97274 30.2643C6.97274 29.7795 6.62012 29.391 6.18481 29.391H5.11242C4.67778 29.391 4.32517 29.7795 4.32517 30.2643C4.32517 30.7462 4.67778 31.1377 5.11242 31.1377H6.18481C6.61946 31.1384 6.97274 30.7469 6.97274 30.2643ZM2.83799 30.2643C2.83799 29.8265 2.54756 29.4622 2.16716 29.3991C2.11093 28.9775 1.78346 28.6543 1.38784 28.6543C0.953861 28.6543 0.600586 29.0458 0.600586 29.5276V30.2636C0.600586 30.7455 0.953861 31.137 1.38784 31.137H2.0494C2.48537 31.1384 2.83799 30.7469 2.83799 30.2643ZM2.17576 26.1084V24.8075C2.17576 24.3227 1.82381 23.9327 1.3885 23.9327C0.954517 23.9327 0.601242 24.3227 0.601242 24.8075V26.1084C0.601242 26.5917 0.954517 26.9817 1.3885 26.9817C1.82315 26.9825 2.17576 26.5917 2.17576 26.1084ZM2.17576 21.5492V20.2483C2.17576 19.7665 1.82381 19.3735 1.3885 19.3735C0.954517 19.3735 0.601242 19.7665 0.601242 20.2483V21.5492C0.601242 22.0325 0.954517 22.4255 1.3885 22.4255C1.82315 22.4262 2.17576 22.0325 2.17576 21.5492ZM2.17576 16.9929V15.6906C2.17576 15.2072 1.82381 14.8157 1.3885 14.8157C0.954517 14.8157 0.601242 15.2072 0.601242 15.6906V16.9929C0.601242 17.4762 0.954517 17.8662 1.3885 17.8662C1.82315 17.867 2.17576 17.4762 2.17576 16.9929ZM2.17576 12.4337V11.1328C2.17576 10.651 1.82381 10.258 1.3885 10.258C0.954517 10.258 0.601242 10.651 0.601242 11.1328V12.4337C0.601242 12.917 0.954517 13.3085 1.3885 13.3085C1.82315 13.3085 2.17576 12.917 2.17576 12.4337ZM2.16716 7.08116C2.54689 7.01799 2.83799 6.65366 2.83799 6.21588C2.83799 5.73256 2.48603 5.34253 2.05006 5.34253H1.3885C0.954517 5.34253 0.601242 5.73256 0.601242 6.21588V6.95188C0.601242 7.43373 0.954517 7.8245 1.3885 7.8245C1.78345 7.8245 2.11093 7.50131 2.16716 7.08116ZM10.6411 6.21588C10.6411 5.73256 10.2891 5.34253 9.85448 5.34253H8.75895C8.3243 5.34253 7.97169 5.73256 7.97169 6.21588C7.97169 6.69773 8.3243 7.08924 8.75895 7.08924H9.85448C10.2885 7.08998 10.6411 6.69773 10.6411 6.21588ZM6.80933 6.21588C6.80933 5.73256 6.45671 5.34253 6.02207 5.34253H4.92785C4.49255 5.34253 4.13993 5.73256 4.13993 6.21588C4.13993 6.69773 4.49255 7.08924 4.92785 7.08924H6.02207C6.45605 7.08998 6.80933 6.69773 6.80933 6.21588ZM14.4292 6.21588C14.4292 5.73256 14.0772 5.34253 13.6426 5.34253H12.9797C12.545 5.34253 12.1931 5.73256 12.1931 6.21588C12.1931 6.69773 12.545 7.08924 12.9797 7.08924H13.6426C14.0772 7.08998 14.4292 6.69773 14.4292 6.21588Z",fill:"#464646",stroke:"#464646","stroke-width":"0.735067"})})})]})]})]}),q.jsx(ft,{className:"center",children:q.jsx(vc,{className:"primary-btn",type:"submit",variant:"contained",sx:{mt:{xs:1,sm:2},mb:{xs:1,sm:2}},onClick:()=>i("Recommendation"),children:"NEXT"})})]}),!G&&q.jsx(ft,{children:q.jsx(mn,{children:"No skin scores available"})})]})},W_=()=>{const[a,i]=se.useState(!1),[p,f]=se.useState(""),[g,x]=se.useState("error");return{snackbarOpen:a,snackbarMessage:p,snackbarSeverity:g,showSnackbar:(E,z="error")=>{f(E),x(z),i(!0)},handleSnackbarClose:()=>{i(!1)}}},b7=({open:a,message:i,severity:p,onClose:f})=>{const g=x=>{switch(x){case"success":return{backgroundColor:"#4caf50",color:"#fff",fontSize:"1rem",fontWeight:700};case"error":return{backgroundColor:"#f44336",color:"#fff",fontSize:"1rem",fontWeight:700};default:return{fontSize:"1rem"}}};return q.jsx(h$,{open:a,autoHideDuration:5e3,onClose:f,anchorOrigin:{vertical:"top",horizontal:"right"},children:q.jsx($Q,{onClose:f,severity:p,sx:{width:"100%",...g(p)},children:i})})};b7.propTypes={open:Db.bool.isRequired,message:Db.string.isRequired,severity:Db.oneOf(["success","error","warning","info"]).isRequired,onClose:Db.func};const j_=()=>{const{setSnackbar:a,sessionId:i}=Jl(),[p,f]=se.useState(null),g=async x=>{if(x.preventDefault(),!p){a({snackbarOpen:!0,snackbarMessage:"Please select a rating",snackbarSeverity:"error"});return}const k=new Ff(i);try{await k.submitFeedback(p),a({snackbarOpen:!0,snackbarMessage:"Feedback submitted successfully",snackbarSeverity:"success"})}catch{a({snackbarOpen:!0,snackbarMessage:"Failed to submit feedback. Please try again.",snackbarSeverity:"error"})}};return q.jsxs(ft,{children:[q.jsx(ft,{sx:{textAlign:"center",mb:3},children:q.jsx(mn,{gutterBottom:!0,sx:{...Xr.heading,textAlign:"center"},children:"Thank You!"})}),q.jsxs(ft,{component:"form",onSubmit:g,noValidate:!0,className:"feedback-form",children:[q.jsx(mn,{className:"center feedback-form-title",children:"How has your experience been?"}),q.jsxs(ft,{className:"feedback-rating",children:[q.jsxs(ft,{className:`${p==="RED"?"selected":""} feedback-rating-star`,onClick:()=>f("RED"),children:[q.jsxs("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 65 65",children:[q.jsx("circle",{className:"face-background",cx:"32.5",cy:"32.5",r:"30",fill:"#FF4330",stroke:"#000",strokeWidth:"1.5"}),q.jsx("circle",{cx:"22.5",cy:"25",r:"3",fill:"#000"}),q.jsx("circle",{cx:"42.5",cy:"25",r:"3",fill:"#000"}),q.jsx("path",{d:"M22.5 45 Q32.5 35 42.5 45",fill:"none",stroke:"#000",strokeWidth:"2",strokeLinecap:"round"})]}),q.jsx(mn,{children:"Average"})]}),q.jsxs(ft,{className:`${p==="YELLOW"?"selected":""} feedback-rating-star`,onClick:()=>f("YELLOW"),children:[q.jsxs("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 65 65",children:[q.jsx("circle",{className:"face-background",cx:"32.5",cy:"32.5",r:"30",fill:"#FFEC02",stroke:"#000",strokeWidth:"1.5"}),q.jsx("circle",{cx:"22.5",cy:"25",r:"3",fill:"#000"}),q.jsx("circle",{cx:"42.5",cy:"25",r:"3",fill:"#000"}),q.jsx("line",{x1:"22.5",y1:"45",x2:"42.5",y2:"45",stroke:"#000",strokeWidth:"2",strokeLinecap:"round"})]}),q.jsx(mn,{children:"Good"})]}),q.jsxs(ft,{className:`${p==="GREEN"?"selected":""} feedback-rating-star`,onClick:()=>f("GREEN"),children:[q.jsxs("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 65 65",children:[q.jsx("circle",{className:"face-background",cx:"32.5",cy:"32.5",r:"30",fill:"#00B81C",stroke:"#000",strokeWidth:"1.5"}),q.jsx("circle",{cx:"22.5",cy:"25",r:"3",fill:"#000"}),q.jsx("circle",{cx:"42.5",cy:"25",r:"3",fill:"#000"}),q.jsx("path",{d:"M22.5 45 Q32.5 55 42.5 45",fill:"none",stroke:"#000",strokeWidth:"2",strokeLinecap:"round"})]}),q.jsx(mn,{children:"Excellent"})]})]}),q.jsx(ft,{sx:{display:"flex",flexDirection:"row",gap:"1rem",alignItems:"center",justifyContent:"center",paddingInline:"8px"},children:q.jsx(vc,{className:"btn btn-next auto-width",type:"submit",variant:"contained",size:"large",disabled:!p,children:"Submit"})})]})]})},H_=()=>{const{view:a,setView:i,snackbar:p}=Jl(),{snackbarOpen:f,snackbarMessage:g,snackbarSeverity:x,showSnackbar:k,handleSnackbarClose:N}=W_();se.useEffect(()=>{p&&k(p.snackbarMessage,p.snackbarSeverity)},[p]),se.useEffect(()=>{const B=document.getElementById("close-react-app"),P=()=>{i("HomePage")};return B&&B.addEventListener("click",P),()=>{B&&B.removeEventListener("click",P)}},[i]);const[E,z]=se.useState("");let[G,j]=se.useState(!1),[,M]=se.useState(!1),[,R]=se.useState("");return se.useEffect(()=>{switch(a){case"Gender":z("");break;case"Age":z(""),R("Gender");break;case"SkinType":z(""),R("Age");break;case"CaptureUpload":z(""),R("SkinType");break;case"PicCapture":z("Snap for Skin Insight"),R("CaptureUpload");break;case"Details":z(""),R("CaptureUpload");break;case"OTP":z(""),R("Details");break;case"Scores":z("congratulations"),R("Details");break;case"Recommendation":z("Here is Your Skin Analysis Report"),R("Details");break}j(a!=="HomePage"),M(a!=="Questionnaire")},[a]),q.jsxs(ft,{sx:{margin:"0 auto",display:"flex",flexDirection:"column",justifyContent:"center",alignItems:"center"},children:[q.jsx(ft,{sx:{display:G?"flex":"none",justifyContent:"center",alignItems:"center",width:"100%",padding:{xs:"10px 20px",md:"20px 40px"}},children:q.jsx(ft,{children:q.jsx(mn,{sx:{...Xr.heading,...a==="Recommendation"&&{paddingTop:{xs:"36px",md:"0"}}},children:E})})}),q.jsxs(ft,{children:[a==="HomePage"&&q.jsx(T_,{}),(a==="Gender"||a==="Age"||a==="SkinType"||a==="CaptureUpload")&&q.jsx(z_,{}),a==="PicCapture"&&q.jsx(O_,{}),(a==="Details"||a==="OTP")&&q.jsx(L_,{}),a==="Recommendation"&&q.jsx(F_,{}),a==="Scores"&&q.jsx(R_,{}),a==="Feedback"&&q.jsx(j_,{})]}),q.jsx(b7,{open:f,message:g,severity:x,onClose:N})]})},G_=()=>{const a=document.getElementById("orbo-cc-skin-analyzer-container");if(!a)throw new Error("Invalid container provided for Orbo Skin Analyzer");const i=r0({typography:{fontFamily:"Courier Prime"}});a.classList.add("orbo-cc-skin-analyzer-container"),AO(a).render(q.jsx(se.StrictMode,{children:q.jsxs(oQ,{theme:i,children:[q.jsx(HK,{}),q.jsx(b$,{children:q.jsx(H_,{})})]})}))};Hn.startOrboSkinAnalyzer=G_,Object.defineProperty(Hn,Symbol.toStringTag,{value:"Module"})});
