/*! For license information please see 659.orbo-smart-capture.js.LICENSE.txt */
"use strict";(self.webpackChunkOrboSmartCapture=self.webpackChunkOrboSmartCapture||[]).push([[659],{2610:(e,r,t)=>{t.d(r,{q:()=>a});var s=t(6125);function a(e,r,t,a){if(e===r||e<r&&t<0||r<e&&t>1)return s.ZSL.makeZerosTypedArray(0,a);const n=Math.abs(Math.ceil((r-e)/t)),o=s.ZSL.makeZerosTypedArray(n,a);r<e&&1===t&&(t=-1),o[0]=e;for(let e=1;e<o.length;e++)o[e]=o[e-1]+t;return o}},7763:(e,r,t)=>{t.d(r,{h:()=>a});var s=t(6125);function a(e,r,t,a){const n=s.ZSL.getArrayFromDType(t,s.ZSL.sizeFromShape(r));if(a&&"string"!==t){let r=0;e.forEach(e=>{const t=s.ZSL.sizeFromShape(e.shape);n.set(e.vals,r),r+=t})}else{let a=0;e.forEach(e=>{const o="string"===t?s.C0T.fromUint8ToStringArray(e.vals):e.vals;let i=0;for(let t=0;t<e.shape[0];++t){const s=t*r[1]+a;for(let r=0;r<e.shape[1];++r)n[s+r]=o[i++]}a+=e.shape[1]})}return n}},7870:(e,r,t)=>{t.d(r,{C:()=>a});var s=t(6125);function a(e,r){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&s.ZSL.assert("complex64"!==e.dtype,()=>`${r} does not support complex64 tensors in the CPU backend.`)})}},7906:(e,r,t)=>{t.d(r,{HS:()=>n,di:()=>o,lv:()=>i});var s=t(6125),a=t(7870);function n(e,r,t,a,n){const o=s.Kro.isSliceContinous(a,r,t),i=s.ZSL.sizeFromShape(t),c=s.ZSL.computeStrides(a);if(o){const t=s.Kro.computeFlatOffset(r,c);return"string"===n?e.slice(t,t+i):e.subarray(t,t+i)}const l="string"===n?s.C0T.fromUint8ToStringArray(e):e,p=(0,s.ra8)(a,n,l),u=(0,s.ra8)(t,n);for(let e=0;e<u.size;++e){const t=u.indexToLoc(e),s=t.map((e,t)=>e+r[t]);u.set(p.get(...s),...t)}return"string"===n?s.C0T.fromStringArrayToUint8(u.values):u.values}function o(e){const{inputs:r,backend:t,attrs:o}=e,{x:i}=r,{begin:c,size:l}=o;(0,a.C)(i,"slice");const[p,u]=s.Kro.parseSliceParams(i,c,l);s.Kro.assertParamsValid(i,p,u);const f=n(t.data.get(i.dataId).values,p,u,i.shape,i.dtype);return t.makeTensorInfo(u,i.dtype,f)}const i={kernelName:s.JiE,backendName:"cpu",kernelFunc:o}}}]);