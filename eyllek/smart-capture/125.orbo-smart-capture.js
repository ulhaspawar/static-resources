/*! For license information please see 125.orbo-smart-capture.js.LICENSE.txt */
(self.webpackChunkOrboSmartCapture=self.webpackChunkOrboSmartCapture||[]).push([[125],{72:function(t,e,n){var r;!function(t,s){function o(t){var e=this,n="";e.x=0,e.y=0,e.z=0,e.w=0,e.next=function(){var t=e.x^e.x<<11;return e.x=e.y,e.y=e.z,e.z=e.w,e.w^=e.w>>>19^t^t>>>8},t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),e.next()}function a(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}function i(t,e){var n=new o(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=i:n.amdD&&n.amdO?void 0===(r=function(){return i}.call(e,n,e,s))||(s.exports=r):this.xor128=i}(0,t=n.nmd(t),n.amdD)},99:(t,e,n)=>{"use strict";n.d(e,{N:()=>g});var r=n(1585),s=n(1830),o=n(5441),a=n(565),i=n(8189),l=n(5119),u=n(7523),c=n(2198),h=n(8646),d=n(5703),p=n(929),f=n(2302);const g=(0,p.op)({fusedMatMul_:function({a:t,b:e,transposeA:n=!1,transposeB:p=!1,bias:g,activation:m="linear",preluActivationWeights:b,leakyreluAlpha:y}){if(!1===(0,h.zE)(r.T2.state.gradientDepth,m)){let r=(0,d.N)(t,e,n,p);return null!=g&&(r=(0,u.W)(r,g)),(0,h.f2)(r,m,b,y)}let v=(0,i.YT)(t,"a","fused matMul"),w=(0,i.YT)(e,"b","fused matMul");[v,w]=(0,a.makeTypesMatch)(v,w);const k=n?v.shape[v.rank-2]:v.shape[v.rank-1],T=p?w.shape[w.rank-1]:w.shape[w.rank-2],x=n?v.shape[v.rank-1]:v.shape[v.rank-2],E=p?w.shape[w.rank-2]:w.shape[w.rank-1],A=v.shape.slice(0,-2),S=w.shape.slice(0,-2),$=l.Ze(A),M=l.Ze(S);l.vA(v.rank>=2&&w.rank>=2&&v.rank===w.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${v.rank} and ${w.rank}.`),l.vA(l.r1(A,S),()=>`Error in fused matMul: outer dimensions (${A}) and (${S}) of Tensors with shapes ${v.shape} and ${w.shape} must match.`),l.vA(k===T,()=>`Error in fused matMul: inner shapes (${k}) and (${T}) of Tensors with shapes ${v.shape} and ${w.shape} and transposeA=${n} and transposeB=${p} must match.`);const I=v.shape.slice(0,-2).concat([x,E]),N=n?(0,f.t)(v,[$,k,x]):(0,f.t)(v,[$,x,k]),_=p?(0,f.t)(w,[M,E,T]):(0,f.t)(w,[M,T,E]);let D,Y;null!=g&&(D=(0,i.YT)(g,"bias","fused matMul"),[D]=(0,a.makeTypesMatch)(D,v),c.Ky(I,D.shape)),null!=b&&(Y=(0,i.YT)(b,"prelu weights","fused matMul"));const R=(t,e)=>{const[r,s,o,a]=e,i=(0,h.XB)((0,f.t)(t,o.shape),o,m);let l,u;return n||p?!n&&p?(l=(0,d.N)(i,s,!1,!1),u=(0,d.N)(i,r,!0,!1)):n&&!p?(l=(0,d.N)(s,i,!1,!0),u=(0,d.N)(r,i,!1,!1)):(l=(0,d.N)(s,i,!0,!0),u=(0,d.N)(i,r,!0,!0)):(l=(0,d.N)(i,s,!1,!0),u=(0,d.N)(r,i,!0,!1)),null!=g?[l,u,(0,h.Do)(a,i)]:[l,u]},F={a:N,b:_,bias:D,preluActivationWeights:Y},B={transposeA:n,transposeB:p,activation:m,leakyreluAlpha:y};if(null==g){const t=(0,s._X)((t,e,n)=>{const s=r.T2.runKernel(o.Dr,F,B);return n([t,e,s]),{value:(0,f.t)(s,I),gradFunc:R}});return t(N,_)}{const t=(0,s._X)((t,e,n,s)=>{const a=r.T2.runKernel(o.Dr,F,B);return s([t,e,a,n]),{value:(0,f.t)(a,I),gradFunc:R}});return t(N,_,D)}}})},112:(t,e,n)=>{"use strict";n.d(e,{V:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({relu_:function(t){const e={x:(0,o.YT)(t,"x","relu")};return r.T2.runKernel(s.fU,e)}})},125:(t,e,n)=>{"use strict";n.d(e,{o:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({clone_:function(t){const e={x:(0,o.YT)(t,"x","clone","string_or_numeric")};return r.T2.runKernel(s.lz,e)}})},152:(t,e,n)=>{"use strict";n.d(e,{z:()=>i});var r=n(1585),s=n(5441),o=n(565),a=n(8189);const i=(0,n(929).op)({mod_:function(t,e){let n=(0,a.YT)(t,"a","mod"),i=(0,a.YT)(e,"b","mod");[n,i]=(0,o.makeTypesMatch)(n,i);const l={a:n,b:i};return r.T2.runKernel(s.BL,l)}})},167:(t,e,n)=>{"use strict";n.d(e,{I:()=>c});var r=n(1585),s=n(5441),o=n(8189),a=n(5119),i=n(7195),l=n(929),u=n(2302);const c=(0,l.op)({conv3d_:function(t,e,n,l,c="NDHWC",h=[1,1,1]){const d=(0,o.YT)(t,"x","conv3d"),p=(0,o.YT)(e,"filter","conv3d");let f=d,g=!1;4===d.rank&&(g=!0,f=(0,u.t)(d,[1,d.shape[0],d.shape[1],d.shape[2],d.shape[3]])),a.vA(5===f.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${f.rank}.`),a.vA(5===p.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${p.rank}.`),a.vA(f.shape[4]===p.shape[3],()=>`Error in conv3d: depth of input (${f.shape[4]}) must match input depth for filter ${p.shape[3]}.`),a.vA((0,i.G0)(n,h),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${h}'`),a.vA("NDHWC"===c,()=>`Error in conv3d: got dataFormat of ${c} but only NDHWC is currently supported.`);const m={x:f,filter:p},b={strides:n,pad:l,dataFormat:c,dilations:h},y=r.T2.runKernel(s.A1,m,b);return g?(0,u.t)(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}})},178:(t,e,n)=>{"use strict";n.d(e,{P:()=>u});var r=n(1585),s=n(5441),o=n(565),a=n(8189),i=n(2198),l=n(9809);const u=(0,n(929).op)({maximum_:function(t,e){let n=(0,a.YT)(t,"a","maximum"),u=(0,a.YT)(e,"b","maximum");[n,u]=(0,o.makeTypesMatch)(n,u),"bool"===n.dtype&&(n=(0,l.w)(n,"int32"),u=(0,l.w)(u,"int32")),(0,i.Ky)(n.shape,u.shape);const c={a:n,b:u};return r.T2.runKernel(s.LD,c)}})},252:(t,e,n)=>{"use strict";n.d(e,{v:()=>l});var r=n(1585),s=n(5441),o=n(5119),a=n(929),i=n(2302);const l=(0,a.op)({conv2DBackpropInput_:function(t,e,n,a,l,u="NHWC",c){o.vA(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let h=t,d=e,p=!1;3===e.rank&&(p=!0,d=(0,i.t)(e,[1,e.shape[0],e.shape[1],e.shape[2]]),h=[1,t[0],t[1],t[2]]),o.vA(4===h.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${h.length}.`),o.vA(4===d.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${d.rank}`),o.vA(4===n.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const f="NHWC"===u?h[3]:h[1],g="NHWC"===u?d.shape[3]:d.shape[1];o.vA(f===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${f}) must match input depth for filter ${n.shape[2]}.`),o.vA(g===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${g}) must match output depth for filter ${n.shape[3]}.`),null!=c&&o.vA(o.E6(l),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${c} but got pad ${l}.`);const m={dy:d,filter:n},b={strides:a,pad:l,dataFormat:u,dimRoundingMode:c,inputShape:h},y=r.T2.runKernel(s.jf,m,b);return p?(0,i.t)(y,[y.shape[1],y.shape[2],y.shape[3]]):y}})},259:(t,e,n)=>{"use strict";n.d(e,{qY:()=>y,yl:()=>h,rT:()=>w,tp:()=>v,B4:()=>b,Q5:()=>m,qP:()=>g});var r=n(1743),s=n(5119);function o(t,e,n,r){const o=(0,s.Ur)(e),i=function(t,e,n,r){const o=(0,s.Ze)(e),i=r[r.length-1],l=new Array(i).fill(0),c=e.length,h="complex64"===n?u(t):t;if(c>1)for(let t=0;t<o/i;t++){const e=t*i;for(let t=0;t<i;t++)l[t]=Math.max(l[t],a(h[e+t],0,n).length)}return l}(t,e,n,o),c=e.length,h=l(t,e,n,o,i),d=["Tensor"];return r&&(d.push(`  dtype: ${n}`),d.push(`  rank: ${c}`),d.push(`  shape: [${e}]`),d.push("  values:")),d.push(h.map(t=>"    "+t).join("\n")),d.join("\n")}function a(t,e,n){let r;return r=Array.isArray(t)?`${parseFloat(t[0].toFixed(7))} + ${parseFloat(t[1].toFixed(7))}j`:(0,s.Kg)(t)?`'${t}'`:"bool"===n?i(t):parseFloat(t.toFixed(7)).toString(),(0,s.av)(r,e)}function i(t){return 0===t?"false":"true"}function l(t,e,n,r,s,o=!0){const c="complex64"===n?2:1,h=e[0],d=e.length;if(0===d)return"complex64"===n?[a(u(t)[0],0,n)]:"bool"===n?[i(t[0])]:[t[0].toString()];if(1===d){if(h>20){const e=3*c;let r=Array.from(t.slice(0,e)),o=Array.from(t.slice((h-3)*c,h*c));return"complex64"===n&&(r=u(r),o=u(o)),["["+r.map((t,e)=>a(t,s[e],n)).join(", ")+", ..., "+o.map((t,e)=>a(t,s[h-3+e],n)).join(", ")+"]"]}return["["+("complex64"===n?u(t):Array.from(t)).map((t,e)=>a(t,s[e],n)).join(", ")+"]"]}const p=e.slice(1),f=r.slice(1),g=r[0]*c,m=[];if(h>20){for(let e=0;e<3;e++){const r=e*g,o=r+g;m.push(...l(t.slice(r,o),p,n,f,s,!1))}m.push("...");for(let e=h-3;e<h;e++){const r=e*g,o=r+g;m.push(...l(t.slice(r,o),p,n,f,s,e===h-1))}}else for(let e=0;e<h;e++){const r=e*g,o=r+g;m.push(...l(t.slice(r,o),p,n,f,s,e===h-1))}const b=2===d?",":"";m[0]="["+m[0]+b;for(let t=1;t<m.length-1;t++)m[t]=" "+m[t]+b;let y=",\n";for(let t=2;t<d;t++)y+="\n";return m[m.length-1]=" "+m[m.length-1]+"]"+(o?"":y),m}function u(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}var c=n(3879);class h{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=s.Ze(t),null!=n){const t=n.length;s.vA(t===this.size,()=>`Length of values '${t}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||s.Ab(e,this.size),this.strides=(0,s.Ur)(t)}set(t,...e){0===e.length&&(e=[0]),s.vA(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const n=this.locToIndex(e);this.values[n]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const n of t){if(n<0||n>=this.shape[e]){const e=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(e)}e++}let n=t[t.length-1];for(let e=0;e<t.length-1;++e)n+=this.strides[e]*t[e];return this.values[n]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return d().makeTensor(this.values,this.shape,this.dtype)}}let d=null,p=null,f=null;function g(t){d=t}function m(t){p=t}function b(t){f=t}class y{constructor(t,e,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=s.Ze(t),this.strides=(0,s.Ur)(t),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return p.buffer(this.shape,this.dtype,t)}bufferSync(){return p.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return(0,s.yw)(this.shape,t,"complex64"===this.dtype)}arraySync(){return(0,s.yw)(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const t=d().read(this.dataId);if("string"===this.dtype){const e=await t;try{return e.map(t=>c.decodeString(t))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataSync(){this.throwIfDisposed();const t=d().readSync(this.dataId);if("string"===this.dtype)try{return t.map(t=>c.decodeString(t))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await d().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(d().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return p.print(this,t)}clone(){return this.throwIfDisposed(),p.clone(this)}toString(t=!1){return o(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),p.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),d().makeVariable(this,t,e,n)}}function v(){return(0,r.m)("Tensor",()=>y)}Object.defineProperty(y,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed}),v();class w extends y{constructor(t,e,n,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!s.r1(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);d().disposeTensor(this),this.dataId=t.dataId,d().incRef(this,null)}dispose(){d().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(w,Symbol.hasInstance,{value:t=>t instanceof y&&null!=t.assign&&t.assign instanceof Function})},269:(t,e,n)=>{"use strict";n.d(e,{y:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({asinh_:function(t){const e={x:(0,o.YT)(t,"x","asinh")};return r.T2.runKernel(s.ep,e)}})},297:function(t,e,n){var r;!function(t,s){function o(t){var e,n=this,r=(e=4022871197,function(t){t=t.toString();for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)});n.next=function(){var t=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=t-(n.c=0|t)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(t),n.s0<0&&(n.s0+=1),n.s1-=r(t),n.s1<0&&(n.s1+=1),n.s2-=r(t),n.s2<0&&(n.s2+=1),r=null}function a(t,e){return e.c=t.c,e.s0=t.s0,e.s1=t.s1,e.s2=t.s2,e}function i(t,e){var n=new o(t),r=e&&e.state,s=n.next;return s.int32=function(){return 4294967296*n.next()|0},s.double=function(){return s()+11102230246251565e-32*(2097152*s()|0)},s.quick=s,r&&("object"==typeof r&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=i:n.amdD&&n.amdO?void 0===(r=function(){return i}.call(e,n,e,s))||(s.exports=r):this.alea=i}(0,t=n.nmd(t),n.amdD)},448:(t,e,n)=>{"use strict";n.d(e,{r:()=>o});var r=n(259),s=n(5119);function o(t,e="float32",n){return e=e||"float32",s.SA(t),new r.yl(t,e,n)}},517:(t,e,n)=>{"use strict";n.d(e,{I:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({expm1_:function(t){const e={x:(0,o.YT)(t,"x","expm1")};return r.T2.runKernel(s.fQ,e)}})},565:(t,e,n)=>{"use strict";n.r(e),n.d(e,{assertTypesMatch:()=>i,getTensorsInContainer:()=>u,isTensorInList:()=>l,makeTypesMatch:()=>a});var r=n(259),s=n(2046),o=n(5119);function a(t,e){if(t.dtype===e.dtype)return[t,e];const n=(0,s.Tu)(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function i(t,e){(0,o.vA)(t.dtype===e.dtype,()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`)}function l(t,e){return e.some(e=>e.id===t.id)}function u(t){const e=[];return c(t,e,new Set),e}function c(t,e,n){if(null==t)return;if(t instanceof r.qY)return void e.push(t);if(s=t,!Array.isArray(s)&&"object"!=typeof s)return;var s;const o=t;for(const t in o){const r=o[t];n.has(r)||(n.add(r),c(r,e,n))}}},676:(t,e,n)=>{"use strict";n.d(e,{G:()=>u});var r=n(1585),s=n(5441),o=n(8189),a=n(5119),i=n(929),l=n(2302);const u=(0,i.op)({depthwiseConv2d_:function(t,e,n,i,u="NHWC",c=[1,1],h){const d=(0,o.YT)(t,"x","depthwiseConv2d","float32"),p=(0,o.YT)(e,"filter","depthwiseConv2d","float32");let f=d,g=!1;3===d.rank&&(g=!0,f=(0,l.t)(d,[1,d.shape[0],d.shape[1],d.shape[2]])),a.vA(4===f.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),a.vA(4===p.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`),a.vA(f.shape[3]===p.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),null!=h&&a.vA(a.E6(i),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${h} but got pad ${i}.`);const m={x:f,filter:p},b={strides:n,pad:i,dataFormat:u,dilations:c,dimRoundingMode:h},y=r.T2.runKernel(s.tG,m,b);return g?(0,l.t)(y,[y.shape[1],y.shape[2],y.shape[3]]):y}})},700:(t,e,n)=>{"use strict";n.d(e,{P:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({step_:function(t,e=0){const n={x:(0,o.YT)(t,"x","step")},a={alpha:e};return r.T2.runKernel(s.pn,n,a)}})},758:(t,e,n)=>{"use strict";n.d(e,{H:()=>i});var r=n(1585),s=n(5441),o=n(8189),a=n(5119);const i=(0,n(929).op)({bincount_:function(t,e,n){const i=(0,o.YT)(t,"x","bincount"),l=(0,o.YT)(e,"weights","bincount");a.vA("int32"===i.dtype,()=>`Error in bincount: input dtype must be int32, but got ${i.dtype}`),a.vA(n>=0,()=>`size must be non-negative, but got ${n}.`),a.vA(l.size===i.size||0===l.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${i.shape}, weights shape: ${l.shape}.`);const u={x:i,weights:l},c={size:n};return r.T2.runKernel(s.N4,u,c)}})},776:(t,e,n)=>{"use strict";n.d(e,{e:()=>i});var r=n(1585),s=n(5441),o=n(8189),a=n(5119);const i=(0,n(929).op)({spaceToBatchND_:function(t,e,n){const i=(0,o.YT)(t,"x","spaceToBatchND");a.vA(i.rank>=1+e.length,()=>`input rank ${i.rank} should be > than [blockShape] ${e.length}`),a.vA(n.length===e.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`),a.vA(i.shape.reduce((t,r,s)=>s>0&&s<=e.length?t&&(r+n[s-1][0]+n[s-1][1])%e[s-1]===0:t,!0),()=>`input spatial dimensions ${i.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`);const l={x:i},u={blockShape:e,paddings:n};return r.T2.runKernel(s.A8,l,u)}})},855:(t,e,n)=>{"use strict";n.d(e,{m:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({ceil_:function(t){const e={x:(0,o.YT)(t,"x","ceil","float32")};return r.T2.runKernel(s.QD,e)}})},897:(t,e,n)=>{"use strict";n.d(e,{F:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({argMax_:function(t,e=0){const n={x:(0,o.YT)(t,"x","argMax")},a={axis:e};return r.T2.runKernel(s.Jp,n,a)}})},919:(t,e,n)=>{"use strict";n.d(e,{e:()=>c});var r=n(565),s=n(8189),o=n(9359),a=n(3020),i=n(929),l=n(2151),u=n(5537);const c=(0,i.op)({divNoNan_:function(t,e){let n=(0,s.YT)(t,"a","div"),i=(0,s.YT)(e,"b","div");[n,i]=(0,r.makeTypesMatch)(n,i);const c=(0,o.y)(n,i),h=(0,u.P)(c),d=(0,a.L)(i,h);return(0,l._)(d,h,c)}})},929:(t,e,n)=>{"use strict";n.d(e,{B:()=>o,op:()=>a});var r=n(1585),s=n(5119);const o="__op";function a(t){const e=Object.keys(t);if(1!==e.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const a=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=o;const i=(...t)=>{r.T2.startScope(n);try{const e=a(...t);return(0,s.yL)(e)&&console.error("Cannot return a Promise inside of tidy."),r.T2.endScope(e),e}catch(t){throw r.T2.endScope(null),t}};return Object.defineProperty(i,"name",{value:n,configurable:!0}),i}},1078:(t,e,n)=>{"use strict";n.d(e,{Em:()=>u,SM:()=>i,WC:()=>l,WH:()=>s,aF:()=>o,fK:()=>h,gx:()=>c,lb:()=>a});var r=n(5119);function s(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function o(t,e,n){const r=t.length+e.length,s=[];let o=0,a=0;for(let i=0;i<r;i++)-1===n.indexOf(i)?s.push(t[o++]):s.push(e[a++]);return s}function a(t,e){const n=[],r=t.length;for(let s=0;s<r;s++)-1===e.indexOf(s)&&n.push(t[s]);return[n,e.map(e=>t[e])]}function i(t,e){return o(t,e.map(t=>1),e)}function l(t,e,n){r.vA(s(e,n),()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`)}function u(t,e){if(s(t,e))return null;const n=[];for(let r=0;r<e;++r)-1===t.indexOf(r)&&n.push(r);return t.forEach(t=>n.push(t)),n}function c(t){return t.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function h(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}},1106:(t,e,n)=>{"use strict";n.d(e,{w:()=>o});var r=n(8189),s=n(252);const o=(0,n(929).op)({conv2dTranspose_:function(t,e,n,o,a,i){const l=(0,r.YT)(t,"x","conv2dTranspose"),u=(0,r.YT)(e,"filter","conv2dTranspose");return(0,s.v)(n,l,u,o,a,"NHWC",i)}})},1115:(t,e,n)=>{"use strict";n.d(e,{_:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({sign_:function(t){const e={x:(0,o.YT)(t,"x","sign")};return r.T2.runKernel(s.YV,e)}})},1190:(t,e,n)=>{"use strict";n.d(e,{r:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({topk_:function(t,e=1,n=!0){const a=(0,o.YT)(t,"x","topk");if(0===a.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const i=a.shape[a.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>i)throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${e}`);const l={x:a},u={k:e,sorted:n},[c,h]=r.T2.runKernel(s.TB,l,u);return{values:c,indices:h}}})},1216:(t,e,n)=>{"use strict";n.d(e,{R:()=>i});var r=n(1585),s=n(5441),o=n(8189),a=n(5119);const i=(0,n(929).op)({depthToSpace_:function(t,e,n="NHWC"){const i=(0,o.YT)(t,"x","depthToSpace","float32"),l="NHWC"===n?i.shape[1]:i.shape[2],u="NHWC"===n?i.shape[2]:i.shape[3],c="NHWC"===n?i.shape[3]:i.shape[1];a.vA(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),a.vA(l*e>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${l} and ${e}  for depthToSpace with input shape\n    ${i.shape}`),a.vA(u*e>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${u} and ${e} for depthToSpace with input shape\n        ${i.shape}`),a.vA(c%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${c} for depthToSpace with input shape ${i.shape}`);const h={x:i},d={blockSize:e,dataFormat:n};return r.T2.runKernel(s.TM,h,d)}})},1303:(t,e,n)=>{"use strict";n.d(e,{M:()=>l});var r=n(1585),s=n(5441),o=n(565),a=n(8189),i=n(2198);const l=(0,n(929).op)({less_:function(t,e){let n=(0,a.YT)(t,"a","less","string_or_numeric"),l=(0,a.YT)(e,"b","less","string_or_numeric");[n,l]=(0,o.makeTypesMatch)(n,l),(0,i.Ky)(n.shape,l.shape);const u={a:n,b:l};return r.T2.runKernel(s.mI,u)}})},1361:(t,e,n)=>{"use strict";n.d(e,{h:()=>a});var r=n(1585),s=n(5441),o=n(5119);const a=(0,n(929).op)({fft_:function(t){(0,o.vA)("complex64"===t.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`);const e={input:t};return r.T2.runKernel(s.rG,e)}})},1404:(t,e,n)=>{"use strict";n.d(e,{F:()=>i});var r=n(1585),s=n(5441),o=n(565),a=n(8189);const i=(0,n(929).op)({atan2_:function(t,e){let n=(0,a.YT)(t,"a","atan2"),i=(0,a.YT)(e,"b","atan2");[n,i]=(0,o.makeTypesMatch)(n,i);const l={a:n,b:i};return r.T2.runKernel(s.lx,l)}})},1411:(t,e,n)=>{"use strict";n.d(e,{S:()=>i});var r=n(1585),s=n(5119),o=n(7148),a=n(2855);function i(t,e="float32"){if("complex64"===e){const e=i(t,"float32"),n=(0,a.U)(t,"float32");return(0,o.f)(e,n)}const n=(0,s.FZ)((0,s.Ze)(t),e);return r.T2.makeTensor(n,t,e)}},1436:function(t,e,n){var r;!function(t,s){function o(t){var e=this;e.next=function(){var t,n,r=e.x,s=e.i;return t=r[s],n=(t^=t>>>7)^t<<24,n^=(t=r[s+1&7])^t>>>10,n^=(t=r[s+3&7])^t>>>3,n^=(t=r[s+4&7])^t<<7,t=r[s+7&7],n^=(t^=t<<13)^t<<9,r[s]=n,e.i=s+1&7,n},function(t,e){var n,r=[];if(e===(0|e))r[0]=e;else for(e=""+e,n=0;n<e.length;++n)r[7&n]=r[7&n]<<15^e.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],t.x=r,t.i=0,n=256;n>0;--n)t.next()}(e,t)}function a(t,e){return e.x=t.x.slice(),e.i=t.i,e}function i(t,e){null==t&&(t=+new Date);var n=new o(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&(r.x&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=i:n.amdD&&n.amdO?void 0===(r=function(){return i}.call(e,n,e,s))||(s.exports=r):this.xorshift7=i}(0,t=n.nmd(t),n.amdD)},1585:(t,e,n)=>{"use strict";n.d(e,{T2:()=>w,Ye:()=>v});var r=n(5149),s=n(6574),o=n(1743),a=n(5441),i=n(7074),l=n(3879),u=n(5119);class c{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new d)}profileKernel(t,e,n){let r;const o=()=>{r=n()};let a;const i=l.now();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(o);else{o();for(const t of r)t.dataSync();a=Promise.resolve({kernelMs:l.now()-i})}if((0,s._K)().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let e=0;e<r.length;e++){const n=r[e];n.data().then(e=>{h(e,n.dtype,t)})}return{kernelName:t,outputs:r,inputs:e,timeMs:a.then(t=>t.kernelMs),extraInfo:a.then(t=>null!=t.getExtraProfileInfo?t.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:n,timeMs:r,inputs:s,extraInfo:o}=t;n.forEach(t=>{Promise.all([t.data(),r,o]).then(n=>{this.logger.logKernelProfile(e,t,n[0],n[1],s,n[2])})})}}function h(t,e,n){if("float32"!==e)return!1;for(let e=0;e<t.length;e++){const r=t[e];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class d{logKernelProfile(t,e,n,r,s,o){const a="number"==typeof r?u.av(`${r}ms`,9):r.error,i=u.av(t,25),l=e.rank,c=e.size,h=u.av(e.shape.toString(),14);let d="";for(const t in s){const n=s[t];if(null!=n){const r=n.shape||e.shape,s=r.length;d+=`${t}: ${s}D ${s>0?r:""} `}}console.log(`%c${i}\t%c${a}\t%c${l}D ${h}\t%c${c}\t%c${d}\t%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}var p=n(259),f=n(565),g=n(3673);function m(t){return null!=t.kernelName}class b{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class y{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new b}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then(()=>{});if(null!=this.backendInstance)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(!(t in this.registryFactory))return null;{const{asyncInit:e}=this.initializeBackend(t);if(e)return null}}return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(g.i(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(null==this.registryFactory[t])throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,null==this.registry[t]){this.backendInstance=null;const{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new c(this.backendInstance),!0}setupRegisteredKernels(){(0,i.Op)(this.backendName).forEach(t=>{null!=t.setupFunc&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){(0,i.Op)(t).forEach(e=>{null!=e.disposeFunc&&e.disposeFunc(this.registry[t])})}initializeBackend(t){const e=this.registryFactory[t];if(null==e)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const n=e.factory();if(!n||n instanceof r.uI||"function"!=typeof n.then)return this.registry[t]=n,{success:!0,asyncInit:!1};{const e=++this.pendingBackendInitId,r=n.then(n=>!(e<this.pendingBackendInitId||(this.registry[t]=n,this.pendingBackendInit=null,0))).catch(n=>(e<this.pendingBackendInitId||(this.pendingBackendInit=null,g.i(`Initialization of backend ${t} failed`),g.i(n.stack||n.message)),!1));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(e){return g.i(`Initialization of backend ${t} failed`),g.i(e.stack||e.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const n=t[e],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const n=this.state.tensorInfo.get(e),r=n.backend,s=this.readSync(e),o=r.refCount(e);r.disposeData(e,!0),n.backend=t,t.move(e,s,n.shape,n.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n,r=null;if(null==e){if("function"!=typeof t)throw new Error("Please provide a function to tidy()");e=t}else{if("string"!=typeof t&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof e)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}return this.scopedRun(()=>this.startScope(r),()=>this.endScope(n),()=>(n=e(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(t,e,n){t();try{const t=n();return e(),t}catch(t){throw e(),t}}nextTensorId(){return y.nextTensorId++}nextVariableId(){return y.nextVariableId++}clone(t){const e=w.runKernel(a.lz,{x:t}),n={x:t};return this.addTapeNode(this.state.activeScope.name,n,[e],t=>({x:()=>{const e={x:t};return w.runKernel(a.KX,e,{dtype:"float32"})}}),[],{}),e}runKernel(t,e,n){if(null==this.backendName&&this.backend,null==(0,i._5)(t,this.backendName))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){const r=this.backend.numDataIds();let s=0;n.forEach(t=>{s+="complex64"===t.dtype?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=r-e-s-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${t}'`)}runKernelFunc(t){let e,n=[];const r=this.isTapeOn(),s=this.state.numBytes,o=this.state.numTensors;let a,l;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const c=m(t)?t.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(m(t)){const{kernelName:e,inputs:s,attrs:o}=t;null==this.backendName&&this.backend;const c=(0,i._5)(e,this.backendName);u.vA(null!=c,()=>`Cannot find registered kernel '${e}' for backend '${this.backendName}'`),a=()=>{const t=this.backend.numDataIds();l=c.kernelFunc({inputs:s,attrs:o,backend:this.backend});const a=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(e,t,a);const i=a.map(t=>{if(null!=t.rank)return t;const{dataId:e,shape:n,dtype:r}=t;return this.makeTensorFromDataId(e,n,r)});if(r){const t=this.getTensorsForGradient(e,s,i);n=this.saveTensorsForBackwardMode(t)}return i}}else{const{forwardFunc:e}=t,s=t=>{r&&(n=t.map(t=>this.keep(this.clone(t))))};a=()=>{const t=this.backend.numDataIds();l=this.tidy(()=>e(this.backend,s));const n=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,t,n),n}}const{inputs:h,attrs:d}=t,p=m(t)?null:t.backwardsFunc;let f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(f=this.profiler.profileKernel(c,h,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),e=f.outputs):e=a()}),r&&this.addTapeNode(c,h,e,p,n,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(h).map(t=>null!=h[t]?h[t].shape:null),outputShapes:e.map(t=>t.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(l)?e:e[0]}saveTensorsForBackwardMode(t){const e=t.map(t=>this.keep(this.clone(t)));return e}getTensorsForGradient(t,e,n){const r=(0,i.vQ)(t);if(null!=r){const t=r.inputsToSave||[],s=r.outputsToSave||[];let o;r.saveAllInputs?(u.vA(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(e).map(t=>e[t])):o=t.map(t=>e[t]);const a=n.filter((t,e)=>s[e]);return o.concat(a)}return[]}makeTensor(t,e,n,r){if(null==t)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let s=t;"string"===n&&u.Kg(t[0])&&(s=t.map(t=>l.encodeString(t)));const o=r.write(s,e,n),a=new p.qY(e,n,o,this.nextTensorId());if(this.trackTensor(a,r),"string"===n){const t=this.state.tensorInfo.get(o),e=(0,u.SL)(s);this.state.numBytes+=e-t.bytes,t.bytes=e}return a}makeTensorFromDataId(t,e,n,r){n=n||"float32";const s=new p.qY(e,n,t,this.nextTensorId());return this.trackTensor(s,r),s}makeVariable(t,e=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==t.dtype&&(t=t.cast(r));const s=new p.rT(t,e,n,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(t,e){this.state.numTensors++,"string"===t.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==t.dtype&&"string"!==t.dtype&&(n=t.size*u.jv(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof p.rT||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,"string"===t.dtype&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),"complex64"!==t.dtype&&"string"!==t.dtype){const e=t.size*u.jv(t.dtype);this.state.numBytes-=e}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),null!=this.state.registeredVariables[t.name]&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,null==t.reasons&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(t=>t.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const t of this.state.activeProfile.kernels)t.kernelTimeMs=await t.kernelTimeMs,t.extraInfo=await t.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(t,e,n,r,s,o){const a={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:s},l=(0,i.vQ)(t);null!=l&&(r=l.gradFunc),null!=r&&(a.gradient=t=>(t=t.map((t,e)=>{if(null==t){const t=n[e],r=u.Ty(t.size,t.dtype);return this.makeTensor(r,t.shape,t.dtype)}return t}),r(t.length>1?t:t[0],s,o))),this.state.activeTape.push(a)}keep(t){return t.kept=!0,t}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=(0,f.getTensorsInContainer)(t),n=new Set(e.map(t=>t.id));for(let t=0;t<this.state.activeScope.track.length;t++){const e=this.state.activeScope.track[t];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(t=>{t.kept||t.scopeId!==r.id||this.track(t)})}gradients(t,e,n,r=!1){if(u.vA(e.length>0,()=>"gradients() received an empty list of xs."),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));u.vA(s instanceof p.qY,()=>"The result y returned by f() must be a tensor.");const o=function(t,e,n){const r={},s={};for(let t=0;t<e.length;t++)r[e[t].id]=!0;for(let n=0;n<t.length;n++){const o=t[n],a=o.inputs;for(const t in a){const n=a[t];let i=!1;for(let t=0;t<e.length;t++)if(r[n.id]){o.outputs.forEach(t=>r[t.id]=!0),i=!0,s[o.id]=!0;break}if(i)break}}const o={};o[n.id]=!0;const a={};for(let e=t.length-1;e>=0;e--){const n=t[e],r=n.inputs;for(let t=0;t<n.outputs.length;t++)if(o[n.outputs[t].id]){for(const t in r)o[r[t].id]=!0,a[n.id]=!0;break}}const i=[];for(let e=0;e<t.length;e++){const n=t[e];if(s[n.id]&&a[n.id]){const t={};for(const e in n.inputs){const s=n.inputs[e];r[s.id]&&(t[e]=s)}const e=Object.assign({},n);e.inputs=t,e.outputs=n.outputs,i.push(e)}}return i}(this.state.activeTape,e,s);if(!r&&0===o.length&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const t={};t[s.id]=null==n?function(t){const e=(0,u.FZ)((0,u.Ze)(t),"float32");return w.makeTensor(e,t,"float32")}(s.shape):n,function(t,e,n,r){for(let s=e.length-1;s>=0;s--){const o=e[s],a=[];if(o.outputs.forEach(e=>{const n=t[e.id];null!=n?a.push(n):a.push(null)}),null==o.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const i=o.gradient(a);for(const e in o.inputs){if(!(e in i))throw new Error(`Cannot backprop through input ${e}. Available gradients found: ${Object.keys(i)}.`);const s=n(()=>i[e]());if("float32"!==s.dtype)throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${e} must have 'float32' dtype, but has '${s.dtype}'`);const a=o.inputs[e];if(!u.r1(s.shape,a.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${e}' has shape '${s.shape}', which does not match the shape of the input '${a.shape}'`);if(null==t[a.id])t[a.id]=s;else{const e=t[a.id];t[a.id]=r(e,s),e.dispose()}}}}(t,o,t=>this.tidy(t),k);const r=e.map(e=>t[e.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(t=>{for(const e of t.saved)e.dispose()}),this.state.activeTape=null),{value:s,grads:r}})}customGrad(t){return u.vA(u.Tn(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{let n;u.vA(e.every(t=>t instanceof p.qY),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const r={};return e.forEach((t,e)=>{r[e]=t}),this.runKernelFunc({forwardFunc:(r,s)=>(n=t(...e,s),u.vA(n.value instanceof p.qY,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),u.vA(u.Tn(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),backwardsFunc:(t,r)=>{const s=n.gradFunc(t,r),o=Array.isArray(s)?s:[s];u.vA(o.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),u.vA(o.every(t=>t instanceof p.qY),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const a={};return o.forEach((t,e)=>{a[e]=()=>t}),a},inputs:r})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}async time(t){const e=(0,l.now)(),n=await this.backend.time(t);return n.wallMs=(0,l.now)()-e,n}track(t){return null!=this.state.activeScope&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new b;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function v(){const t=(0,o.L)();if(null==t._tfengine){const e=new s.OH(t);t._tfengine=new y(e)}return(0,s.tj)(t._tfengine.ENV),(0,p.qP)(()=>t._tfengine),t._tfengine}y.nextTensorId=0,y.nextVariableId=0;const w=v();function k(t,e){const n={a:t,b:e};return w.runKernel(a.OM,n)}},1624:(t,e,n)=>{"use strict";n.d(e,{G:()=>y});var r=n(1585),s=n(1830),o=n(5441),a=n(565),i=n(8189),l=n(5119),u=n(7523),c=n(2198),h=n(7195),d=n(676),p=n(1890),f=n(3134),g=n(8646),m=n(929),b=n(2302);const y=(0,m.op)({fusedDepthwiseConv2d_:function({x:t,filter:e,strides:n,pad:m,dataFormat:y="NHWC",dilations:v=[1,1],dimRoundingMode:w,bias:k,activation:T="linear",preluActivationWeights:x,leakyreluAlpha:E}){if(!1===(0,g.zE)(r.T2.state.gradientDepth,T)){let r=(0,d.G)(t,e,n,m,y,v,w);return null!=k&&(r=(0,u.W)(r,k)),(0,g.f2)(r,T,x,E)}const A=(0,i.YT)(t,"x","depthwiseConv2d","float32"),S=(0,i.YT)(e,"filter","depthwiseConv2d","float32");let $=A,M=!1;3===A.rank&&(M=!0,$=(0,b.t)(A,[1,A.shape[0],A.shape[1],A.shape[2]])),l.vA(4===$.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${$.rank}.`),l.vA(4===S.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${S.rank}.`),l.vA($.shape[3]===S.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${$.shape[3]}) must match the inChannels dimension in filter ${S.shape[2]}.`),null==v&&(v=[1,1]),l.vA(h.G0(n,v),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${v}'`),null!=w&&l.vA(l.E6(m),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${w} but got pad ${m}.`);const I=h.uf($.shape,S.shape,n,v,m,w,!0);let N,_;null!=k&&(N=(0,i.YT)(k,"bias","fused conv2d"),[N]=(0,a.makeTypesMatch)(N,A),c.Ky(I.outShape,N.shape)),null!=x&&(_=(0,i.YT)(x,"prelu weights","fused depthwiseConv2d"));const D=(t,e)=>{l.vA(h.Dh(v),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${v}'`);const[r,s,o,a]=e,i=(0,g.XB)(t,o,T),u=(0,f.l)(s.shape,i,r,n,m,v,w),c=(0,p.x)(s,i,r.shape,n,m,v,w);return null!=a?[u,c,(0,g.Do)(N,i)]:[u,c]},Y={x:$,filter:S,bias:N,preluActivationWeights:_},R={strides:n,pad:m,dataFormat:y,dilations:v,dimRoundingMode:w,activation:T,leakyreluAlpha:E};if(null==k){const t=(0,s._X)((t,e,n)=>{let s=r.T2.runKernel(o.T7,Y,R);return n([e,t,s]),M&&(s=(0,b.t)(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:D}});return t($,S)}{const t=(0,s._X)((t,e,n,s)=>{let a=r.T2.runKernel(o.T7,Y,R);return s([e,t,a,n]),M&&(a=(0,b.t)(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:D}});return t($,S,N)}}})},1668:function(t,e,n){var r;!function(t,s){function o(t){var e=this,n="";e.next=function(){var t=e.b,n=e.c,r=e.d,s=e.a;return t=t<<25^t>>>7^n,n=n-r|0,r=r<<24^r>>>8^s,s=s-t|0,e.b=t=t<<20^t>>>12^n,e.c=n=n-r|0,e.d=r<<16^n>>>16^s,e.a=s-t|0},e.a=0,e.b=0,e.c=-1640531527,e.d=1367130551,t===Math.floor(t)?(e.a=t/4294967296|0,e.b=0|t):n+=t;for(var r=0;r<n.length+20;r++)e.b^=0|n.charCodeAt(r),e.next()}function a(t,e){return e.a=t.a,e.b=t.b,e.c=t.c,e.d=t.d,e}function i(t,e){var n=new o(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=i:n.amdD&&n.amdO?void 0===(r=function(){return i}.call(e,n,e,s))||(s.exports=r):this.tychei=i}(0,t=n.nmd(t),n.amdD)},1743:(t,e,n)=>{"use strict";let r;function s(){if(null==r){let t;if("undefined"!=typeof window)t=window;else if(void 0!==n.g)t=n.g;else if("undefined"!=typeof process)t=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");t=self}r=t}return r}function o(t,e){const n=function(){const t=s();return null==t._tfGlobals&&(t._tfGlobals=new Map),t._tfGlobals}();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}n.d(e,{L:()=>s,m:()=>o})},1760:(t,e,n)=>{"use strict";n.d(e,{M:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({oneHot_:function(t,e,n=1,a=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const i={indices:(0,o.YT)(t,"indices","oneHot","int32")},l={depth:e,onValue:n,offValue:a};return r.T2.runKernel(s.ur,i,l)}})},1781:(t,e,n)=>{"use strict";n.d(e,{O:()=>l});var r=n(1585),s=n(5441),o=n(8189),a=n(929),i=n(2302);const l=(0,a.op)({multinomial_:function(t,e,n,a=!1){const l=(0,o.YT)(t,"logits","multinomial"),u=l.size,c=l.rank;if(u<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${u}.`);if(c>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${c}`);n=n||Math.random();const h={logits:1===c?(0,i.t)(l,[1,-1]):l},d={numSamples:e,seed:n,normalized:a},p=r.T2.runKernel(s.WT,h,d);return 1===c?(0,i.t)(p,[p.size]):p}})},1830:(t,e,n)=>{"use strict";n.d(e,{Dv:()=>i,_X:()=>d,jY:()=>u,mu:()=>c,ok:()=>l,y7:()=>h});var r=n(1585),s=n(259),o=n(8189),a=n(5119);function i(t){return a.vA(a.Tn(t),()=>"The f passed in grad(f) must be a function"),(e,n)=>{const s=(0,o.YT)(e,"x","tf.grad","string_or_numeric"),i=null!=n?(0,o.YT)(n,"dy","tf.grad"):null;return r.T2.tidy(()=>{const{value:e,grads:n}=r.T2.gradients(()=>t(s),[s],i);return null!=i&&a.O3(e.shape,i.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),p(n),n[0]})}}function l(t){return a.vA(a.Tn(t),()=>"The f passed in grads(f) must be a function"),(e,n)=>{a.vA(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const s=(0,o.j1)(e,"args","tf.grads","string_or_numeric"),i=null!=n?(0,o.YT)(n,"dy","tf.grads"):null;return r.T2.tidy(()=>{const{value:e,grads:n}=r.T2.gradients(()=>t(...s),s,i);return null!=i&&a.O3(e.shape,i.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),p(n),n})}}function u(t){return a.vA(a.Tn(t),()=>"The f passed in valueAndGrad(f) must be a function"),(e,n)=>{a.vA(e instanceof s.qY,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),a.vA(null==n||n instanceof s.qY,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:o,value:i}=r.T2.gradients(()=>t(e),[e],n);return p(o),{grad:o[0],value:i}}}function c(t){return a.vA(a.Tn(t),()=>"The f passed in valueAndGrads(f) must be a function"),(e,n)=>{a.vA(Array.isArray(e)&&e.every(t=>t instanceof s.qY),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),a.vA(null==n||n instanceof s.qY,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const o=r.T2.gradients(()=>t(...e),e,n);return null!=n&&a.O3(o.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),p(o.grads),o}}function h(t,e){a.vA(a.Tn(t),()=>"The f passed in variableGrads(f) must be a function"),a.vA(null==e||Array.isArray(e)&&e.every(t=>t instanceof s.rT),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=null!=e;if(!n){e=[];for(const t in r.T2.registeredVariables)e.push(r.T2.registeredVariables[t])}const o=n?e.filter(t=>!t.trainable):null,i=e.length;e=e.filter(t=>t.trainable),a.vA(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`);const{value:l,grads:u}=r.T2.gradients(t,e,null,!0);a.vA(u.some(t=>null!=t),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),a.vA(0===l.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${l.rank} tensor`);const c={};return e.forEach((t,e)=>{null!=u[e]&&(c[t.name]=u[e])}),null!=o&&o.forEach(t=>c[t.name]=null),{value:l,grads:c}}function d(t){return r.T2.customGrad(t)}function p(t){if(t.filter(t=>null==t).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}},1890:(t,e,n)=>{"use strict";n.d(e,{x:()=>i});var r=n(1585),s=n(5441),o=n(929),a=n(2302);const i=(0,o.op)({depthwiseConv2dNativeBackpropFilter_:function(t,e,n,o,i,l=[1,1],u){let c=t;3===t.rank&&(c=(0,a.t)(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let h=e;3===h.rank&&(h=(0,a.t)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const d={x:c,dy:h},p={strides:o,pad:i,dimRoundingMode:u,dilations:l,filterShape:n};return r.T2.runKernel(s.X$,d,p)}})},1895:(t,e,n)=>{"use strict";n.d(e,{c:()=>l});var r=n(1585),s=n(5441),o=n(5119),a=n(929),i=n(2302);const l=(0,a.op)({conv3DBackpropInput_:function(t,e,n,a,l){o.vA(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let u=t,c=e,h=!1;4===e.rank&&(h=!0,c=(0,i.t)(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),u=[1,t[0],t[1],t[2],t[3]]);const d=u[4],p=c.shape[4];o.vA(5===u.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${u.length}.`),o.vA(5===c.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${c.rank}`),o.vA(5===n.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),o.vA(d===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${d}) must match input depth for filter ${n.shape[3]}.`),o.vA(p===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${p}) must match output depth for filter ${n.shape[4]}.`);const f={dy:c,filter:n},g={pad:l,strides:a,inputShape:u},m=r.T2.runKernel(s.gC,f,g);return h?(0,i.t)(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}})},1902:(t,e,n)=>{"use strict";n.d(e,{x:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({real_:function(t){const e={input:(0,o.YT)(t,"input","real")};return r.T2.runKernel(s.LR,e)}})},1938:(t,e,n)=>{"use strict";n.d(e,{T:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({max_:function(t,e=null,n=!1){const a={x:(0,o.YT)(t,"x","max")},i={reductionIndices:e,keepDims:n};return r.T2.runKernel(s.VA,a,i)}})},2015:(t,e,n)=>{"use strict";n.d(e,{K:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({log1p_:function(t){const e={x:(0,o.YT)(t,"x","log1p")};return r.T2.runKernel(s.Cg,e)}})},2018:(t,e,n)=>{"use strict";n.d(e,{t:()=>a});var r=n(8189),s=n(5119),o=n(9171);function a(t,e){(0,s.HO)(t);const n=(0,r.MZ)(t,e);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return(0,o.Q)(t,null,n,e)}},2046:(t,e,n)=>{"use strict";var r,s,o,a,i;n.d(e,{Tu:()=>u,ch:()=>c,rg:()=>r}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(r||(r={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(s||(s={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(o||(o={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(a||(a={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(i||(i={}));const l={float32:a,int32:s,bool:o,complex64:i};function u(t,e){if("string"===t||"string"===e){if("string"===t&&"string"===e)return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return l[t][e]}function c(t){return u(t,"int32")}},2058:(t,e,n)=>{"use strict";n.d(e,{r:()=>l});var r=n(1585),s=n(5441),o=n(565),a=n(8189),i=n(2198);const l=(0,n(929).op)({greater_:function(t,e){let n=(0,a.YT)(t,"a","greater","string_or_numeric"),l=(0,a.YT)(e,"b","greater","string_or_numeric");[n,l]=(0,o.makeTypesMatch)(n,l),(0,i.Ky)(n.shape,l.shape);const u={a:n,b:l};return r.T2.runKernel(s.Xh,u)}})},2118:(t,e,n)=>{"use strict";n.d(e,{E:()=>l});var r=n(1585),s=n(5441),o=n(565),a=n(8189),i=n(2198);const l=(0,n(929).op)({notEqual_:function(t,e){let n=(0,a.YT)(t,"a","notEqual","string_or_numeric"),l=(0,a.YT)(e,"b","notEqual","string_or_numeric");[n,l]=(0,o.makeTypesMatch)(n,l),(0,i.Ky)(n.shape,l.shape);const u={a:n,b:l};return r.T2.runKernel(s.yl,u)}})},2151:(t,e,n)=>{"use strict";n.d(e,{_:()=>l});var r=n(1585),s=n(5441),o=n(8189),a=n(3567),i=n(2198);const l=(0,n(929).op)({where_:function(t,e,n){const l=(0,o.YT)(e,"a","where"),u=(0,o.YT)(n,"b","where"),c=(0,o.YT)(t,"condition","where","bool"),h=(0,i.Ky)((0,i.Ky)(c.shape,l.shape),u.shape),d={condition:(0,a.h)(c,h),t:(0,a.h)(l,h),e:(0,a.h)(u,h)};return r.T2.runKernel(s.l6,d)}})},2198:(t,e,n)=>{"use strict";function r(t,e){const n=t.length,r=[];for(let s=0;s<n;s++){const o=n-1-s,a=t[o]||1;(e[e.length-1-s]||1)>1&&1===a&&r.unshift(o)}return r}function s(t,e){const n=[];for(let r=0;r<e.length;r++){const s=t[t.length-r-1],o=e.length-r-1,a=e[o];(null==s||1===s&&a>1)&&n.unshift(o)}return n}function o(t,e){const n=[],r=Math.max(t.length,e.length);for(let s=0;s<r;s++){let r=t[t.length-s-1];null==r&&(r=1);let o=e[e.length-s-1];if(null==o&&(o=1),1===r)n.unshift(o);else if(1===o)n.unshift(r);else{if(r!==o)throw Error(`Operands could not be broadcast together with shapes ${t} and ${e}.`);n.unshift(r)}}return n}n.d(e,{Ky:()=>o,Lx:()=>s,NE:()=>r})},2292:(t,e,n)=>{"use strict";n.d(e,{g:()=>f});var r=n(7148),s=n(5030),o=n(5040),a=n(9258),i=n(929),l=n(1902),u=n(2302),c=n(3262),h=n(5702),d=n(7986),p=n(3108);const f=(0,i.op)({irfft_:function(t){const e=t.shape[t.shape.length-1],n=t.size/e;let i;if(e<=2){const r=(0,u.t)(t,[n,e]);i=(0,p.K)(r)}else{const f=[n,2*(e-1)],g=(0,u.t)((0,l.x)(t),[n,e]),m=(0,u.t)((0,o.n)(t),[n,e]),b=(0,c.B)((0,d.d)(g,[0,1],[n,e-2]),1),y=(0,a.l)((0,c.B)((0,d.d)(m,[0,1],[n,e-2]),1),(0,h.d)(-1)),v=(0,s.x)([g,b],1),w=(0,s.x)([m,y],1),k=(0,u.t)((0,r.f)(v,w),[f[0],f[1]]);i=(0,p.K)(k)}if(i=(0,l.x)(i),3===t.rank&&0!==t.shape[0]){const e=i,n=t.shape[0];i=(0,u.t)(i,[n,i.shape[0]/n,i.shape[1]]),e.dispose()}return i}})},2302:(t,e,n)=>{"use strict";n.d(e,{t:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({reshape_:function(t,e){const n={x:(0,o.YT)(t,"x","reshape","string_or_numeric")},a={shape:e};return r.T2.runKernel(s.R2,n,a)}})},2307:(t,e,n)=>{"use strict";n.d(e,{Q:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({all_:function(t,e=null,n=!1){const a={x:(0,o.YT)(t,"x","all","bool")},i={axis:e,keepDims:n};return r.T2.runKernel(s.u8,a,i)}})},2596:(t,e,n)=>{"use strict";n.d(e,{x:()=>b});var r=n(8189),s=n(5119),o=n(4888),a=n(1078),i=n(1938),l=n(7436),u=n(929),c=n(8990),h=n(2302),d=n(5702),p=n(9348),f=n(5793),g=n(3791);function m(t,e,n=null){if(0===t.rank)return(0,o.t)(t);if(1!==t.rank&&null===n)return m((0,h.t)(t,[-1]),e,n);if(1===t.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===e)return(0,g.c)((0,o.t)(t),n);if(e===1/0)return(0,i.T)((0,o.t)(t),n);if(e===-1/0)return(0,l.j)((0,o.t)(t),n);if("euclidean"===e||2===e)return(0,p.R)((0,g.c)((0,c.n)((0,o.t)(t),(0,d.d)(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&2===n.length){if(1===e)return(0,i.T)((0,g.c)((0,o.t)(t),n[0]),n[1]-1);if(e===1/0)return(0,i.T)((0,g.c)((0,o.t)(t),n[1]),n[0]);if(e===-1/0)return(0,l.j)((0,g.c)((0,o.t)(t),n[1]),n[0]);if("fro"===e||"euclidean"===e)return(0,p.R)((0,g.c)((0,f.E)(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const b=(0,u.op)({norm_:function(t,e="euclidean",n=null,o=!1){const i=m(t=(0,r.YT)(t,"x","norm"),e,n);let l=i.shape;if(o){const e=(0,s.Y6)(n,t.shape);l=a.SM(i.shape,e)}return(0,h.t)(i,l)}})},2611:(t,e,n)=>{"use strict";n.d(e,{i:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({mean_:function(t,e=null,n=!1){const a={x:(0,o.YT)(t,"x","mean")},i={axis:e,keepDims:n};return r.T2.runKernel(s.g5,a,i)}})},2644:(t,e,n)=>{"use strict";n.d(e,{B:()=>u});var r=n(1585),s=n(5441),o=n(565),a=n(8189),i=n(2198),l=n(9809);const u=(0,n(929).op)({minimum_:function(t,e){let n=(0,a.YT)(t,"a","minimum"),u=(0,a.YT)(e,"b","minimum");[n,u]=(0,o.makeTypesMatch)(n,u),"bool"===n.dtype&&(n=(0,l.w)(n,"int32"),u=(0,l.w)(u,"int32")),(0,i.Ky)(n.shape,u.shape);const c={a:n,b:u};return r.T2.runKernel(s.LG,c)}})},2768:(t,e,n)=>{"use strict";n.d(e,{$:()=>a});var r=n(8189),s=n(5119),o=n(9171);function a(t,e,n){if((0,s.HO)(t),null!=e&&3!==e.length)throw new Error("tensor3d() requires shape to have three numbers");const a=(0,r.MZ)(t,n);if(3!==a.length&&1!==a.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===a.length&&null==e)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return(0,o.Q)(t,e,a,n)}},2804:(t,e,n)=>{"use strict";n.d(e,{H:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({acos_:function(t){const e={x:(0,o.YT)(t,"x","acos")};return r.T2.runKernel(s.Vv,e)}})},2855:(t,e,n)=>{"use strict";n.d(e,{U:()=>a});var r=n(1585),s=n(5119),o=n(7148);function a(t,e="float32"){if("complex64"===e){const e=a(t,"float32"),n=a(t,"float32");return(0,o.f)(e,n)}const n=(0,s.Ty)((0,s.Ze)(t),e);return r.T2.makeTensor(n,t,e)}},2954:(t,e,n)=>{"use strict";n.d(e,{b:()=>u});var r=n(1585),s=n(5441),o=n(8189),a=n(5119),i=n(929),l=n(2302);const u=(0,i.op)({resizeNearestNeighbor_:function(t,e,n=!1,i=!1){const u=(0,o.YT)(t,"images","resizeNearestNeighbor");a.vA(3===u.rank||4===u.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${u.rank}.`),a.vA(2===e.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),a.vA("float32"===u.dtype||"int32"===u.dtype,()=>"`images` must have `int32` or `float32` as dtype"),a.vA(!1===i||!1===n,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let c=u,h=!1;3===u.rank&&(h=!0,c=(0,l.t)(u,[1,u.shape[0],u.shape[1],u.shape[2]]));const[]=e,d={images:c},p={alignCorners:n,halfPixelCenters:i,size:e},f=r.T2.runKernel(s.jO,d,p);return h?(0,l.t)(f,[f.shape[1],f.shape[2],f.shape[3]]):f}})},3002:(t,e,n)=>{"use strict";n.d(e,{X:()=>u});var r=n(1585),s=n(5441),o=n(8189),a=n(5119),i=n(929),l=n(2302);const u=(0,i.op)({dilation2d_:function(t,e,n,i,u=[1,1],c="NHWC"){const h=(0,o.YT)(t,"x","dilation2d"),d=(0,o.YT)(e,"filter","dilation2d");a.vA(3===h.rank||4===h.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${h.rank}.`),a.vA(3===d.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${d.rank}.`),a.vA("NHWC"===c,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${c}`);let p=h,f=!1;3===h.rank&&(p=(0,l.t)(h,[1,h.shape[0],h.shape[1],h.shape[2]]),f=!0);const g={x:p,filter:d},m={strides:n,pad:i,dilations:u},b=r.T2.runKernel(s.jx,g,m);return f?(0,l.t)(b,[b.shape[1],b.shape[2],b.shape[3]]):b}})},3020:(t,e,n)=>{"use strict";n.d(e,{L:()=>l});var r=n(1585),s=n(5441),o=n(565),a=n(8189),i=n(2198);const l=(0,n(929).op)({equal_:function(t,e){let n=(0,a.YT)(t,"a","equal","string_or_numeric"),l=(0,a.YT)(e,"b","equal","string_or_numeric");[n,l]=(0,o.makeTypesMatch)(n,l),(0,i.Ky)(n.shape,l.shape);const u={a:n,b:l};return r.T2.runKernel(s.BR,u)}})},3108:(t,e,n)=>{"use strict";n.d(e,{K:()=>a});var r=n(1585),s=n(5441),o=n(5119);const a=(0,n(929).op)({ifft_:function(t){(0,o.vA)("complex64"===t.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`);const e={input:t};return r.T2.runKernel(s.OA,e)}})},3134:(t,e,n)=>{"use strict";n.d(e,{l:()=>i});var r=n(1585),s=n(5441),o=n(929),a=n(2302);const i=(0,o.op)({depthwiseConv2dNativeBackpropInput_:function(t,e,n,o,i,l=[1,1],u){let c=e,h=!1;3===e.rank&&(h=!0,c=(0,a.t)(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const d={dy:c,filter:n},p={strides:o,pad:i,dimRoundingMode:u,dilations:l,inputShape:t},f=r.T2.runKernel(s.nV,d,p);return h?(0,a.t)(f,[f.shape[1],f.shape[2],f.shape[3]]):f}})},3262:(t,e,n)=>{"use strict";n.d(e,{B:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({reverse_:function(t,e){const n={x:(0,o.YT)(t,"x","reverse")},a={dims:e};return r.T2.runKernel(s.D7,n,a)}})},3325:(t,e,n)=>{"use strict";n.d(e,{F:()=>a});var r=n(259),s=n(8189),o=n(5119);const a=async function(t,e){const n=(0,s.YT)(t,"x","setdiff1d"),a=(0,s.YT)(e,"y","setdiff1d");o.vA(n.dtype===a.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${a.dtype}).`),o.vA(1===n.rank,()=>`x should be 1D tensor, but got x (${n.shape}).`),o.vA(1===a.rank,()=>`y should be 1D tensor, but got y (${a.shape}).`);const i=await n.data(),l=await a.data(),u=new Set(l);let c=0;for(let t=0;t<i.length;t++)u.has(i[t])||c++;const h=new r.yl([c],n.dtype),d=new r.yl([c],"int32");for(let t=0,e=0;t<i.length;t++)u.has(i[t])||(h.values[e]=i[t],d.values[e]=t,e++);return[h.toTensor(),d.toTensor()]}},3330:(t,e,n)=>{"use strict";n.d(e,{V:()=>f});var r=n(8189),s=n(5119),o=n(7523),a=n(1078),i=n(8631),l=n(4010),u=n(1938),c=n(929),h=n(2302),d=n(7126),p=n(3791);const f=(0,c.op)({logSumExp_:function(t,e=null,n=!1){const c=(0,r.YT)(t,"x","logSumExp"),f=(0,s.Y6)(e,c.shape),g=(0,u.T)(c,f,!0),m=(0,d.j)(c,g),b=(0,i.o)(m),y=(0,p.c)(b,f),v=(0,l.R)(y),w=(0,o.W)((0,h.t)(g,v.shape),v);if(n){const t=(0,a.SM)(w.shape,f);return(0,h.t)(w,t)}return w}})},3337:(t,e,n)=>{"use strict";n.d(e,{D:()=>l});var r=n(1585),s=n(5441),o=n(565),a=n(8189),i=n(2198);const l=(0,n(929).op)({greaterEqual_:function(t,e){let n=(0,a.YT)(t,"a","greaterEqual","string_or_numeric"),l=(0,a.YT)(e,"b","greaterEqual","string_or_numeric");[n,l]=(0,o.makeTypesMatch)(n,l),(0,i.Ky)(n.shape,l.shape);const u={a:n,b:l};return r.T2.runKernel(s.lL,u)}})},3416:(t,e,n)=>{"use strict";n.d(e,{P:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({elu_:function(t){const e={x:(0,o.YT)(t,"x","elu","float32")};return r.T2.runKernel(s.P,e)}})},3427:(t,e,n)=>{"use strict";n.d(e,{P:()=>l});var r=n(1585),s=n(5441),o=n(565),a=n(8189),i=n(2198);const l=(0,n(929).op)({squaredDifference_:function(t,e){let n=(0,a.YT)(t,"a","squaredDifference"),l=(0,a.YT)(e,"b","squaredDifference");[n,l]=(0,o.makeTypesMatch)(n,l),(0,i.Ky)(n.shape,l.shape);const u={a:n,b:l};return r.T2.runKernel(s.Dd,u,{})}})},3454:(t,e,n)=>{"use strict";n.d(e,{E:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({isInf_:function(t){const e={x:(0,o.YT)(t,"x","isInf")};return r.T2.runKernel(s.E3,e)}})},3502:(t,e,n)=>{"use strict";n.d(e,{X:()=>y});var r=n(1585),s=n(1830),o=n(5441),a=n(565),i=n(8189),l=n(5119),u=n(7523),c=n(2198),h=n(8794),d=n(5248),p=n(252),f=n(7195),g=n(8646),m=n(929),b=n(2302);const y=(0,m.op)({fusedConv2d_:function({x:t,filter:e,strides:n,pad:m,dataFormat:y="NHWC",dilations:v=[1,1],dimRoundingMode:w,bias:k,activation:T="linear",preluActivationWeights:x,leakyreluAlpha:E}){if(T=T||"linear",!1===(0,g.zE)(r.T2.state.gradientDepth,T)){let r=(0,h.X)(t,e,n,m,y,v,w);return null!=k&&(r=(0,u.W)(r,k)),(0,g.f2)(r,T,x,E)}const A=(0,i.YT)(t,"x","conv2d","float32"),S=(0,i.YT)(e,"filter","conv2d","float32");let $=A,M=!1;3===A.rank&&(M=!0,$=(0,b.t)(A,[1,A.shape[0],A.shape[1],A.shape[2]])),l.vA(4===$.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${$.rank}.`),l.vA(4===S.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${S.rank}.`),null!=w&&l.vA(l.E6(m),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${w} but got pad ${m}.`),l.vA($.shape[3]===S.shape[2],()=>`Error in conv2d: depth of input (${$.shape[3]}) must match input depth for filter ${S.shape[2]}.`),l.vA(f.G0(n,v),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${v}'`),l.vA("NHWC"===y,()=>`Error in conv2d: got dataFormat of ${y} but only NHWC is currently supported.`);const I=f.uf($.shape,S.shape,n,v,m,w);let N,_;null!=k&&(N=(0,i.YT)(k,"bias","fused conv2d"),[N]=(0,a.makeTypesMatch)(N,A),c.Ky(I.outShape,N.shape)),null!=x&&(_=(0,i.YT)(x,"prelu weights","fused conv2d"));const D=(t,e)=>{const[r,s,o,a]=e,i=(0,g.XB)(t,o,T);l.vA(f.Dh(v),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${v}'`);const u=[(0,p.v)(s.shape,i,r,n,m),(0,d.H)(s,i,r.shape,n,m)];if(null!=a){const t=(0,g.Do)(a,i);u.push(t)}return u},Y={x:$,filter:S,bias:N,preluActivationWeights:_},R={strides:n,pad:m,dataFormat:y,dilations:v,dimRoundingMode:w,activation:T,leakyreluAlpha:E};if(null==k){const t=(0,s._X)((t,e,n)=>{let s=r.T2.runKernel(o.aA,Y,R);return n([e,t,s]),M&&(s=(0,b.t)(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:D}});return t($,S)}{const t=(0,s._X)((t,e,n,s)=>{let a=r.T2.runKernel(o.aA,Y,R);return s([e,t,a,n]),M&&(a=(0,b.t)(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:D}});return t($,S,N)}}})},3531:(t,e,n)=>{"use strict";n.d(e,{K:()=>u});var r=n(1585),s=n(5441),o=n(8189),a=n(5119),i=n(929),l=n(2302);const u=(0,i.op)({localResponseNormalization_:function(t,e=5,n=1,i=1,u=.5){const c=(0,o.YT)(t,"x","localResponseNormalization");a.vA(4===c.rank||3===c.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${c.rank}.`),a.vA(a.E6(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let h=c,d=!1;3===c.rank&&(d=!0,h=(0,l.t)(c,[1,c.shape[0],c.shape[1],c.shape[2]]));const p={x:h},f={depthRadius:e,bias:n,alpha:i,beta:u},g=r.T2.runKernel(s.jM,p,f);return d?(0,l.t)(g,[g.shape[1],g.shape[2],g.shape[3]]):g}})},3567:(t,e,n)=>{"use strict";n.d(e,{h:()=>u});var r=n(1585),s=n(5441),o=n(8189),a=n(125),i=n(929),l=n(2302);const u=(0,i.op)({broadcastTo_:function(t,e){let n=(0,o.YT)(t,"broadcastTo","x");const i=n.shape;if(e.some(t=>!(t>0)||t%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const t=n.shape.slice();for(;t.length<e.length;)t.unshift(1);n=(0,l.t)(n,t)}const u=n.shape,c=Array.from(e);for(let t=e.length-1;t>=0;t--)if(u[t]===e[t])c[t]=1;else if(1!==n.shape[t])throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${e}].`);if(0===c.map((t,e)=>t>1?e:-1).filter(t=>t>=0).length)return(0,a.o)(n);const h={x:n},d={reps:c};return r.T2.runKernel(s.FA,h,d)}})},3673:(t,e,n)=>{"use strict";n.d(e,{R:()=>o,i:()=>s});var r=n(6574);function s(...t){(0,r._K)().getBool("IS_TEST")||(0,r._K)().getBool("PROD")||console.warn(...t)}function o(...t){(0,r._K)().getBool("IS_TEST")||(0,r._K)().getBool("PROD")||console.log(...t)}},3701:(t,e,n)=>{"use strict";n.d(e,{k:()=>u});var r=n(8189),s=n(5119),o=n(8794),a=n(7195),i=n(929),l=n(2302);const u=(0,i.op)({conv1d_:function(t,e,n,i,u="NWC",c=1,h){const d=(0,r.YT)(t,"x","conv1d"),p=(0,r.YT)(e,"filter","conv1d");let f=d,g=!1;2===d.rank&&(g=!0,f=(0,l.t)(d,[1,d.shape[0],d.shape[1]])),s.vA(3===f.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${f.rank}.`),s.vA(3===p.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${p.rank}.`),null!=h&&s.vA(s.E6(i),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${h} but got pad ${i}.`),s.vA(f.shape[2]===p.shape[1],()=>`Error in conv1d: depth of input (${f.shape[2]}) must match input depth for filter ${p.shape[1]}.`),s.vA(a.G0(n,c),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${c}'`),s.vA("NWC"===u,()=>`Error in conv1d: got dataFormat of ${u} but only NWC is currently supported.`);const m=(0,l.t)(p,[1,p.shape[0],p.shape[1],p.shape[2]]),b=(0,l.t)(f,[f.shape[0],1,f.shape[1],f.shape[2]]),y=[1,n],v=[1,c],w=(0,o.X)(b,m,y,i,"NHWC",v,h);return g?(0,l.t)(w,[w.shape[2],w.shape[3]]):(0,l.t)(w,[w.shape[0],w.shape[2],w.shape[3]])}})},3726:(t,e,n)=>{"use strict";n.d(e,{F:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({sin_:function(t){const e={x:(0,o.YT)(t,"x","sin","float32")};return r.T2.runKernel(s.hq,e)}})},3732:(t,e,n)=>{"use strict";n.d(e,{j:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({relu6_:function(t){const e={x:(0,o.YT)(t,"x","relu6")};return r.T2.runKernel(s.P_,e)}})},3774:(t,e,n)=>{"use strict";n.d(e,{r:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({atanh_:function(t){const e={x:(0,o.YT)(t,"x","atanh")};return r.T2.runKernel(s.zP,e)}})},3789:(t,e,n)=>{"use strict";n.d(e,{n:()=>i});var r=n(1585),s=n(5441),o=n(8189),a=n(2198);const i=(0,n(929).op)({logicalAnd_:function(t,e){const n=(0,o.YT)(t,"a","logicalAnd","bool"),i=(0,o.YT)(e,"b","logicalAnd","bool");(0,a.Ky)(n.shape,i.shape);const l={a:n,b:i};return r.T2.runKernel(s.RU,l)}})},3791:(t,e,n)=>{"use strict";n.d(e,{c:()=>i});var r=n(1585),s=n(5441),o=n(8189),a=n(9809);const i=(0,n(929).op)({sum_:function(t,e=null,n=!1){let i=(0,o.YT)(t,"x","sum");"bool"===i.dtype&&(i=(0,a.w)(i,"int32"));const l={x:i},u={axis:e,keepDims:n};return r.T2.runKernel(s.Wu,l,u)}})},3855:(t,e,n)=>{"use strict";n.d(e,{s:()=>c});var r=n(1585),s=n(5441),o=n(8189),a=n(5119),i=n(9809),l=n(929),u=n(2302);const c=(0,l.op)({avgPool3d_:function(t,e,n,l,c,h="NDHWC"){const d=(0,o.YT)(t,"x","avgPool3d","float32");let p=d,f=!1;4===d.rank&&(f=!0,p=(0,u.t)(d,[1,d.shape[0],d.shape[1],d.shape[2],d.shape[3]])),a.vA(5===p.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${p.rank}.`),a.vA("NDHWC"===h,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${h}`),null!=c&&a.vA(a.E6(l),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${c} but got pad ${l}.`);const g={x:p},m={filterSize:e,strides:n,pad:l,dimRoundingMode:c,dataFormat:h};let b=r.T2.runKernel(s.cS,g,m);return b=(0,i.w)(b,p.dtype),f?(0,u.t)(b,[b.shape[1],b.shape[2],b.shape[3],b.shape[4]]):b}})},3879:(t,e,n)=>{"use strict";n.r(e),n.d(e,{arraysEqual:()=>s.r1,assert:()=>s.vA,assertNonNegativeIntegerDimensions:()=>s.SA,assertNonNull:()=>s.HO,assertShapesMatch:()=>s.O3,bytesFromStringArray:()=>s.SL,bytesPerElement:()=>s.jv,checkConversionForErrors:()=>s.nd,clamp:()=>s.qE,computeStrides:()=>s.Ur,createScalarValue:()=>v,createShuffledIndices:()=>s.P8,decodeString:()=>E,distSquared:()=>s.oO,encodeString:()=>x,fetch:()=>T,fingerPrint64:()=>y,flatten:()=>s.Bq,getArrayFromDType:()=>s.Ab,getTypedArrayFromDType:()=>s.ce,hasEncodingLoss:()=>s.BE,hexToLong:()=>i,indexToLoc:()=>s._k,inferDtype:()=>s.X$,inferFromImplicitShape:()=>s.XT,isBoolean:()=>s.Lm,isFunction:()=>s.Tn,isInt:()=>s.E6,isNumber:()=>s.Et,isPromise:()=>s.yL,isScalarShape:()=>s.Sf,isString:()=>s.Kg,isTypedArray:()=>s.iu,isValidDtype:()=>s.xn,locToIndex:()=>s.sX,makeOnesTypedArray:()=>s.FZ,makeZerosNestedTypedArray:()=>s.c7,makeZerosTypedArray:()=>s.Ty,nearestDivisor:()=>s.lK,nearestLargerEven:()=>s.eV,now:()=>k,parseAxisParam:()=>s.Y6,randUniform:()=>s.so,repeatedTry:()=>s._q,rightPad:()=>s.av,shuffle:()=>s.k4,shuffleCombo:()=>s.a0,sizeFromShape:()=>s.Ze,sizeToSquarishShape:()=>s.gS,squeezeShape:()=>s.gx,sum:()=>s.cz,swap:()=>s.wg,tanh:()=>s.ym,toNestedArray:()=>s.yw,toTypedArray:()=>w});var r=n(6574),s=n(5119),o=n(8570);const a=n.n(o)()||o;function i(t){return a.fromString(t,!0,16)}const l=i("c3a5c85c97cb3127"),u=i("b492b66fbe98f273"),c=i("9ae16a3b2f90404f");function h(t){return t.xor(t.shru(47))}function d(t,e,n){const r=t.slice(e,e+n);return a.fromBytes(Array.from(r),!0,!0)}function p(t,e){return d(t,e,8)}function f(t,e){return d(t,e,4)}function g(t,e){return 0===e?t:t.shru(e).or(t.shl(64-e))}function m(t,e,n=i("9ddfea08eb382d69")){let r=t.xor(e).mul(n);r=r.xor(r.shru(47));let s=e.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function b(t,e,n,r){return function(t,e,n,r,s,o){s=s.add(t),o=g(o.add(s).add(r),21);const a=s;return s=(s=s.add(e)).add(n),o=o.add(g(s,44)),[s.add(r),o.add(a)]}(p(t,e),p(t,e+8),p(t,e+16),p(t,e+24),n,r)}function y(t,e=t.length){const n=a.fromNumber(81,!0);if(e<=32)return e<=16?function(t,e=t.length){if(e>=8){const n=c.add(2*e),r=p(t,0).add(c),s=p(t,e-8);return m(g(s,37).mul(n).add(r),g(r,25).add(s).mul(n),n)}if(e>=4){const n=c.add(2*e);return m(f(t,0).shl(3).add(e),f(t,e-4),n)}if(e>0){const n=t[0]+(t[e>>1]<<8),r=e+(t[e-1]<<2);return h(c.mul(n).xor(l.mul(r))).mul(c)}return c}(t,e):function(t,e=t.length){const n=c.add(2*e),r=p(t,0).mul(u),s=p(t,8),o=p(t,e-8).mul(n),a=p(t,e-16).mul(c);return m(g(r.add(s),43).add(g(o,30)).add(a),r.add(g(s.add(c),18)).add(o),n)}(t,e);if(e<=64)return function(t,e=t.length){const n=c.add(2*e),r=p(t,0).mul(c),s=p(t,8),o=p(t,e-8).mul(n),a=p(t,e-16).mul(c),i=g(r.add(s),43).add(g(o,30)).add(a),l=m(i,r.add(g(s.add(c),18)).add(o),n),u=p(t,16).mul(n),h=p(t,24),d=i.add(p(t,e-32)).mul(n),f=l.add(p(t,e-24)).mul(n);return m(g(u.add(h),43).add(g(d,30)).add(f),u.add(g(h.add(r),18)).add(d),n)}(t,e);let r=n,s=n.mul(u).add(113),o=h(s.mul(c).add(113)).mul(c),i=[a.UZERO,a.UZERO],d=[a.UZERO,a.UZERO];r=r.mul(c).add(p(t,0));let y=0;const v=64*(e-1>>6),w=v+(e-1&63)-63;do{r=g(r.add(s).add(i[0]).add(p(t,y+8)),37).mul(u),s=g(s.add(i[1]).add(p(t,y+48)),42).mul(u),r=r.xor(d[1]),s=s.add(i[0]).add(p(t,y+40)),o=g(o.add(d[0]),33).mul(u),i=b(t,y,i[1].mul(u),r.add(d[0])),d=b(t,y+32,o.add(d[1]),s.add(p(t,y+16))),[o,r]=[r,o],y+=64}while(y!==v);const k=u.add(o.and(255).shl(1));return y=w,d[0]=d[0].add(e-1&63),i[0]=i[0].add(d[0]),d[0]=d[0].add(i[0]),r=g(r.add(s).add(i[0]).add(p(t,y+8)),37).mul(k),s=g(s.add(i[1]).add(p(t,y+48)),42).mul(k),r=r.xor(d[1].mul(9)),s=s.add(i[0].mul(9).add(p(t,y+40))),o=g(o.add(d[0]),33).mul(k),i=b(t,y,i[1].mul(k),r.add(d[0])),d=b(t,y+32,o.add(d[1]),s.add(p(t,y+16))),[o,r]=[r,o],m(m(i[0],d[0],k).add(h(s).mul(l)).add(o),m(i[1],d[1],k).add(r),k)}function v(t,e){return"string"===e?x(t):w([t],e)}function w(t,e){if("string"===e)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=s.Bq(t)),(0,r._K)().getBool("DEBUG")&&s.nd(t,e),function(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}(t,e))return t;if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e){const e=new Uint8Array(t.length);for(let n=0;n<e.length;++n)0!==Math.round(t[n])&&(e[n]=1);return e}throw new Error(`Unknown data type ${e}`)}function k(){return(0,r._K)().platform.now()}function T(t,e){return(0,r._K)().platform.fetch(t,e)}function x(t,e="utf-8"){return e=e||"utf-8",(0,r._K)().platform.encode(t,e)}function E(t,e="utf-8"){return e=e||"utf-8",(0,r._K)().platform.decode(t,e)}},3909:(t,e,n)=>{"use strict";n.d(e,{$:()=>h});var r=n(1585),s=n(5441),o=n(8189),a=n(5119),i=n(9809),l=n(7195),u=n(929),c=n(2302);const h=(0,u.op)({avgPool_:function(t,e,n,u,h){const d=(0,o.YT)(t,"x","avgPool","float32");a.vA(l.G0(n,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`);let p=d,f=!1;3===d.rank&&(f=!0,p=(0,c.t)(d,[1,d.shape[0],d.shape[1],d.shape[2]])),a.vA(4===p.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${p.rank}.`),null!=h&&a.vA(a.E6(u),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${h} but got pad ${u}.`);const g={x:p},m={filterSize:e,strides:n,pad:u,dimRoundingMode:h};let b=r.T2.runKernel(s.ho,g,m);return b=(0,i.w)(b,d.dtype),f?(0,c.t)(b,[b.shape[1],b.shape[2],b.shape[3]]):b}})},3937:(t,e,n)=>{"use strict";n.d(e,{A:()=>i});var r=n(1585),s=n(5441),o=n(8189),a=n(5119);const i=(0,n(929).op)({unique_:function(t,e=0){const n=(0,o.YT)(t,"x","unique","string_or_numeric");(0,a.vA)(n.rank>0,()=>"The input tensor must be at least 1D");const i={x:n},l={axis:e},[u,c]=r.T2.runKernel(s.Ew,i,l);return{values:u,indices:c}}})},4010:(t,e,n)=>{"use strict";n.d(e,{R:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({log_:function(t){const e={x:(0,o.YT)(t,"x","log","float32")};return r.T2.runKernel(s.M3,e)}})},4027:(t,e,n)=>{"use strict";n.d(e,{O:()=>o});var r=n(8189),s=n(9171);function o(t,e,n){const o=(0,r.MZ)(t,n);return(0,s.Q)(t,e,o,n)}},4268:(t,e,n)=>{"use strict";n.d(e,{t:()=>i});var r=n(1585),s=n(5441),o=n(8189),a=n(5119);const i=(0,n(929).op)({stack_:function(t,e=0){const n=(0,o.j1)(t,"tensors","stack","string_or_numeric");a.vA(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&a.vA(e<=n[0].rank,()=>"Axis must be <= rank of the tensor");const i=n,l={axis:e};return r.T2.runKernel(s.mM,i,l)}})},4339:(t,e,n)=>{"use strict";n.d(e,{X:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({argMin_:function(t,e=0){const n={x:(0,o.YT)(t,"x","argMin")},a={axis:e};return r.T2.runKernel(s.p_,n,a)}})},4349:(t,e,n)=>{"use strict";n.d(e,{e:()=>u});var r=n(1585),s=n(5441),o=n(8189),a=n(5119),i=n(929),l=n(2302);const u=(0,i.op)({maxPool3d_:function(t,e=[1,1,1],n,i,u,c="NDHWC"){const h=(0,o.YT)(t,"x","maxPool3d");let d=h,p=!1;4===h.rank&&(p=!0,d=(0,l.t)(h,[1,h.shape[0],h.shape[1],h.shape[2],h.shape[3]])),a.vA(5===d.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${d.rank}.`),a.vA("NDHWC"===c,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${c}`),null!=u&&a.vA(a.E6(i),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${u} but got pad ${i}.`);const f={x:d},g={filterSize:e,strides:n,pad:i,dimRoundingMode:u,dataFormat:c},m=r.T2.runKernel(s.yS,f,g);return p?(0,l.t)(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}})},4394:(t,e,n)=>{"use strict";n.d(e,{N:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({prelu_:function(t,e){const n={x:(0,o.YT)(t,"x","prelu"),alpha:(0,o.YT)(e,"alpha","prelu")};return r.T2.runKernel(s.Nc,n)}})},4411:(t,e,n)=>{"use strict";n.d(e,{Y:()=>s});var r=n(448);function s(t,e){const n=[];for(let t=0;t<e.length;t++)e[t]&&n.push(t);const s=(0,r.r)(t,"int32"),o=(0,r.r)([n.length,t.length],"int32");for(let e=0;e<n.length;e++){const r=s.indexToLoc(n[e]),a=e*t.length;o.values.set(r,a)}return o.toTensor()}},4645:(t,e,n)=>{"use strict";n.d(e,{y:()=>o});var r=n(1585),s=n(5441);function o(t,e,n=1,o="float32"){if(0===n)throw new Error("Cannot have a step of zero");const a={start:t,stop:e,step:n,dtype:o};return r.T2.runKernel(s.Q6,{},a)}},4711:(t,e,n)=>{"use strict";n.d(e,{v:()=>u});var r=n(1585),s=n(5441),o=n(8189),a=n(5119),i=n(929),l=n(2302);const u=(0,i.op)({resizeBilinear_:function(t,e,n=!1,i=!1){const u=(0,o.YT)(t,"images","resizeBilinear");a.vA(3===u.rank||4===u.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${u.rank}.`),a.vA(2===e.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),a.vA(!1===i||!1===n,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let c=u,h=!1;3===u.rank&&(h=!0,c=(0,l.t)(u,[1,u.shape[0],u.shape[1],u.shape[2]]));const[]=e,d={images:c},p={alignCorners:n,halfPixelCenters:i,size:e},f=r.T2.runKernel(s.hg,d,p);return h?(0,l.t)(f,[f.shape[1],f.shape[2],f.shape[3]]):f}})},4791:(t,e,n)=>{"use strict";n.d(e,{N:()=>l});var r=n(1585),s=n(5441),o=n(8189),a=n(929),i=n(6170);const l=(0,a.op)({scatterND_:function(t,e,n){const a=(0,o.YT)(t,"indices","scatterND","int32"),l=(0,o.YT)(e,"updates","scatterND");i.validateInput(l,a,n);const u={indices:a,updates:l},c={shape:n};return r.T2.runKernel(s.pJ,u,c)}})},4826:(t,e,n)=>{"use strict";n.d(e,{V:()=>i});var r=n(1585),s=n(5441),o=n(8189),a=n(5119);const i=(0,n(929).op)({tile_:function(t,e){const n=(0,o.YT)(t,"x","tile","string_or_numeric");a.vA(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`);const i={x:n},l={reps:e};return r.T2.runKernel(s.FA,i,l)}})},4888:(t,e,n)=>{"use strict";n.d(e,{t:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({abs_:function(t){const e=(0,o.YT)(t,"x","abs");if("complex64"===e.dtype){const t={x:e};return r.T2.runKernel(s.$z,t)}{const t={x:e};return r.T2.runKernel(s.lj,t)}}})},4969:(t,e,n)=>{"use strict";n.r(e),n.d(e,{assertParamsValid:()=>a,computeFlatOffset:()=>v,computeOutShape:()=>l,getNormalizedAxes:()=>d,isSliceContinous:()=>y,maskToAxes:()=>i,parseSliceParams:()=>w,sliceInfo:()=>k,startForAxis:()=>m,startIndicesWithElidedDims:()=>p,stopForAxis:()=>b,stopIndicesWithElidedDims:()=>f,stridesForAxis:()=>g,stridesWithElidedDims:()=>u});var r=n(5119);const s=-2,o=-1;function a(t,e,n){const s=t.shape.length;r.vA(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),r.vA(s===n.length,()=>`Error in slice${s}D: Length of size ${n} must match the rank of the array (${s}).`);for(let o=0;o<s;++o)r.vA(e[o]+n[o]<=t.shape[o],()=>`Error in slice${s}D: begin[${o}] + size[${o}] (${e[o]+n[o]}) would overflow input.shape[${o}] (${t.shape[o]})`)}function i(t){const e=[];let n=0;for(;t>0;)1&t&&e.push(n),t/=2,n++;return e}function l(t,e,n){const r=[];for(let s=0;s<t.length;s++)r[s]=Math.ceil((e[s]-t[s])/n[s]);return r}function u(t,e,n,r){const s=[...t];for(let t=s.length;t<r.length;t++)s.push(1);for(let t=0;t<n;t++)0===t?s[e]=1:(s.splice(e,0,1),s.pop());return s}function c(t,e,n){return n<=t?n:n-(e-1)}function h(t,e){const n=[];for(let r=0;r<t;r++)n.push(e+r);return n}function d(t,e,n,r,s,o,a,i,l){const c=t.length;let h=new Array(c),d=new Array(c),y=new Array(c);if(e.length&&n>0){const l=e[0],c=n+1;h=p(a,l,c,r,t),d=f(i,l,c,s,t),y=u(o,l,c,t)}else for(let e=0;e<c;e++)h[e]=m(a,r,o,t,e,l),d[e]=b(i,s,o,t,e,l),y[e]=g(o,e,l);return{begin:h,end:d,strides:y}}function p(t,e,n,r,s){const o=[...s],a=h(n,e);for(let s=0;s<o.length;s++)if(a.indexOf(s)>-1)o[s]=0;else{const a=c(e,n,s);let i=r[a];t&1<<a&&(i=0),o[s]=i}return o}function f(t,e,n,s,o){const a=[...o],i=h(n,e);for(let r=0;r<a.length;r++)if(i.indexOf(r)>-1)a[r]=Number.MAX_SAFE_INTEGER;else{const o=c(e,n,r);let i=s[o];t&1<<o&&(i=Number.MAX_SAFE_INTEGER),a[r]=i}for(let t=0;t<a.length;t++){const e=o[t];a[t]<0&&(a[t]+=e),a[t]=r.qE(0,a[t],o[t])}return a}function g(t,e,n){let r=t[e];return(n&1<<e||null==r)&&(r=1),r}function m(t,e,n,s,o,a){let i=e[o];const l=n[o]||1;(t&1<<o||a&1<<o||null==i)&&(i=l>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const u=s[o];return i<0&&(i+=u),i=r.qE(0,i,u-1),i}function b(t,e,n,s,o,a){let i=e[o];const l=n[o]||1;(t&1<<o||a&1<<o||null==i)&&(i=l>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const u=s[o];return i<0&&(i+=u),i=l>0?r.qE(0,i,u):r.qE(-1,i,u-1),i}function y(t,e,n){let r=n.length;for(let t=0;t<n.length;t++)if(n[t]>1){r=t;break}for(let s=r+1;s<n.length;s++)if(e[s]>0||n[s]!==t[s])return!1;return!0}function v(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function w(t,e,n){let s;const o=t.shape.length;let a;return s="number"==typeof e?[e,...new Array(o-1).fill(0)]:e.length<o?e.concat(new Array(o-e.length).fill(0)):e.slice(),s.forEach(t=>{r.vA(-1!==t,()=>"slice() does not support negative begin indexing.")}),a=null==n?new Array(o).fill(-1):"number"==typeof n?[n,...new Array(o-1).fill(-1)]:n.length<o?n.concat(new Array(o-n.length).fill(-1)):n,a=a.map((e,n)=>e>=0?e:(r.vA(-1===e,()=>`Negative size values should be exactly -1 but got ${e} for the slice() size at index ${n}.`),t.shape[n]-s[n])),[s,a]}function k(t,e,n,r,a,i,l,u,c){let h;if(null==r?(h=new Array(e.length),h.fill(1)):h=r,null!=l&&l&l-1)throw new Error("Multiple ellipses in slice is not allowed.");let d=!1;const p={dims:h.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:n.slice(),strides:h.slice(),beginMask:a,endMask:i,ellipsisMask:l,newAxisMask:u,shrinkAxisMask:c};for(let t=0;t<p.dims;t++)d&&1<<t&u&&p.numAddAxisAfterEllipsis++,1<<t&l&&(d=!0);d||(p.ellipsisMask|=1<<p.dims,p.dims++);const f={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(t,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let n=0;e.beginValid=null!=t.begin,e.endValid=null!=t.end,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<t.dims;r++)if(1<<r&t.ellipsisMask){const s=Math.min(e.dims-(t.dims-r)+1+t.numAddAxisAfterEllipsis,e.dims);for(;n<s;n++)e.begin[n]=0,e.end[n]=0,e.strides[n]=1,e.beginMask|=1<<n,e.endMask|=1<<n,e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&t.newAxisMask)e.finalShapeGatherIndices.push(s),e.finalShapeGatherIndicesSparse.push(-1);else{if(n===e.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${e.dims} dims, ${e.begin.length}.`);null!=t.begin&&(e.begin[n]=t.begin[r]),null!=t.end&&(e.end[n]=t.end[r]),e.strides[n]=t.strides[r],t.beginMask&1<<r&&(e.beginMask|=1<<n),t.endMask&1<<r&&(e.endMask|=1<<n),t.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(o),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<n):(e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[n]=r,n++}}(p,f);let g=!0,m=!0,b=!0;const y=[],v=[];for(let e=0;e<t.length;++e){if(0===f.strides[e])throw Error(`strides[${e}] must be non-zero`);const n=!!(f.shrinkAxisMask&1<<e),r=t[e];if(-1===r){y.push(n?1:-1);continue}const s=[f.beginMask&1<<e,f.endMask&1<<e],o=[f.strides[e]>0?0:-1,f.strides[e]>0?r:r-1];if(n&&f.strides[e]<=0)throw Error("only stride 1 allowed on non-range indexing.");b=b&&1===f.strides[e];const a=!!(f.beginMask&1<<e&&f.endMask&1<<e);if(f.beginValid&&f.endValid){if(n){const t=f.begin[e]<0?r+f.begin[e]:f.begin[e];if(f.begin[e]=t,f.end[e]=f.begin[e]+1,t<0||t>=r)throw Error(`slice index ${f.begin[e]} of dimension ${e} out of bounds.`)}else f.begin[e]=T(f.begin[e],0,f.strides[e],r,s,o),f.end[e]=T(f.end[e],1,f.strides[e],r,s,o);const t=1===f.strides[e]&&0===f.begin[e]&&f.end[e]===r;g=g&&t,m=m&&(0===e&&1===f.strides[e]||t)}else g=g&&1===f.strides[e]&&a,m=m&&(0===e&&1===f.strides[e]||a);let i,l=!1;if(f.beginValid&&f.endValid?(i=f.end[e]-f.begin[e],l=!0):n?(i=1,l=!0):a&&r>=0&&(i=f.strides[e]<0?-r:r,l=!0),l){let t;t=0===i||i<0!=f.strides[e]<0?0:Math.trunc(i/f.strides[e])+(i%f.strides[e]!==0?1:0),y.push(t)}else y.push(-1)}for(let t=0;t<f.finalShapeGatherIndices.length;++t){const e=f.finalShapeGatherIndices[t];e>=0?v.push(y[e]):e===s&&v.push(1)}return{finalShapeSparse:v.filter((t,e)=>f.finalShapeGatherIndices[e]!==s),finalShape:v,isIdentity:g,sliceDim0:m,isSimpleSlice:b,begin:f.begin,end:f.end,strides:f.strides}}function T(t,e,n,r,s,o){if(s[e])return n>0?o[e]:o[e+1&1];{const e=t<0?r+t:t;return e<o[0]?o[0]:e>o[1]?o[1]:e}}},5030:(t,e,n)=>{"use strict";n.d(e,{x:()=>l});var r=n(1585),s=n(5441),o=n(8189),a=n(5119),i=n(125);const l=(0,n(929).op)({concat_:function(t,e=0){(0,a.vA)(t.length>=1,()=>"Pass at least one tensor to concat");const n=(0,o.j1)(t,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach(t=>{if("complex64"!==t.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${t.dtype}. `)}),1===n.length)return(0,i.o)(n[0]);const l=n,u={axis:e};return r.T2.runKernel(s.$d,l,u)}})},5040:(t,e,n)=>{"use strict";n.d(e,{n:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({imag_:function(t){const e={input:(0,o.YT)(t,"input","imag")};return r.T2.runKernel(s.dv,e)}})},5119:(t,e,n)=>{"use strict";function r(t){let e=t.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,i(t,e,n)}function s(t,e){if(t.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${t.length}Second array length was ${e.length}`);let n=t.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,i(t,n,r),i(e,n,r)}function o(t,e,n){return Math.max(t,Math.min(e,n))}function a(t){return t%2==0?t:t+1}function i(t,e,n){const r=t[e];t[e]=t[n],t[n]=r}function l(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function u(t,e){const n=Math.random();return e*n+(1-n)*t}function c(t,e){let n=0;for(let r=0;r<t.length;r++){const s=Number(t[r])-Number(e[r]);n+=s*s}return n}function h(t,e){if(!t)throw new Error("string"==typeof e?e:e())}function d(t,e,n=""){h(b(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function p(t){h(null!=t,()=>"The input to the tensor constructor must be a non-null value.")}function f(t,e=[],n=!1){if(null==e&&(e=[]),Array.isArray(t)||D(t)&&!n)for(let r=0;r<t.length;++r)f(t[r],e,n);else e.push(t);return e}function g(t){if(0===t.length)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function m(t){return 0===t.length}function b(t,e){if(t===e)return!0;if(null==t||null==e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function y(t){return t%1==0}function v(t){if(null!=Math.tanh)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;{const e=Math.exp(2*t);return(e-1)/(e+1)}}function w(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function k(t){const e=new Uint32Array(t);for(let n=0;n<t;++n)e[n]=n;return r(e),e}function T(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function x(t,e=t=>0,n){return new Promise((r,s)=>{let o=0;const a=()=>{if(t())return void r();o++;const i=e(o);null!=n&&o>=n?s():setTimeout(a,i)};a()})}function E(t,e){let n=1,r=-1;for(let e=0;e<t.length;++e)if(t[e]>=0)n*=t[e];else if(-1===t[e]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${e}`);r=e}else if(t[e]<0)throw Error(`Shapes can not be < 0. Found ${t[e]} at dim ${e}`);if(-1===r){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(0===n)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const s=t.slice();return s[r]=e/n,s}function A(t,e){const n=e.length;return h((t=null==t?e.map((t,e)=>e):[].concat(t)).every(t=>t>=-n&&t<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`),h(t.every(t=>y(t)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(t=>t<0?n+t:t)}function S(t,e){const n=[],r=[],s=null!=e&&Array.isArray(e)&&0===e.length,o=null==e||s?null:A(e,t).sort();let a=0;for(let e=0;e<t.length;++e){if(null!=o){if(o[a]===e&&1!==t[e])throw new Error(`Can't squeeze axis ${e} since its dim '${t[e]}' is not 1`);(null==o[a]||o[a]>e)&&1===t[e]&&(n.push(t[e]),r.push(e)),o[a]<=e&&a++}1!==t[e]&&(n.push(t[e]),r.push(e))}return{newShape:n,keptDims:r}}function $(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else{if("bool"!==t)throw new Error(`Unknown data type ${t}`);n=new Uint8Array(e)}return n}function M(t,e){let n=null;if(null==t||"float32"===t)n=new Float32Array(e);else if("int32"===t)n=new Int32Array(e);else if("bool"===t)n=new Uint8Array(e);else{if("string"!==t)throw new Error(`Unknown data type ${t}`);n=new Array(e)}return n}function I(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function N(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}function _(t,e){return!("complex64"===e||"float32"===e&&"complex64"!==t||"int32"===e&&"float32"!==t&&"complex64"!==t||"bool"===e&&"bool"===t)}function D(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}function Y(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error(`Unknown dtype ${t}`)}function R(t){if(null==t)return 0;let e=0;return t.forEach(t=>e+=t.length),e}function F(t){return"string"==typeof t||t instanceof String}function B(t){return"boolean"==typeof t}function C(t){return"number"==typeof t}function O(t){return Array.isArray(t)?O(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":C(t)?"float32":F(t)?"string":B(t)?"bool":"float32"}function P(t){return!!(t&&t.constructor&&t.call&&t.apply)}function L(t,e){for(let n=e;n<t;++n)if(t%n===0)return n;return t}function K(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function z(t,e,n,r=!1){const s=new Array;if(1===e.length){const o=e[0]*(r?2:1);for(let e=0;e<o;e++)s[e]=n[t+e]}else{const o=e[0],a=e.slice(1),i=a.reduce((t,e)=>t*e)*(r?2:1);for(let e=0;e<o;e++)s[e]=z(t+e*i,a,n,r)}return s}function W(t,e,n=!1){if(0===t.length)return e[0];const r=t.reduce((t,e)=>t*e)*(n?2:1);if(0===r)return[];if(r!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return z(0,t,e,n)}function j(t,e){const n=G(t,e);for(let t=0;t<n.length;t++)n[t]=1;return n}function G(t,e){if(null==e||"float32"===e||"complex64"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function U(t,e){const n=t.reduce((t,e)=>t*e,1);if(null==e||"float32"===e)return W(t,new Float32Array(n));if("int32"===e)return W(t,new Int32Array(n));if("bool"===e)return W(t,new Uint8Array(n));throw new Error(`Unknown data type ${e}`)}function q(t){t.forEach(e=>{h(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function H(t,e,n){if(0===e)return 0;if(1===e)return t[0];let r=t[t.length-1];for(let e=0;e<t.length-1;++e)r+=n[e]*t[e];return r}function V(t,e,n){if(0===e)return[];if(1===e)return[t];const r=new Array(e);for(let e=0;e<r.length-1;++e)r[e]=Math.floor(t/n[e]),t-=r[e]*n[e];return r[r.length-1]=t,r}function Z(t){return t&&t.then&&"function"==typeof t.then}n.d(e,{Ab:()=>M,BE:()=>_,Bq:()=>f,E6:()=>y,Et:()=>C,FZ:()=>j,HO:()=>p,Kg:()=>F,Lm:()=>B,O3:()=>d,P8:()=>k,SA:()=>q,SL:()=>R,Sf:()=>m,Tn:()=>P,Ty:()=>G,Ur:()=>K,X$:()=>O,XT:()=>E,Y6:()=>A,Ze:()=>g,_k:()=>V,_q:()=>x,a0:()=>s,av:()=>T,c7:()=>U,ce:()=>$,cz:()=>l,eV:()=>a,gS:()=>w,gx:()=>S,iu:()=>D,jv:()=>Y,k4:()=>r,lK:()=>L,nd:()=>I,oO:()=>c,qE:()=>o,r1:()=>b,sX:()=>H,so:()=>u,vA:()=>h,wg:()=>i,xn:()=>N,yL:()=>Z,ym:()=>v,yw:()=>W})},5149:(t,e,n)=>{"use strict";n.d(e,{GJ:()=>r,uI:()=>s});class r{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class s{refCount(t){return o("refCount")}incRef(t){return o("incRef")}timerAvailable(){return!0}time(t){return o("time")}read(t){return o("read")}readSync(t){return o("readSync")}numDataIds(){return o("numDataIds")}disposeData(t,e){return o("disposeData")}write(t,e,n){return o("write")}move(t,e,n,r,s){return o("move")}memory(){return o("memory")}floatPrecision(){return o("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return o("dispose")}}function o(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}},5207:(t,e,n)=>{"use strict";n.d(e,{Y:()=>l});var r=n(1585),s=n(5441),o=n(8189),a=n(5119),i=n(9809);const l=(0,n(929).op)({erf_:function(t){let e=(0,o.YT)(t,"x","erf");a.vA("int32"===e.dtype||"float32"===e.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===e.dtype&&(e=(0,i.w)(e,"float32"));const n={x:e};return r.T2.runKernel(s._s,n)}})},5242:function(t,e,n){var r;!function(t,s){function o(t){var e=this;e.next=function(){var t,n,r=e.w,s=e.X,o=e.i;return e.w=r=r+1640531527|0,n=s[o+34&127],t=s[o=o+1&127],n^=n<<13,t^=t<<17,n^=n>>>15,t^=t>>>12,n=s[o]=n^t,e.i=o,n+(r^r>>>16)|0},function(t,e){var n,r,s,o,a,i=[],l=128;for(e===(0|e)?(r=e,e=null):(e+="\0",r=0,l=Math.max(l,e.length)),s=0,o=-32;o<l;++o)e&&(r^=e.charCodeAt((o+32)%e.length)),0===o&&(a=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,o>=0&&(a=a+1640531527|0,s=0==(n=i[127&o]^=r+a)?s+1:0);for(s>=128&&(i[127&(e&&e.length||0)]=-1),s=127,o=512;o>0;--o)r=i[s+34&127],n=i[s=s+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,i[s]=r^n;t.w=a,t.X=i,t.i=s}(e,t)}function a(t,e){return e.i=t.i,e.w=t.w,e.X=t.X.slice(),e}function i(t,e){null==t&&(t=+new Date);var n=new o(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&(r.X&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=i:n.amdD&&n.amdO?void 0===(r=function(){return i}.call(e,n,e,s))||(s.exports=r):this.xor4096=i}(0,t=n.nmd(t),n.amdD)},5243:(t,e,n)=>{"use strict";n.d(e,{R:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({maxPoolWithArgmax_:function(t,e,n,a,i=!1){const l={x:(0,o.YT)(t,"x","maxPoolWithArgmax")},u={filterSize:e,strides:n,pad:a,includeBatchInIndex:i},c=r.T2.runKernel(s.TL,l,u);return{result:c[0],indexes:c[1]}}})},5248:(t,e,n)=>{"use strict";n.d(e,{H:()=>l});var r=n(1585),s=n(5441),o=n(5119),a=n(929),i=n(2302);const l=(0,a.op)({conv2DBackpropFilter_:function(t,e,n,a,l,u="NHWC",c){let h=t;3===t.rank&&(h=(0,i.t)(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let d=e;3===d.rank&&(d=(0,i.t)(e,[1,e.shape[0],e.shape[1],e.shape[2]])),o.vA(4===h.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${h.shape}.`),o.vA(4===d.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${d.shape}.`),o.vA(4===n.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const p="NHWC"===u?h.shape[3]:h.shape[1],f="NHWC"===u?d.shape[3]:d.shape[1];o.vA(p===n[2],()=>`Error in conv2dDerFilter: depth of input ${p}) must match input depth in filter (${n[2]}.`),o.vA(f===n[3],()=>`Error in conv2dDerFilter: depth of dy (${f}) must match output depth for filter (${n[3]}).`),null!=c&&o.vA(o.E6(l),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${c} but got pad ${l}.`);const g={x:h,dy:d},m={strides:a,pad:l,dataFormat:u,dimRoundingMode:c,filterShape:n};return r.T2.runKernel(s.rF,g,m)}})},5287:(t,e,n)=>{"use strict";n.d(e,{AS:()=>m,DZ:()=>g,Gc:()=>w,Hi:()=>d,Hs:()=>S,IS:()=>u,ME:()=>f,Ok:()=>$,Sm:()=>i,W4:()=>E,aC:()=>b,fL:()=>c,gJ:()=>A,gY:()=>l,go:()=>x,jh:()=>v,jz:()=>k,kB:()=>y,m1:()=>p,rE:()=>T,rm:()=>h});var r=n(1585),s=n(6574),o=n(259),a=n(565);function i(){(0,s._K)().set("PROD",!0)}function l(){(0,s._K)().set("DEBUG",!0)}function u(){(0,s._K)().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function c(t){(0,s._K)().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function h(){r.T2.disposeVariables()}function d(){return r.T2}function p(){return r.T2.memory()}function f(t){return r.T2.profile(t)}function g(t,e){return r.T2.tidy(t,e)}function m(t){(0,a.getTensorsInContainer)(t).forEach(t=>t.dispose())}function b(t){return r.T2.keep(t)}function y(t){return r.T2.time(t)}function v(t){return r.T2.setBackend(t)}function w(){return r.T2.ready()}function k(){return r.T2.backendName}function T(t){r.T2.removeBackend(t)}function x(t){return r.T2.findBackend(t)}function E(t){return r.T2.findBackendFactory(t)}function A(t,e,n=1){return r.T2.registerBackend(t,e,n)}function S(){return r.T2.backend}function $(t,e){(0,s._K)().setPlatform(t,e)}(0,o.B4)(c)},5295:(t,e,n)=>{"use strict";function r(t,e=!1){console.log(t.toString(e))}n.d(e,{y:()=>r})},5441:(t,e,n)=>{"use strict";n.d(e,{$d:()=>_,$j:()=>je,$z:()=>N,A1:()=>F,A8:()=>_e,BK:()=>sn,BL:()=>Gt,BR:()=>nt,Bl:()=>De,Bo:()=>Fe,Bx:()=>lt,C8:()=>Re,Cg:()=>$t,Cw:()=>Et,D7:()=>be,Dd:()=>Pe,Dr:()=>on,Dv:()=>Ce,E3:()=>wt,Ek:()=>i,El:()=>ct,Ew:()=>Qe,FA:()=>He,FC:()=>ge,FS:()=>u,Fi:()=>Me,Ik:()=>T,J3:()=>Ae,Ji:()=>xe,Jp:()=>c,K2:()=>Ye,KX:()=>S,L6:()=>Be,LB:()=>E,LD:()=>Ft,LG:()=>Wt,LR:()=>le,LW:()=>Jt,LX:()=>Nt,M3:()=>St,M6:()=>Le,MR:()=>K,Mn:()=>P,N4:()=>x,Nc:()=>oe,O4:()=>pt,OA:()=>bt,OD:()=>ne,OM:()=>a,OR:()=>q,P:()=>J,PH:()=>o,P_:()=>me,Pb:()=>Ge,Q6:()=>ie,QD:()=>$,QK:()=>d,Qg:()=>Q,R2:()=>he,RU:()=>Mt,RX:()=>Ct,SD:()=>Zt,SQ:()=>it,T7:()=>ln,TB:()=>Ve,TL:()=>Lt,TM:()=>W,TO:()=>ve,To:()=>Yt,Ty:()=>f,Uc:()=>Ke,VA:()=>Rt,VC:()=>y,Vv:()=>s,WT:()=>Ut,Wu:()=>Ne,X$:()=>G,X0:()=>Tt,XQ:()=>pe,Xh:()=>ft,YA:()=>ze,YV:()=>Se,Zg:()=>ut,Zl:()=>Xt,_s:()=>et,aA:()=>an,aw:()=>rn,bC:()=>re,bP:()=>V,cH:()=>Pt,cS:()=>v,dF:()=>Ie,dL:()=>Ze,dX:()=>Je,dv:()=>yt,e0:()=>Qt,ep:()=>p,fQ:()=>ot,fU:()=>ce,g5:()=>Kt,gC:()=>C,gI:()=>vt,hV:()=>ye,hg:()=>fe,ho:()=>b,hq:()=>Ee,hu:()=>ue,i5:()=>ht,iG:()=>B,iP:()=>kt,iW:()=>We,iu:()=>qe,jA:()=>k,jM:()=>Dt,jO:()=>de,jf:()=>R,jg:()=>Oe,jx:()=>H,kd:()=>ae,l0:()=>Ht,l6:()=>ke,lL:()=>gt,lN:()=>zt,lj:()=>r,lx:()=>m,lz:()=>mt,mI:()=>xt,mM:()=>ee,mn:()=>At,mx:()=>dt,nV:()=>U,nY:()=>L,nZ:()=>It,oF:()=>Ue,ox:()=>rt,p2:()=>D,pJ:()=>we,pP:()=>tn,p_:()=>h,pk:()=>Z,pn:()=>nn,pr:()=>I,py:()=>se,rF:()=>Y,rG:()=>at,rs:()=>tt,sD:()=>X,t2:()=>O,t3:()=>Bt,tG:()=>j,u$:()=>Te,u8:()=>l,ur:()=>te,v:()=>M,vI:()=>$e,vj:()=>A,wN:()=>z,ww:()=>w,wx:()=>Xe,x7:()=>jt,xJ:()=>en,xu:()=>qt,yS:()=>Ot,yb:()=>st,yl:()=>Vt,zP:()=>g,zf:()=>_t});const r="Abs",s="Acos",o="Acosh",a="Add",i="AddN",l="All",u="Any",c="ArgMax",h="ArgMin",d="Asin",p="Asinh",f="Atan",g="Atanh",m="Atan2",b="AvgPool",y="AvgPoolGrad",v="AvgPool3D",w="AvgPool3DGrad",k="BatchMatMul",T="BatchToSpaceND",x="Bincount",E="BroadcastTo",A="BroadcastArgs",S="Cast",$="Ceil",M="ClipByValue",I="Complex",N="ComplexAbs",_="Concat",D="Conv2D",Y="Conv2DBackpropFilter",R="Conv2DBackpropInput",F="Conv3D",B="Conv3DBackpropFilterV2",C="Conv3DBackpropInputV2",O="Cos",P="Cosh",L="Cumsum",K="CropAndResize",z="DenseBincount",W="DepthToSpace",j="DepthwiseConv2dNative",G="DepthwiseConv2dNativeBackpropFilter",U="DepthwiseConv2dNativeBackpropInput",q="Diag",H="Dilation2D",V="Dilation2DBackpropInput",Z="Dilation2DBackpropFilter",X="RealDiv",Q="Einsum",J="Elu",tt="EluGrad",et="Erf",nt="Equal",rt="Exp",st="ExpandDims",ot="Expm1",at="FFT",it="Fill",lt="FlipLeftRight",ut="Floor",ct="FloorDiv",ht="FusedBatchNorm",dt="GatherV2",pt="GatherNd",ft="Greater",gt="GreaterEqual",mt="Identity",bt="IFFT",yt="Imag",vt="IsFinite",wt="IsInf",kt="IsNan",Tt="LeakyRelu",xt="Less",Et="LessEqual",At="LinSpace",St="Log",$t="Log1p",Mt="LogicalAnd",It="LogicalNot",Nt="LogicalOr",_t="LogSoftmax",Dt="LRN",Yt="LRNGrad",Rt="Max",Ft="Maximum",Bt="MaxPool",Ct="MaxPoolGrad",Ot="MaxPool3D",Pt="MaxPool3DGrad",Lt="MaxPoolWithArgmax",Kt="Mean",zt="Min",Wt="Minimum",jt="MirrorPad",Gt="Mod",Ut="Multinomial",qt="Multiply",Ht="Neg",Vt="NotEqual",Zt="NonMaxSuppressionV3",Xt="NonMaxSuppressionV4",Qt="NonMaxSuppressionV5",Jt="OnesLike",te="OneHot",ee="Pack",ne="PadV2",re="Pool",se="Pow",oe="Prelu",ae="Prod",ie="Range",le="Real",ue="Reciprocal",ce="Relu",he="Reshape",de="ResizeNearestNeighbor",pe="ResizeNearestNeighborGrad",fe="ResizeBilinear",ge="ResizeBilinearGrad",me="Relu6",be="Reverse",ye="Round",ve="Rsqrt",we="ScatterNd",ke="Select",Te="Selu",xe="Slice",Ee="Sin",Ae="Sinh",Se="Sign",$e="Sigmoid",Me="Softplus",Ie="Sqrt",Ne="Sum",_e="SpaceToBatchND",De="SplitV",Ye="Softmax",Re="SparseFillEmptyRows",Fe="SparseReshape",Be="SparseSegmentMean",Ce="SparseSegmentSum",Oe="SparseToDense",Pe="SquaredDifference",Le="Square",Ke="StridedSlice",ze="StringNGrams",We="StringSplit",je="StringToHashBucketFast",Ge="Sub",Ue="Tan",qe="Tanh",He="Tile",Ve="TopK",Ze="Transform",Xe="Transpose",Qe="Unique",Je="Unpack",tn="UnsortedSegmentSum",en="ZerosLike",nn="Step",rn="FromPixels",sn="RotateWithOffset",on="_FusedMatMul",an="FusedConv2D",ln="FusedDepthwiseConv2D"},5537:(t,e,n)=>{"use strict";n.d(e,{P:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({zerosLike_:function(t){const e={x:(0,o.YT)(t,"x","zerosLike")};return r.T2.runKernel(s.xJ,e)}})},5598:(t,e,n)=>{"use strict";n.d(e,{S:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({gatherND_:function(t,e){const n=(0,o.YT)(e,"indices","gatherND","int32"),a={params:(0,o.YT)(t,"x","gatherND","string_or_numeric"),indices:n};return r.T2.runKernel(s.O4,a)}})},5606:(t,e,n)=>{"use strict";n.d(e,{R:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({floor_:function(t){const e={x:(0,o.YT)(t,"x","floor","float32")};return r.T2.runKernel(s.Zg,e)}})},5645:(t,e,n)=>{"use strict";n.d(e,{n:()=>c});var r=n(1830),s=n(8189),o=n(9258),a=n(6522),i=n(929),l=n(8968),u=n(6030);const c=(0,i.op)({logSigmoid_:function(t){const e=(0,s.YT)(t,"x","logSigmoid");return(0,r._X)(t=>({value:(0,a.H)((0,u.l)((0,a.H)(t))),gradFunc:e=>(0,o.l)(e,(0,l.r)((0,a.H)(t)))}))(e)}})},5661:(t,e,n)=>{"use strict";n.d(e,{e:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({pad_:function(t,e,n=0){const a=(0,o.YT)(t,"x","pad");if(0===a.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const i={paddings:e,constantValue:n},l={x:a};return r.T2.runKernel(s.OD,l,i)}})},5702:(t,e,n)=>{"use strict";n.d(e,{d:()=>o});var r=n(5119),s=n(9171);function o(t,e){if(((0,r.iu)(t)&&"string"!==e||Array.isArray(t))&&"complex64"!==e)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===e&&(0,r.iu)(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return(0,s.Q)(t,[],[],e)}},5703:(t,e,n)=>{"use strict";n.d(e,{N:()=>i});var r=n(1585),s=n(5441),o=n(565),a=n(8189);const i=(0,n(929).op)({matMul_:function(t,e,n=!1,i=!1){let l=(0,a.YT)(t,"a","matMul"),u=(0,a.YT)(e,"b","matMul");[l,u]=(0,o.makeTypesMatch)(l,u);const c={a:l,b:u},h={transposeA:n,transposeB:i};return r.T2.runKernel(s.jA,c,h)}})},5793:(t,e,n)=>{"use strict";n.d(e,{E:()=>o});var r=n(1585),s=n(8189);const o=(0,n(929).op)({square_:function(t){const e=(0,s.YT)(t,"x","square");return r.T2.runKernel("Square",{x:e},{})}})},5894:(t,e,n)=>{"use strict";n.d(e,{Y:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({stridedSlice_:function(t,e,n,a,i=0,l=0,u=0,c=0,h=0){const d={x:(0,o.YT)(t,"x","stridedSlice","string_or_numeric")},p={begin:e,end:n,strides:a,beginMask:i,endMask:l,ellipsisMask:u,newAxisMask:c,shrinkAxisMask:h};return r.T2.runKernel(s.Uc,d,p)}})},5912:(t,e,n)=>{"use strict";n.d(e,{L:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({round_:function(t){const e={x:(0,o.YT)(t,"x","round")};return r.T2.runKernel(s.hV,e)}})},5932:(t,e,n)=>{"use strict";n.d(e,{r:()=>i});var r=n(8189),s=n(5119),o=n(929),a=n(2302);const i=(0,o.op)({squeeze_:function(t,e){const n=(0,r.YT)(t,"x","squeeze");return(0,a.t)(n,(0,s.gx)(n.shape,e).newShape)}})},6030:(t,e,n)=>{"use strict";n.d(e,{l:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({softplus_:function(t){const e={x:(0,o.YT)(t,"x","softplus")};return r.T2.runKernel(s.Fi,e)}})},6054:(t,e,n)=>{"use strict";n.d(e,{Q:()=>i});var r=n(1585),s=n(5441),o=n(8189),a=n(5119);const i=(0,n(929).op)({addN_:function(t){a.vA(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),a.vA(t.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`);const e=t.map((t,e)=>(0,o.YT)(t,`tensors${e}`,"addN")),n=e[0];e.forEach(t=>{if(t.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(t=>{if(!a.r1(t.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const i=e;return r.T2.runKernel(s.Ek,i)}})},6111:(t,e,n)=>{"use strict";n.d(e,{G:()=>o});var r=n(1585),s=n(5441);function o(t,e,n){const o={shape:t,value:e,dtype:n};return r.T2.runKernel(s.SQ,{},o)}},6125:(t,e,n)=>{"use strict";n.d(e,{ljI:()=>qt.lj,Vvy:()=>qt.Vv,PH8:()=>qt.PH,K$F:()=>De,ah4:()=>Re,FYc:()=>Ce,oC7:()=>Le,OMN:()=>qt.OM,EkD:()=>qt.Ek,u8Z:()=>qt.u8,FSt:()=>qt.FS,Jp_:()=>qt.Jp,p_m:()=>qt.p_,QKF:()=>qt.QK,epO:()=>qt.ep,TyE:()=>qt.Ty,lxb:()=>qt.lx,zP9:()=>qt.zP,ho8:()=>qt.ho,cS:()=>qt.cS,wwC:()=>qt.ww,VCH:()=>qt.VC,jAQ:()=>qt.jA,Ik2:()=>qt.Ik,N4F:()=>qt.N4,vj7:()=>qt.vj,LB5:()=>qt.LB,KXH:()=>qt.KX,QDP:()=>qt.QD,vaV:()=>qt.v,pr3:()=>qt.pr,$zE:()=>qt.$z,$dB:()=>qt.$d,p2J:()=>qt.p2,rFm:()=>qt.rF,jfg:()=>qt.jf,A1h:()=>qt.A1,iGz:()=>qt.iG,gC7:()=>qt.gC,Mn0:()=>qt.t2,MnK:()=>qt.Mn,MRQ:()=>qt.MR,nY8:()=>qt.nY,GJx:()=>Un.GJ,wNW:()=>qt.wN,TMz:()=>qt.TM,tGH:()=>qt.tG,X$8:()=>qt.X$,nVu:()=>qt.nV,ORI:()=>qt.OR,jxD:()=>qt.jx,pk0:()=>qt.pk,bP9:()=>qt.bP,Kmu:()=>y.Km,Qgm:()=>qt.Qg,Pah:()=>qt.P,rsH:()=>qt.rs,OH$:()=>y.OH,BRl:()=>qt.BR,_s9:()=>qt._s,ox3:()=>qt.ox,ybN:()=>qt.yb,ybj:()=>qt.fQ,rGP:()=>qt.rG,SQl:()=>qt.SQ,BxF:()=>qt.Bx,ZgB:()=>qt.Zg,ElG:()=>qt.El,awo:()=>qt.aw,i5R:()=>qt.i5,aAr:()=>qt.aA,T7M:()=>qt.T7,O4G:()=>qt.O4,mxL:()=>qt.mx,XhZ:()=>qt.Xh,lLS:()=>qt.lL,OAQ:()=>qt.OA,lzr:()=>qt.lz,dv8:()=>qt.dv,gIW:()=>qt.gI,E3$:()=>qt.E3,iPs:()=>qt.iP,uI_:()=>Un.uI,jM4:()=>qt.jM,ToN:()=>qt.To,X0$:()=>qt.X0,mIA:()=>qt.mI,CwD:()=>qt.Cw,mnI:()=>qt.mn,tG8:()=>qt.M3,Cg$:()=>qt.Cg,zfU:()=>qt.zf,RUm:()=>qt.RU,nZd:()=>qt.nZ,LXA:()=>qt.LX,VAI:()=>qt.VA,t3d:()=>qt.t3,ySp:()=>qt.yS,cHb:()=>qt.cH,RXX:()=>qt.RX,TL8:()=>qt.TL,LDN:()=>qt.LD,g5A:()=>qt.g5,lNG:()=>qt.lN,LG0:()=>qt.LG,x7F:()=>qt.x7,BLA:()=>qt.BL,Qu_:()=>ze,WT3:()=>qt.WT,xu7:()=>qt.xu,l0G:()=>qt.l0,SDM:()=>qt.SD,Zl4:()=>qt.Zl,e0f:()=>qt.e0,ylV:()=>qt.yl,BTT:()=>Ue.BTT,urI:()=>qt.ur,LWX:()=>qt.LW,ELo:()=>_e,L5p:()=>je,mM$:()=>qt.mM,ODT:()=>qt.OD,bCz:()=>qt.bC,pyJ:()=>qt.py,Ncv:()=>qt.Nc,kdj:()=>qt.kd,PS5:()=>We,Q6t:()=>qt.Q6,rgM:()=>Ge.rg,LRy:()=>qt.LR,sDr:()=>qt.sD,huO:()=>qt.hu,iDl:()=>qe.i,fUj:()=>qt.fU,P_L:()=>qt.P_,R23:()=>qt.R2,hgw:()=>qt.hg,FCQ:()=>qt.FC,jOE:()=>qt.jO,XQy:()=>qt.XQ,D7i:()=>qt.D7,BK4:()=>qt.BK,hVg:()=>qt.hV,TOR:()=>qt.TO,SYI:()=>Ke,pJc:()=>qt.pJ,l6P:()=>qt.l6,u$b:()=>qt.u$,vI1:()=>qt.vI,YVe:()=>qt.YV,hql:()=>qt.hq,J3C:()=>qt.J3,JiE:()=>qt.Ji,rFG:()=>qt.K2,Fin:()=>qt.Fi,A8B:()=>qt.A8,C8s:()=>qt.C8,BoJ:()=>qt.Bo,L6G:()=>qt.L6,DvZ:()=>qt.Dv,jgd:()=>qt.jg,Blb:()=>qt.Bl,dFH:()=>qt.dF,M6A:()=>qt.M6,Ddj:()=>qt.Dd,pnw:()=>qt.pn,UcO:()=>qt.Uc,YAb:()=>qt.YA,iW0:()=>qt.iW,$jE:()=>qt.$j,PbM:()=>qt.Pb,WuN:()=>qt.Wu,oFs:()=>qt.oF,iuW:()=>qt.iu,qYS:()=>Tt.qY,ylz:()=>Tt.yl,FAs:()=>qt.FA,TBb:()=>qt.TB,dLy:()=>qt.dL,wx0:()=>qt.wx,EwU:()=>qt.Ew,dXR:()=>qt.dX,pPe:()=>qt.pP,rTt:()=>Tt.rT,xJ3:()=>qt.xJ,Dr:()=>qt.Dr,tnl:()=>Ue.tnl,HQu:()=>Ue.HQu,FqL:()=>Ue.FqL,WQq:()=>Ue.WQq,QiD:()=>Ue.QiD,Q7R:()=>Ue.Q7R,bzn:()=>Ue.bzn,FLi:()=>Ue.FLi,XRg:()=>Ue.XRg,qRo:()=>Ue.qRo,yHs:()=>Ue.yHs,rYl:()=>Ue.rYl,FPz:()=>Ue.FPz,rfv:()=>Ue.rfv,$jT:()=>Ue.$jT,sub:()=>Ue.sub,Hs:()=>Te.Hs,C0T:()=>h,lZX:()=>Ue.lZX,$v7:()=>Ue.$v7,BFc:()=>Ue.BFc,kSi:()=>Ue.kSi,T5N:()=>Ue.T5N,GTe:()=>Ue.GTe,HbZ:()=>Ue.HbZ,ftb:()=>Ue.ftb,ROE:()=>Ue.ROE,hOW:()=>Ue.hOW,TaL:()=>a,ra8:()=>Ue.ra8,wgE:()=>Ue.wgE,mkO:()=>Ue.mkO,zQh:()=>Ue.zQh,o8B:()=>Ue.o8B,faB:()=>Ue.faB,xWs:()=>Ue.xWs,I1m:()=>Ue.I1m,RPU:()=>Ue.RPU,O5O:()=>Ue.O5O,P1l:()=>Ue.P1l,kA9:()=>Ue.kA9,Xtf:()=>Ue.Xtf,wX9:()=>Ue.wX9,IPL:()=>Ue.IPL,jIJ:()=>Ue.jIJ,Cfv:()=>Ht.Cf,gnS:()=>Ue.gnS,yIG:()=>Ue.yIG,_jP:()=>Ue._jP,rCv:()=>Ue.rCv,_Xg:()=>Ie._X,aOp:()=>Ue.aOp,fLc:()=>Te.fL,Rj8:()=>Ue.Rj8,Gl3:()=>Ue.Gl3,eMq:()=>r,smy:()=>Ue.smy,X7t:()=>Ue.X7t,ISJ:()=>Te.IS,ASo:()=>Te.AS,rm6:()=>Te.rm,y4m:()=>Ue.y4m,ek5:()=>Ue.ek5,Omf:()=>Ue.Omf,EZY:()=>Ue.EZY,_3C:()=>Ue._3C,Pqc:()=>Ue.Pqc,gYU:()=>Te.gY,SmG:()=>Te.Sm,FJY:()=>Ue.FJY,Hi9:()=>Te.Hi,_K2:()=>y._K,LCg:()=>Ue.LCg,Y12:()=>Ue.Y12,oNF:()=>Ue.oNF,UG6:()=>Ue.UG6,IYd:()=>Ue.IYd,y5U:()=>Ue.y5U,hVP:()=>Ue.hVP,GSj:()=>Ue.GSj,goy:()=>Te.go,W4C:()=>Te.W4,RIf:()=>Ue.RIf,wh_:()=>Ue.wh_,cZk:()=>Ue.cZk,kgh:()=>Ue.kgh,SY9:()=>Ue.SY9,FJy:()=>i,jz4:()=>Te.jz,vQR:()=>Ht.vQ,_5H:()=>Ht._5,OpK:()=>Ht.Op,Dvk:()=>Ie.Dv,ok9:()=>Ie.ok,rhj:()=>Ue.rhj,DQN:()=>Ue.DQN,KGM:()=>Ue.KGM,ngS:()=>Ue.ngS,Slp:()=>Ue.Slp,U4u:()=>Ue.U4u,io:()=>s,ggX:()=>Ue.ggX,MIs:()=>Ue.MIs,EN4:()=>Ue.EN4,yrW:()=>Ue.yrW,aCs:()=>Te.aC,kpo:()=>d,H8d:()=>Ue.H8d,M7h:()=>Ue.M7h,InN:()=>Ue.InN,mPL:()=>Ue.mPL,mT8:()=>Ue.mT8,Kgs:()=>Ue.Kgs,Rm2:()=>Ue.Rm2,Kko:()=>Ue.Kko,nqI:()=>Ue.nqI,HPB:()=>Ue.HPB,VZ:()=>Ue.VZ,n76:()=>Ue.n76,NSZ:()=>Ue.NSZ,ztW:()=>Ue.ztW,rxB:()=>Ue.rxB,YYh:()=>Ue.YYh,NoW:()=>Ue.NoW,DyF:()=>o,T9B:()=>Ue.T9B,jgi:()=>Ue.jgi,NYV:()=>Ue.NYV,RO:()=>Ue.RO,PhQ:()=>Ue.PhQ,i2o:()=>Ue.i2o,m1Z:()=>Te.m1,OYQ:()=>Ue.OYQ,jkA:()=>Ue.jkA,BpO:()=>Ue.BpO,FFZ:()=>Ue.FFZ,ziu:()=>Ue.ziu,Clk:()=>Ue.Clk,CRk:()=>Ue.CRk,lKK:()=>Ue.lKK,YDF:()=>Ue.YDF,OjQ:()=>Ue.OjQ,HZy:()=>Ue.HZy,dA1:()=>Ze,xbf:()=>Ue.xbf,Ec:()=>Ue.Ec,Mw0:()=>Ue.Mw0,SaS:()=>Ue.SaS,P61:()=>Ue.P61,op:()=>Ue.op,X4o:()=>Ue.X4o,eVF:()=>Ue.eVF,BZs:()=>Ue.BZs,grY:()=>Ue.grY,XHu:()=>Ue.XHu,WLX:()=>Ue.WLX,dzn:()=>Ue.dzn,n7C:()=>Ue.n7C,NsG:()=>Ue.NsG,yyV:()=>Ue.yyV,_eU:()=>Ue._eU,MEE:()=>Te.ME,_9M:()=>Ue._9M,pR9:()=>Ue.pR9,FE$:()=>Ue.FE$,YeY:()=>Ue.YeY,y17:()=>Ue.y17,Gc4:()=>Te.Gc,xav:()=>Ue.xav,VOZ:()=>Ue.VOZ,gJX:()=>Te.gJ,krJ:()=>Ht.kr,tAK:()=>Ht.tA,VVh:()=>Ue.VVh,j__:()=>Ue.j__,rEj:()=>Te.rE,tQQ:()=>Ue.tQQ,BEg:()=>Ue.BEg,QD2:()=>Ue.QD2,LMr:()=>Ue.LMr,I2l:()=>Ue.I2l,JYU:()=>Ue.JYU,z8$:()=>Ue.z8$,LIG:()=>Ue.LIG,Z$r:()=>Ue.Z$r,d_2:()=>Ue.d_2,NFr:()=>Ue.NFr,g23:()=>ne,WfX:()=>Ue.WfX,wdz:()=>Ue.wdz,JFn:()=>l,jh6:()=>Te.jh,OkC:()=>Te.Ok,F12:()=>Ue.F12,ry7:()=>Ue.ry7,_SZ:()=>Ue._SZ,vPA:()=>Ue.vPA,F8e:()=>Ue.F8e,L0l:()=>Ue.L0l,dik:()=>Ue.dik,Q$M:()=>Ue.Q$M,zAd:()=>Ue.zAd,wck:()=>Ue.wck,R0O:()=>Ue.R0O,Kro:()=>re,Vs9:()=>Ue.Vs9,lw0:()=>Ue.lw0,eDJ:()=>Ue.eDJ,lMo:()=>Ue.lMo,Zhr:()=>Ue.Zhr,lOn:()=>Ue.lOn,lDo:()=>Ue.lDo,RZD:()=>Ue.RZD,EwI:()=>Ue.EwI,Pbu:()=>Ue.Pbu,r2V:()=>Ue.r2V,t$z:()=>Ue.t$z,PMw:()=>Ue.PMw,Ym9:()=>Ue.Ym9,YjP:()=>Ue.YjP,jbE:()=>Ue.jbE,czq:()=>Ue.czq,chL:()=>Ge.ch,Mlm:()=>Ue.Mlm,ymU:()=>Ue.ymU,OEK:()=>Ue.OEK,tGX:()=>Ue.tGX,KtR:()=>Ue.KtR,$_$:()=>Ue.$_$,g9W:()=>Ue.g9W,Lpo:()=>Ue.Lpo,yxw:()=>Ue.yxw,d_S:()=>ie,Obs:()=>u,DZQ:()=>Te.DZ,Vsq:()=>Ue.Vsq,kBw:()=>Te.kB,rfw:()=>Ue.rfw,BaG:()=>He,mgz:()=>Ue.mgz,efE:()=>Ue.efE,AmM:()=>Ue.AmM,rYx:()=>Ht.rY,iPt:()=>Ht.iP,zAU:()=>Ue.zAU,K$i:()=>Ue.K$i,TuY:()=>Ge.Tu,ZSL:()=>le,jYt:()=>Ie.jY,muS:()=>Ie.mu,bvq:()=>Ue.bvq,y7e:()=>Ie.y7,bgA:()=>ke,_M9:()=>Ue._M9,YJN:()=>Ue.YJN,Ul9:()=>Ue.Ul9,POl:()=>Ue.POl});var r={};n.r(r),n.d(r,{isBrowser:()=>b,isMobile:()=>m,mockIsMobile:()=>g});var s={};n.r(s),n.d(s,{browserFiles:()=>$t,browserHTTPRequest:()=>Bt,concatenateArrayBuffers:()=>N,copyModel:()=>ft,decodeWeights:()=>S,encodeWeights:()=>A,fromMemory:()=>Pt,getLoadHandlers:()=>L,getModelArtifactsForJSON:()=>Y,getModelArtifactsInfoForJSON:()=>R,getSaveHandlers:()=>P,http:()=>Ft,isHTTPScheme:()=>Yt,listModels:()=>dt,loadWeights:()=>Nt,moveModel:()=>gt,registerLoadRouter:()=>O,registerSaveRouter:()=>C,removeModel:()=>pt,weightsLoaderFactory:()=>_t,withSaveHandler:()=>Lt});var o={};n.r(o),n.d(o,{confusionMatrix:()=>Ut});var a={};n.r(a),n.d(a,{fromPixels:()=>te,fromPixelsAsync:()=>Qt,toPixels:()=>Jt});var i={};n.r(i),n.d(i,{prepareAndValidate:()=>ee});var l={};n.r(l),n.d(l,{Serializable:()=>se,SerializationMap:()=>oe,registerClass:()=>ae});var u={};n.r(u),n.d(u,{TEST_EPSILON_FLOAT16:()=>ce,encodeStrings:()=>we,expectArrayBuffersEqual:()=>ve,expectArraysClose:()=>he,expectArraysEqual:()=>ge,expectNumbersClose:()=>me,expectPromiseToFail:()=>fe,expectValuesInRange:()=>ye,testEpsilon:()=>de});var c={};n.r(c),n.d(c,{collectGatherOpShapeInfo:()=>Kn,computeOutShape:()=>Ln,segOpComputeOptimalWindowSize:()=>Pn});var h={};n.r(h),n.d(h,{ERF_A1:()=>fn,ERF_A2:()=>gn,ERF_A3:()=>mn,ERF_A4:()=>bn,ERF_A5:()=>yn,ERF_P:()=>pn,PARALLELIZE_THRESHOLD:()=>rn,SELU_SCALE:()=>dn.X,SELU_SCALEALPHA:()=>dn.j,applyActivation:()=>nn.f2,assertAndGetBroadcastShape:()=>Qe.Ky,assertAxesAreInnerMostDims:()=>Xe.WC,assertParamsConsistent:()=>Je,assignToTypedArray:()=>An,axesAreInnerMostDims:()=>Xe.WH,calculateShapes:()=>ne.calculateShapes,checkEinsumDimSizes:()=>Rn,combineLocations:()=>Xe.aF,complexWithEvenIndex:()=>Tn,complexWithOddIndex:()=>xn,computeConv2DInfo:()=>en.uf,computeConv3DInfo:()=>en.p$,computeDefaultPad:()=>en.G8,computeDilation2DInfo:()=>en.YQ,computeOptimalWindowSize:()=>sn,computeOutAndReduceShapes:()=>Xe.lb,computeOutShape:()=>tn,computePool2DInfo:()=>en.E6,computePool3DInfo:()=>en.l5,convertConv2DDataFormat:()=>en.$Q,decodeEinsumEquation:()=>Dn,eitherStridesOrDilationsAreOne:()=>en.G0,expandShapeToKeepDim:()=>Xe.SM,exponent:()=>$n,exponents:()=>Sn,fromStringArrayToUint8:()=>Wn,fromUint8ToStringArray:()=>zn,getAxesPermutation:()=>Xe.Em,getBroadcastDims:()=>Qe.NE,getComplexWithIndex:()=>En,getEinsumComputePath:()=>Fn,getEinsumPermutation:()=>Yn,getFusedBiasGradient:()=>nn.Do,getFusedDyActivation:()=>nn.XB,getImageCenter:()=>on,getInnerMostAxes:()=>Xe.fK,getPermuted:()=>ln,getReductionAxes:()=>Qe.Lx,getReshaped:()=>an,getReshapedPermuted:()=>un,getSliceBeginCoords:()=>cn,getSliceSize:()=>hn,getUndoAxesPermutation:()=>Xe.gx,isIdentityPermutation:()=>Bn,log:()=>vn.R,mergeRealAndImagArrays:()=>wn,prepareAndValidate:()=>ee,prepareSplitSize:()=>On,segment_util:()=>c,shouldFuse:()=>nn.zE,slice_util:()=>re,splitRealAndImagArrays:()=>kn,tupleValuesAreOne:()=>en.Dh,upcastType:()=>Ge.Tu,validateInput:()=>ne.validateInput,validateUpdateShape:()=>ne.validateUpdateShape,warn:()=>vn.i});var d={};n.r(d),n.d(d,{nonMaxSuppressionV3Impl:()=>jn.c7,nonMaxSuppressionV4Impl:()=>jn.ZS,nonMaxSuppressionV5Impl:()=>jn.ut,whereImpl:()=>Gn.Y});var p=n(1585);let f;function g(t){f=t}function m(t){if(void 0!==f)return f;if(t||"undefined"!=typeof navigator&&null!=navigator){if(t||(t=navigator),"ReactNative"===t.product)return!0;const e=t.userAgent||t.vendor||("undefined"!=typeof window?window.opera:"");if(!e){const e=t;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function b(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}var y=n(6574);const v=(0,y._K)();v.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),v.registerFlag("IS_BROWSER",()=>b()),v.registerFlag("IS_NODE",()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node),v.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),v.registerFlag("PROD",()=>!1),v.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>v.getBool("DEBUG")),v.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),v.registerFlag("IS_TEST",()=>!1),v.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),v.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);var w=n(7148),k=n(4027),T=n(5119);const x={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},E=4;async function A(t,e){const n=[],r=[],s=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);for(let o=0;o<s.length;++o){const a=s[o],i=Array.isArray(t)?t[o].tensor:t[a];if("float32"!==i.dtype&&"int32"!==i.dtype&&"bool"!==i.dtype&&"string"!==i.dtype&&"complex64"!==i.dtype)throw new Error(`Unsupported dtype in weight '${a}': ${i.dtype}`);const l={name:a,shape:i.shape,dtype:i.dtype};if("string"===i.dtype){const t=new Promise(async t=>{const e=await i.bytes(),n=e.reduce((t,e)=>t+e.length,0)+E*e.length,r=new Uint8Array(n);let s=0;for(let t=0;t<e.length;t++){const n=e[t],o=new Uint8Array(new Uint32Array([n.length]).buffer);r.set(o,s),s+=E,r.set(n,s),s+=n.length}t(r)});r.push(t)}else r.push(i.data());null!=e&&(l.group=e),n.push(l)}return{data:$(await Promise.all(r)),specs:n}}function S(t,e){const n={};let r,s=0;for(const o of e){const e=o.name,a=o.dtype,i=o.shape,l=(0,T.Ze)(i);let u;if("quantization"in o){const n=o.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${o.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${o.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==a)throw new Error(`Weight ${o.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${a}.`)}const i=x[n.dtype],c=t.slice(s,s+l*i),h="uint8"===n.dtype?new Uint8Array(c):new Uint16Array(c);if("float32"===a)if("uint8"===n.dtype||"uint16"===n.dtype){u=new Float32Array(h.length);for(let t=0;t<h.length;t++){const e=h[t];u[t]=e*n.scale+n.min}}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===r&&(r=F()),u=r(h)}else{if("int32"!==a)throw new Error(`Unsupported dtype in weight '${e}': ${a}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);u=new Int32Array(h.length);for(let t=0;t<h.length;t++){const e=h[t];u[t]=Math.round(e*n.scale+n.min)}}s+=l*i}else if("string"===a){const e=(0,T.Ze)(o.shape);u=[];for(let n=0;n<e;n++){const e=new Uint32Array(t.slice(s,s+E))[0];s+=E;const n=new Uint8Array(t.slice(s,s+e));u.push(n),s+=e}}else{const r=x[a],o=t.slice(s,s+l*r);if("float32"===a)u=new Float32Array(o);else if("int32"===a)u=new Int32Array(o);else if("bool"===a)u=new Uint8Array(o);else{if("complex64"!==a)throw new Error(`Unsupported dtype in weight '${e}': ${a}`);{u=new Float32Array(o);const t=new Float32Array(u.length/2),r=new Float32Array(u.length/2);for(let e=0;e<t.length;e++)t[e]=u[2*e],r[e]=u[2*e+1];const s=(0,k.O)(t,i,"float32"),a=(0,k.O)(r,i,"float32");n[e]=(0,w.f)(s,a),s.dispose(),a.dispose()}}s+=l*r}"complex64"!==a&&(n[e]=(0,k.O)(u,i,a))}return n}function $(t){if(null===t)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach(t=>{if(e+=t.byteLength,n.push(t.byteLength===t.buffer.byteLength?t:new t.constructor(t)),!(t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${t.constructor.name}`)});const r=new Uint8Array(e);let s=0;return n.forEach(t=>{r.set(new Uint8Array(t.buffer),s),s+=t.byteLength}),r.buffer}const M="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function I(t){return M?Buffer.byteLength(t):new Blob([t]).size}function N(t){if(1===t.length)return t[0];let e=0;t.forEach(t=>{e+=t.byteLength});const n=new Uint8Array(e);let r=0;return t.forEach(t=>{n.set(new Uint8Array(t),r),r+=t.byteLength}),n.buffer}function _(t){for(t=t.trim();t.endsWith("/");)t=t.slice(0,t.length-1);const e=t.split("/");return e[e.length-1]}function D(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return null!=t.signature&&(n.signature=t.signature),null!=t.userDefinedMetadata&&(n.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(n.modelInitializer=t.modelInitializer),null!=t.trainingConfig&&(n.trainingConfig=t.trainingConfig),n}async function Y(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(null!=t.trainingConfig&&(n.trainingConfig=t.trainingConfig),null!=t.weightsManifest){const[r,s]=await e(t.weightsManifest);n.weightSpecs=r,n.weightData=s}return null!=t.signature&&(n.signature=t.signature),null!=t.userDefinedMetadata&&(n.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(n.modelInitializer=t.modelInitializer),n}function R(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==t.modelTopology?0:I(JSON.stringify(t.modelTopology)),weightSpecsBytes:null==t.weightSpecs?0:I(JSON.stringify(t.weightSpecs)),weightDataBytes:null==t.weightData?0:t.weightData.byteLength}}function F(){const t=function(){const t=t=>{let e=t<<13,n=0;for(;!(8388608&e);)n-=8388608,e<<=1;return e&=-8388609,n+=947912704,e|n},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}(),e=function(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}(),n=function(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}();return r=>{const s=new ArrayBuffer(4*r.length),o=new Uint32Array(s);for(let s=0;s<r.length;s++){const a=r[s],i=t[n[a>>10]+(1023&a)]+e[a>>10];o[s]=i}return new Float32Array(s)}}class B{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==B.instance&&(B.instance=new B),B.instance}static registerSaveRouter(t){B.getInstance().saveRouters.push(t)}static registerLoadRouter(t){B.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return B.getHandlers(t,"save")}static getLoadHandlers(t,e){return B.getHandlers(t,"load",e)}static getHandlers(t,e,n){const r=[];return("load"===e?B.getInstance().loadRouters:B.getInstance().saveRouters).forEach(e=>{const s=e(t,n);null!==s&&r.push(s)}),r}}const C=t=>B.registerSaveRouter(t),O=t=>B.registerLoadRouter(t),P=t=>B.getSaveHandlers(t),L=(t,e)=>B.getLoadHandlers(t,e),K="tensorflowjs",z="models_store",W="model_info_store";function j(){if(!(0,y._K)().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t="undefined"==typeof window?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(null==e)throw new Error("The current browser does not appear to support IndexedDB.");return e}function G(t){const e=t.result;e.createObjectStore(z,{keyPath:"modelPath"}),e.createObjectStore(W,{keyPath:"modelPath"})}class U{constructor(t){if(this.indexedDB=j(),null==t||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise((t,n)=>{const r=this.indexedDB.open(K,1);r.onupgradeneeded=()=>G(r),r.onsuccess=()=>{const s=r.result;if(null==e){const e=s.transaction(z,"readonly"),r=e.objectStore(z).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return s.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));t(r.result.modelArtifacts)},r.onerror=t=>(s.close(),n(r.error)),e.oncomplete=()=>s.close()}else{const r=R(e),o=s.transaction(W,"readwrite");let a=o.objectStore(W);const i=a.put({modelPath:this.modelPath,modelArtifactsInfo:r});let l;i.onsuccess=()=>{l=s.transaction(z,"readwrite");const i=l.objectStore(z).put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:r});i.onsuccess=()=>t({modelArtifactsInfo:r}),i.onerror=t=>{a=o.objectStore(W);const e=a.delete(this.modelPath);e.onsuccess=()=>(s.close(),n(i.error)),e.onerror=t=>(s.close(),n(i.error))}},i.onerror=t=>(s.close(),n(i.error)),o.oncomplete=()=>{null==l?s.close():l.oncomplete=()=>s.close()}}},r.onerror=t=>n(r.error)})}}U.URL_SCHEME="indexeddb://";const q=t=>{return(0,y._K)().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(U.URL_SCHEME)?(e=t.slice(U.URL_SCHEME.length),new U(e)):null;var e};B.registerSaveRouter(q),B.registerLoadRouter(q);class H{constructor(){this.indexedDB=j()}async listModels(){return new Promise((t,e)=>{const n=this.indexedDB.open(K,1);n.onupgradeneeded=()=>G(n),n.onsuccess=()=>{const r=n.result,s=r.transaction(W,"readonly"),o=s.objectStore(W).getAll();o.onsuccess=()=>{const e={};for(const t of o.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},o.onerror=t=>(r.close(),e(o.error)),s.oncomplete=()=>r.close()},n.onerror=t=>e(n.error)})}async removeModel(t){var e;return t=(e=t).startsWith(U.URL_SCHEME)?e.slice(U.URL_SCHEME.length):e,new Promise((e,n)=>{const r=this.indexedDB.open(K,1);r.onupgradeneeded=()=>G(r),r.onsuccess=()=>{const s=r.result,o=s.transaction(W,"readwrite"),a=o.objectStore(W),i=a.get(t);let l;i.onsuccess=()=>{if(null==i.result)return s.close(),n(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const r=a.delete(t),o=()=>{l=s.transaction(z,"readwrite");const r=l.objectStore(z).delete(t);r.onsuccess=()=>e(i.result.modelArtifactsInfo),r.onerror=t=>n(i.error)};r.onsuccess=o,r.onerror=t=>(o(),s.close(),n(i.error))}},i.onerror=t=>(s.close(),n(i.error)),o.oncomplete=()=>{null==l?s.close():l.oncomplete=()=>s.close()}},r.onerror=t=>n(r.error)})}}const V="/",Z="tensorflowjs_models",X="info",Q="model_topology",J="weight_specs",tt="weight_data",et="model_metadata";function nt(t){return{info:[Z,t,X].join(V),topology:[Z,t,Q].join(V),weightSpecs:[Z,t,J].join(V),weightData:[Z,t,tt].join(V),modelMetadata:[Z,t,et].join(V)}}function rt(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function st(t){const e=t.split(V);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(V)}class ot{constructor(t){if(!(0,y._K)().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=nt(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),r=R(t);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(t){if(M)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let t=0,r=e.length;t<r;t++)n+=String.fromCharCode(e[t]);return btoa(n)}(t.weightData));const s={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:null!=t.signature?t.signature:void 0,userDefinedMetadata:null!=t.userDefinedMetadata?t.userDefinedMetadata:void 0,modelInitializer:null!=t.modelInitializer?t.modelInitializer:void 0,trainingConfig:null!=t.trainingConfig?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:r}}catch(t){throw rt(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(null==t)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=r;const s=this.LS.getItem(this.keys.modelMetadata);if(null!=s){const t=JSON.parse(s);e.format=t.format,e.generatedBy=t.generatedBy,e.convertedBy=t.convertedBy,null!=t.signature&&(e.signature=t.signature),null!=t.userDefinedMetadata&&(e.userDefinedMetadata=t.userDefinedMetadata),null!=t.modelInitializer&&(e.modelInitializer=t.modelInitializer),null!=t.trainingConfig&&(e.trainingConfig=t.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(null==o)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=function(t){if(M){const e=Buffer.from(t,"base64");return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let t=0;t<e.length;++t)n.set([e.charCodeAt(t)],t);return n.buffer}(o),e}}ot.URL_SCHEME="localstorage://";const at=t=>{return(0,y._K)().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(ot.URL_SCHEME)?(e=t.slice(ot.URL_SCHEME.length),new ot(e)):null;var e};B.registerSaveRouter(at),B.registerLoadRouter(at);class it{constructor(){(0,T.vA)((0,y._K)().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),(0,T.vA)("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},e=Z+V,n=V+X;for(let r=0;r<this.LS.length;++r){const s=this.LS.key(r);s.startsWith(e)&&s.endsWith(n)&&(t[st(s)]=JSON.parse(this.LS.getItem(s)))}return t}async removeModel(t){var e;const n=nt(t=(e=t).startsWith(ot.URL_SCHEME)?e.slice(ot.URL_SCHEME.length):e);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${t}'`);const r=JSON.parse(this.LS.getItem(n.info));return rt(n),r}}const lt="://";class ut{constructor(){this.managers={}}static getInstance(){return null==ut.instance&&(ut.instance=new ut),ut.instance}static registerManager(t,e){(0,T.vA)(null!=t,()=>"scheme must not be undefined or null."),t.endsWith(lt)&&(t=t.slice(0,t.indexOf(lt))),(0,T.vA)(t.length>0,()=>"scheme must not be an empty string.");const n=ut.getInstance();(0,T.vA)(null==n.managers[t],()=>`A model store manager is already registered for scheme '${t}'.`),n.managers[t]=e}static getManager(t){const e=this.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(this.getInstance().managers)}}function ct(t){if(-1===t.indexOf(lt))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${ut.getSchemes().join(",")}`);return{scheme:t.split(lt)[0],path:t.split(lt)[1]}}async function ht(t,e,n=!1){(0,T.vA)(t!==e,()=>`Old path and new path are the same: '${t}'`);const r=B.getLoadHandlers(t);(0,T.vA)(r.length>0,()=>`Copying failed because no load handler is found for source URL ${t}.`),(0,T.vA)(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${t}.`);const s=r[0],o=B.getSaveHandlers(e);(0,T.vA)(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),(0,T.vA)(o.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);const a=o[0],i=ct(t).scheme,l=ct(t).path,u=i===ct(t).scheme,c=await s.load();n&&u&&await ut.getManager(i).removeModel(l);const h=await a.save(c);return n&&!u&&await ut.getManager(i).removeModel(l),h.modelArtifactsInfo}async function dt(){const t=ut.getSchemes(),e={};for(const n of t){const t=await ut.getManager(n).listModels();for(const r in t)e[n+lt+r]=t[r]}return e}async function pt(t){const e=ct(t);return ut.getManager(e.scheme).removeModel(e.path)}async function ft(t,e){return ht(t,e,!1)}async function gt(t,e){return ht(t,e,!0)}class mt{fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}}if((0,y._K)().get("IS_BROWSER")){(0,y._K)().setPlatform("browser",new mt);try{ut.registerManager(ot.URL_SCHEME,new it)}catch(t){}try{ut.registerManager(U.URL_SCHEME,new H)}catch(t){}}let bt;(0,y._K)().get("IS_NODE")&&(0,y._K)().setPlatform("node",new class{constructor(){this.util=n(8590),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=(0,y._K)().global.fetch?(0,y._K)().global.fetch(t,e):(null==bt&&(bt=n(5817)),bt(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}});var yt=n(448),vt=n(9809),wt=n(125),kt=n(5295),Tt=n(259);(0,p.Ye)();const xt={buffer:yt.r,cast:vt.w,clone:wt.o,print:kt.y};function Et(t){return new Promise(t=>setTimeout(t)).then(t)}(0,Tt.Q5)(xt);class At{constructor(t){if(!(0,y._K)().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(At.URL_SCHEME)&&(t=t.slice(At.URL_SCHEME.length)),null!=t&&0!==t.length||(t="model"),this.modelJsonFileName=t+".json",this.weightDataFileName=t+".weights.bin"}async save(t){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=D(t,[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(n)],{type:"application/json"})),s=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(s.download=this.modelJsonFileName,s.href=r,await Et(()=>s.dispatchEvent(new MouseEvent("click"))),null!=t.weightData){const t=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;t.download=this.weightDataFileName,t.href=e,await Et(()=>t.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:R(t)}}}}At.URL_SCHEME="downloads://";class St{constructor(t){if(null==t||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}async load(){return new Promise((t,e)=>{const n=new FileReader;n.onload=n=>{const r=JSON.parse(n.target.result),s=r.modelTopology;if(null==s)return void e(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==r.weightsManifest)return void e(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void t({modelTopology:s});const o=Y(r,t=>this.loadWeights(t));t(o)},n.onerror=t=>e(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(t){const e=[],n=[];for(const r of t)e.push(...r.weights),n.push(...r.paths);const r=this.checkManifestAndWeightFiles(t),s=n.map(t=>this.loadWeightsFile(t,r[t]));return Promise.all(s).then(t=>[e,N(t)])}loadWeightsFile(t,e){return new Promise((n,r)=>{const s=new FileReader;s.onload=t=>{const e=t.target.result;n(e)},s.onerror=e=>r(`Failed to weights data from file of path '${t}'.`),s.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(t){const e=[],n=this.weightsFiles.map(t=>_(t.name)),r={};for(const s of t)s.paths.forEach(t=>{const s=_(t);if(-1!==e.indexOf(s))throw new Error(`Duplicate file basename found in weights manifest: '${s}'`);if(e.push(s),-1===n.indexOf(s))throw new Error(`Weight file with basename '${s}' is not provided.`);r[t]=this.weightsFiles[n.indexOf(s)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}function $t(t){return new St(t)}function Mt(t,e,n,r){!function(t){(0,T.vA)(null!=t&&Array.isArray(t)&&t.length>0,()=>"promises must be a none empty array")}(t),function(t,e){(0,T.vA)(t>=0&&t<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${t}`),(0,T.vA)(e>=0&&e<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${e}`),(0,T.vA)(e>=t,()=>`startFraction must be no more than endFraction, but got startFraction ${t} and endFraction ${e}`)}(n=null==n?0:n,r=null==r?1:r);let s=0;return Promise.all(t.map(o=>(o.then(o=>{const a=n+ ++s/t.length*(r-n);return e(a),o}),o)))}async function It(t,e){null==e&&(e={});const n=null==e.fetchFunc?(0,y._K)().platform.fetch:e.fetchFunc,r=t.map(t=>n(t,e.requestInit,{isBinary:!0})),s=(null==e.onProgress?await Promise.all(r):await Mt(r,e.onProgress,0,.5)).map(t=>t.arrayBuffer());return null==e.onProgress?await Promise.all(s):await Mt(s,e.onProgress,.5,1)}async function Nt(t,e="",n,r){return _t(t=>It(t,{requestInit:r}))(t,e,n)}function _t(t){return async(e,n="",r)=>{const s=e.map(()=>!1),o={},a=null!=r?r.map(()=>!1):[],i=[];if(e.forEach((t,e)=>{let n=0;t.weights.forEach(t=>{const l="quantization"in t?t.quantization.dtype:t.dtype,u=x[l]*T.Ze(t.shape),c=()=>{s[e]=!0,null==o[e]&&(o[e]=[]),o[e].push({manifestEntry:t,groupOffset:n,sizeBytes:u})};null!=r?r.forEach((e,n)=>{e===t.name&&(c(),a[n]=!0)}):c(),i.push(t.name),n+=u})}),!a.every(t=>t)){const t=r.filter((t,e)=>!a[e]);throw new Error(`Could not find weights in manifest with names: ${t.join(", ")}. \nManifest JSON has weights with names: ${i.join(", ")}.`)}const l=s.reduce((t,e,n)=>(e&&t.push(n),t),[]),u=[];l.forEach(t=>{e[t].paths.forEach(t=>{const e=n+(n.endsWith("/")?"":"/")+t;u.push(e)})});const c=await t(u),h={};let d=0;return l.forEach(t=>{const n=e[t].paths.length;let r=0;for(let t=0;t<n;t++)r+=c[d+t].byteLength;const s=new ArrayBuffer(r),a=new Uint8Array(s);let i=0;for(let t=0;t<n;t++){const e=new Uint8Array(c[d+t]);a.set(e,i),i+=e.byteLength}o[t].forEach(t=>{const e=S(s.slice(t.groupOffset,t.groupOffset+t.sizeBytes),[t.manifestEntry]);for(const t in e)h[t]=e[t]}),d+=n}),h}}B.registerSaveRouter(t=>(0,y._K)().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(At.URL_SCHEME)?function(t="model"){return new At(t)}(t.slice(At.URL_SCHEME.length)):null);class Dt{constructor(t,e){if(this.DEFAULT_METHOD="POST",null==e&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,null!=e.fetchFunc?((0,T.vA)("function"==typeof e.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=(0,y._K)().platform.fetch,(0,T.vA)(null!=t&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&(0,T.vA)(2===t.length,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,null!=e.requestInit&&null!=e.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const n=D(t,[{paths:["./model.weights.bin"],weights:t.weightSpecs}]);e.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=t.weightData&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:"application/octet-stream"}),"model.weights.bin");const r=await this.fetch(this.path,e);if(r.ok)return{modelArtifactsInfo:R(t),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async load(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch(t){let e=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const n=e.modelTopology,r=e.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return Y(e,t=>this.loadWeights(t))}async loadWeights(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?");return[t.substring(0,e)+"/",n>e?t.substring(n):""]}(e),s=this.weightPathPrefix||n,o=[];for(const e of t)o.push(...e.weights);const a=[],i=[];for(const e of t)for(const t of e.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(t)):a.push(s+t+r);return this.weightUrlConverter&&a.push(...await Promise.all(i)),[o,N(await It(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function Yt(t){return null!=t.match(Dt.URL_SCHEME_REGEX)}Dt.URL_SCHEME_REGEX=/^https?:\/\//;const Rt=(t,e)=>{if("undefined"==typeof fetch&&(null==e||null==e.fetchFunc))return null;{let n=!0;if(n=Array.isArray(t)?t.every(t=>Yt(t)):Yt(t),n)return Ft(t,e)}return null};function Ft(t,e){return new Dt(t,e)}function Bt(t,e){return Ft(t,e)}B.registerSaveRouter(Rt),B.registerLoadRouter(Rt);class Ct{constructor(t){this.modelArtifacts=t}async load(){return this.modelArtifacts}}class Ot{constructor(t){this.saveHandler=t}async save(t){return this.saveHandler(t)}}function Pt(t,e,n,r){return 1===arguments.length?null!=t.modelTopology||null!=t.weightSpecs?new Ct(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Ct({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Ct({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:r}))}function Lt(t){return new Ot(t)}var Kt=n(8189),zt=n(5703),Wt=n(1760),jt=n(929),Gt=n(7703);const Ut=(0,jt.op)({confusionMatrix_:function(t,e,n){const r=(0,Kt.YT)(t,"labels","confusionMatrix"),s=(0,Kt.YT)(e,"predictions","confusionMatrix");T.vA(null==n||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),T.vA(1===r.rank,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),T.vA(1===s.rank,()=>`Expected the rank of predictions to be 1, but got ${s.rank}`),T.vA(r.shape[0]===s.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${s.shape[0]}. Labels and predictions should have the same number of elements.`),T.vA(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);const o=(0,Wt.M)((0,vt.w)(r,"int32"),n),a=(0,Wt.M)((0,vt.w)(s,"int32"),n),i=(0,Gt.m)(o),l=(0,zt.N)(i,a);return(0,vt.w)(l,"int32")}});var qt=n(5441),Ht=n(7074),Vt=n(2768);let Zt;function Xt(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==t)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,o=!1,a=!1,i=!1;if(t.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&t instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&t instanceof HTMLVideoElement)s=!0;else if("undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement)o=!0;else if(null!=t.getContext)a=!0;else{if(!("undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);i=!0}if(s){const e=2;if(s&&t.readyState<e)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(null!=(0,Ht._5)(qt.aw,p.T2.backendName)){const n={pixels:t},r={numChannels:e};return p.T2.runKernel(qt.aw,n,r)}const[l,u]=s?[t.videoWidth,t.videoHeight]:[t.width,t.height];let c,h;if(a)c=t.getContext("2d").getImageData(0,0,l,u).data;else if(r||n)c=t.data;else if(o||s||i){if(null==Zt)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");Zt=new OffscreenCanvas(1,1).getContext("2d")}else Zt=document.createElement("canvas").getContext("2d");Zt.canvas.width=l,Zt.canvas.height=u,Zt.drawImage(t,0,0,l,u),c=Zt.getImageData(0,0,l,u).data}if(4===e)h=new Int32Array(c);else{const t=l*u;h=new Int32Array(t*e);for(let n=0;n<t;n++)for(let t=0;t<e;++t)h[n*e+t]=c[4*n+t]}const d=[u,l,e];return(0,Vt.$)(h,d,"int32")}async function Qt(t,e=3){let n=null;if((0,y._K)().getBool("WRAP_TO_IMAGEBITMAP")&&function(t){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(t instanceof ImageBitmap)&&function(t){return null!=t&&0!==t.width&&0!==t.height}(t)&&!function(t){return null!=t&&t.data instanceof Uint8Array}(t)}(t)){let e;try{e=await createImageBitmap(t,{premultiplyAlpha:"none"})}catch(t){e=null}n=null!=e&&e.width===t.width&&e.height===t.height?e:t}else n=t;return Xt(n,e)}async function Jt(t,e){let n=(0,Kt.YT)(t,"img","toPixels");if(!(t instanceof Tt.qY)){const t=n;n=(0,vt.w)(t,"int32"),t.dispose()}if(2!==n.rank&&3!==n.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const[r,s]=n.shape.slice(0,2),o=2===n.rank?1:n.shape[2];if(o>4||2===o)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${o}`);if("float32"!==n.dtype&&"int32"!==n.dtype)throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);const a=await n.data(),i="float32"===n.dtype?255:1,l=new Uint8ClampedArray(s*r*4);for(let t=0;t<r*s;++t){const e=[0,0,0,255];for(let r=0;r<o;r++){const s=a[t*o+r];if("float32"===n.dtype){if(s<0||s>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${s}.`)}else if("int32"===n.dtype&&(s<0||s>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${s}.`);1===o?(e[0]=s*i,e[1]=s*i,e[2]=s*i):e[r]=s*i}const r=4*t;l[r+0]=Math.round(e[0]),l[r+1]=Math.round(e[1]),l[r+2]=Math.round(e[2]),l[r+3]=Math.round(e[3])}if(null!=e){e.width=s,e.height=r;const t=e.getContext("2d"),n=new ImageData(l,s,r);t.putImageData(n,0,0)}return n!==t&&n.dispose(),l}const te=(0,jt.op)({fromPixels_:Xt});function ee(t,e){const n=t.shape.length,r=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==e.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${n}`);if(0===(0,T.Ze)(t.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const s=e.shape,o=s[s.length-1];let a=1;for(let t=0;t<s.length-1;++t)a*=s[t];const i=t.shape,l=s.slice();l.pop();let u=1;for(let t=o;t<n;++t)u*=i[t],l.push(i[t]);const c=[...(0,T.Ur)(t.shape).map(t=>t/u),1].slice(0,o);return[l,a,u,c]}var ne=n(6170),re=n(4969);class se{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class oe{constructor(){this.classNameMap={}}static getMap(){return null==oe.instance&&(oe.instance=new oe),oe.instance}static register(t){oe.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function ae(t){(0,T.vA)(null!=t.className,()=>"Class being registered does not have the static className property defined."),(0,T.vA)("string"==typeof t.className,()=>"className is required to be a string, but got type "+typeof t.className),(0,T.vA)(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),oe.register(t)}var ie=n(565),le=n(3879);const ue=.001,ce=.1;function he(t,e,n){return null==n&&(n=de()),pe(t,e,(t,e)=>be(t,e,n))}function de(){return 32===p.T2.backend.floatPrecision()?ue:ce}function pe(t,e,n){let r=!0;if(((0,T.iu)(t)||(0,T.iu)(e))&&(r=!1),(0,T.iu)(t)&&(0,T.iu)(e)&&(r=!0),r){const n=t.constructor.name,r=e.constructor.name;if(n!==r)throw new Error(`Arrays are of different type. Actual: ${n}. Expected: ${r}`)}if(Array.isArray(t)&&Array.isArray(e)){const n=(0,Kt.MZ)(t),r=(0,Kt.MZ)(e);if(!(0,T.r1)(n,r))throw new Error(`Arrays have different shapes. Actual: [${n}]. Expected: [${r}]`)}const s=(0,T.iu)(t)?t:(0,T.Bq)(t),o=(0,T.iu)(e)?e:(0,T.Bq)(e);if(s.length!==o.length)throw new Error(`Arrays have different lengths actual: ${s.length} vs expected: ${o.length}.\nActual:   ${s}.\nExpected: ${o}.`);for(let t=0;t<o.length;++t){const e=s[t],r=o[t];if(!n(e,r))throw new Error(`Arrays differ: actual[${t}] = ${e}, expected[${t}] = ${r}.\nActual:   ${s}.\nExpected: ${o}.`)}}function fe(t,e){t().then(()=>e.fail(),()=>e())}function ge(t,e){const n="string"==typeof e||"number"==typeof e||"boolean"==typeof e?[e]:e;return(0,T.Kg)(t)||(0,T.Kg)(t[0])||(0,T.Kg)(e)||(0,T.Kg)(e[0])?pe(t,n,(t,e)=>t==e):pe(t,e,(t,e)=>be(t,e,0))}function me(t,e,n){if(null==n&&(n=de()),!be(t,e,n))throw new Error(`Numbers differ: actual === ${t}, expected === ${e}`)}function be(t,e,n){return!isFinite(t)&&!isFinite(e)||!(isNaN(t)||isNaN(e)||Math.abs(t-e)>n)}function ye(t,e,n){for(let r=0;r<t.length;r++)if(t[r]<e||t[r]>n)throw new Error(`Value out of range:${t[r]} low: ${e}, high: ${n}`)}function ve(t,e){expect(new Float32Array(t)).toEqual(new Float32Array(e))}function we(t){for(let e=0;e<t.length;e++){const n=t[e];Array.isArray(n)?we(n):t[e]=(0,le.encodeString)(n)}return t}const ke="3.11.0";var Te=n(5287),xe=n(7523),Ee=n(9359),Ae=n(9258),Se=n(9348),$e=n(5793),Me=n(5537),Ie=n(1830),Ne=n(5702);class _e extends se{minimize(t,e=!1,n){const{value:r,grads:s}=this.computeGradients(t,n);if(null!=n){const t=n.map(t=>({name:t.name,tensor:s[t.name]}));this.applyGradients(t)}else this.applyGradients(s);return(0,Te.AS)(s),e?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return(0,Ie.y7)(t,e)}dispose(){null!=this.iterations_&&(0,Te.AS)(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:(0,Ne.d)(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(_e,Symbol.hasInstance,{value:t=>null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients});class De extends _e{constructor(t,e,n=null){super(),this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=p.T2.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const r=p.T2.registeredVariables[e],s=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${e}/accum_grad`,variable:(0,Te.DZ)(()=>(0,Me.P)(r).variable(s))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${e}/accum_var`,variable:(0,Te.DZ)(()=>(0,Me.P)(r).variable(s))});const o=Array.isArray(t)?t[n].tensor:t[e];if(null==o)return;const a=this.accumulatedGrads[n].variable,i=this.accumulatedUpdates[n].variable;(0,Te.DZ)(()=>{const t=(0,xe.W)((0,Ae.l)(a,this.rho),(0,Ae.l)((0,$e.E)(o),1-this.rho)),e=(0,Ae.l)((0,Ee.y)((0,Se.R)((0,xe.W)(i,this.epsilon)),(0,Se.R)((0,xe.W)(a,this.epsilon))),o),n=(0,xe.W)((0,Ae.l)(i,this.rho),(0,Ae.l)((0,$e.E)(e),1-this.rho));a.assign(t),i.assign(n);const s=(0,xe.W)((0,Ae.l)(e,-this.learningRate),r);r.assign(s)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&((0,Te.AS)(this.accumulatedGrads.map(t=>t.variable)),(0,Te.AS)(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){const e=(t=await this.extractIterations(t)).length/2,n=!1;this.accumulatedGrads=t.slice(0,e).map(t=>({originalName:t.name,variable:t.tensor.variable(n)})),this.accumulatedUpdates=t.slice(e,2*e).map(t=>({originalName:t.name,variable:t.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}De.className="Adadelta",ae(De);var Ye=n(6111);class Re extends _e{constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const r=p.T2.registeredVariables[e];if(null==this.accumulatedGrads[n]){const t=!1;this.accumulatedGrads[n]={originalName:`${e}/accumulator`,variable:(0,Te.DZ)(()=>(0,Ye.G)(r.shape,this.initialAccumulatorValue).variable(t))}}const s=Array.isArray(t)?t[n].tensor:t[e];if(null==s)return;const o=this.accumulatedGrads[n].variable;(0,Te.DZ)(()=>{const t=(0,xe.W)(o,(0,$e.E)(s));o.assign(t);const e=(0,xe.W)((0,Ae.l)((0,Ee.y)(s,(0,Se.R)((0,xe.W)(t,p.T2.backend.epsilon()))),-this.learningRate),r);r.assign(e)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&(0,Te.AS)(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t),this.accumulatedGrads=t.map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}Re.className="Adagrad",ae(Re);var Fe=n(8990),Be=n(7126);class Ce extends _e{constructor(t,e,n,r=null){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],(0,Te.DZ)(()=>{this.accBeta1=(0,Ne.d)(e).variable(),this.accBeta2=(0,Ne.d)(n).variable()}),null==r&&(this.epsilon=p.T2.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);(0,Te.DZ)(()=>{const n=(0,Be.j)(1,this.accBeta1),r=(0,Be.j)(1,this.accBeta2);e.forEach((e,s)=>{const o=p.T2.registeredVariables[e],a=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${e}/m`,variable:(0,Te.DZ)(()=>(0,Me.P)(o).variable(a))}),null==this.accumulatedSecondMoment[s]&&(this.accumulatedSecondMoment[s]={originalName:`${e}/v`,variable:(0,Te.DZ)(()=>(0,Me.P)(o).variable(a))});const i=Array.isArray(t)?t[s].tensor:t[e];if(null==i)return;const l=this.accumulatedFirstMoment[s].variable,u=this.accumulatedSecondMoment[s].variable,c=(0,xe.W)((0,Ae.l)(l,this.beta1),(0,Ae.l)(i,1-this.beta1)),h=(0,xe.W)((0,Ae.l)(u,this.beta2),(0,Ae.l)((0,$e.E)(i),1-this.beta2)),d=(0,Ee.y)(c,n),f=(0,Ee.y)(h,r);l.assign(c),u.assign(h);const g=(0,xe.W)((0,Ae.l)((0,Ee.y)(d,(0,xe.W)((0,Se.R)(f),this.epsilon)),-this.learningRate),o);o.assign(g)}),this.accBeta1.assign((0,Ae.l)(this.accBeta1,this.beta1)),this.accBeta2.assign((0,Ae.l)(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&(0,Te.AS)(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedSecondMoment&&(0,Te.AS)(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t),(0,Te.DZ)(()=>{this.accBeta1.assign((0,Fe.n)(this.beta1,this.iterations_+1)),this.accBeta2.assign((0,Fe.n)(this.beta2,this.iterations_+1))});const e=t.length/2,n=!1;this.accumulatedFirstMoment=t.slice(0,e).map(t=>({originalName:t.name,variable:t.tensor.variable(n)})),this.accumulatedSecondMoment=t.slice(e,2*e).map(t=>({originalName:t.name,variable:t.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}Ce.className="Adam",ae(Ce);var Oe=n(4888),Pe=n(178);class Le extends _e{constructor(t,e,n,r=null,s=0){super(),this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],(0,Te.DZ)(()=>{this.iteration=(0,Ne.d)(0).variable(),this.accBeta1=(0,Ne.d)(e).variable()}),null==r&&(this.epsilon=p.T2.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(t=>t.name):Object.keys(t);(0,Te.DZ)(()=>{const n=(0,Be.j)(1,this.accBeta1),r=(0,Ee.y)(-this.learningRate,(0,xe.W)((0,Ae.l)(this.iteration,this.decay),1));e.forEach((e,s)=>{const o=p.T2.registeredVariables[e],a=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${e}/m`,variable:(0,Me.P)(o).variable(a)}),null==this.accumulatedWeightedInfNorm[s]&&(this.accumulatedWeightedInfNorm[s]={originalName:`${e}/v`,variable:(0,Me.P)(o).variable(a)});const i=Array.isArray(t)?t[s].tensor:t[e];if(null==i)return;const l=this.accumulatedFirstMoment[s].variable,u=this.accumulatedWeightedInfNorm[s].variable,c=(0,xe.W)((0,Ae.l)(l,this.beta1),(0,Ae.l)(i,1-this.beta1)),h=(0,Ae.l)(u,this.beta2),d=(0,Oe.t)(i),f=(0,Pe.P)(h,d);l.assign(c),u.assign(f);const g=(0,xe.W)((0,Ae.l)((0,Ee.y)(r,n),(0,Ee.y)(c,(0,xe.W)(f,this.epsilon))),o);o.assign(g)}),this.iteration.assign((0,xe.W)(this.iteration,1)),this.accBeta1.assign((0,Ae.l)(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&(0,Te.AS)(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedWeightedInfNorm&&(0,Te.AS)(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}Le.className="Adamax",ae(Le);class Ke extends _e{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const r=Array.isArray(t)?t[n].tensor:t[e];if(null==r)return;const s=p.T2.registeredVariables[e];(0,Te.DZ)(()=>{const t=(0,xe.W)((0,Ae.l)(this.c,r),s);s.assign(t)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=(0,Te.aC)((0,Ne.d)(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(0!==(t=await this.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}Ke.className="SGD",ae(Ke);class ze extends Ke{constructor(t,e,n=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=(0,Ne.d)(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const r=p.T2.registeredVariables[e];if(null==this.accumulations[n]){const t=!1;this.accumulations[n]={originalName:`${e}/momentum`,variable:(0,Te.DZ)(()=>(0,Me.P)(r).variable(t))}}const s=this.accumulations[n].variable,o=Array.isArray(t)?t[n].tensor:t[e];null!=o&&(0,Te.DZ)(()=>{let t;const e=(0,xe.W)((0,Ae.l)(this.m,s),o);t=this.useNesterov?(0,xe.W)((0,Ae.l)(this.c,(0,xe.W)(o,(0,Ae.l)(e,this.m))),r):(0,xe.W)((0,Ae.l)(this.c,e),r),s.assign(e),r.assign(t)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&(0,Te.AS)(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t),this.accumulations=t.map(t=>({originalName:t.name,variable:t.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}ze.className="Momentum",ae(ze);class We extends _e{constructor(t,e=.9,n=0,r=null,s=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,null==r&&(this.epsilon=p.T2.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(t=>t.name):Object.keys(t)).forEach((e,n)=>{const r=p.T2.registeredVariables[e],s=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${e}/rms`,variable:(0,Te.DZ)(()=>(0,Me.P)(r).variable(s))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${e}/momentum`,variable:(0,Te.DZ)(()=>(0,Me.P)(r).variable(s))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${e}/mg`,variable:(0,Te.DZ)(()=>(0,Me.P)(r).variable(s))});const o=Array.isArray(t)?t[n].tensor:t[e];if(null==o)return;const a=this.accumulatedMeanSquares[n].variable,i=this.accumulatedMoments[n].variable;(0,Te.DZ)(()=>{const t=(0,xe.W)((0,Ae.l)(a,this.decay),(0,Ae.l)((0,$e.E)(o),1-this.decay));if(this.centered){const e=this.accumulatedMeanGrads[n].variable,s=(0,xe.W)((0,Ae.l)(e,this.decay),(0,Ae.l)(o,1-this.decay)),l=(0,Ee.y)((0,Ae.l)(o,this.learningRate),(0,Se.R)((0,Be.j)(t,(0,xe.W)((0,$e.E)(s),this.epsilon)))),u=(0,xe.W)((0,Ae.l)(i,this.momentum),l);a.assign(t),e.assign(s),i.assign(u);const c=(0,Be.j)(r,u);r.assign(c)}else{const t=(0,xe.W)((0,Ae.l)(a,this.decay),(0,Ae.l)((0,$e.E)(o),1-this.decay)),e=(0,xe.W)((0,Ae.l)(i,this.momentum),(0,Ee.y)((0,Ae.l)(o,this.learningRate),(0,Se.R)((0,xe.W)(t,this.epsilon))));a.assign(t),i.assign(e);const n=(0,Be.j)(r,e);r.assign(n)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&(0,Te.AS)(this.accumulatedMeanSquares.map(t=>t.variable)),null!=this.accumulatedMeanGrads&&this.centered&&(0,Te.AS)(this.accumulatedMeanGrads.map(t=>t.variable)),null!=this.accumulatedMoments&&(0,Te.AS)(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,n=!1;this.accumulatedMeanSquares=t.slice(0,e).map(t=>({originalName:t.name,variable:t.tensor.variable(n)})),this.accumulatedMoments=t.slice(e,2*e).map(t=>({originalName:t.name,variable:t.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=t.slice(2*e,3*e).map(t=>({originalName:t.name,variable:t.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}We.className="RMSProp",ae(We);class je{static sgd(t){return new Ke(t)}static momentum(t,e,n=!1){return new ze(t,e,n)}static rmsprop(t,e=.9,n=0,r=null,s=!1){return new We(t,e,n,r,s)}static adam(t=.001,e=.9,n=.999,r=null){return new Ce(t,e,n,r)}static adadelta(t=.001,e=.95,n=null){return new De(t,e,n)}static adamax(t=.002,e=.9,n=.999,r=null,s=0){return new Le(t,e,n,r,s)}static adagrad(t,e=.1){return new Re(t,e)}}var Ge=n(2046),Ue=n(9235),qe=n(7084);const He={sgd:je.sgd,momentum:je.momentum,adadelta:je.adadelta,adagrad:je.adagrad,rmsprop:je.rmsprop,adamax:je.adamax,adam:je.adam},Ve="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:t=>t();function Ze(){return new Promise(t=>Ve(()=>t()))}var Xe=n(1078),Qe=n(2198);function Je(t,e){const n=t[0].length;t.forEach((t,e)=>{T.vA(t.length===n,()=>`Error in concat${n}D: rank of tensors[${e}] must be the same as the rank of the rest (${n})`)}),T.vA(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=t[0];t.forEach((t,s)=>{for(let o=0;o<n;o++)T.vA(o===e||t[o]===r[o],()=>`Error in concat${n}D: Shape of tensors[${s}] (${t}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`)})}function tn(t,e){const n=t[0].slice();for(let r=1;r<t.length;r++)n[e]+=t[r][e];return n}var en=n(7195),nn=n(8646);const rn=30;function sn(t){return t<=rn?t:(0,T.lK)(t,Math.floor(Math.sqrt(t)))}function on(t,e,n){return[n*("number"==typeof t?t:t[0]),e*("number"==typeof t?t:t[1])]}function an(t,e,n,r=!0){let s=[];if(r)s=s.concat(e.slice(0)),s.push(t[0]/n),s=s.concat(t.slice(1));else{s=s.concat(t[0]);const n=e.length;for(let r=0;r<n;++r)s=s.concat([t[r+1]/e[r],e[r]]);s=s.concat(t.slice(n+1))}return s}function ln(t,e,n=!0){const r=[];if(n){r.push(e);for(let n=e+1;n<t;++n)n<=2*e?(r.push(n),r.push(n-(e+1))):r.push(n)}else{const n=[],s=[];for(let r=1;r<t;++r)r>=2*e+1||r%2==1?s.push(r):n.push(r);r.push(...n),r.push(0),r.push(...s)}return r}function un(t,e,n,r=!0){const s=[];r?s.push(t[0]/n):s.push(t[0]*n);for(let n=1;n<t.length;++n)n<=e.length?r?s.push(e[n-1]*t[n]):s.push(t[n]/e[n-1]):s.push(t[n]);return s}function cn(t,e){const n=[0];for(let r=0;r<e;++r)n.push(t[r][0]);return n}function hn(t,e,n){const r=t.slice(0,1);for(let s=0;s<n;++s)r.push(t[s+1]-e[s][0]-e[s][1]);return r}var dn=n(8576);const pn=.3275911,fn=.254829592,gn=-.284496736,mn=1.421413741,bn=-1.453152027,yn=1.061405429;var vn=n(3673);function wn(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(2*t.length);for(let r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function kn(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}function Tn(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let e=0;e<t.length;e+=4)n[Math.floor(e/4)]=t[e],r[Math.floor(e/4)]=t[e+1];return{real:n,imag:r}}function xn(t){const e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let e=2;e<t.length;e+=4)n[Math.floor(e/4)]=t[e],r[Math.floor(e/4)]=t[e+1];return{real:n,imag:r}}function En(t,e){return{real:t[2*e],imag:t[2*e+1]}}function An(t,e,n,r){t[2*r]=e,t[2*r+1]=n}function Sn(t,e){const n=new Float32Array(t/2),r=new Float32Array(t/2);for(let s=0;s<Math.ceil(t/2);s++){const o=(e?2:-2)*Math.PI*(s/t);n[s]=Math.cos(o),r[s]=Math.sin(o)}return{real:n,imag:r}}function $n(t,e,n){const r=(n?2:-2)*Math.PI*(t/e);return{real:Math.cos(r),imag:Math.sin(r)}}const Mn="->",In=/->/g,Nn=",",_n="...";function Dn(t,e){const n=((t=t.replace(/\s/g,"")).length-t.replace(In,"").length)/Mn.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Mn}").`);const[r,s]=t.split(Mn);(0,T.vA)(-1===r.indexOf(_n),()=>`The ellipsis notation ("${_n}") is not supported yet.`);const o=r.split(Nn),a=o.length;if(e!==a)throw new Error(`Expected ${a} input tensors, received ${e}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let t=0;t<s.length;++t){const e=s[t];if(!o.some(t=>-1!==t.indexOf(e)))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===i.indexOf(e)&&i.push(e)}for(let t=0;t<r.length;++t){const e=r[t];-1===i.indexOf(e)&&e!==Nn&&i.push(e)}const l=new Array(o.length);for(let t=0;t<a;++t){if(new Set(o[t].split("")).size!==o[t].length)throw new Error(`Found duplicate axes in input component ${o[t]}. Support for duplicate axes in input is not implemented yet.`);l[t]=[];for(let e=0;e<o[t].length;++e)l[t].push(i.indexOf(o[t][e]))}const u=i.length,c=[];for(let t=s.length;t<u;++t)c.push(t);return{allDims:i,summedDims:c,idDims:l}}function Yn(t,e){let n=new Array(t);n.fill(-1);for(let t=0;t<e.length;++t)n[e[t]]=t;const r=[];for(let e=0;e<t;++e)-1===n[e]&&r.push(e);return n=n.filter(t=>-1!==t),{permutationIndices:n,expandDims:r}}function Rn(t,e,n){const r=new Array(t);for(let t=0;t<n.length;++t){const s=n[t].shape;for(let n=0;n<e[t].length;++n)void 0===r[e[t][n]]?r[e[t][n]]=s[n]:(0,T.vA)(r[e[t][n]]===s[n],()=>`Expected dimension ${r[e[t][n]]} at axis ${n} of input shaped ${JSON.stringify(s)}, but got dimension ${s[n]}`)}}function Fn(t,e){const n=t,r=[];let s=0;0===t.length&&n.push(-1),s=t.length+1;for(let t=0;t<s;++t)r.push([]);const o=[];for(let t=0;t<n.length;++t){const s=Cn(e,n[t]);for(const e of s)-1===o.indexOf(e)&&(r[t].push(e),o.push(e))}return{path:n,steps:r}}function Bn(t){return t.every((t,e)=>t===e)}function Cn(t,e){const n=[];for(let r=0;r<t.length;++r)0!==t[r].length&&-1===t[r].indexOf(e)&&-1!==e||n.push(r);return n}function On(t,e,n=0){let r=[];if("number"==typeof e)(0,T.vA)(t.shape[n]%e===0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(t.shape[n]/e);else{const s=e.reduce((t,e)=>(-1===e&&(t+=1),t),0);(0,T.vA)(s<=1,()=>"There should be only one negative value in split array.");const o=e.indexOf(-1);if(-1!==o){const r=e.reduce((t,e)=>e>0?t+e:t);e[o]=t.shape[n]-r}(0,T.vA)(t.shape[n]===e.reduce((t,e)=>t+e),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}function Pn(t,e){let n,r=!1;for(t<=rn?(n=t,r=!0):n=(0,T.lK)(t,Math.floor(Math.sqrt(t)));!r;)n>e||n===t?r=!0:n=(0,T.lK)(t,n+1);return n}function Ln(t,e,n){const r=[],s=t.length;for(let o=0;o<s;o++)o!==e?r.push(t[o]):r.push(n);return r}function Kn(t,e,n,r){const s=e.shape.length,o=t.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>o)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${o}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let n=0;n<r;++n)if(t.shape[n]!==e.shape[n])throw new Error(`x.shape[${n}]: ${t.shape[n]} should be equal to indices.shape[${n}]: ${e.shape[n]}.`);const a=t.shape[n],i=[];let l=1,u=1,c=1;for(let e=0;e<r;++e)i.push(t.shape[e]),l*=t.shape[e];for(let e=r;e<n;e++)i.push(t.shape[e]),u*=t.shape[e];for(let t=r;t<s;t++)i.push(e.shape[t]);for(let e=n+1;e<o;e++)i.push(t.shape[e]),c*=t.shape[e];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:a,outputShape:i}}function zn(t){try{return t.map(t=>(0,le.decodeString)(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function Wn(t){return t.map(t=>(0,le.encodeString)(t))}var jn=n(8360),Gn=n(4411),Un=n(5149)},6170:(t,e,n)=>{"use strict";n.r(e),n.d(e,{calculateShapes:()=>a,validateInput:()=>o,validateUpdateShape:()=>s});var r=n(5119);function s(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(o+` update.rank < ${s}. `);if(t.length<r+(n.rank-s))throw new Error(o+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+t.length-r)throw new Error(o+" update.rank != "+(s+t.length-r));for(let t=0;t<s;++t)if(n.shape[t]!==e.shape[t])throw new Error(o+` updates.shape[${t}] (${n.shape[t]}) != indices.shape[${t}] (${e.shape[t]}).`);for(let e=0;e<n.rank-s;++e)if(n.shape[e+s]!==t[e+r])throw new Error(o+` updates.shape[${e+s}] (${n.shape[e+s]}) != shape[${e+s}] (${t[e+s]})`)}function o(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if("int32"!==e.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===e.size)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(0===t.size)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}s(n,e,t)}function a(t,e,n){const s=e.shape.length,o=s>1?e.shape[s-1]:1,a=n.length;let i=1;for(let t=o;t<a;++t)i*=n[t];const l=o<1?1:o;return{sliceRank:o,numUpdates:(0,r.Ze)(e.shape)/l,sliceSize:i,strides:[...(0,r.Ur)(n.slice(0,o)),1],outputSize:(0,r.Ze)(n)}}},6300:(t,e,n)=>{"use strict";n.d(e,{y:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({isNaN_:function(t){const e={x:(0,o.YT)(t,"x","isNaN")};return r.T2.runKernel(s.iP,e)}})},6325:(t,e,n)=>{"use strict";n.d(e,{W:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({selu_:function(t){const e={x:(0,o.YT)(t,"x","selu")};return r.T2.runKernel(s.u$,e)}})},6346:(t,e,n)=>{"use strict";n.d(e,{V:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({softmax_:function(t,e=-1){const n=(0,o.YT)(t,"logits","softmax","float32");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);const a={logits:n},i={dim:e};return r.T2.runKernel(s.K2,a,i)}})},6508:(t,e,n)=>{"use strict";n.d(e,{I:()=>l});var r=n(1585),s=n(5441),o=n(565),a=n(8189),i=n(2198);const l=(0,n(929).op)({lessEqual_:function(t,e){let n=(0,a.YT)(t,"a","lessEqual","string_or_numeric"),l=(0,a.YT)(e,"b","lessEqual","string_or_numeric");[n,l]=(0,o.makeTypesMatch)(n,l),(0,i.Ky)(n.shape,l.shape);const u={a:n,b:l};return r.T2.runKernel(s.Cw,u)}})},6512:(t,e,n)=>{"use strict";n.d(e,{l:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({split_:function(t,e,n=0){const a={x:(0,o.YT)(t,"x","split")},i={numOrSizeSplits:e,axis:n};return r.T2.runKernel(s.Bl,a,i)}})},6522:(t,e,n)=>{"use strict";n.d(e,{H:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({neg_:function(t){const e={x:(0,o.YT)(t,"x","neg")};return r.T2.runKernel(s.l0,e)}})},6545:(t,e,n)=>{"use strict";n.d(e,{m:()=>o});var r=n(1585),s=n(5441);function o(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");const o={start:t,stop:e,num:n};return r.T2.runKernel(s.mn,{},o)}},6567:(t,e,n)=>{"use strict";n.d(e,{F:()=>i});var r=n(1585),s=n(5441),o=n(8189),a=n(5119);const i=(0,n(929).op)({mirrorPad_:function(t,e,n){a.vA("reflect"===n||"symmetric"===n,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const i=(0,o.YT)(t,"x","mirrorPad");if(0===i.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");a.vA(e.length===i.rank,()=>`Padding doesn't match input. Must be ${i.rank}. Got ${e.length}.`);const l="reflect"===n?1:0;for(let t=0;t<i.rank;t++)a.vA(2===e[t].length,()=>"Invalid number of paddings. Must be length of 2 each."),a.vA(e[t][0]>=0&&e[t][0]<=i.shape[t]-l&&e[t][1]>=0&&e[t][1]<=i.shape[t]-l,()=>`Padding in dimension ${t} cannot be greater than or equal to ${i.shape[t]-l} or less than 0 for input of shape ${i.shape}`);const u={paddings:e,mode:n},c={x:i};return r.T2.runKernel(s.x7,c,u)}})},6574:(t,e,n)=>{"use strict";n.d(e,{Km:()=>u,OH:()=>a,_K:()=>l,tj:()=>c});var r=n(5119),s=n(3673);const o="tfjsflags";class a{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=i,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&s.i(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},null!=this.urlFlags[t]){const e=this.urlFlags[t];s.i(`Setting feature override from URL ${t}: ${e}.`),this.set(t,e)}}async getAsync(t){return t in this.flags||(this.flags[t]=await this.evaluateFlag(t)),this.flags[t]}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if((0,r.yL)(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=this.getQueryParams(this.global.location.search);o in t&&t[o].split(",").forEach(t=>{const[e,n]=t.split(":");this.urlFlags[e]=function(t,e){if("true"===(e=e.toLowerCase())||"false"===e)return"true"===e;if(""+ +e===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)}(e,n)})}}function i(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...n)=>(function(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}(e,n[0],n[1]),n.join("="))),e}function l(){return u}let u=null;function c(t){u=t}},6652:(t,e,n)=>{"use strict";n.d(e,{Y:()=>o});var r=n(4411),s=n(8189);const o=async function(t){const e=(0,s.YT)(t,"condition","whereAsync","bool"),n=await e.data(),o=(0,r.Y)(e.shape,n);return t!==e&&e.dispose(),o}},6654:(t,e,n)=>{"use strict";n.d(e,{Z:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({sparseToDense_:function(t,e,n,a=0){const i=(0,o.YT)(t,"sparseIndices","sparseToDense","int32"),l=(0,o.YT)(e,"sparseValues","sparseToDense"),u=(0,o.YT)(a,"defaultValue","sparseToDense",l.dtype);!function(t,e,n,r){if("int32"!==t.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const s=t.rank>0?t.shape[0]:1,o=t.rank>1?t.shape[1]:1;if(n.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${o}.`);const a=e.size;if(0!==e.rank&&(1!==e.rank||a!==s))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${s}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(i,l,n,u);const c={sparseIndices:i,sparseValues:l,defaultValue:u},h={outputShape:n};return r.T2.runKernel(s.jg,c,h)}})},6808:(t,e,n)=>{"use strict";n.d(e,{r:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({cumsum_:function(t,e=0,n=!1,a=!1){const i={x:(0,o.YT)(t,"x","cumsum")},l={axis:e,exclusive:n,reverse:a};return r.T2.runKernel(s.nY,i,l)}})},6841:(t,e,n)=>{"use strict";n.d(e,{q:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({asin_:function(t){const e={x:(0,o.YT)(t,"x","asin")};return r.T2.runKernel(s.QK,e)}})},6919:(t,e,n)=>{"use strict";n.d(e,{H:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({leakyRelu_:function(t,e=.2){const n={x:(0,o.YT)(t,"x","leakyRelu")},a={alpha:e};return r.T2.runKernel(s.X0,n,a)}})},6928:(t,e,n)=>{"use strict";n.d(e,{z:()=>i});var r=n(1585),s=n(5441),o=n(8189),a=n(5119);const i=(0,n(929).op)({clipByValue_:function(t,e,n){const i=(0,o.YT)(t,"x","clipByValue");a.vA(e<=n,()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`);const l={x:i},u={clipValueMin:e,clipValueMax:n};return r.T2.runKernel(s.v,l,u)}})},6950:function(t,e,n){var r;!function(t,s){function o(t){var e=this,n="";e.next=function(){var t=e.x^e.x>>>2;return e.x=e.y,e.y=e.z,e.z=e.w,e.w=e.v,(e.d=e.d+362437|0)+(e.v=e.v^e.v<<4^t^t<<1)|0},e.x=0,e.y=0,e.z=0,e.w=0,e.v=0,t===(0|t)?e.x=t:n+=t;for(var r=0;r<n.length+64;r++)e.x^=0|n.charCodeAt(r),r==n.length&&(e.d=e.x<<10^e.x>>>4),e.next()}function a(t,e){return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e.v=t.v,e.d=t.d,e}function i(t,e){var n=new o(t),r=e&&e.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var t=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=i:n.amdD&&n.amdO?void 0===(r=function(){return i}.call(e,n,e,s))||(s.exports=r):this.xorwow=i}(0,t=n.nmd(t),n.amdD)},6999:(t,e,n)=>{"use strict";n.d(e,{j:()=>c});var r=n(1585),s=n(5441),o=n(8189),a=n(5119),i=n(7195),l=n(929),u=n(2302);const c=(0,l.op)({maxPool_:function(t,e,n,l,c){const h=(0,o.YT)(t,"x","maxPool");let d=h,p=!1;3===h.rank&&(p=!0,d=(0,u.t)(h,[1,h.shape[0],h.shape[1],h.shape[2]])),a.vA(4===d.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${d.rank}.`),a.vA(i.G0(n,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`),null!=c&&a.vA(a.E6(l),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${c} but got pad ${l}.`);const f={x:d},g={filterSize:e,strides:n,pad:l,dimRoundingMode:c},m=r.T2.runKernel(s.t3,f,g);return p?(0,u.t)(m,[m.shape[1],m.shape[2],m.shape[3]]):m}})},7074:(t,e,n)=>{"use strict";n.d(e,{Cf:()=>g,Op:()=>c,_5:()=>l,iP:()=>p,kr:()=>d,rY:()=>f,tA:()=>h,vQ:()=>u});var r=n(6574),s=n(1743),o=n(3673);const a=(0,s.m)("kernelRegistry",()=>new Map),i=(0,s.m)("gradRegistry",()=>new Map);function l(t,e){const n=m(t,e);return a.get(n)}function u(t){return i.get(t)}function c(t){const e=a.entries(),n=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[o,a]=s,[i]=o.split("_");i===t&&n.push(a)}return n}function h(t){const{kernelName:e,backendName:n}=t,r=m(e,n);a.has(r)&&o.i(`The kernel '${e}' for backend '${n}' is already registered`),a.set(r,t)}function d(t){const{kernelName:e}=t;i.has(e)&&(0,r._K)().getBool("DEBUG")&&o.i(`Overriding the gradient for '${e}'`),i.set(e,t)}function p(t,e){const n=m(t,e);if(!a.has(n))throw new Error(`The kernel '${t}' for backend '${e}' is not registered`);a.delete(n)}function f(t){if(!i.has(t))throw new Error(`The gradient '${t}' for backend is not registered`);i.delete(t)}function g(t,e){c(t).forEach(t=>{h(Object.assign({},t,{backendName:e}))})}function m(t,e){return`${e}_${t}`}},7084:(t,e,n)=>{"use strict";var r;n.d(e,{i:()=>r}),function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(r||(r={}))},7126:(t,e,n)=>{"use strict";n.d(e,{j:()=>i});var r=n(1585),s=n(5441),o=n(565),a=n(8189);const i=(0,n(929).op)({sub_:function(t,e){let n=(0,a.YT)(t,"a","sub"),i=(0,a.YT)(e,"b","sub");[n,i]=(0,o.makeTypesMatch)(n,i);const l={a:n,b:i};return r.T2.runKernel(s.Pb,l)}})},7148:(t,e,n)=>{"use strict";n.d(e,{f:()=>i});var r=n(1585),s=n(5441),o=n(8189),a=n(5119);const i=(0,n(929).op)({complex_:function(t,e){const n=(0,o.YT)(t,"real","complex"),i=(0,o.YT)(e,"imag","complex");a.O3(n.shape,i.shape,`real and imag shapes, ${n.shape} and ${i.shape}, must match in call to tf.complex().`);const l={real:n,imag:i};return r.T2.runKernel(s.pr,l)}})},7195:(t,e,n)=>{"use strict";function r(t,e,n,r,s="NHWC",o){return a(t,[...e,t[3]],n,o,r,null,null,g(s))}function s(t,e,n,r,s,o,i="channelsLast"){const[l,c]=u(e);let h;if("channelsLast"===i)h=[l,c,t[3],t[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);h=[l,c,t[1],t[1]]}return a(t,h,n,r,s,o,!1,i)}function o(t,e,n,r,s,o,a="NDHWC"){const[l,u,h]=c(e);let d,p;if("NDHWC"===a)p="channelsLast",d=[l,u,h,t[4],t[4]];else{if("NCDHW"!==a)throw new Error(`Unknown dataFormat ${a}`);p="channelsFirst",d=[l,u,h,t[1],t[1]]}return i(t,d,n,r,s,!1,p,o)}function a(t,e,n,r,s,o,a=!1,i="channelsLast"){let[c,p,f,g]=[-1,-1,-1,-1];if("channelsLast"===i)[c,p,f,g]=t;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[c,g,p,f]=t}const[m,b,,y]=e,[v,w]=u(n),[k,T]=u(r),x=h(m,k),E=h(b,T),{padInfo:A,outHeight:S,outWidth:$}=function(t,e,n,r,s,o,a,i,u){let c,h,p;if("number"==typeof t){c={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const s=function(t,e,n,r,s){null==r&&(r=l(t,e,n));const o=t[1];return[d((t[0]-e+2*r)/n+1,s),d((o-e+2*r)/n+1,s)]}([e,n],o,r,t,i);h=s[0],p=s[1]}else if("same"===t){h=Math.ceil(e/r),p=Math.ceil(n/s);const t=Math.max(0,(h-1)*r+o-e),i=Math.max(0,(p-1)*s+a-n),l=Math.floor(t/2),u=t-l,d=Math.floor(i/2);c={top:l,bottom:u,left:d,right:i-d,type:"SAME"}}else if("valid"===t)c={top:0,bottom:0,left:0,right:0,type:"VALID"},h=Math.ceil((e-o+1)/r),p=Math.ceil((n-a+1)/s);else{if("object"!=typeof t)throw Error(`Unknown padding parameter: ${t}`);{const l="channelsLast"===u?t[1][0]:t[2][0],f="channelsLast"===u?t[1][1]:t[2][1],g="channelsLast"===u?t[2][0]:t[3][0],m="channelsLast"===u?t[2][1]:t[3][1];c={top:l,bottom:f,left:g,right:m,type:0===l&&0===f&&0===g&&0===m?"VALID":"EXPLICIT"},h=d((e-o+l+f)/r+1,i),p=d((n-a+g+m)/s+1,i)}}return{padInfo:c,outHeight:h,outWidth:p}}(s,p,f,v,w,x,E,o,i),M=a?y*g:y;let I;return"channelsFirst"===i?I=[c,M,S,$]:"channelsLast"===i&&(I=[c,S,$,M]),{batchSize:c,dataFormat:i,inHeight:p,inWidth:f,inChannels:g,outHeight:S,outWidth:$,outChannels:M,padInfo:A,strideHeight:v,strideWidth:w,filterHeight:m,filterWidth:b,effectiveFilterHeight:x,effectiveFilterWidth:E,dilationHeight:k,dilationWidth:T,inShape:t,outShape:I,filterShape:e}}function i(t,e,n,r,s,o=!1,a="channelsLast",i){let[u,p,f,g,m]=[-1,-1,-1,-1,-1];if("channelsLast"===a)[u,p,f,g,m]=t;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[u,m,p,f,g]=t}const[b,y,v,,w]=e,[k,T,x]=c(n),[E,A,S]=c(r),$=h(b,E),M=h(y,A),I=h(v,S),{padInfo:N,outDepth:_,outHeight:D,outWidth:Y}=function(t,e,n,r,s,o,a,i,u,c,h){let p,f,g,m;if("number"==typeof t){p={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const o=function(t,e,n,r,s,o){null==s&&(s=l(t,e,r));const a=t[1],i=t[2];return[d((t[0]-e+2*s)/r+1,o),d((a-e+2*s)/r+1,o),d((i-e+2*s)/r+1,o),1]}([e,n,r,1],i,0,s,t,h);f=o[0],g=o[1],m=o[2]}else if("same"===t){f=Math.ceil(e/s),g=Math.ceil(n/o),m=Math.ceil(r/a);const t=(f-1)*s+i-e,l=(g-1)*o+u-n,h=(m-1)*a+c-r,d=Math.floor(t/2),b=t-d,y=Math.floor(l/2),v=l-y,w=Math.floor(h/2);p={top:y,bottom:v,left:w,right:h-w,front:d,back:b,type:"SAME"}}else{if("valid"!==t)throw Error(`Unknown padding parameter: ${t}`);p={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},f=Math.ceil((e-i+1)/s),g=Math.ceil((n-u+1)/o),m=Math.ceil((r-c+1)/a)}return{padInfo:p,outDepth:f,outHeight:g,outWidth:m}}(s,p,f,g,k,T,x,$,M,I,i),R=o?w*m:w;let F;return"channelsFirst"===a?F=[u,R,_,D,Y]:"channelsLast"===a&&(F=[u,_,D,Y,R]),{batchSize:u,dataFormat:a,inDepth:p,inHeight:f,inWidth:g,inChannels:m,outDepth:_,outHeight:D,outWidth:Y,outChannels:R,padInfo:N,strideDepth:k,strideHeight:T,strideWidth:x,filterDepth:b,filterHeight:y,filterWidth:v,effectiveFilterDepth:$,effectiveFilterHeight:M,effectiveFilterWidth:I,dilationDepth:E,dilationHeight:A,dilationWidth:S,inShape:t,outShape:F,filterShape:e}}function l(t,e,n,r=1){const s=h(e,r);return Math.floor((t[0]*(n-1)-n+s)/2)}function u(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function c(t){return"number"==typeof t?[t,t,t]:t}function h(t,e){return e<=1?t:t+(t-1)*(e-1)}function d(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function p(t){const[e,n,r]=u(t);return 1===e&&1===n&&1===r}function f(t,e){return p(t)||p(e)}function g(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}n.d(e,{$Q:()=>g,Dh:()=>p,E6:()=>s,G0:()=>f,G8:()=>l,YQ:()=>r,l5:()=>o,p$:()=>i,uf:()=>a})},7261:(t,e,n)=>{"use strict";n.d(e,{K:()=>i});var r=n(1585),s=n(5441),o=n(8189),a=n(5119);const i=(0,n(929).op)({unstack_:function(t,e=0){const n=(0,o.YT)(t,"x","unstack","string_or_numeric");a.vA(e>=-n.shape.length&&e<n.shape.length,()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`);const i={value:n},l={axis:e};return r.T2.runKernel(s.dX,i,l)}})},7311:(t,e,n)=>{"use strict";n.d(e,{y:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({tanh_:function(t){const e={x:(0,o.YT)(t,"x","tanh","float32")};return r.T2.runKernel(s.iu,e)}})},7367:(t,e,n)=>{"use strict";n.d(e,{R:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({broadcastArgs_:function(t,e){const n=(0,o.YT)(t,"s0","broadcastArgs","int32"),a=(0,o.YT)(e,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==a.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${a.rank}`);const i={s0:n,s1:a};return r.T2.runKernel(s.vj,i)}})},7436:(t,e,n)=>{"use strict";n.d(e,{j:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({min_:function(t,e=null,n=!1){const a={x:(0,o.YT)(t,"x","min")},i={axis:e,keepDims:n};return r.T2.runKernel(s.lN,a,i)}})},7451:(t,e,n)=>{"use strict";n.d(e,{y:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({cosh_:function(t){const e={x:(0,o.YT)(t,"x","cosh","float32")};return r.T2.runKernel(s.Mn,e)}})},7523:(t,e,n)=>{"use strict";n.d(e,{W:()=>i});var r=n(1585),s=n(5441),o=n(565),a=n(8189);const i=(0,n(929).op)({add_:function(t,e){let n=(0,a.YT)(t,"a","add"),i=(0,a.YT)(e,"b","add");[n,i]=(0,o.makeTypesMatch)(n,i);const l={a:n,b:i};return r.T2.runKernel(s.OM,l)}})},7558:(t,e,n)=>{"use strict";n.d(e,{F:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({acosh_:function(t){const e={x:(0,o.YT)(t,"x","acosh")};return r.T2.runKernel(s.PH,e)}})},7703:(t,e,n)=>{"use strict";n.d(e,{m:()=>i});var r=n(1585),s=n(5441),o=n(8189),a=n(5119);const i=(0,n(929).op)({transpose_:function(t,e){const n=(0,o.YT)(t,"x","transpose");if(null==e&&(e=n.shape.map((t,e)=>e).reverse()),a.vA(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${e}.`),e.forEach(t=>{a.vA(t>=0&&t<n.rank,()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+` but got ${e}`)}),n.rank<=1)return n.clone();const i={x:n},l={perm:e};return r.T2.runKernel(s.wx,i,l)}})},7706:(t,e,n)=>{"use strict";n.d(e,{z:()=>i});var r=n(1585),s=n(5441),o=n(8189),a=n(5119);const i=(0,n(929).op)({unsortedSegmentSum_:function(t,e,n){const i=(0,o.YT)(t,"x","unsortedSegmentSum"),l=(0,o.YT)(e,"segmentIds","unsortedSegmentSum","int32");(0,a.vA)((0,a.E6)(n),()=>"numSegments must be of dtype int");const u={x:i,segmentIds:l},c={numSegments:n};return r.T2.runKernel(s.pP,u,c)}})},7771:(t,e,n)=>{"use strict";n.d(e,{_:()=>i});var r=n(1585),s=n(5441),o=n(8189),a=n(9809);const i=(0,n(929).op)({prod_:function(t,e=null,n=!1){let i=(0,o.YT)(t,"x","prod");"bool"===i.dtype&&(i=(0,a.w)(i,"int32"));const l={x:i},u={axis:e,keepDims:n};return r.T2.runKernel(s.kd,l,u)}})},7820:(t,e,n)=>{"use strict";n.d(e,{Z:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({rsqrt_:function(t){const e={x:(0,o.YT)(t,"x","rsqrt","float32")};return r.T2.runKernel(s.TO,e)}})},7823:(t,e,n)=>{"use strict";n.d(e,{M:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({tan_:function(t){const e={x:(0,o.YT)(t,"x","tan","float32")};return r.T2.runKernel(s.oF,e)}})},7858:(t,e,n)=>{"use strict";n.d(e,{e:()=>a});var r=n(448),s=n(929),o=n(9748);const a=(0,s.op)({truncatedNormal_:function(t,e=0,n=1,s,a){if(null!=s&&"bool"===s)throw new Error("Unsupported data type $ { dtype }");const i=new o.ai(e,n,s,!0,a),l=(0,r.r)(t,s);for(let t=0;t<l.values.length;t++)l.values[t]=i.nextValue();return l.toTensor()}})},7872:(t,e,n)=>{"use strict";n.d(e,{d:()=>d});var r=n(8189),s=n(5119),o=n(3909),a=n(9772),i=n(7195),l=n(6999),u=n(929),c=n(2302),h=n(776);const d=(0,u.op)({pool_:function(t,e,n,u,d,p){null==d&&(d=[1,1]),null==p&&(p=1),0===u&&(u="valid");const f=(0,r.YT)(t,"x","maxPool");let g=f,m=!1;3===f.rank&&(m=!0,g=(0,c.t)(f,[1,f.shape[0],f.shape[1],f.shape[2]])),s.vA(i.G0(p,d),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${p} and dilations '${d}'`);const b=i.E6(g.shape,e,p,d,u),y=[b.dilationHeight,b.dilationWidth];let v;v="same"===u?function(t,e){const n=t.map((t,n)=>t+(t-1)*(e[n]-1)).map(t=>t-1),r=n.map(t=>Math.floor(t/2)),s=n.map((t,e)=>t-r[e]);return n.map((t,e)=>[r[e],s[e]])}([b.filterHeight,b.filterWidth],y):[[0,0],[0,0]];const w=1===y[0]&&1===y[1],[k,T]=function(t,e,n){const r=n.map(t=>t[0]),s=n.map(t=>t[1]),o=t.concat(r,s),a=e.map((t,e)=>(t-o[e]%t)%t),i=s.map((t,e)=>t+a[e]);return[e.map((t,e)=>[r[e],i[e]]),e.map((t,e)=>[0,a[e]])]}([b.inHeight,b.inWidth],y,v),x=w?u:"valid",E=w?g:(0,h.e)(g,y,k),A=("avg"===n?()=>(0,o.$)(E,e,p,x):()=>(0,l.j)(E,e,p,x))(),S=w?A:(0,a.G)(A,y,T);return m?(0,c.t)(S,[S.shape[1],S.shape[2],S.shape[3]]):S}})},7974:(t,e,n)=>{"use strict";n.d(e,{a:()=>i});var r=n(1585),s=n(5441),o=n(8189),a=n(5119);const i=(0,n(929).op)({denseBincount_:function(t,e,n,i=!1){const l=(0,o.YT)(t,"x","denseBincount"),u=(0,o.YT)(e,"weights","denseBincount");a.vA("int32"===l.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${l.dtype}`),a.vA(l.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${l.rank}.`),a.vA(n>=0,()=>`size must be non-negative, but got ${n}.`),a.vA(u.size===l.size||0===u.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${l.shape}, weights shape: ${u.shape}.`);const c={x:l,weights:u},h={size:n,binaryOutput:i};return r.T2.runKernel(s.wN,c,h)}})},7986:(t,e,n)=>{"use strict";n.d(e,{d:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({slice_:function(t,e,n){const a=(0,o.YT)(t,"x","slice","string_or_numeric");if(0===a.rank)throw new Error("Slicing scalar is not possible");const i={x:a},l={begin:e,size:n};return r.T2.runKernel(s.Ji,i,l)}})},7991:(t,e,n)=>{"use strict";n.d(e,{H:()=>p});var r=n(1830),s=n(8189),o=n(9809),a=n(8631),i=n(4010),l=n(1938),u=n(9258),c=n(929),h=n(7126),d=n(3791);const p=(0,c.op)({logSoftmax_:function(t,e=-1){const n=(0,s.YT)(t,"logits","logSoftmax");if(-1===e&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return(0,r._X)((t,n)=>{const r=(0,l.T)(t,e,!0),s=(0,h.j)(t,r),c=(0,h.j)((0,o.w)(s,"float32"),(0,i.R)((0,d.c)((0,a.o)(s),e,!0)));return n([c]),{value:c,gradFunc:(t,n)=>{const[r]=n,s=(0,a.o)(r);return(0,h.j)(t,(0,u.l)((0,d.c)(t,e,!0),s))}}})(n)}})},8189:(t,e,n)=>{"use strict";n.d(e,{MZ:()=>l,YT:()=>h,j1:()=>d});var r=n(1585),s=n(6574),o=n(259),a=n(5119),i=n(3879);function l(t,e){let n=t;if((0,a.iu)(t))return"string"===e?[]:[t.length];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||(0,a.iu)(n)&&"string"!==e;)r.push(n.length),n=n[0];return Array.isArray(t)&&(0,s._K)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&u(t,r,[]),r}function u(t,e,n){if(n=n||[],!Array.isArray(t)&&!(0,a.iu)(t))return void(0,a.vA)(0===e.length,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);(0,a.vA)(e.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`),(0,a.vA)(t.length===e[0],()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);const r=e.slice(1);for(let e=0;e<t.length;++e)u(t[e],r,n.concat(e))}function c(t,e,n,r){if("string_or_numeric"!==t){if(null==t)throw new Error("Expected dtype cannot be null.");if("numeric"!==t&&t!==e||"numeric"===t&&"string"===e)throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}}function h(t,e,n,s="numeric"){if(t instanceof o.qY)return c(s,t.dtype,e,n),t;let u=(0,a.X$)(t);if("string"!==u&&["bool","int32","float32"].indexOf(s)>=0&&(u=s),c(s,u,e,n),null==t||!(0,a.iu)(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t){const r=null==t?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const h=l(t,u);(0,a.iu)(t)||Array.isArray(t)||(t=[t]);const d="string"!==u?(0,i.toTypedArray)(t,u):(0,a.Bq)(t,[],!0);return r.T2.makeTensor(d,h,u)}function d(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((t,s)=>h(t,`${e}[${s}]`,n,r))}},8229:(t,e,n)=>{"use strict";n.d(e,{k:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({gather_:function(t,e,n=0,a=0){const i={x:(0,o.YT)(t,"x","gather"),indices:(0,o.YT)(e,"indices","gather","int32")},l={axis:n,batchDims:a};return r.T2.runKernel(s.mx,i,l)}})},8276:(t,e,n)=>{"use strict";n.d(e,{L:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({sinh_:function(t){const e={x:(0,o.YT)(t,"x","sinh")};return r.T2.runKernel(s.J3,e)}})},8318:(t,e,n)=>{"use strict";n.d(e,{M:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({isFinite_:function(t){const e={x:(0,o.YT)(t,"x","isFinite")};return r.T2.runKernel(s.gI,e)}})},8360:(t,e,n)=>{"use strict";function r(t,e,n){const r=function(t,e,n){return function(t,e,n){let r=0,s=t.length,o=0,a=!1;for(;r<s;){o=r+(s-r>>>1);const i=n(e,t[o]);i>0?r=o+1:(s=o,a=!i)}return a?r:-r-1}(t,e,n||s)}(t,e,n),o=r<0?-(r+1):r;t.splice(o,0,e)}function s(t,e){return t>e?1:t<e?-1:0}function o(t,e,n,r,s){return l(t,e,n,r,s,0)}function a(t,e,n,r,s,o){return l(t,e,n,r,s,0,!1,o,!0)}function i(t,e,n,r,s,o){return l(t,e,n,r,s,o,!0)}function l(t,e,n,s,o,a,i=!1,l=!1,d=!1){const p=[];for(let t=0;t<e.length;t++)e[t]>o&&p.push({score:e[t],boxIndex:t,suppressBeginIndex:0});p.sort(h);const f=a>0?-.5/a:0,g=[],m=[];for(;g.length<n&&p.length>0;){const e=p.pop(),{score:n,boxIndex:a,suppressBeginIndex:i}=e;if(n<o)break;let l=!1;for(let n=g.length-1;n>=i;--n){const r=u(t,a,g[n]);if(r>=s){l=!0;break}if(e.score=e.score*c(s,f,r),e.score<=o)break}e.suppressBeginIndex=g.length,l||(e.score===n?(g.push(a),m.push(e.score)):e.score>o&&r(p,e,h))}const b=g.length,y=n-b;l&&y>0&&(g.push(...new Array(y).fill(0)),m.push(...new Array(y).fill(0)));const v={selectedIndices:g};return i&&(v.selectedScores=m),d&&(v.validOutputs=b),v}function u(t,e,n){const r=t.subarray(4*e,4*e+4),s=t.subarray(4*n,4*n+4),o=Math.min(r[0],r[2]),a=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),p=(i-o)*(l-a),f=(h-u)*(d-c);if(p<=0||f<=0)return 0;const g=Math.max(o,u),m=Math.max(a,c),b=Math.min(i,h),y=Math.min(l,d),v=Math.max(b-g,0)*Math.max(y-m,0);return v/(p+f-v)}function c(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function h(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}n.d(e,{c7:()=>o,ZS:()=>a,ut:()=>i})},8570:t=>{t.exports=n;var e=null;try{e=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(t){}function n(t,e,n){this.low=0|t,this.high=0|e,this.unsigned=!!n}function r(t){return!0===(t&&t.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var s={},o={};function a(t,e){var n,r,a;return e?(a=0<=(t>>>=0)&&t<256)&&(r=o[t])?r:(n=l(t,(0|t)<0?-1:0,!0),a&&(o[t]=n),n):(a=-128<=(t|=0)&&t<128)&&(r=s[t])?r:(n=l(t,t<0?-1:0,!1),a&&(s[t]=n),n)}function i(t,e){if(isNaN(t))return e?b:m;if(e){if(t<0)return b;if(t>=p)return T}else{if(t<=-f)return x;if(t+1>=f)return k}return t<0?i(-t,e).neg():l(t%d|0,t/d|0,e)}function l(t,e,r){return new n(t,e,r)}n.fromInt=a,n.fromNumber=i,n.fromBits=l;var u=Math.pow;function c(t,e,n){if(0===t.length)throw Error("empty string");if("NaN"===t||"Infinity"===t||"+Infinity"===t||"-Infinity"===t)return m;if("number"==typeof e?(n=e,e=!1):e=!!e,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=t.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(t.substring(1),e,n).neg();for(var s=i(u(n,8)),o=m,a=0;a<t.length;a+=8){var l=Math.min(8,t.length-a),h=parseInt(t.substring(a,a+l),n);if(l<8){var d=i(u(n,l));o=o.mul(d).add(i(h))}else o=(o=o.mul(s)).add(i(h))}return o.unsigned=e,o}function h(t,e){return"number"==typeof t?i(t,e):"string"==typeof t?c(t,e):l(t.low,t.high,"boolean"==typeof e?e:t.unsigned)}n.fromString=c,n.fromValue=h;var d=4294967296,p=d*d,f=p/2,g=a(1<<24),m=a(0);n.ZERO=m;var b=a(0,!0);n.UZERO=b;var y=a(1);n.ONE=y;var v=a(1,!0);n.UONE=v;var w=a(-1);n.NEG_ONE=w;var k=l(-1,2147483647,!1);n.MAX_VALUE=k;var T=l(-1,-1,!0);n.MAX_UNSIGNED_VALUE=T;var x=l(0,-2147483648,!1);n.MIN_VALUE=x;var E=n.prototype;E.toInt=function(){return this.unsigned?this.low>>>0:this.low},E.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},E.toString=function(t){if((t=t||10)<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(x)){var e=i(t),n=this.div(e),r=n.mul(e).sub(this);return n.toString(t)+r.toInt().toString(t)}return"-"+this.neg().toString(t)}for(var s=i(u(t,6),this.unsigned),o=this,a="";;){var l=o.div(s),c=(o.sub(l.mul(s)).toInt()>>>0).toString(t);if((o=l).isZero())return c+a;for(;c.length<6;)c="0"+c;a=""+c+a}},E.getHighBits=function(){return this.high},E.getHighBitsUnsigned=function(){return this.high>>>0},E.getLowBits=function(){return this.low},E.getLowBitsUnsigned=function(){return this.low>>>0},E.getNumBitsAbs=function(){if(this.isNegative())return this.eq(x)?64:this.neg().getNumBitsAbs();for(var t=0!=this.high?this.high:this.low,e=31;e>0&&!(t&1<<e);e--);return 0!=this.high?e+33:e+1},E.isZero=function(){return 0===this.high&&0===this.low},E.eqz=E.isZero,E.isNegative=function(){return!this.unsigned&&this.high<0},E.isPositive=function(){return this.unsigned||this.high>=0},E.isOdd=function(){return!(1&~this.low)},E.isEven=function(){return!(1&this.low)},E.equals=function(t){return r(t)||(t=h(t)),(this.unsigned===t.unsigned||this.high>>>31!=1||t.high>>>31!=1)&&this.high===t.high&&this.low===t.low},E.eq=E.equals,E.notEquals=function(t){return!this.eq(t)},E.neq=E.notEquals,E.ne=E.notEquals,E.lessThan=function(t){return this.comp(t)<0},E.lt=E.lessThan,E.lessThanOrEqual=function(t){return this.comp(t)<=0},E.lte=E.lessThanOrEqual,E.le=E.lessThanOrEqual,E.greaterThan=function(t){return this.comp(t)>0},E.gt=E.greaterThan,E.greaterThanOrEqual=function(t){return this.comp(t)>=0},E.gte=E.greaterThanOrEqual,E.ge=E.greaterThanOrEqual,E.compare=function(t){if(r(t)||(t=h(t)),this.eq(t))return 0;var e=this.isNegative(),n=t.isNegative();return e&&!n?-1:!e&&n?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1},E.comp=E.compare,E.negate=function(){return!this.unsigned&&this.eq(x)?x:this.not().add(y)},E.neg=E.negate,E.add=function(t){r(t)||(t=h(t));var e=this.high>>>16,n=65535&this.high,s=this.low>>>16,o=65535&this.low,a=t.high>>>16,i=65535&t.high,u=t.low>>>16,c=0,d=0,p=0,f=0;return p+=(f+=o+(65535&t.low))>>>16,d+=(p+=s+u)>>>16,c+=(d+=n+i)>>>16,c+=e+a,l((p&=65535)<<16|(f&=65535),(c&=65535)<<16|(d&=65535),this.unsigned)},E.subtract=function(t){return r(t)||(t=h(t)),this.add(t.neg())},E.sub=E.subtract,E.multiply=function(t){if(this.isZero())return m;if(r(t)||(t=h(t)),e)return l(e.mul(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned);if(t.isZero())return m;if(this.eq(x))return t.isOdd()?x:m;if(t.eq(x))return this.isOdd()?x:m;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(g)&&t.lt(g))return i(this.toNumber()*t.toNumber(),this.unsigned);var n=this.high>>>16,s=65535&this.high,o=this.low>>>16,a=65535&this.low,u=t.high>>>16,c=65535&t.high,d=t.low>>>16,p=65535&t.low,f=0,b=0,y=0,v=0;return y+=(v+=a*p)>>>16,b+=(y+=o*p)>>>16,y&=65535,b+=(y+=a*d)>>>16,f+=(b+=s*p)>>>16,b&=65535,f+=(b+=o*d)>>>16,b&=65535,f+=(b+=a*c)>>>16,f+=n*p+s*d+o*c+a*u,l((y&=65535)<<16|(v&=65535),(f&=65535)<<16|(b&=65535),this.unsigned)},E.mul=E.multiply,E.divide=function(t){if(r(t)||(t=h(t)),t.isZero())throw Error("division by zero");var n,s,o;if(e)return this.unsigned||-2147483648!==this.high||-1!==t.low||-1!==t.high?l((this.unsigned?e.div_u:e.div_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?b:m;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return b;if(t.gt(this.shru(1)))return v;o=b}else{if(this.eq(x))return t.eq(y)||t.eq(w)?x:t.eq(x)?y:(n=this.shr(1).div(t).shl(1)).eq(m)?t.isNegative()?y:w:(s=this.sub(t.mul(n)),o=n.add(s.div(t)));if(t.eq(x))return this.unsigned?b:m;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();o=m}for(s=this;s.gte(t);){n=Math.max(1,Math.floor(s.toNumber()/t.toNumber()));for(var a=Math.ceil(Math.log(n)/Math.LN2),c=a<=48?1:u(2,a-48),d=i(n),p=d.mul(t);p.isNegative()||p.gt(s);)p=(d=i(n-=c,this.unsigned)).mul(t);d.isZero()&&(d=y),o=o.add(d),s=s.sub(p)}return o},E.div=E.divide,E.modulo=function(t){return r(t)||(t=h(t)),e?l((this.unsigned?e.rem_u:e.rem_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this.sub(this.div(t).mul(t))},E.mod=E.modulo,E.rem=E.modulo,E.not=function(){return l(~this.low,~this.high,this.unsigned)},E.and=function(t){return r(t)||(t=h(t)),l(this.low&t.low,this.high&t.high,this.unsigned)},E.or=function(t){return r(t)||(t=h(t)),l(this.low|t.low,this.high|t.high,this.unsigned)},E.xor=function(t){return r(t)||(t=h(t)),l(this.low^t.low,this.high^t.high,this.unsigned)},E.shiftLeft=function(t){return r(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?l(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):l(0,this.low<<t-32,this.unsigned)},E.shl=E.shiftLeft,E.shiftRight=function(t){return r(t)&&(t=t.toInt()),0==(t&=63)?this:t<32?l(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):l(this.high>>t-32,this.high>=0?0:-1,this.unsigned)},E.shr=E.shiftRight,E.shiftRightUnsigned=function(t){if(r(t)&&(t=t.toInt()),0==(t&=63))return this;var e=this.high;return t<32?l(this.low>>>t|e<<32-t,e>>>t,this.unsigned):l(32===t?e:e>>>t-32,0,this.unsigned)},E.shru=E.shiftRightUnsigned,E.shr_u=E.shiftRightUnsigned,E.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},E.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},E.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()},E.toBytesLE=function(){var t=this.high,e=this.low;return[255&e,e>>>8&255,e>>>16&255,e>>>24,255&t,t>>>8&255,t>>>16&255,t>>>24]},E.toBytesBE=function(){var t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,255&t,e>>>24,e>>>16&255,e>>>8&255,255&e]},n.fromBytes=function(t,e,r){return r?n.fromBytesLE(t,e):n.fromBytesBE(t,e)},n.fromBytesLE=function(t,e){return new n(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)},n.fromBytesBE=function(t,e){return new n(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)}},8576:(t,e,n)=>{"use strict";n.d(e,{X:()=>s,j:()=>r});const r=1.7580993408473768,s=1.0507009873554805},8631:(t,e,n)=>{"use strict";n.d(e,{o:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({exp_:function(t){const e={x:(0,o.YT)(t,"x","exp")};return r.T2.runKernel(s.ox,e)}})},8646:(t,e,n)=>{"use strict";n.d(e,{Do:()=>g,XB:()=>f,f2:()=>m,zE:()=>b});var r=n(2198),s=n(3416),o=n(6919),a=n(9258),i=n(4394),l=n(112),u=n(3732),c=n(2302),h=n(8968),d=n(700),p=n(3791);function f(t,e,n){if(null==n||"linear"===n)return t;if("relu"===n)return(0,a.l)(t,(0,d.P)(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function g(t,e){let n=e;const s=r.Lx(t.shape,e.shape);return s.length>0&&(n=(0,p.c)(n,s)),(0,c.t)(n,t.shape)}function m(t,e,n,r){if("linear"===e)return t;if("relu"===e)return(0,l.V)(t);if("elu"===e)return(0,s.P)(t);if("relu6"===e)return(0,u.j)(t);if("prelu"===e)return(0,i.N)(t,n);if("leakyrelu"===e)return(0,o.H)(t,r);if("sigmoid"===e)return(0,h.r)(t);throw new Error(`Unknown fused activation ${e}.`)}const b=(t,e)=>!(t>0)||"linear"===e},8710:(t,e,n)=>{"use strict";n.d(e,{U:()=>i});var r=n(1585),s=n(5441),o=n(8189),a=n(5119);const i=(0,n(929).op)({expandDims_:function(t,e=0){const n=(0,o.YT)(t,"x","expandDims","string_or_numeric");a.vA(e<=n.rank,()=>"Axis must be <= rank of the tensor");const i={input:n},l={dim:e};return r.T2.runKernel(s.yb,i,l)}})},8775:(t,e,n)=>{"use strict";n.d(e,{z:()=>g});var r=n(5119),s=n(7148),o=n(5030),a=n(5040),i=n(929),l=n(1902),u=n(2302),c=n(7986),h=n(6512),d=n(2855),p=n(5537),f=n(1361);const g=(0,i.op)({rfft_:function(t,e){(0,r.vA)("float32"===t.dtype,()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let n=t.shape[t.shape.length-1];const i=t.size/n;let g;if(null!=e&&e<n){const r=t.shape.map(t=>0),s=t.shape.map(t=>t);s[t.shape.length-1]=e,g=(0,c.d)(t,r,s),n=e}else if(null!=e&&e>n){const r=t.shape.map(t=>t);r[t.shape.length-1]=e-n,g=(0,o.x)([t,(0,d.U)(r)],t.shape.length-1),n=e}else g=t;const m=(0,p.P)(g),b=(0,u.t)((0,s.f)(g,m),[i,n]),y=(0,f.h)(b),v=Math.floor(n/2)+1,w=(0,l.x)(y),k=(0,a.n)(y),T=(0,h.l)(w,[v,n-v],w.shape.length-1),x=(0,h.l)(k,[v,n-v],k.shape.length-1),E=g.shape.slice();return E[g.shape.length-1]=v,(0,u.t)((0,s.f)(T[0],x[0]),E)}})},8794:(t,e,n)=>{"use strict";n.d(e,{X:()=>c});var r=n(1585),s=n(5441),o=n(8189),a=n(5119),i=n(7195),l=n(929),u=n(2302);const c=(0,l.op)({conv2d_:function(t,e,n,l,c="NHWC",h=[1,1],d){const p=(0,o.YT)(t,"x","conv2d","float32"),f=(0,o.YT)(e,"filter","conv2d","float32");let g=p,m=!1;3===p.rank&&(m=!0,g=(0,u.t)(p,[1,p.shape[0],p.shape[1],p.shape[2]])),a.vA(4===g.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${g.rank}.`),a.vA(4===f.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${f.rank}.`),null!=d&&a.vA(a.E6(l),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${d} but got pad ${l}.`);const b="NHWC"===c?g.shape[3]:g.shape[1];a.vA(b===f.shape[2],()=>`Error in conv2d: depth of input (${b}) must match input depth for filter ${f.shape[2]}.`),a.vA(i.G0(n,h),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${h}'`);const y={x:g,filter:f},v={strides:n,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d},w=r.T2.runKernel(s.p2,y,v);return m?(0,u.t)(w,[w.shape[1],w.shape[2],w.shape[3]]):w}})},8968:(t,e,n)=>{"use strict";n.d(e,{r:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({sigmoid_:function(t){const e={x:(0,o.YT)(t,"x","sigmoid","float32")};return r.T2.runKernel(s.vI,e)}})},8990:(t,e,n)=>{"use strict";n.d(e,{n:()=>i});var r=n(1585),s=n(5441),o=n(565),a=n(8189);const i=(0,n(929).op)({pow_:function(t,e){let n=(0,a.YT)(t,"base","pow"),i=(0,a.YT)(e,"exp","pow");[n,i]=(0,o.makeTypesMatch)(n,i);const l={a:n,b:i};return r.T2.runKernel(s.py,l)}})},8991:(t,e,n)=>{"use strict";n.d(e,{w:()=>i});var r=n(1585),s=n(5441),o=n(565),a=n(8189);const i=(0,n(929).op)({floorDiv_:function(t,e){let n=(0,a.YT)(t,"a","floorDiv"),i=(0,a.YT)(e,"b","floorDiv");[n,i]=(0,o.makeTypesMatch)(n,i);const l={a:n,b:i};return r.T2.runKernel(s.El,l)}})},9160:(t,e,n)=>{"use strict";n.d(e,{$:()=>l});var r=n(1585),s=n(5441),o=n(8189),a=n(5119),i=n(2302);const l=(0,n(929).op)({batchNorm_:function(t,e,n,l,u,c){null==c&&(c=.001);const h=(0,o.YT)(t,"x","batchNorm"),d=(0,o.YT)(e,"mean","batchNorm"),p=(0,o.YT)(n,"variance","batchNorm");let f,g;null!=u&&(f=(0,o.YT)(u,"scale","batchNorm")),null!=l&&(g=(0,o.YT)(l,"offset","batchNorm")),a.vA(d.rank===p.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),a.vA(null==g||d.rank===g.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),a.vA(null==f||d.rank===f.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const m={x:function(t){let e;return e=0===t.rank||1===t.rank?(0,i.t)(t,[1,1,1,t.size]):2===t.rank?(0,i.t)(t,[1,1,t.shape[0],t.shape[1]]):3===t.rank?(0,i.t)(t,[1,t.shape[0],t.shape[1],t.shape[2]]):t,e}(h),scale:f,offset:g,mean:d,variance:p},b={varianceEpsilon:c},y=r.T2.runKernel(s.i5,m,b);return(0,i.t)(y,h.shape)}})},9171:(t,e,n)=>{"use strict";n.d(e,{Q:()=>a});var r=n(1585),s=n(5119),o=n(3879);function a(t,e,n,a){if(null==a&&(a=(0,s.X$)(t)),"complex64"===a)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!(0,s.iu)(t)&&!Array.isArray(t)&&"number"!=typeof t&&"boolean"!=typeof t&&"string"!=typeof t)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=e){(0,s.SA)(e);const t=(0,s.Ze)(e),r=(0,s.Ze)(n);(0,s.vA)(t===r,()=>`Based on the provided shape, [${e}], the tensor should have ${t} values but has ${r}`);for(let t=0;t<n.length;++t){const r=n[t],o=t!==n.length-1||r!==(0,s.Ze)(e.slice(t));(0,s.vA)(n[t]===e[t]||!o,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return(0,s.iu)(t)||Array.isArray(t)||(t=[t]),e=e||n,t="string"!==a?(0,o.toTypedArray)(t,a):(0,s.Bq)(t,[],!0),r.T2.makeTensor(t,e,a)}},9235:(t,e,n)=>{"use strict";n.d(e,{BTT:()=>E.B,tnl:()=>s.t,HQu:()=>o.H,FqL:()=>a.F,WQq:()=>i.W,QiD:()=>l.Q,Q7R:()=>u.Q,bzn:()=>c.b,FLi:()=>h.F,XRg:()=>d.X,qRo:()=>p.q,yHs:()=>f.y,rYl:()=>g.r,FPz:()=>m.F,rfv:()=>b.r,$jT:()=>y.$,sub:()=>v.s,lZX:()=>M,$v7:()=>N.$,BFc:()=>D,kSi:()=>Y,T5N:()=>R,GTe:()=>I.G,HbZ:()=>F.H,ftb:()=>Bn,ROE:()=>B.R,hOW:()=>C.h,ra8:()=>O.r,wgE:()=>P.w,mkO:()=>L.m,zQh:()=>K.z,o8B:()=>z.o,faB:()=>W.f,xWs:()=>k.x,I1m:()=>j,RPU:()=>G,O5O:()=>U,P1l:()=>q,kA9:()=>H.k,Xtf:()=>V.X,wX9:()=>Z.w,IPL:()=>X.I,jIJ:()=>J,gnS:()=>tt.g,yIG:()=>et.y,_jP:()=>Un,rCv:()=>nt.r,aOp:()=>rt.a,Rj8:()=>st.R,Gl3:()=>ot.G,smy:()=>lt,X7t:()=>ut.X,y4m:()=>ct.y,ek5:()=>ht.e,Omf:()=>dt.O,EZY:()=>jn,_3C:()=>pt._,Pqc:()=>ft.P,FJY:()=>Gn,LCg:()=>gt.L,Y12:()=>mt.Y,oNF:()=>bt.o,UG6:()=>yt.U,IYd:()=>vt.I,y5U:()=>Tt,hVP:()=>sn.h,GSj:()=>xt.G,RIf:()=>Et.R,wh_:()=>At.w,cZk:()=>r,kgh:()=>St.k,SY9:()=>Wn.S,rhj:()=>$t.r,DQN:()=>Mt.D,KGM:()=>on.K,ngS:()=>It.n,Slp:()=>Pr,U4u:()=>qn,ggX:()=>an.g,MIs:()=>Nt.M,EN4:()=>_t.E,yrW:()=>Dt.y,H8d:()=>Yt.H,M7h:()=>Rt.M,InN:()=>Ft.I,mPL:()=>Lr,mT8:()=>Bt.m,Kgs:()=>Ct.K,Rm2:()=>Ot.R,Kko:()=>Pt.K,nqI:()=>Lt.n,HPB:()=>Kt.H,VZ:()=>zt.V,n76:()=>Wt.n,NSZ:()=>jt.N,ztW:()=>Gt.z,rxB:()=>Ut.r,YYh:()=>Kr,NoW:()=>T.N,T9B:()=>qt.T,jgi:()=>Ht.j,NYV:()=>Vt.e,RO:()=>Zt.R,PhQ:()=>Xt.P,i2o:()=>Qt.i,OYQ:()=>ee,jkA:()=>ne.j,BpO:()=>re.B,FFZ:()=>se.F,ziu:()=>oe.z,Clk:()=>ue,CRk:()=>Ln,lKK:()=>x.l,YDF:()=>ce,OjQ:()=>he.O,HZy:()=>de.H,xbf:()=>On.x,Ec:()=>pe.E,Mw0:()=>fe.M,SaS:()=>Jt.S,P61:()=>ge.P,op:()=>E.op,X4o:()=>me,eVF:()=>be.e,BZs:()=>ye,grY:()=>ve,XHu:()=>we,WLX:()=>ke,dzn:()=>Te.d,n7C:()=>xe.n,NsG:()=>Ee.N,yyV:()=>Ae.y,_eU:()=>Se._,_9M:()=>$e,pR9:()=>Ie,FE$:()=>Ne,YeY:()=>_e.Y,y17:()=>De.y,xav:()=>Ye.x,VOZ:()=>Re.V,VVh:()=>Fe.V,j__:()=>Be.j,tQQ:()=>wt.t,BEg:()=>Ce.B,QD2:()=>Oe,LMr:()=>Pe,I2l:()=>Le,JYU:()=>Ke,z8$:()=>ln.z,LIG:()=>ze.L,Z$r:()=>We.Z,d_2:()=>je.d,NFr:()=>Kn.N,WfX:()=>Ge.W,wdz:()=>Ue.w,F12:()=>qe.F,ry7:()=>A.r,_SZ:()=>He._,vPA:()=>Or,F8e:()=>Ve.F,L0l:()=>Ze.L,dik:()=>S.d,Q$M:()=>Xe,zAd:()=>Qe,wck:()=>Je,R0O:()=>tn,Vs9:()=>en.V,lw0:()=>nn.l,eDJ:()=>rn.e,lMo:()=>zr,Zhr:()=>zn.Z,lOn:()=>Cr,lDo:()=>un.l,RZD:()=>cn.R,EwI:()=>ie.E,Pbu:()=>hn.P,r2V:()=>dn.r,t$z:()=>pn.t,PMw:()=>fn.P,Ym9:()=>gn.Y,YjP:()=>Wr,jbE:()=>le.j,czq:()=>mn.c,Mlm:()=>bn.M,ymU:()=>$.y,OEK:()=>yn.O,tGX:()=>vn.t,KtR:()=>kn,$_$:()=>Tn.$,g9W:()=>xn,Lpo:()=>En,yxw:()=>An,Vsq:()=>kt.V,rfw:()=>Sn.r,mgz:()=>Cn.m,efE:()=>$n.e,AmM:()=>Mn.A,zAU:()=>In.z,K$i:()=>Nn.K,bvq:()=>_n,_M9:()=>Dn._,YJN:()=>Yn.Y,Ul9:()=>Rn.U,POl:()=>Fn.P});var r={};n.r(r),n.d(r,{conv2d:()=>Hn.X,depthwiseConv2d:()=>Vn.G,matMul:()=>Zn.N});var s=n(4888),o=n(2804),a=n(7558),i=n(7523),l=n(6054),u=n(2307),c=n(9326),h=n(897),d=n(4339),p=n(6841),f=n(269),g=n(9580),m=n(1404),b=n(3774),y=n(3909),v=n(3855),w=n(8189),k=n(5030),T=n(5703),x=n(9258),E=n(929),A=n(8968),S=n(7986),$=n(7311);const M=(0,E.op)({basicLSTMCell_:function(t,e,n,r,s,o){const a=(0,w.YT)(t,"forgetBias","basicLSTMCell"),l=(0,w.YT)(e,"lstmKernel","basicLSTMCell"),u=(0,w.YT)(n,"lstmBias","basicLSTMCell"),c=(0,w.YT)(r,"data","basicLSTMCell"),h=(0,w.YT)(s,"c","basicLSTMCell"),d=(0,w.YT)(o,"h","basicLSTMCell"),p=(0,k.x)([c,d],1),f=(0,T.N)(p,l),g=(0,i.W)(f,u),m=g.shape[0],b=g.shape[1]/4,y=[m,b],v=(0,S.d)(g,[0,0],y),E=(0,S.d)(g,[0,b],y),M=(0,S.d)(g,[0,2*b],y),I=(0,S.d)(g,[0,3*b],y),N=(0,i.W)((0,x.l)((0,A.r)(v),(0,$.y)(E)),(0,x.l)(h,(0,A.r)((0,i.W)(a,M))));return[N,(0,x.l)((0,$.y)(N),(0,A.r)(I))]}});var I=n(9772),N=n(9160),_=n(5119);const D=(0,E.op)({batchNorm2d_:function(t,e,n,r,s,o){const a=(0,w.YT)(t,"x","batchNorm"),i=(0,w.YT)(e,"mean","batchNorm"),l=(0,w.YT)(n,"variance","batchNorm");let u,c;return null!=s&&(u=(0,w.YT)(s,"scale","batchNorm")),null!=r&&(c=(0,w.YT)(r,"offset","batchNorm")),_.vA(2===a.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),_.vA(2===i.rank||1===i.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),_.vA(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=u&&_.vA(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=c&&_.vA(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),(0,N.$)(a,i,l,c,u,o)}}),Y=(0,E.op)({batchNorm3d_:function(t,e,n,r,s,o){const a=(0,w.YT)(t,"x","batchNorm"),i=(0,w.YT)(e,"mean","batchNorm"),l=(0,w.YT)(n,"variance","batchNorm");let u,c;return null!=s&&(u=(0,w.YT)(s,"scale","batchNorm")),null!=r&&(c=(0,w.YT)(r,"offset","batchNorm")),_.vA(3===a.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),_.vA(3===i.rank||1===i.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),_.vA(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=u&&_.vA(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=c&&_.vA(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),(0,N.$)(a,i,l,c,u,o)}}),R=(0,E.op)({batchNorm4d_:function(t,e,n,r,s,o){const a=(0,w.YT)(t,"x","batchNorm"),i=(0,w.YT)(e,"mean","batchNorm"),l=(0,w.YT)(n,"variance","batchNorm");let u,c;return null!=s&&(u=(0,w.YT)(s,"scale","batchNorm")),null!=r&&(c=(0,w.YT)(r,"offset","batchNorm")),_.vA(4===a.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),_.vA(4===i.rank||1===i.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),_.vA(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=u&&_.vA(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=c&&_.vA(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),(0,N.$)(a,i,l,c,u,o)}});var F=n(758),B=n(7367),C=n(3567),O=n(448),P=n(9809),L=n(855),K=n(6928),z=n(125),W=n(7148);const j=(0,E.op)({concat1d_:function(t){return(0,k.x)(t,0)}}),G=(0,E.op)({concat2d_:function(t,e){return(0,k.x)(t,e)}}),U=(0,E.op)({concat3d_:function(t,e){return(0,k.x)(t,e)}}),q=(0,E.op)({concat4d_:function(t,e){return(0,k.x)(t,e)}});var H=n(3701),V=n(8794),Z=n(1106),X=n(167),Q=n(1895);const J=(0,E.op)({conv3dTranspose_:function(t,e,n,r,s){const o=(0,w.YT)(t,"x","conv3dTranspose"),a=(0,w.YT)(e,"filter","conv3dTranspose");return(0,Q.c)(n,o,a,r,s)}});var tt=n(9907),et=n(7451),nt=n(6808),rt=n(7974),st=n(1216),ot=n(676),at=n(1585),it=n(5441);const lt=(0,E.op)({diag_:function(t){const e={x:(0,w.YT)(t,"x","diag")};return at.T2.runKernel(it.OR,e)}});var ut=n(3002),ct=n(9359),ht=n(919),dt=n(9759),pt=n(9853),ft=n(3416),gt=n(3020),mt=n(5207),bt=n(8631),yt=n(8710),vt=n(517),wt=n(2302),kt=n(4826);const Tt=(0,E.op)({eye_:function(t,e,n,r="float32"){null==e&&(e=t);const s=(0,O.r)([t,e],r),o=t<=e?t:e;for(let t=0;t<o;++t)s.set(1,t,t);const a=(0,wt.t)(s.toTensor(),[t,e]);if(null==n)return a;if(1===n.length)return(0,kt.V)((0,yt.U)(a,0),[n[0],1,1]);if(2===n.length)return(0,kt.V)((0,yt.U)((0,yt.U)(a,0),0),[n[0],n[1],1,1]);if(3===n.length)return(0,kt.V)((0,yt.U)((0,yt.U)((0,yt.U)(a,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});var xt=n(6111),Et=n(5606),At=n(8991),St=n(8229),$t=n(2058),Mt=n(3337),It=n(5040),Nt=n(8318),_t=n(3454),Dt=n(6300),Yt=n(6919),Rt=n(1303),Ft=n(6508),Bt=n(6545),Ct=n(3531),Ot=n(4010),Pt=n(2015),Lt=n(5645),Kt=n(7991),zt=n(3330),Wt=n(3789),jt=n(9881),Gt=n(9879),Ut=n(9925),qt=n(1938),Ht=n(6999),Vt=n(4349),Zt=n(5243),Xt=n(178),Qt=n(2611),Jt=n(1411),te=n(259);function ee(t,e,{indexing:n="xy"}={}){if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===t)return[];let r=(0,w.YT)(t,"x","meshgrid",t instanceof te.qY?t.dtype:"float32");if(void 0===e)return[r];let s=(0,w.YT)(e,"y","meshgrid",e instanceof te.qY?e.dtype:"float32");const o=(0,_.Ze)(r.shape),a=(0,_.Ze)(s.shape);return"xy"===n?(r=(0,wt.t)(r,[1,-1]),s=(0,wt.t)(s,[-1,1]),[(0,T.N)((0,Jt.S)([a,1],r.dtype),r),(0,T.N)(s,(0,Jt.S)([1,o],s.dtype))]):(r=(0,wt.t)(r,[-1,1]),s=(0,wt.t)(s,[1,-1]),[(0,T.N)(r,(0,Jt.S)([1,a],r.dtype)),(0,T.N)((0,Jt.S)([o,1],s.dtype),s)])}var ne=n(7436),re=n(2644),se=n(6567),oe=n(152),ae=n(1078),ie=n(5793),le=n(7126);const ue=(0,E.op)({moments_:function(t,e=null,n=!1){t=(0,w.YT)(t,"x","moments");const r=(0,_.Y6)(e,t.shape),s=(0,Qt.i)(t,r,n);let o=s.shape;n||(o=(0,ae.SM)(s.shape,r));const a=(0,ie.E)((0,le.j)((0,P.w)(t,"float32"),(0,wt.t)(s,o)));return{mean:s,variance:(0,Qt.i)(a,r,n)}}}),ce=(0,E.op)({multiRNNCell_:function(t,e,n,r){const s=(0,w.YT)(e,"data","multiRNNCell"),o=(0,w.j1)(n,"c","multiRNNCell"),a=(0,w.j1)(r,"h","multiRNNCell");let i=s;const l=[];for(let e=0;e<t.length;e++){const n=t[e](i,o[e],a[e]);l.push(n[0]),l.push(n[1]),i=n[1]}const u=[],c=[];for(let t=0;t<l.length;t+=2)u.push(l[t]),c.push(l[t+1]);return[u,c]}});var he=n(1781),de=n(6522),pe=n(2118),fe=n(1760),ge=n(9885);const me=(0,E.op)({outerProduct_:function(t,e){const n=(0,w.YT)(t,"v1","outerProduct"),r=(0,w.YT)(e,"v2","outerProduct");_.vA(1===n.rank&&1===r.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);const s=(0,wt.t)(n,[-1,1]),o=(0,wt.t)(r,[1,-1]);return(0,T.N)(s,o)}});var be=n(5661);const ye=(0,E.op)({pad1d_:function(t,e,n=0){return(0,_.vA)(2===e.length,()=>"Invalid number of paddings. Must be length of 2."),(0,be.e)(t,[e],n)}}),ve=(0,E.op)({pad2d_:function(t,e,n=0){return(0,_.vA)(2===e.length&&2===e[0].length&&2===e[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),(0,be.e)(t,e,n)}}),we=(0,E.op)({pad3d_:function(t,e,n=0){return(0,_.vA)(3===e.length&&2===e[0].length&&2===e[1].length&&2===e[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),(0,be.e)(t,e,n)}}),ke=(0,E.op)({pad4d_:function(t,e,n=0){return(0,_.vA)(4===e.length&&2===e[0].length&&2===e[1].length&&2===e[2].length&&2===e[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),(0,be.e)(t,e,n)}});var Te=n(7872),xe=n(8990),Ee=n(4394),Ae=n(5295),Se=n(7771);const $e=(0,E.op)({rand_:function(t,e,n){const r=(0,_.Ze)(t);let s=null;if(null==n||"float32"===n)s=new Float32Array(r);else if("int32"===n)s=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);s=new Uint8Array(r)}for(let t=0;t<r;t++)s[t]=e();return at.T2.makeTensor(s,t,n)}});var Me=n(9748);const Ie=(0,E.op)({randomGamma_:function(t,e,n=1,r="float32",s){if(null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const o=new Me.XA(e,n,r,s),a=(0,O.r)(t,r);for(let t=0;t<a.values.length;t++)a.values[t]=o.nextValue();return a.toTensor()}}),Ne=(0,E.op)({randomNormal_:function(t,e=0,n=1,r,s){if(null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const o=new Me.ai(e,n,r,!1,s),a=(0,O.r)(t,r);for(let t=0;t<a.values.length;t++)a.values[t]=o.nextValue();return a.toTensor()}});var _e=n(9546),De=n(4645),Ye=n(1902),Re=n(9870),Fe=n(112),Be=n(3732),Ce=n(3262);const Oe=(0,E.op)({reverse1d_:function(t){const e=(0,w.YT)(t,"x","reverse");return _.vA(1===e.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),(0,Ce.B)(e,0)}}),Pe=(0,E.op)({reverse2d_:function(t,e){const n=(0,w.YT)(t,"x","reverse");return _.vA(2===n.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),(0,Ce.B)(n,e)}}),Le=(0,E.op)({reverse3d_:function(t,e){const n=(0,w.YT)(t,"x","reverse");return _.vA(3===n.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),(0,Ce.B)(n,e)}}),Ke=(0,E.op)({reverse4d_:function(t,e){const n=(0,w.YT)(t,"x","reverse");return _.vA(4===n.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),(0,Ce.B)(n,e)}});var ze=n(5912),We=n(7820),je=n(5702),Ge=n(6325),Ue=n(9986),qe=n(3325),He=n(1115),Ve=n(3726),Ze=n(8276);const Xe=(0,E.op)({slice1d_:function(t,e,n){const r=(0,w.YT)(t,"x","slice1d");return _.vA(1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),(0,S.d)(r,[e],[n])}}),Qe=(0,E.op)({slice2d_:function(t,e,n){const r=(0,w.YT)(t,"x","slice2d");return _.vA(2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),(0,S.d)(r,e,n)}}),Je=(0,E.op)({slice3d_:function(t,e,n){const r=(0,w.YT)(t,"x","slice3d");return _.vA(3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),(0,S.d)(r,e,n)}}),tn=(0,E.op)({slice4d_:function(t,e,n){const r=(0,w.YT)(t,"x","slice4d");return _.vA(4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),(0,S.d)(r,e,n)}});var en=n(6346),nn=n(6030),rn=n(776),sn=n(1361),on=n(3108),an=n(2292),ln=n(8775),un=n(6512),cn=n(9348),hn=n(3427),dn=n(5932),pn=n(4268),fn=n(700),gn=n(5894),mn=n(3791),bn=n(7823),yn=n(4027),vn=n(2018),wn=n(9171);function kn(t,e,n){if((0,_.HO)(t),null!=e&&2!==e.length)throw new Error("tensor2d() requires shape to have two numbers");const r=(0,w.MZ)(t,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return(0,wn.Q)(t,e,r,n)}var Tn=n(2768);function xn(t,e,n){if((0,_.HO)(t),null!=e&&4!==e.length)throw new Error("tensor4d() requires shape to have four numbers");const r=(0,w.MZ)(t,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return(0,wn.Q)(t,e,r,n)}function En(t,e,n){if((0,_.HO)(t),null!=e&&5!==e.length)throw new Error("tensor5d() requires shape to have five numbers");const r=(0,w.MZ)(t,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return(0,wn.Q)(t,e,r,n)}function An(t,e,n){if((0,_.HO)(t),null!=e&&6!==e.length)throw new Error("tensor6d() requires shape to have six numbers");const r=(0,w.MZ)(t,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==e)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||r,(0,wn.Q)(t,e,r,n)}var Sn=n(1190),$n=n(7858),Mn=n(3937),In=n(7706),Nn=n(7261);function _n(t,e=!0,n,r){return at.T2.makeVariable(t,e,n,r)}var Dn=n(2151),Yn=n(6652),Rn=n(2855),Fn=n(5537);const Bn=async function(t,e,n){const r=(0,w.YT)(t,"tensor","boolMask"),s=(0,w.YT)(e,"mask","boolMask","bool"),o=null==n?0:n,a=s.rank,i=r.shape;_.vA(a>0,()=>"mask cannot be scalar"),_.O3(i.slice(o,o+a),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let t=o;t<o+a;t++)l*=i[t];const u=i.slice(0,o).concat([l],i.slice(o+a)),c=(0,wt.t)(r,u),h=(0,wt.t)(s,[-1]),d=await(0,Yn.Y)(h),p=(0,dn.r)(d,[1]),f=(0,St.k)(c,p,o);return t!==r&&r.dispose(),e!==s&&s.dispose(),p.dispose(),c.dispose(),h.dispose(),d.dispose(),f};var Cn=n(7703),On=n(2596),Pn=n(565);const Ln=(0,E.op)({movingAverage_:function(t,e,n,r,s=!0){const o=(0,w.YT)(t,"v","movingAverage"),a=(0,w.YT)(e,"x","movingAverage"),l=(0,w.YT)(n,"decay","movingAverage");(0,Pn.assertTypesMatch)(o,a),_.vA(_.r1(o.shape,a.shape),()=>"Shape mismatch in v and x");const u=(0,je.d)(1),c=(0,le.j)(u,l);let h=(0,x.l)((0,le.j)(a,o),c);if(s){_.vA(null!=r,()=>"When using zeroDebias: true, step is required.");const t=(0,w.YT)(r,"step","movingAverage");h=(0,ct.y)(h,(0,le.j)(u,(0,xe.n)(l,t)))}return(0,i.W)(o,h)}});var Kn=n(4791),zn=n(6654),Wn=n(5598);const jn=(0,E.op)({dropout_:function(t,e,n,r){const s=(0,w.YT)(t,"x","dropout");if(_.vA("float32"===s.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),_.vA(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),0===e)return t instanceof te.qY?s.clone():s;const o=function(t,e){if(null==e)return t.shape.slice();if(_.r1(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let r=0;r<t.shape.length;r++)null==e[r]&&null!=t.shape[r]?n.push(t.shape[r]):n.push(e[r]);return n}return e}(s,n),a=1-e,l=(0,ct.y)((0,Et.R)((0,i.W)((0,_e.Y)(o,0,1,"float32",r),a)),a);return(0,x.l)(s,l)}});function Gn(t){return Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2))))}function Un(t,e,n){const r=1-t%2,s=new Float32Array(t);for(let o=0;o<t;++o){const a=2*Math.PI*o/(t+r-1);s[o]=e-n*Math.cos(a)}return(0,vn.t)(s,"float32")}const qn=async function(t,e,n=1){const r=(0,w.YT)(t,"predictions","inTopK"),s=(0,w.YT)(e,"targets","inTopK");(0,_.vA)(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),(0,_.vA)(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),(0,_.O3)(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const o=r.shape[r.shape.length-1];(0,_.vA)(n>0&&n<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${n}`);const a=await r.data(),i=await s.data(),[l,u]=[a.length/o,o],c=(0,_.ce)("bool",l);for(let t=0;t<l;t++){const e=t*u,r=a.subarray(e,e+u),s=[];for(let t=0;t<r.length;t++)s.push({value:r[t],index:t});s.sort((t,e)=>e.value-t.value),c[t]=0;for(let e=0;e<n;e++)if(s[e].index===i[t]){c[t]=1;break}}return t!==r&&r.dispose(),e!==s&&s.dispose(),(0,yn.O)(c,s.shape,"bool")};var Hn=n(3502),Vn=n(1624),Zn=n(99);const Xn=(0,E.op)({hammingWindow_:function(t){return Un(t,.54,.46)}}),Qn=(0,E.op)({hannWindow_:function(t){return Un(t,.5,.5)}}),Jn=(0,E.op)({frame_:function(t,e,n,r=!1,s=0){let o=0;const a=[];for(;o+e<=t.size;)a.push((0,S.d)(t,o,e)),o+=n;if(r)for(;o<t.size;){const r=o+e-t.size,i=(0,k.x)([(0,S.d)(t,o,e-r),(0,xt.G)([r],s)]);a.push(i),o+=n}return 0===a.length?kn([],[0,e]):(0,wt.t)((0,k.x)(a),[a.length,e])}}),tr=(0,E.op)({stft_:function(t,e,n,r,s=Qn){null==r&&(r=Gn(e));const o=Jn(t,e,n),a=(0,x.l)(o,s(e));return(0,ln.z)(a,r)}}),er=(0,E.op)({cropAndResize_:function(t,e,n,r,s="bilinear",o=0){const a=(0,w.YT)(t,"image","cropAndResize"),i=(0,w.YT)(e,"boxes","cropAndResize","float32"),l=(0,w.YT)(n,"boxInd","cropAndResize","int32"),u=i.shape[0];_.vA(4===a.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),_.vA(2===i.rank&&4===i.shape[1],()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${i.shape}.`),_.vA(1===l.rank&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${i.shape}.`),_.vA(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),_.vA(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),_.vA("bilinear"===s||"nearest"===s,()=>`method must be bilinear or nearest, but was ${s}`);const c={image:a,boxes:i,boxInd:l},h={method:s,extrapolationValue:o,cropSize:r};return at.T2.runKernel(it.MR,c,h)}}),nr=(0,E.op)({flipLeftRight_:function(t){const e=(0,w.YT)(t,"image","flipLeftRight","float32");_.vA(4===e.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const n={image:e};return at.T2.runKernel(it.Bx,n,{})}}),rr=(0,E.op)({grayscaleToRGB_:function(t){const e=(0,w.YT)(t,"image","grayscaleToRGB"),n=e.rank-1,r=e.shape[n];_.vA(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),_.vA(1===r,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(e.rank);return s.fill(1,0,n),s[n]=3,(0,kt.V)(e,s)}}),sr=(0,E.op)({rotateWithOffset_:function(t,e,n=0,r=.5){const s=(0,w.YT)(t,"image","rotateWithOffset","float32");_.vA(4===s.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const o={image:s},a={radians:e,fillValue:n,center:r};return at.T2.runKernel(it.BK,o,a)}});function or(t,e,n,r,s,o){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==o&&(o=0);const a=t.shape[0];return n=Math.min(n,a),_.vA(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),_.vA(2===t.rank,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),_.vA(4===t.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),_.vA(1===e.rank,()=>"scores must be a 1D tensor"),_.vA(e.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`),_.vA(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:o}}const ar=(0,E.op)({nonMaxSuppression_:function(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const o=(0,w.YT)(t,"boxes","nonMaxSuppression","float32"),a=(0,w.YT)(e,"scores","nonMaxSuppression","float32"),i=or(o,a,n,r,s),l={maxOutputSize:n=i.maxOutputSize,iouThreshold:r=i.iouThreshold,scoreThreshold:s=i.scoreThreshold};return at.T2.runKernel(it.SD,{boxes:o,scores:a},l)}});var ir=n(8360);const lr=(0,E.op)({nonMaxSuppressionWithScore_:function(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const a=(0,w.YT)(t,"boxes","nonMaxSuppression"),i=(0,w.YT)(e,"scores","nonMaxSuppression"),l=or(a,i,n,r,s,o),u={boxes:a,scores:i},c={maxOutputSize:n=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:s=l.scoreThreshold,softNmsSigma:o=l.softNmsSigma},h=at.T2.runKernel(it.e0,u,c);return{selectedIndices:h[0],selectedScores:h[1]}}}),ur=(0,E.op)({nonMaxSuppressionPadded_:function(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const a=(0,w.YT)(t,"boxes","nonMaxSuppression"),i=(0,w.YT)(e,"scores","nonMaxSuppression"),l=or(a,i,n,r,s,null),u={boxes:a,scores:i},c={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:o},h=at.T2.runKernel(it.Zl,u,c);return{selectedIndices:h[0],validOutputs:h[1]}}});var cr=n(4711),hr=n(2954);const dr=(0,E.op)({threshold_:function(t,e="binary",n=!1,r=.5){const s=(0,w.YT)(t,"image","threshold"),o=s.shape[0]*s.shape[1];let a,l,u,c,h=(0,x.l)((0,vn.t)([r]),255);if(_.vA(3===s.rank,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),_.vA(3===s.shape[2]||1===s.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),_.vA("int32"===s.dtype||"float32"===s.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),_.vA("otsu"===e||"binary"===e,()=>`Method must be binary or otsu, but was ${e}`),3===s.shape[2]){[a,l,u]=(0,un.l)(s,[1,1,1],-1);const t=(0,x.l)(a,.2989),e=(0,x.l)(l,.587),n=(0,x.l)(u,.114);c=(0,i.W)((0,i.W)(t,e),n)}else c=t;"otsu"===e&&(h=function(t,e){let n,r,s,o,a,l,u=(0,vn.t)([-1]),c=(0,vn.t)([0]),h=(0,vn.t)([0]);for(let d=0;d<t.size-1;d++){n=(0,S.d)(t,0,d+1),r=(0,S.d)(t,d+1),a=(0,ct.y)((0,mn.c)(n),e),l=(0,ct.y)((0,mn.c)(r),e);const p=(0,mn.c)((0,x.l)(n,(0,De.y)(0,n.size)));s=(0,ct.y)(p,(0,mn.c)(n));const f=(0,xt.G)(r.shape,n.size),g=(0,i.W)((0,De.y)(0,r.size),f),m=(0,x.l)(r,g);o=(0,ct.y)((0,mn.c)(m),(0,mn.c)(r));const b=(0,le.j)(s,o),y=(0,le.j)(s,o),v=(0,x.l)(a,l);h=(0,x.l)((0,x.l)(v,b),y);const w=(0,$t.r)(h,c);c=(0,Dn._)(w,h,c),u=(0,Dn._)(w,(0,vn.t)([d]),u)}return u}((0,F.H)((0,P.w)((0,ze.L)(c),"int32"),(0,yn.O)([]),256),o));const d=n?(0,Ft.I)(c,h):(0,$t.r)(c,h);return(0,P.w)((0,x.l)(d,255),"int32")}}),pr=(0,E.op)({transform_:function(t,e,n="nearest",r="constant",s=0,o){const a=(0,w.YT)(t,"image","transform","float32"),i=(0,w.YT)(e,"transforms","transform","float32");_.vA(4===a.rank,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),_.vA(2===i.rank&&(i.shape[0]===a.shape[0]||1===i.shape[0])&&8===i.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),_.vA(null==o||2===o.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`);const l={image:a,transforms:i},u={interpolation:n,fillMode:r,fillValue:s,outputShape:o};return at.T2.runKernel(it.dL,l,u)}}),fr=(0,E.op)({bandPart_:function(t,e,n){(0,_.vA)(e%1==0,()=>`bandPart(): numLower must be an integer, got ${e}.`),(0,_.vA)(n%1==0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);const r=(0,w.YT)(t,"a","bandPart");(0,_.vA)(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[o,a]=r.shape.slice(-2);if(!(e<=o))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${o}).`);if(!(n<=a))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${a}).`);e<0&&(e=o),n<0&&(n=a);const i=(0,wt.t)((0,De.y)(0,o,1,"int32"),[-1,1]),l=(0,De.y)(0,a,1,"int32"),u=(0,le.j)(i,l),c=(0,Wt.n)((0,Ft.I)(u,(0,je.d)(+e,"int32")),(0,Mt.D)(u,(0,je.d)(-n,"int32"))),h=(0,Rn.U)([o,a],r.dtype);return(0,wt.t)((0,pn.t)((0,Nn.K)((0,wt.t)(r,[-1,o,a])).map(t=>(0,Dn._)(c,t,h))),s)}}),gr=(0,E.op)({gramSchmidt_:function(t){let e;if(Array.isArray(t)){e=!1,(0,_.vA)(null!=t&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const n=t[0].shape[0];for(let e=1;e<t.length;++e)(0,_.vA)(t[e].shape[0]===n,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[e].shape[0]} vs. ${n})`)}else e=!0,t=(0,un.l)(t,t.shape[0],0).map(t=>(0,dn.r)(t,[0]));(0,_.vA)(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const n=[],r=t;for(let e=0;e<t.length;++e)n.push(at.T2.tidy(()=>{let t=r[e];if(e>0)for(let r=0;r<e;++r){const e=(0,x.l)((0,mn.c)((0,x.l)(n[r],t)),n[r]);t=(0,le.j)(t,e)}return(0,ct.y)(t,(0,On.x)(t,"euclidean"))}));return e?(0,pn.t)(n,0):n}});var mr=n(5287);function br(t,e=!1){return at.T2.tidy(()=>{(0,_.vA)(2===t.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const n=t.shape[0],r=t.shape[1];let s=Tt(n),o=(0,z.o)(t);const a=kn([[1]],[1,1]);let i=(0,z.o)(a);const l=n>=r?r:n;for(let t=0;t<l;++t){const e=o,l=i,u=s;[i,o,s]=at.T2.tidy(()=>{const e=(0,S.d)(o,[t,t],[n-t,1]),l=(0,On.x)(e),u=(0,S.d)(o,[t,t],[1,1]),c=(0,Dn._)((0,$t.r)(u,0),kn([[-1]]),kn([[1]])),h=(0,le.j)(u,(0,x.l)(c,l)),d=(0,ct.y)(e,h);i=1===d.shape[0]?(0,z.o)(a):(0,k.x)([a,(0,S.d)(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=(0,de.H)((0,ct.y)((0,T.N)(c,h),l)),f=(0,S.d)(o,[t,0],[n-t,r]),g=(0,x.l)(p,i),m=(0,Cn.m)(i);if(0===t)o=(0,le.j)(f,(0,T.N)(g,(0,T.N)(m,f)));else{const e=(0,le.j)(f,(0,T.N)(g,(0,T.N)(m,f)));o=(0,k.x)([(0,S.d)(o,[0,0],[t,r]),e],0)}const b=(0,Cn.m)(g),y=(0,S.d)(s,[0,t],[n,s.shape[1]-t]);if(0===t)s=(0,le.j)(y,(0,T.N)((0,T.N)(y,i),b));else{const e=(0,le.j)(y,(0,T.N)((0,T.N)(y,i),b));s=(0,k.x)([(0,S.d)(s,[0,0],[n,t]),e],1)}return[i,o,s]}),(0,mr.AS)([e,l,u])}return!e&&n>r&&(s=(0,S.d)(s,[0,0],[n,r]),o=(0,S.d)(o,[0,0],[r,r])),[s,o]})}const yr=(0,E.op)({qr_:function(t,e=!1){if((0,_.vA)(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),2===t.rank)return br(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce((t,e)=>t*e),r=(0,Nn.K)((0,wt.t)(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),s=[],o=[];return r.forEach(t=>{const[n,r]=br(t,e);s.push(n),o.push(r)}),[(0,wt.t)((0,pn.t)(s,0),t.shape),(0,wt.t)((0,pn.t)(o,0),t.shape)]}}});var vr=n(7084);const wr=(0,E.op)({computeWeightedLoss_:function(t,e,n=vr.i.SUM_BY_NONZERO_WEIGHTS){const r=(0,w.YT)(t,"losses","computeWeightedLoss");let s=null;null!=e&&(s=(0,w.YT)(e,"weights","computeWeightedLoss"));const o=null==s?r:(0,x.l)(r,s);if(n===vr.i.NONE)return o;if(n===vr.i.SUM)return(0,mn.c)(o);if(n===vr.i.MEAN){if(null==s)return(0,Qt.i)(o);{const t=r.size/s.size,e=(0,ct.y)((0,mn.c)(o),(0,mn.c)(s));return t>1?(0,ct.y)(e,(0,je.d)(t)):e}}if(n===vr.i.SUM_BY_NONZERO_WEIGHTS){if(null==s)return(0,ct.y)((0,mn.c)(o),(0,je.d)(r.size));{const t=(0,x.l)(s,(0,Jt.S)(r.shape)),e=(0,P.w)((0,mn.c)((0,pe.E)(t,(0,je.d)(0))),"float32");return(0,ct.y)((0,mn.c)(o),e)}}throw Error(`Unknown reduction: ${n}`)}}),kr=(0,E.op)({absoluteDifference_:function(t,e,n,r=vr.i.SUM_BY_NONZERO_WEIGHTS){const o=(0,w.YT)(t,"labels","absoluteDifference"),a=(0,w.YT)(e,"predictions","absoluteDifference");let i=null;null!=n&&(i=(0,w.YT)(n,"weights","absoluteDifference")),(0,_.O3)(o.shape,a.shape,"Error in absoluteDifference: ");const l=(0,s.t)((0,le.j)(o,a));return wr(l,i,r)}}),Tr=(0,E.op)({cosineDistance_:function(t,e,n,r,s=vr.i.SUM_BY_NONZERO_WEIGHTS){const o=(0,w.YT)(t,"labels","cosineDistance"),a=(0,w.YT)(e,"predictions","cosineDistance");let i=null;null!=r&&(i=(0,w.YT)(r,"weights","cosineDistance")),(0,_.O3)(o.shape,a.shape,"Error in cosineDistance: ");const l=(0,je.d)(1),u=(0,le.j)(l,(0,mn.c)((0,x.l)(o,a),n,!0));return wr(u,i,s)}}),xr=(0,E.op)({hingeLoss_:function(t,e,n,r=vr.i.SUM_BY_NONZERO_WEIGHTS){let s=(0,w.YT)(t,"labels","hingeLoss");const o=(0,w.YT)(e,"predictions","hingeLoss");let a=null;null!=n&&(a=(0,w.YT)(n,"weights","hingeLoss")),(0,_.O3)(s.shape,o.shape,"Error in hingeLoss: ");const i=(0,je.d)(1);s=(0,le.j)((0,x.l)((0,je.d)(2),s),i);const l=(0,Fe.V)((0,le.j)(i,(0,x.l)(s,o)));return wr(l,a,r)}}),Er=(0,E.op)({huberLoss_:function(t,e,n,r=1,o=vr.i.SUM_BY_NONZERO_WEIGHTS){const a=(0,w.YT)(t,"labels","huberLoss"),l=(0,w.YT)(e,"predictions","huberLoss");let u=null;null!=n&&(u=(0,w.YT)(n,"weights","huberLoss")),(0,_.O3)(a.shape,l.shape,"Error in huberLoss: ");const c=(0,je.d)(r),h=(0,s.t)((0,le.j)(l,a)),d=(0,re.B)(h,c),p=(0,le.j)(h,d),f=(0,i.W)((0,x.l)((0,je.d)(.5),(0,ie.E)(d)),(0,x.l)(c,p));return wr(f,u,o)}}),Ar=(0,E.op)({logLoss_:function(t,e,n,r=1e-7,s=vr.i.SUM_BY_NONZERO_WEIGHTS){const o=(0,w.YT)(t,"labels","logLoss"),a=(0,w.YT)(e,"predictions","logLoss");let l=null;null!=n&&(l=(0,w.YT)(n,"weights","logLoss")),(0,_.O3)(o.shape,a.shape,"Error in logLoss: ");const u=(0,je.d)(1),c=(0,je.d)(r),h=(0,de.H)((0,x.l)(o,(0,Ot.R)((0,i.W)(a,c)))),d=(0,x.l)((0,le.j)(u,o),(0,Ot.R)((0,i.W)((0,le.j)(u,a),c))),p=(0,le.j)(h,d);return wr(p,l,s)}}),Sr=(0,E.op)({meanSquaredError_:function(t,e,n,r=vr.i.SUM_BY_NONZERO_WEIGHTS){const s=(0,w.YT)(t,"labels","meanSquaredError"),o=(0,w.YT)(e,"predictions","meanSquaredError");let a=null;null!=n&&(a=(0,w.YT)(n,"weights","meanSquaredError")),(0,_.O3)(s.shape,o.shape,"Error in meanSquaredError: ");const i=(0,hn.P)(s,o);return wr(i,a,r)}}),$r=(0,E.op)({sigmoidCrossEntropy_:function(t,e,n,r=0,o=vr.i.SUM_BY_NONZERO_WEIGHTS){let a=(0,w.YT)(t,"multiClassLabels","sigmoidCrossEntropy");const l=(0,w.YT)(e,"logits","sigmoidCrossEntropy");let u=null;if(null!=n&&(u=(0,w.YT)(n,"weights","sigmoidCrossEntropy")),(0,_.O3)(a.shape,l.shape,"Error in sigmoidCrossEntropy: "),r>0){const t=(0,je.d)(r),e=(0,je.d)(1),n=(0,je.d)(.5);a=(0,i.W)((0,x.l)(a,(0,le.j)(e,t)),(0,x.l)(n,t))}const c=function(t,e){const n=(0,w.YT)(t,"labels","sigmoidCrossEntropyWithLogits"),r=(0,w.YT)(e,"logits","sigmoidCrossEntropyWithLogits");(0,_.O3)(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const o=(0,Fe.V)(r),a=(0,x.l)(r,n),l=(0,Pt.K)((0,bt.o)((0,de.H)((0,s.t)(r))));return(0,i.W)((0,le.j)(o,a),l)}(a,l);return wr(c,u,o)}});var Mr=n(1830);const Ir=(0,E.op)({softmaxCrossEntropy_:function(t,e,n,r=0,s=vr.i.SUM_BY_NONZERO_WEIGHTS){let o=(0,w.YT)(t,"onehotLabels","softmaxCrossEntropy");const a=(0,w.YT)(e,"logits","softmaxCrossEntropy");let l=null;if(null!=n&&(l=(0,w.YT)(n,"weights","softmaxCrossEntropy")),(0,_.O3)(o.shape,a.shape,"Error in softmaxCrossEntropy: "),r>0){const t=(0,je.d)(r),e=(0,je.d)(1),n=(0,je.d)(o.shape[1]);o=(0,i.W)((0,x.l)(o,(0,le.j)(e,t)),(0,ct.y)(t,n))}const u=function(t,e,n=-1){if(-1===n&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);const r=(0,Mr._X)((t,e,r)=>{const s=(0,zt.V)(e,[n],!0),o=(0,le.j)((0,P.w)(e,"float32"),s);r([t,o]);const a=(0,de.H)((0,x.l)(o,t));return{value:(0,mn.c)(a,[n]),gradFunc:(t,e)=>{const[r,s]=e,o=(0,ae.SM)(t.shape,[n]);return[(0,x.l)((0,wt.t)(t,o),(0,le.j)((0,P.w)(r,"float32"),(0,bt.o)(s))),(0,x.l)((0,wt.t)(t,o),(0,le.j)((0,bt.o)(s),(0,P.w)(r,"float32")))]}}});return r(t,e)}(o,a);return wr(u,l,s)}}),Nr=(0,E.op)({sparseFillEmptyRows_:function(t,e,n,r){const s=(0,w.YT)(t,"indices","sparseFillEmptyRows"),o=(0,w.YT)(e,"values","sparseFillEmptyRows"),a=(0,w.YT)(n,"denseShape","sparseFillEmptyRows"),i=(0,w.YT)(r,"defaultValue","sparseFillEmptyRows",o.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==o.rank)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(1!==a.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(0!==i.rank)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);const l={indices:s,values:o,denseShape:a,defaultValue:i},u=at.T2.runKernel(it.C8,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}}),_r=(0,E.op)({sparseReshape_:function(t,e,n){const r=(0,w.YT)(t,"inputIndices","sparseReshape"),s=(0,w.YT)(e,"inputShape","sparseReshape"),o=(0,w.YT)(n,"newShape","sparseReshape");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==o.rank)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const a={inputIndices:r,inputShape:s,newShape:o},i=at.T2.runKernel(it.Bo,a);return{outputIndices:i[0],outputShape:i[1]}}}),Dr=(0,E.op)({sparseSegmentMean_:function(t,e,n){const r=(0,w.YT)(t,"data","sparseSegmentMean"),s=(0,w.YT)(e,"indices","sparseSegmentMean"),o=(0,w.YT)(n,"segmentIds","sparseSegmentMean");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${s.shape}`);if(1!==o.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${o.shape}`);const a={data:r,indices:s,segmentIds:o};return at.T2.runKernel(it.L6,a)}}),Yr=(0,E.op)({sparseSegmentSum_:function(t,e,n){const r=(0,w.YT)(t,"data","sparseSegmentSum"),s=(0,w.YT)(e,"indices","sparseSegmentSum"),o=(0,w.YT)(n,"segmentIds","sparseSegmentSum");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${s.shape}`);if(1!==o.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${o.shape}`);const a={data:r,indices:s,segmentIds:o};return at.T2.runKernel(it.Dv,a)}}),Rr=(0,E.op)({stringNGrams_:function(t,e,n,r,s,o,a,i){const l=(0,w.YT)(t,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=(0,w.YT)(e,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:r,leftPad:s,rightPad:o,padWidth:a,preserveShortSequences:i},h={data:l,dataSplits:u},d=at.T2.runKernel(it.YA,h,c);return{nGrams:d[0],nGramsSplits:d[1]}}}),Fr=(0,E.op)({stringSplit_:function(t,e,n=!0){const r=(0,w.YT)(t,"input","stringSplit","string"),s=(0,w.YT)(e,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==s.rank)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const o={skipEmpty:n},a={input:r,delimiter:s},i=at.T2.runKernel(it.iW,a,o);return{indices:i[0],values:i[1],shape:i[2]}}}),Br=(0,E.op)({stringToHashBucketFast_:function(t,e){const n=(0,w.YT)(t,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const s={input:n};return at.T2.runKernel(it.$j,s,r)}}),Cr={fft:sn.h,ifft:on.K,rfft:ln.z,irfft:an.g},Or={hammingWindow:Xn,hannWindow:Qn,frame:Jn,stft:tr},Pr={flipLeftRight:nr,grayscaleToRGB:rr,resizeNearestNeighbor:hr.b,resizeBilinear:cr.v,rotateWithOffset:sr,cropAndResize:er,nonMaxSuppression:ar,nonMaxSuppressionAsync:async function(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY){const o=(0,w.YT)(t,"boxes","nonMaxSuppressionAsync"),a=(0,w.YT)(e,"scores","nonMaxSuppressionAsync"),i=or(o,a,n,r,s);n=i.maxOutputSize,r=i.iouThreshold,s=i.scoreThreshold;const l=await Promise.all([o.data(),a.data()]),u=l[0],c=l[1],{selectedIndices:h}=(0,ir.c7)(u,c,n,r,s);return o!==t&&o.dispose(),a!==e&&a.dispose(),(0,vn.t)(h,"int32")},nonMaxSuppressionWithScore:lr,nonMaxSuppressionWithScoreAsync:async function(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const a=(0,w.YT)(t,"boxes","nonMaxSuppressionAsync"),i=(0,w.YT)(e,"scores","nonMaxSuppressionAsync"),l=or(a,i,n,r,s,o);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,o=l.softNmsSigma;const u=await Promise.all([a.data(),i.data()]),c=u[0],h=u[1],{selectedIndices:d,selectedScores:p}=(0,ir.ut)(c,h,n,r,s,o);return a!==t&&a.dispose(),i!==e&&i.dispose(),{selectedIndices:(0,vn.t)(d,"int32"),selectedScores:(0,vn.t)(p)}},nonMaxSuppressionPadded:ur,nonMaxSuppressionPaddedAsync:async function(t,e,n,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const a=(0,w.YT)(t,"boxes","nonMaxSuppressionAsync"),i=(0,w.YT)(e,"scores","nonMaxSuppressionAsync"),l=or(a,i,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([a.data(),i.data()]),{selectedIndices:f,validOutputs:g}=(0,ir.ZS)(d,p,u,c,h,o);return a!==t&&a.dispose(),i!==e&&i.dispose(),{selectedIndices:(0,vn.t)(f,"int32"),validOutputs:(0,je.d)(g,"int32")}},threshold:dr,transform:pr},Lr={bandPart:fr,gramSchmidt:gr,qr:yr},Kr={absoluteDifference:kr,computeWeightedLoss:wr,cosineDistance:Tr,hingeLoss:xr,huberLoss:Er,logLoss:Ar,meanSquaredError:Sr,sigmoidCrossEntropy:$r,softmaxCrossEntropy:Ir},zr={sparseFillEmptyRows:Nr,sparseReshape:_r,sparseSegmentMean:Dr,sparseSegmentSum:Yr},Wr={stringNGrams:Rr,stringSplit:Fr,stringToHashBucketFast:Br}},9258:(t,e,n)=>{"use strict";n.d(e,{l:()=>i});var r=n(1585),s=n(5441),o=n(565),a=n(8189);const i=(0,n(929).op)({mul_:function(t,e){let n=(0,a.YT)(t,"a","mul"),i=(0,a.YT)(e,"b","mul");[n,i]=(0,o.makeTypesMatch)(n,i);const l={a:n,b:i};return r.T2.runKernel(s.xu,l)}})},9264:(t,e,n)=>{var r=n(297),s=n(72),o=n(6950),a=n(1436),i=n(5242),l=n(1668),u=n(9456);u.alea=r,u.xor128=s,u.xorwow=o,u.xorshift7=a,u.xor4096=i,u.tychei=l,t.exports=u},9326:(t,e,n)=>{"use strict";n.d(e,{b:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({any_:function(t,e=null,n=!1){const a={x:(0,o.YT)(t,"x","any","bool")},i={axis:e,keepDims:n};return r.T2.runKernel(s.FS,a,i)}})},9348:(t,e,n)=>{"use strict";n.d(e,{R:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({sqrt_:function(t){const e={x:(0,o.YT)(t,"x","sqrt","float32")};return r.T2.runKernel(s.dF,e)}})},9359:(t,e,n)=>{"use strict";n.d(e,{y:()=>l});var r=n(1585),s=n(5441),o=n(565),a=n(8189),i=n(8991);const l=(0,n(929).op)({div_:function(t,e){let n=(0,a.YT)(t,"a","div"),l=(0,a.YT)(e,"b","div");if([n,l]=(0,o.makeTypesMatch)(n,l),"int32"===n.dtype&&"int32"===l.dtype)return(0,i.w)(n,l);const u={a:n,b:l};return r.T2.runKernel(s.sD,u,{})}})},9456:(t,e,n)=>{var r;!function(s,o){var a,i=this,l=256,u="random",c=o.pow(l,6),h=o.pow(2,52),d=2*h,p=255;function f(t,e,n){var r=[],p=y(b((e=1==e?{entropy:!0}:e||{}).entropy?[t,v(s)]:null==t?function(){try{var t;return a&&(t=a.randomBytes)?t=t(l):(t=new Uint8Array(l),(i.crypto||i.msCrypto).getRandomValues(t)),v(t)}catch(t){var e=i.navigator,n=e&&e.plugins;return[+new Date,i,n,i.screen,v(s)]}}():t,3),r),f=new g(r),w=function(){for(var t=f.g(6),e=c,n=0;t<h;)t=(t+n)*l,e*=l,n=f.g(1);for(;t>=d;)t/=2,e/=2,n>>>=1;return(t+n)/e};return w.int32=function(){return 0|f.g(4)},w.quick=function(){return f.g(4)/4294967296},w.double=w,y(v(f.S),s),(e.pass||n||function(t,e,n,r){return r&&(r.S&&m(r,f),t.state=function(){return m(f,{})}),n?(o[u]=t,e):t})(w,p,"global"in e?e.global:this==o,e.state)}function g(t){var e,n=t.length,r=this,s=0,o=r.i=r.j=0,a=r.S=[];for(n||(t=[n++]);s<l;)a[s]=s++;for(s=0;s<l;s++)a[s]=a[o=p&o+t[s%n]+(e=a[s])],a[o]=e;(r.g=function(t){for(var e,n=0,s=r.i,o=r.j,a=r.S;t--;)e=a[s=p&s+1],n=n*l+a[p&(a[s]=a[o=p&o+e])+(a[o]=e)];return r.i=s,r.j=o,n})(l)}function m(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function b(t,e){var n,r=[],s=typeof t;if(e&&"object"==s)for(n in t)try{r.push(b(t[n],e-1))}catch(t){}return r.length?r:"string"==s?t:t+"\0"}function y(t,e){for(var n,r=t+"",s=0;s<r.length;)e[p&s]=p&(n^=19*e[p&s])+r.charCodeAt(s++);return v(e)}function v(t){return String.fromCharCode.apply(0,t)}if(o["seed"+u]=f,y(o.random(),s),t.exports){t.exports=f;try{a=n(3857)}catch(t){}}else void 0===(r=function(){return f}.call(e,n,e,t))||(t.exports=r)}([],Math)},9546:(t,e,n)=>{"use strict";n.d(e,{Y:()=>a});var r=n(448),s=n(929),o=n(9748);const a=(0,s.op)({randomUniform_:function(t,e=0,n=1,s="float32",a){const i=(0,r.r)(t,s),l=new o.yU(e,n,null,a);for(let t=0;t<i.values.length;t++)i.values[t]=l.nextValue();return i.toTensor()}})},9580:(t,e,n)=>{"use strict";n.d(e,{r:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({atan_:function(t){const e={x:(0,o.YT)(t,"x","atan")};return r.T2.runKernel(s.Ty,e)}})},9748:(t,e,n)=>{"use strict";n.d(e,{XA:()=>o,ai:()=>s,yU:()=>a});var r=n(9264);class s{constructor(t,e,n,s,o){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const a=o||Math.random();this.random=r.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const t=this.nextVal;return this.nextVal=NaN,t}let t,e,n=!1;for(;!n;){let r,s,o;do{r=2*this.random()-1,s=2*this.random()-1,o=r*r+s*s}while(o>=1||0===o);const a=Math.sqrt(-2*Math.log(o)/o);t=this.mean+this.stdDev*r*a,e=this.mean+this.stdDev*s*a,this.truncated&&!this.isValidTruncated(t)||(n=!0)}return this.truncated&&!this.isValidTruncated(e)||(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class o{constructor(t,e,n,o){this.alpha=t,this.beta=1/e,this.dtype=n;const a=o||Math.random();this.randu=r.alea(a.toString()),this.randn=new s(0,1,n,!1,this.randu()),this.d=t<1?t+2/3:t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,n,r,s,o;for(;;){do{r=this.randn.nextValue(),o=1+this.c*r}while(o<=0);if(o*=o*o,t=r*r,e=1-.331*t*t,n=.5*t+this.d*(1-o+Math.log(o)),s=this.randu(),s<e||Math.log(s)<n)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(t){return"float32"===this.dtype?t:Math.round(t)}}class a{constructor(t=0,e=1,n,s){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=n,null==s&&(s=Math.random()),"number"==typeof s&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=r.alea(s)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}},9759:(t,e,n)=>{"use strict";n.d(e,{O:()=>l});var r=n(8189),s=n(5119),o=n(5703),a=n(929),i=n(2302);const l=(0,a.op)({dot_:function(t,e){const n=(0,r.YT)(t,"t1","dot"),a=(0,r.YT)(e,"t2","dot");s.vA(!(1!==n.rank&&2!==n.rank||1!==a.rank&&2!==a.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${a.rank}.`);const l=1===n.rank?n.size:n.shape[1],u=1===a.rank?a.size:a.shape[0];if(s.vA(l===u,()=>`Error in dot: inner dimensions of inputs must match, but got ${l} and ${u}.`),1===n.rank&&1===a.rank){const t=(0,i.t)(n,[1,-1]),e=(0,i.t)(a,[-1,1]),r=(0,o.N)(t,e);return(0,i.t)(r,[])}if(1===n.rank&&2===a.rank){const t=(0,i.t)(n,[1,-1]),e=(0,i.t)(a,[a.shape[0],a.shape[1]]),r=(0,o.N)(t,e);return(0,i.t)(r,[r.size])}if(2===n.rank&&1===a.rank){const t=(0,i.t)(a,[-1,1]),e=(0,o.N)(n,t);return(0,i.t)(e,[e.size])}{const t=(0,i.t)(a,[a.shape[0],a.shape[1]]);return(0,o.N)(n,t)}}})},9772:(t,e,n)=>{"use strict";n.d(e,{G:()=>i});var r=n(1585),s=n(5441),o=n(8189),a=n(5119);const i=(0,n(929).op)({batchToSpaceND_:function(t,e,n){const i=(0,o.YT)(t,"x","batchToSpaceND"),l=e.reduce((t,e)=>t*e);a.vA(i.rank>=1+e.length,()=>`input rank is ${i.rank} but should be > than blockShape.length ${e.length}`),a.vA(n.length===e.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`),a.vA(i.shape[0]%l===0,()=>`input tensor batch is ${i.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${l}`);const u={x:i},c={blockShape:e,crops:n};return r.T2.runKernel(s.Ik,u,c)}})},9809:(t,e,n)=>{"use strict";n.d(e,{w:()=>i});var r=n(1585),s=n(5441),o=n(8189),a=n(5119);const i=(0,n(929).op)({cast_:function(t,e){const n=(0,o.YT)(t,"x","cast");if(!a.xn(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if("string"===e&&"string"!==n.dtype||"string"!==e&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const i={x:n},l={dtype:e};return r.T2.runKernel(s.KX,i,l)}})},9853:(t,e,n)=>{"use strict";n.d(e,{_:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({einsum_:function(t,...e){const n=e.map((t,e)=>(0,o.YT)(t,`tensors${e}`,"einsum")),a={equation:t};return r.T2.runKernel(s.Qg,n,a)}})},9870:(t,e,n)=>{"use strict";n.d(e,{V:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({reciprocal_:function(t){const e={x:(0,o.YT)(t,"x","reciprocal")};return r.T2.runKernel(s.hu,e)}})},9879:(t,e,n)=>{"use strict";n.d(e,{z:()=>i});var r=n(1585),s=n(5441),o=n(8189),a=n(2198);const i=(0,n(929).op)({logicalOr_:function(t,e){const n=(0,o.YT)(t,"a","logicalOr","bool"),i=(0,o.YT)(e,"b","logicalOr","bool");(0,a.Ky)(n.shape,i.shape);const l={a:n,b:i};return r.T2.runKernel(s.LX,l)}})},9881:(t,e,n)=>{"use strict";n.d(e,{N:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({logicalNot_:function(t){const e={x:(0,o.YT)(t,"x","logicalNot","bool")};return r.T2.runKernel(s.nZ,e)}})},9885:(t,e,n)=>{"use strict";n.d(e,{P:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({onesLike_:function(t){const e={x:(0,o.YT)(t,"x","onesLike")};return r.T2.runKernel(s.LW,e)}})},9907:(t,e,n)=>{"use strict";n.d(e,{g:()=>a});var r=n(1585),s=n(5441),o=n(8189);const a=(0,n(929).op)({cos_:function(t){const e={x:(0,o.YT)(t,"x","cos","float32")};return r.T2.runKernel(s.t2,e)}})},9925:(t,e,n)=>{"use strict";n.d(e,{r:()=>l});var r=n(8189),s=n(2198),o=n(3789),a=n(9881),i=n(9879);const l=(0,n(929).op)({logicalXor_:function(t,e){const n=(0,r.YT)(t,"a","logicalXor","bool"),l=(0,r.YT)(e,"b","logicalXor","bool");return(0,s.Ky)(n.shape,l.shape),(0,o.n)((0,i.z)(t,e),(0,a.N)((0,o.n)(t,e)))}})},9986:(t,e,n)=>{"use strict";n.d(e,{w:()=>u});var r=n(8189),s=n(5119),o=n(8794),a=n(676),i=n(929),l=n(2302);const u=(0,i.op)({separableConv2d_:function(t,e,n,i,u,c=[1,1],h="NHWC"){const d=(0,r.YT)(t,"x","separableConv2d"),p=(0,r.YT)(e,"depthwiseFilter","separableConv2d"),f=(0,r.YT)(n,"pointwiseFilter","separableConv2d");let g=d,m=!1;if(3===d.rank&&(m=!0,g=(0,l.t)(d,[1,d.shape[0],d.shape[1],d.shape[2]])),"NCHW"===h)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");s.vA(4===g.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${g.rank}.`),s.vA(4===p.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${p.rank}.`),s.vA(4===f.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${p.rank}.`),s.vA(1===f.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${f.shape[0]}.`),s.vA(1===f.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${f.shape[1]}.`);const b=p.shape[2],y=p.shape[3];s.vA(f.shape[2]===b*y,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${b*y}, but got ${f.shape[2]}.`);const v=(0,a.G)(g,p,i,u,h,c),w=(0,o.X)(v,f,1,"valid",h);return m?(0,l.t)(w,[w.shape[1],w.shape[2],w.shape[3]]):w}})}}]);